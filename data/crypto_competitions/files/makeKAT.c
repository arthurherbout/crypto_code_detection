/*
 * -----------------------------------------------------------------------
 * (c) Thomas Pornin 2014. This software is provided 'as-is', without
 * any express or implied warranty. In no event will the author be held
 * liable for any damages arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to no restriction.
 *
 * Technical remarks and questions can be addressed to:
 * <pornin@bolet.org>
 * -----------------------------------------------------------------------
 */

/*
 * This command-line tool generates known-answer test values, to be
 * compared with the reference file.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * We use OpenSSL's SHA-256 implementation to compute an aggregate hash
 * of all KAT outputs.
 */
#include <openssl/sha.h>

#include "makwa.h"

/*
 * A conventional Makwa modulus (2048 bits).
 */
static const unsigned char PUB2048[] = {
	0x55, 0x41, 0x4d, 0x30, 0x01, 0x00, 0xc2, 0x2c,
	0x40, 0xbb, 0xd0, 0x56, 0xbb, 0x21, 0x3a, 0xad,
	0x7c, 0x83, 0x05, 0x19, 0x10, 0x1a, 0xb9, 0x26,
	0xae, 0x18, 0xe3, 0xe9, 0xfc, 0x96, 0x99, 0xc8,
	0x06, 0xe0, 0xae, 0x5c, 0x25, 0x94, 0x14, 0xa0,
	0x1a, 0xc1, 0xd5, 0x2e, 0x87, 0x3e, 0xc0, 0x80,
	0x46, 0xa6, 0x8e, 0x34, 0x4c, 0x8d, 0x74, 0xa5,
	0x08, 0x95, 0x28, 0x42, 0xef, 0x0f, 0x03, 0xf7,
	0x1a, 0x6e, 0xdc, 0x07, 0x7f, 0xaa, 0x14, 0x89,
	0x9a, 0x79, 0xf8, 0x3c, 0x3a, 0xe1, 0x36, 0xf7,
	0x74, 0xfa, 0x6e, 0xb8, 0x8f, 0x1d, 0x1a, 0xea,
	0x5e, 0xa0, 0x2f, 0xc0, 0xcc, 0xaf, 0x96, 0xe2,
	0xce, 0x86, 0xf3, 0x49, 0x0f, 0x49, 0x93, 0xb4,
	0xb5, 0x66, 0xc0, 0x07, 0x96, 0x41, 0x47, 0x2d,
	0xef, 0xc1, 0x4b, 0xec, 0xcf, 0x48, 0x98, 0x4a,
	0x79, 0x46, 0xf1, 0x44, 0x1e, 0xa1, 0x44, 0xea,
	0x4c, 0x80, 0x2a, 0x45, 0x75, 0x50, 0xba, 0x3d,
	0xf0, 0xf1, 0x4c, 0x09, 0x0a, 0x75, 0xfe, 0x9e,
	0x6a, 0x77, 0xcf, 0x0b, 0xe9, 0x8b, 0x71, 0xd5,
	0x62, 0x51, 0xa8, 0x69, 0x43, 0xe7, 0x19, 0xd2,
	0x78, 0x65, 0xa4, 0x89, 0x56, 0x6c, 0x1d, 0xc5,
	0x7f, 0xcd, 0xef, 0xac, 0xa6, 0xab, 0x04, 0x3f,
	0x8e, 0x13, 0xf6, 0xc0, 0xbe, 0x7b, 0x39, 0xc9,
	0x2d, 0xa8, 0x6e, 0x1d, 0x87, 0x47, 0x7a, 0x18,
	0x9e, 0x73, 0xce, 0x8e, 0x31, 0x1d, 0x3d, 0x51,
	0x36, 0x1f, 0x8b, 0x00, 0x24, 0x9f, 0xb3, 0xd8,
	0x43, 0x56, 0x07, 0xb1, 0x4a, 0x1e, 0x70, 0x17,
	0x0f, 0x9a, 0xf3, 0x67, 0x84, 0x11, 0x0a, 0x3f,
	0x2e, 0x67, 0x42, 0x8f, 0xc1, 0x8f, 0xb0, 0x13,
	0xb3, 0x0f, 0xe6, 0x78, 0x2a, 0xec, 0xb4, 0x42,
	0x8d, 0x7c, 0x8e, 0x35, 0x4a, 0x0f, 0xbd, 0x06,
	0x1b, 0x01, 0x91, 0x7c, 0x72, 0x7a, 0xbe, 0xe0,
	0xfe, 0x3f, 0xd3, 0xce, 0xf7, 0x61
};

/*
 * The private key for the modulus in PUB2048[].
 */
static const unsigned char PRIV2048[] = {
	0x55, 0x41, 0x4d, 0x31, 0x00, 0x80, 0xea, 0x43,
	0xd7, 0x9d, 0xf0, 0xb8, 0x74, 0x14, 0x0a, 0x55,
	0xec, 0xd1, 0x44, 0x73, 0x2e, 0xaf, 0x49, 0xd9,
	0xc8, 0xf0, 0xe4, 0x37, 0x6f, 0x5d, 0x72, 0x97,
	0x2a, 0x14, 0x66, 0x79, 0xe3, 0x82, 0x44, 0xf5,
	0xa9, 0x6e, 0xf5, 0xce, 0x92, 0x8a, 0x54, 0x25,
	0x12, 0x40, 0x47, 0x5f, 0xd1, 0xdd, 0x96, 0x8b,
	0x9a, 0x77, 0xad, 0xd1, 0x65, 0x50, 0x56, 0x4c,
	0x1d, 0xd2, 0x42, 0x40, 0x08, 0xea, 0x83, 0xc2,
	0x59, 0xd5, 0x3b, 0x88, 0x61, 0xc5, 0xe9, 0x4f,
	0x22, 0x8f, 0x03, 0xc4, 0x98, 0xdd, 0x3c, 0x8c,
	0x69, 0x49, 0xe3, 0x66, 0x02, 0xfe, 0x74, 0x6d,
	0x64, 0xd5, 0x14, 0x89, 0xc7, 0x6c, 0x74, 0xdb,
	0xc2, 0x44, 0x7e, 0x22, 0x2e, 0xcf, 0x28, 0xfa,
	0x9b, 0xd4, 0x4e, 0x81, 0x41, 0x07, 0x55, 0x87,
	0x9e, 0x71, 0xbd, 0xf8, 0xfb, 0x4a, 0x61, 0xd8,
	0xad, 0x3d, 0xf4, 0x4f, 0xfc, 0x9b, 0x00, 0x80,
	0xd4, 0x30, 0x28, 0xee, 0x37, 0x4f, 0xeb, 0xb9,
	0x3b, 0x5d, 0xf8, 0xdc, 0x1c, 0x68, 0x37, 0x13,
	0xab, 0x05, 0x10, 0xaf, 0x7e, 0xeb, 0xe6, 0x3d,
	0x33, 0xf9, 0x0a, 0xf7, 0x63, 0xfa, 0x22, 0x64,
	0xb6, 0x8b, 0x09, 0x21, 0x94, 0x90, 0xa5, 0xa5,
	0x64, 0x4d, 0x63, 0x56, 0x85, 0x9c, 0x27, 0xcd,
	0xf9, 0x76, 0x71, 0x12, 0x2e, 0x4d, 0x9a, 0x13,
	0xd9, 0x16, 0x09, 0x60, 0x9c, 0x46, 0x90, 0x14,
	0xda, 0xe3, 0x0f, 0x9a, 0xe6, 0xbc, 0x93, 0x78,
	0xe7, 0x97, 0x47, 0x60, 0x1e, 0xee, 0xa8, 0x18,
	0x46, 0x98, 0x42, 0x72, 0x08, 0x9c, 0x08, 0x53,
	0x49, 0x7f, 0xc5, 0x3a, 0x51, 0xd4, 0x5d, 0x37,
	0xf0, 0xcb, 0x4e, 0x67, 0xd8, 0xb9, 0x59, 0x21,
	0xb7, 0xd2, 0x93, 0xd7, 0x55, 0xb4, 0x9d, 0xda,
	0x55, 0xb8, 0x15, 0x29, 0xa7, 0x06, 0xcd, 0x67,
	0xee, 0x3b, 0xfe, 0xfe, 0xc4, 0xf3, 0xf5, 0xb3
};

/*
 * Some pre-generated salt values. These 16 salts, of 16 bytes each,
 * actually use all byte values from 0 to 255; they were generated as
 * a random permutation of the 0..255 range.
 */
static const unsigned char SALTS[][16] = {
	{ /* 0 */
		0xb8, 0x2c, 0xb4, 0x2e, 0x3a, 0x2d, 0xfc, 0x2a,
		0xd6, 0x0b, 0x8b, 0x76, 0xc6, 0x66, 0xb0, 0x15
	},
	{ /* 1 */
		0xa8, 0x67, 0xf0, 0x36, 0xcc, 0x97, 0x43, 0x41,
		0x5a, 0x7c, 0xf8, 0xe7, 0x6f, 0x3d, 0x79, 0xc3
	},
	{ /* 2 */
		0x07, 0x96, 0x09, 0x03, 0x6d, 0xd1, 0x89, 0x4c,
		0xe3, 0x7d, 0x08, 0xab, 0x20, 0x21, 0xa3, 0x02
	},
	{ /* 3 */
		0x1a, 0xdb, 0xc1, 0xe6, 0xa9, 0xdd, 0x48, 0x1f,
		0xff, 0x00, 0xeb, 0x93, 0xb2, 0x8e, 0x9a, 0xce
	},
	{ /* 4 */
		0xd8, 0x8f, 0x1d, 0x9b, 0x71, 0xd0, 0xa1, 0x59,
		0xf1, 0x1b, 0x28, 0x84, 0x78, 0x18, 0x29, 0x16
	},
	{ /* 5 */
		0x1c, 0x37, 0x22, 0x64, 0x42, 0x19, 0xb5, 0xcd,
		0x55, 0xf3, 0x68, 0xcf, 0xcb, 0xe5, 0x4e, 0xd7
	},
	{ /* 6 */
		0x82, 0xef, 0x58, 0x8d, 0xd5, 0xc5, 0x52, 0xdf,
		0xa2, 0xf6, 0x46, 0x99, 0x87, 0x91, 0xa5, 0x75
	},
	{ /* 7 */
		0x4b, 0x9f, 0x85, 0x74, 0x2f, 0x0c, 0xfb, 0xda,
		0xde, 0x12, 0xb7, 0x3e, 0x54, 0xb9, 0x95, 0x10
	},
	{ /* 8 */
		0xaf, 0xa6, 0xa0, 0x92, 0xf2, 0x35, 0x4a, 0x8a,
		0xaa, 0x0e, 0x80, 0x23, 0x56, 0xe4, 0x7e, 0x01
	},
	{ /* 9 */
		0x60, 0xf4, 0x8c, 0xdc, 0x69, 0x3f, 0x2b, 0x7b,
		0xc0, 0x6b, 0xc9, 0x13, 0x53, 0x86, 0x30, 0xbc
	},
	{ /* 10 */
		0x06, 0xbe, 0xfd, 0x62, 0xea, 0xc8, 0xe0, 0x5d,
		0x4d, 0x65, 0x39, 0xa4, 0xe9, 0xf5, 0xba, 0xfa
	},
	{ /* 11 */
		0x73, 0x9c, 0x40, 0x51, 0xf7, 0x04, 0x6c, 0x33,
		0xad, 0x11, 0x1e, 0x7f, 0xed, 0x3c, 0x9d, 0x34
	},
	{ /* 12 */
		0x31, 0x24, 0x44, 0xb6, 0x83, 0x88, 0x9e, 0x94,
		0x5e, 0xd4, 0x47, 0x26, 0x49, 0xe1, 0x6a, 0x0d
	},
	{ /* 13 */
		0xbf, 0xfe, 0xbb, 0x98, 0x5b, 0xc4, 0xc7, 0x5f,
		0x77, 0xa7, 0x81, 0xd3, 0x0f, 0xe8, 0x7a, 0xee
	},
	{ /* 14 */
		0x63, 0xf9, 0xc2, 0x27, 0xd2, 0x5c, 0xae, 0x3b,
		0xd9, 0x45, 0x4f, 0x61, 0x05, 0x0a, 0x90, 0xbd
	},
	{ /* 15 */
		0xe2, 0x38, 0x17, 0x25, 0x14, 0xca, 0xb3, 0x57,
		0xb1, 0x50, 0xec, 0x32, 0x72, 0x6e, 0x70, 0xac
	}
};

/*
 * The "small" work factor is below the threshold for use of the
 * "fast path", while the "large" work factor is above. Threshold is
 * 34% of the modulus size (in bits), i.e. 696 for a 2048-bit modulus.
 */
#define WF_SMALL   384
#define WF_LARGE  4096

/*
 * The salt for the "detailed test vector" from the specification.
 */
static const unsigned char SALT_D[] = {
	0xC7, 0x27, 0x03, 0xC2, 0x2A, 0x96, 0xD9, 0x99,
	0x2F, 0x3D, 0xEA, 0x87, 0x64, 0x97, 0xE3, 0x92
};

/*
 * The expected binary output for the "detailed test vector" from the
 * specification.
 */
static const unsigned char REF_D[] = {
	0xC9, 0xCE, 0xA0, 0xE6, 0xEF, 0x09, 0x39, 0x3A,
	0xB1, 0x71, 0x0A, 0x08
};

/*
 * Successive hash outputs are concatenated and hashed together with
 * SHA-256, thus producing an aggregate checksum of all KAT.
 */
static SHA256_CTX sha256;

static void
print_blob(char *name, const void *data, size_t len)
{
	const unsigned char *buf;

	buf = data;
	printf("%s: ", name);
	while (len -- > 0) {
		printf("%02x", *buf ++);
	}
	printf("\n");
}

static void
printKDF(char *banner, int hf,
	unsigned char *input, size_t input_len, size_t output_len)
{
	unsigned char output[4096];

	if (output_len > sizeof output) {
		abort();
	}
	makwa_kdf(hf, input, input_len, output, output_len);
	printf("%s\n", banner);
	print_blob("input", input, input_len);
	print_blob("output", output, output_len);
	printf("\n");
	SHA256_Update(&sha256, output, output_len);
}

static void
printKAT4(char *banner, makwa_context *mcpub, makwa_context *mcpriv,
	const unsigned char *input, size_t input_len,
	const unsigned char *salt, size_t salt_len,
	int pre_hash, size_t post_hash_len)
{
	unsigned char outs1[300], outs2[300], outb1[300], outb2[300];
	size_t outs1_len, outs2_len, outb1_len, outb2_len;
	char tmp[30];
	char *outs1_str, *outb1_str;
	size_t outs1_str_len, outb1_str_len;

	memset(outs1, 0x00, sizeof outs1);
	memset(outs2, 0xFF, sizeof outs2);
	memset(outb1, 0x00, sizeof outb1);
	memset(outb2, 0xFF, sizeof outb2);
	outs1_len = sizeof outs1;
	outs2_len = sizeof outs2;
	if (makwa_hash(mcpub, input, input_len, salt, salt_len,
		pre_hash, post_hash_len, WF_SMALL, outs1, &outs1_len) < 0)
	{
		abort();
	}
	if (makwa_hash(mcpriv, input, input_len, salt, salt_len,
		pre_hash, post_hash_len, WF_SMALL, outs2, &outs2_len) < 0)
	{
		abort();
	}
	if (outs1_len != outs2_len || memcmp(outs1, outs2, outs1_len) != 0) {
		abort();
	}
	outb1_len = sizeof outb1;
	outb2_len = sizeof outb2;
	if (makwa_hash(mcpub, input, input_len, salt, salt_len,
		pre_hash, post_hash_len, WF_LARGE, outb1, &outb1_len) < 0)
	{
		abort();
	}
	if (makwa_hash(mcpriv, input, input_len, salt, salt_len,
		pre_hash, post_hash_len, WF_LARGE, outb2, &outb2_len) < 0)
	{
		abort();
	}
	if (outb1_len != outb2_len || memcmp(outb1, outb2, outb1_len) != 0) {
		abort();
	}

	printf("%s\n", banner);
	print_blob("input", input, input_len);
	print_blob("salt", salt, salt_len);
	printf("pre-hashing: %s\n", pre_hash ? "true" : "false");
	if (post_hash_len == 0) {
		printf("post-hashing: false\n");
	} else {
		printf("post-hashing: %lu\n", (unsigned long)post_hash_len);
	}
	sprintf(tmp, "bin%d", WF_SMALL);
	print_blob(tmp, outs1, outs1_len);
	sprintf(tmp, "bin%d", WF_LARGE);
	print_blob(tmp, outb1, outb1_len);

	if (makwa_encode_string(mcpriv, salt, salt_len, pre_hash,
		post_hash_len, WF_SMALL, outs1, NULL, &outs1_str_len) < 0)
	{
		abort();
	}
	outs1_str = malloc(outs1_str_len);
	if (outs1_str == NULL) {
		abort();
	}
	if (makwa_encode_string(mcpriv, salt, salt_len, pre_hash,
		post_hash_len, WF_SMALL, outs1, outs1_str, &outs1_str_len) < 0)
	{
		abort();
	}
	if (makwa_encode_string(mcpriv, salt, salt_len, pre_hash,
		post_hash_len, WF_LARGE, outb1, NULL, &outb1_str_len) < 0)
	{
		abort();
	}
	outb1_str = malloc(outb1_str_len);
	if (outb1_str == NULL) {
		abort();
	}
	if (makwa_encode_string(mcpriv, salt, salt_len, pre_hash,
		post_hash_len, WF_LARGE, outb1, outb1_str, &outb1_str_len) < 0)
	{
		abort();
	}

	printf("str%d: %s\n", WF_SMALL, outs1_str);
	printf("str%d: %s\n", WF_LARGE, outb1_str);
	printf("\n");

	SHA256_Update(&sha256, outs1, outs1_len);
	SHA256_Update(&sha256, outb1, outb1_len);
	SHA256_Update(&sha256, outs1_str, strlen(outs1_str));
	SHA256_Update(&sha256, outb1_str, strlen(outb1_str));

	free(outs1_str);
	free(outb1_str);
}

static void
printKAT3(char *banner, makwa_context *mcpub, makwa_context *mcpriv,
	const unsigned char *input, size_t input_len,
	const unsigned char *salt, size_t salt_len,
	size_t ph_len)
{
	printKAT4(banner, mcpub, mcpriv,
		input, input_len, salt, salt_len, 0, 0);
	printKAT4(banner, mcpub, mcpriv,
		input, input_len, salt, salt_len, 0, ph_len);
	printKAT4(banner, mcpub, mcpriv,
		input, input_len, salt, salt_len, 1, 0);
	printKAT4(banner, mcpub, mcpriv,
		input, input_len, salt, salt_len, 1, ph_len);
}

static void
printKAT2(char *banner, makwa_context *mcpub, makwa_context *mcpriv,
	const unsigned char *input, size_t input_len)
{
	int i;

	for (i = 0; i < 16; i ++) {
		printKAT3(banner, mcpub, mcpriv,
			input, input_len, SALTS[i], 16, 10 + i);
	}
}

static void
printKAT(char *banner, makwa_context *mcpub, makwa_context *mcpriv)
{
	unsigned char input[150];
	int i, j;

	for (i = 0; i < 150; i ++) {
		input[i] = (17 + 73 * i) & 0xFF;
	}
	printKAT2(banner, mcpub, mcpriv, input, 150);

	for (i = 0; i < 22; i ++) {
		for (j = 0; j < 13; j ++) {
			input[j] = (13 * i + j + 8) & 0xFF;
		}
		printKAT2(banner, mcpub, mcpriv, input, 13);
	}
}

int
main(void)
{
	makwa_context *mcpub, *mcpriv;
	int i, j;
	char *pwd;
	unsigned char tmp[32];
	size_t tmp_len;
	char detailed_string[1024];

	SHA256_Init(&sha256);

	for (i = 0; i < 200; i ++) {
		unsigned char input[200];

		for (j = 0; j < i; j ++) {
			input[j] = (7 * i + 83 * j) & 0xFF;
		}
		printKDF("KDF/SHA-256", MAKWA_SHA256, input, i, 100);
		printKDF("KDF/SHA-512", MAKWA_SHA512, input, i, 100);
	}

	mcpub = makwa_new();
	mcpriv = makwa_new();

	if (makwa_init(mcpub, PUB2048, sizeof PUB2048, MAKWA_SHA256) < 0) {
		abort();
	}
	if (makwa_init(mcpriv, PRIV2048, sizeof PRIV2048, MAKWA_SHA256) < 0) {
		abort();
	}
	pwd = "Gego beshwaji'aaken awe makwa; onzaam naniizaanizi.";
	tmp_len = sizeof tmp;
	if (makwa_hash(mcpub, pwd, strlen(pwd), SALT_D, sizeof SALT_D,
		0, 12, 4096, tmp, &tmp_len) < 0)
	{
		abort();
	}
	if (tmp_len != sizeof REF_D || memcmp(tmp, REF_D, tmp_len) != 0) {
		abort();
	}
	memset(tmp, 0, sizeof tmp);
	if (makwa_hash(mcpriv, pwd, strlen(pwd), SALT_D, sizeof SALT_D,
		0, 12, 4096, tmp, &tmp_len) < 0)
	{
		abort();
	}
	if (tmp_len != sizeof REF_D || memcmp(tmp, REF_D, tmp_len) != 0) {
		abort();
	}
	if (makwa_encode_string(mcpub, SALT_D, sizeof SALT_D,
		0, 12, 4096, REF_D, detailed_string, NULL) != 0)
	{
		abort();
	}
	printf("2048-bit modulus, SHA-256\n");
	print_blob("input", pwd, strlen(pwd));
	print_blob("salt", SALT_D, sizeof SALT_D);
	printf("pre-hashing: false\n");
	printf("post-hashing: 12\n");
	print_blob("bin4096", tmp, sizeof REF_D);
	printf("str4096: %s\n\n", detailed_string);

	SHA256_Update(&sha256, tmp, sizeof REF_D);
	SHA256_Update(&sha256, detailed_string, strlen(detailed_string));

	printKAT("2048-bit modulus, SHA-256", mcpub, mcpriv);
	if (makwa_init(mcpub, PUB2048, sizeof PUB2048, MAKWA_SHA512) < 0) {
		abort();
	}
	if (makwa_init(mcpriv, PRIV2048, sizeof PRIV2048, MAKWA_SHA512) < 0) {
		abort();
	}
	printKAT("2048-bit modulus, SHA-512", mcpub, mcpriv);

	makwa_free(mcpub);
	makwa_free(mcpriv);

	SHA256_Final(tmp, &sha256);
	print_blob("KAT digest", tmp, 32);
	return 0;
}
