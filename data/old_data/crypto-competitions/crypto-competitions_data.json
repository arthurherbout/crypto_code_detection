{
    "data_source": "crypto-competitions",
    "label": 1,
    "data": [
        {
            "file_name": "acorn128_encrypt.cpp",
            "content": "namespace Acorn128_raw {\nint numRounds = -1;\n\n#include <string.h>\n#include \"acorn128_encrypt.h\"\n\n\n#define maj(x,y,z)   (  ((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z))  )\n#define ch(x,y,z)    (  ((x) & (y)) ^ ( ((x) ^ 1) & (z))  )\n\nunsigned char KSG128(unsigned char *state)\n{\n    return ( state[12] ^ state[154] ^ maj(state[235], state[61], state[193]) );\n}\n\nunsigned char FBK128(unsigned char *state, unsigned char *ks, unsigned char ca, unsigned char cb)\n{\n    unsigned char f;\n    *ks = KSG128(state);\n    f  = state[0] ^ (state[107] ^ 1) ^ maj(state[244], state[23], state[160]) ^ ch(state[230], state[111], state[66]) ^ (ca & state[196]) ^ (cb & (*ks));\n    return f;\n}\n\n//encrypt one bit \nvoid Encrypt_StateUpdate128(unsigned char *state, unsigned char plaintextbit, unsigned char *ciphertextbit, unsigned char *ks, unsigned char ca, unsigned char cb)\n{\n    unsigned int  j;\n    unsigned char f;\n\n    state[289] ^= state[235] ^ state[230];\n    state[230] ^= state[196] ^ state[193];\n    state[193] ^= state[160] ^ state[154];\n    state[154] ^= state[111] ^ state[107];\n    state[107] ^= state[66]  ^ state[61];\n    state[61]  ^= state[23]  ^ state[0];\n\n    f  = FBK128(state, ks, ca, cb);\n\n    for (j = 0; j <= 291; j++) state[j] = state[j+1];\n    state[292] = f ^ plaintextbit;\n    *ciphertextbit = *ks ^ plaintextbit;\n}\n\n//decrypt one bit \nvoid Decrypt_StateUpdate128(unsigned char *state, unsigned char *plaintextbit, unsigned char ciphertextbit, unsigned char *ks, unsigned char ca, unsigned char cb)\n{\n    unsigned int  j;\n    unsigned char f;\n\n    state[289] ^= state[235] ^ state[230];\n    state[230] ^= state[196] ^ state[193];\n    state[193] ^= state[160] ^ state[154];\n    state[154] ^= state[111] ^ state[107];\n    state[107] ^= state[66]  ^ state[61];\n    state[61]  ^= state[23]  ^ state[0];\n\n    f = FBK128(state, ks, ca, cb);  \n\n    for (j = 0; j <= 291; j++) state[j] = state[j+1]; \n    *plaintextbit = *ks ^ ciphertextbit; \n    state[292] = f ^ *plaintextbit; \n}\n\n// encrypt one byte\nvoid acorn128_enc_onebyte(unsigned char *state, unsigned char plaintextbyte,\n       unsigned char *ciphertextbyte, unsigned char *ksbyte, unsigned char cabyte, unsigned char cbbyte)\n{\n    unsigned char i;\n    unsigned char plaintextbit,ciphertextbit,kstem,ca,cb;\n\n    *ciphertextbyte = 0;\n    kstem = 0;\n    *ksbyte = 0;\n    for (i = 0; i < 8; i++)\n    {\n        ca = (cabyte >> i) & 1;\n        cb = (cbbyte >> i) & 1;\n        plaintextbit = (plaintextbyte >> i) & 1;\n        Encrypt_StateUpdate128(state, plaintextbit, &ciphertextbit, &kstem, ca, cb);\n        *ciphertextbyte |= (ciphertextbit << i);\n        *ksbyte |= (kstem << i);\n    }\n}\n\n\n// decrypt one byte  \nvoid acorn128_dec_onebyte(unsigned char *state, unsigned char *plaintextbyte,\n       unsigned char ciphertextbyte, unsigned char *ksbyte, unsigned char cabyte, unsigned char cbbyte)\n{\n    unsigned char i;\n    unsigned char plaintextbit,ciphertextbit, ks,ca,cb;\n\n    *plaintextbyte = 0;\n    for  (i = 0; i < 8; i++)\n    {\n        ca = (cabyte >> i) & 1;\n        cb = (cbbyte >> i) & 1;\n        ciphertextbit = (ciphertextbyte >> i) & 1;\n        Decrypt_StateUpdate128(state, &plaintextbit, ciphertextbit, &ks, ca, cb);\n        *plaintextbyte |= (plaintextbit << i);\n    }\n}\n\n\n//The initialization state of ACORN\n/*The input to initialization is the 128-bit key; 128-bit IV;*/\nvoid acorn128_initialization(const unsigned char *key, const unsigned char *iv, unsigned char *state)\n{\n        int i,j;\n        unsigned char m[1536], ks, tem;\n\n        //initialize the state to 0\n        for (j = 0; j <= 292; j++) state[j] = 0;\n\n        //set the value of m\n        for (j = 0; j <= 127; j++) m[j]     = ( key[j/8] >> (j & 7) ) & 1;\n        for (j = 0; j <= 127; j++) m[j+128] = ( iv[j/8]  >> (j & 7) ) & 1;\n        m[256] = 1;\n        for (j = 257; j <= 1535; j++) m[j]  = 0;\n\n        //run the cipher for 1536 steps\n        for (i = 0; i < 1536; i++)\n        {\n             Encrypt_StateUpdate128(state, m[i], &tem, &ks, 1, 1);\n        }\n}\n\n//the finalization state of acorn\nvoid acorn128_tag_generation(unsigned long long msglen, unsigned long long adlen, unsigned char maclen, unsigned char *mac, unsigned char *state)\n{\n    int i;\n    unsigned char plaintextbyte  = 0;\n    unsigned char ciphertextbyte = 0;\n    unsigned char ksbyte = 0;\n\n    for (i = 0; i < 512/8; i++)\n    {\n        acorn128_enc_onebyte(state, plaintextbyte, &ciphertextbyte, &ksbyte, 0xff, 0xff);\n        if ( i >= (512/8 - 16) ) {mac[i-(512/8-16)] = ksbyte; }\n    }\n}\n\n\n//encrypt a message.\nint crypto_aead_encrypt(\n\tunsigned char *c,unsigned long long *clen,\n\tconst unsigned char *m,unsigned long long mlen,\n\tconst unsigned char *ad,unsigned long long adlen,\n\tconst unsigned char *nsec,\n\tconst unsigned char *npub,\n\tconst unsigned char *k\n\t)\n{\n    unsigned long i;\n    unsigned char plaintextbyte, ciphertextbyte, ksbyte, mac[16];\n    unsigned char state[293];\n    unsigned char ca, cb;\n\n    //initialization stage\n    acorn128_initialization(k, npub, state);\n\n    //process the associated data\n    for (i = 0; i < adlen; i++)\n    {\n        acorn128_enc_onebyte(state, ad[i], &ciphertextbyte, &ksbyte, 0xff, 0xff);\n    }\n\n    for (i = 0; i < 512/8; i++)\n    {\n        if ( i == 0 ) plaintextbyte = 1;\n        else plaintextbyte = 0;\n\n        if ( i < 256/8)   ca = 0xff;\n        else ca = 0;\n\n        cb = 0xff;\n\n        acorn128_enc_onebyte(state, plaintextbyte, &ciphertextbyte, &ksbyte, ca, cb);\n    }\n\n    //process the plaintext\n    for (i = 0; i < mlen; i++)\n    {\n        acorn128_enc_onebyte(state, m[i], &c[i], &ksbyte, 0xff, 0 );\n    }\n\n    for (i = 0; i < 512/8; i++)\n    {\n        if ( i == 0 ) plaintextbyte = 1;\n        else plaintextbyte = 0;\n\n        if ( i < 256/8)   ca = 0xff;\n        else ca = 0;\n\n        cb = 0;\n\n        acorn128_enc_onebyte(state, plaintextbyte, &ciphertextbyte, &ksbyte, ca, cb);\n    }\n\n    //finalization stage, we assume that the tag length is a multiple of bytes\n    acorn128_tag_generation(mlen, adlen, 16, mac, state);\n\n    *clen = mlen + 16;\n    memcpy(c+mlen, mac, 16);\n\n    return 0;\n}\n\n\nint crypto_aead_decrypt(\n\tunsigned char *m,unsigned long long *mlen,\n\tunsigned char *nsec,\n\tconst unsigned char *c,unsigned long long clen,\n\tconst unsigned char *ad,unsigned long long adlen,\n\tconst unsigned char *npub,\n\tconst unsigned char *k\n\t)\n{\n    unsigned long i;\n    unsigned char plaintextbyte, ciphertextbyte, ksbyte;\n    unsigned char state[293];\n    unsigned char tag[16];\n    unsigned char check = 0;\n    unsigned char ca, cb;\n\n    if (clen < 16) return -1;\n\n    //initialization stage\n    acorn128_initialization(k, npub, state);\n\n    //process the associated data\n    for (i = 0; i < adlen; i++)\n    {\n        acorn128_enc_onebyte(state, ad[i], &ciphertextbyte, &ksbyte, 0xff, 0xff);\n    }\n\n    for (i = 0; i < 512/8; i++)\n    {\n        if ( i == 0 ) plaintextbyte = 1;\n        else plaintextbyte = 0;\n\n        if ( i < 256/8)   ca = 0xff;\n        else ca = 0;\n\n        cb = 0xff;\n\n        acorn128_enc_onebyte(state, plaintextbyte, &ciphertextbyte, &ksbyte, ca, cb);\n    }\n\n\n    //process the plaintext\n\n    *mlen = clen - 16;\n\n    for (i = 0; i < *mlen; i++)\n    {\n        acorn128_dec_onebyte(state, &m[i], c[i], &ksbyte, 0xff, 0 );\n    }\n\n    for (i = 0; i < 512/8; i++)\n    {\n        if ( i == 0 ) plaintextbyte = 1;\n        else plaintextbyte = 0;\n\n        if ( i < 256/8)   ca = 0xff;\n        else ca = 0;\n\n        cb = 0;\n\n        acorn128_enc_onebyte(state, plaintextbyte, &ciphertextbyte, &ksbyte, ca, cb);\n    }\n\n    //finalization stage, we assume that the tag length is a multiple of bytes\n    acorn128_tag_generation(*mlen, adlen, 16, tag, state);\n\n    for (i = 0; i  < 16; i++) check |= (tag[i] ^ c[clen - 16 + i]);\n    if (check == 0) return 0;\n    else return -1;\n}\n\n\n} // namespace Acorn128_raw\n"
        },
        {
            "file_name": "aeadaes256ocbtaglen128v1_encrypt.cpp",
            "content": "namespace Aeadaes256ocbtaglen128v1_raw {\nint numRounds = -1;\n\n/* \n// CAESAR OCB v1 reference code. Info: http://www.cs.ucdavis.edu/~rogaway/ocb\n//\n// ** This version is slow and susceptible to side-channel attacks. **\n// ** Do not use for any purpose other than to understand OCB.      **\n//\n// Written by Ted Krovetz (ted@krovetz.net). Last modified 13 May 2014.\n//\n// Phillip Rogaway holds patents relevant to OCB. See the following for\n// his free patent grant: http://www.cs.ucdavis.edu/~rogaway/ocb/grant.htm\n//\n// This is free and unencumbered software released into the public domain.\n//\n// Anyone is free to copy, modify, publish, use, compile, sell, or\n// distribute this software, either in source code form or as a compiled\n// binary, for any purpose, commercial or non-commercial, and by any\n// means.\n//\n// In jurisdictions that recognize copyright laws, the author or authors\n// of this software dedicate any and all copyright interest in the\n// software to the public domain. We make this dedication for the benefit\n// of the public at large and to the detriment of our heirs and\n// successors. We intend this dedication to be an overt act of\n// relinquishment in perpetuity of all present and future rights to this\n// software under copyright law.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n//\n// For more information, please refer to <http://unlicense.org/>\n*/\n\n#include <string.h>\n#include <openssl/aes.h>\n\n#include \"aeadaes256ocbtaglen128v1_api.h\"\n#include \"aeadaes256ocbtaglen128v1_encrypt.h\"\n#define KEYBYTES   CRYPTO_KEYBYTES\n#define NONCEBYTES CRYPTO_NPUBBYTES\n#define TAGBYTES   CRYPTO_ABYTES\n\ntypedef unsigned char block[16];\n\n/* ------------------------------------------------------------------------- */\n\nstatic void xor_block(block d, block s1, block s2) {\n    unsigned i;\n    for (i=0; i<16; i++)\n        d[i] = s1[i] ^ s2[i];\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic void double_block(block d, block s) {\n    unsigned i;\n    unsigned char tmp = s[0];\n    for (i=0; i<15; i++)\n        d[i] = (s[i] << 1) | (s[i+1] >> 7);\n    d[15] = (s[15] << 1) ^ ((tmp >> 7) * 135);\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic void calc_L_i(block l, block ldollar, unsigned i) {\n    double_block(l, ldollar);         /* l is now L_0               */\n    for ( ; (i&1)==0 ; i>>=1)\n        double_block(l,l);            /* double for each trailing 0 */\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic void hash(block result, unsigned char *k,\n                 unsigned char *a, unsigned abytes) {\n    AES_KEY aes_key;\n    block lstar, ldollar, offset, sum, tmp;\n    unsigned i;\n    \n    /* Key-dependent variables */\n    \n    /* L_* = ENCIPHER(K, zeros(128)) */\n    AES_set_encrypt_key(k, KEYBYTES*8, &aes_key);\n    memset(tmp, 0, 16);\n    AES_encrypt(tmp, lstar, &aes_key);\n    /* L_$ = double(L_*) */\n    double_block(ldollar, lstar); \n    \n    /* Process any whole blocks */\n    \n    /* Sum_0 = zeros(128) */\n    memset(sum, 0, 16);\n    /* Offset_0 = zeros(128) */\n    memset(offset, 0, 16);\n    for (i=1; i<=abytes/16; i++, a = a + 16) {\n        /* Offset_i = Offset_{i-1} xor L_{ntz(i)} */\n        calc_L_i(tmp, ldollar, i);\n        xor_block(offset, offset, tmp);\n        /* Sum_i = Sum_{i-1} xor ENCIPHER(K, A_i xor Offset_i) */\n        xor_block(tmp, offset, a);\n        AES_encrypt(tmp, tmp, &aes_key);\n        xor_block(sum, sum, tmp);\n    }\n\n    /* Process any final partial block; compute final hash value */\n\n    abytes = abytes % 16;  /* Bytes in final block */\n    if (abytes > 0) {\n        /* Offset_* = Offset_m xor L_* */\n        xor_block(offset, offset, lstar);\n        /* tmp = (A_* || 1 || zeros(127-bitlen(A_*))) xor Offset_* */\n        memset(tmp, 0, 16);\n        memcpy(tmp, a, abytes);\n        tmp[abytes] = 0x80;\n        xor_block(tmp, offset, tmp);\n        /* Sum = Sum_m xor ENCIPHER(K, tmp) */\n        AES_encrypt(tmp, tmp, &aes_key);\n        xor_block(sum, tmp, sum);\n    }\n    \n    memcpy(result, sum, 16);\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic int ocb_crypt(unsigned char *out, unsigned char *k, unsigned char *n,\n                     unsigned char *a, unsigned abytes,\n                     unsigned char *in, unsigned inbytes, int encrypting) {\n    AES_KEY aes_encrypt_key, aes_decrypt_key;\n    block lstar, ldollar, sum, offset, ktop, pad, nonce, tag, tmp, ad_hash;\n    unsigned char stretch[24];\n    unsigned bottom, byteshift, bitshift, i;\n    \n    /* Setup AES and strip ciphertext of its tag */\n    if ( ! encrypting ) {\n         if (inbytes < TAGBYTES) return -1;\n         inbytes -= TAGBYTES;\n         AES_set_decrypt_key(k, KEYBYTES*8, &aes_decrypt_key);\n    }\n    AES_set_encrypt_key(k, KEYBYTES*8, &aes_encrypt_key);\n     \n    /* Key-dependent variables */\n\n    /* L_* = ENCIPHER(K, zeros(128)) */\n    memset(tmp, 0, 16);\n    AES_encrypt(tmp, lstar, &aes_encrypt_key);\n    /* L_$ = double(L_*) */\n    double_block(ldollar, lstar); \n\n    /* Nonce-dependent and per-encryption variables */\n\n    /* Nonce = zeros(127-bitlen(N)) || 1 || N */\n    memset(nonce,0,16);\n    memcpy(&nonce[16-NONCEBYTES],n,NONCEBYTES);\n    nonce[0] = (unsigned char)(((TAGBYTES * 8) % 128) << 1);\n    nonce[16-NONCEBYTES-1] |= 0x01;\n    /* bottom = str2num(Nonce[123..128]) */\n    bottom = nonce[15] & 0x3F;\n    /* Ktop = ENCIPHER(K, Nonce[1..122] || zeros(6)) */\n    nonce[15] &= 0xC0;\n    AES_encrypt(nonce, ktop, &aes_encrypt_key);\n    /* Stretch = Ktop || (Ktop[1..64] xor Ktop[9..72]) */\n    memcpy(stretch, ktop, 16);\n    memcpy(tmp, &ktop[1], 8);\n    xor_block(tmp, tmp, ktop);\n    memcpy(&stretch[16],tmp,8);\n    /* Offset_0 = Stretch[1+bottom..128+bottom] */\n    byteshift = bottom/8;\n    bitshift  = bottom%8;\n    if (bitshift != 0)\n        for (i=0; i<16; i++)\n            offset[i] = (stretch[i+byteshift] << bitshift) |\n                        (stretch[i+byteshift+1] >> (8-bitshift));\n    else\n        for (i=0; i<16; i++)\n            offset[i] = stretch[i+byteshift];\n    /* Checksum_0 = zeros(128) */\n    memset(sum, 0, 16);\n\n    /* Hash associated data */\n    hash(ad_hash, k, a, abytes);\n\n    /* Process any whole blocks */\n\n    for (i=1; i<=inbytes/16; i++, in=in+16, out=out+16) {\n        /* Offset_i = Offset_{i-1} xor L_{ntz(i)} */\n        calc_L_i(tmp, ldollar, i);\n        xor_block(offset, offset, tmp);\n        \n        xor_block(tmp, offset, in);\n        if (encrypting) {\n            /* Checksum_i = Checksum_{i-1} xor P_i */\n            xor_block(sum, in, sum);\n            /* C_i = Offset_i xor ENCIPHER(K, P_i xor Offset_i) */\n            AES_encrypt(tmp, tmp, &aes_encrypt_key);\n            xor_block(out, offset, tmp);\n        } else {\n            /* P_i = Offset_i xor DECIPHER(K, C_i xor Offset_i) */\n            AES_decrypt(tmp, tmp, &aes_decrypt_key);\n            xor_block(out, offset, tmp);\n            /* Checksum_i = Checksum_{i-1} xor P_i */\n            xor_block(sum, out, sum);\n        }\n    }\n\n    /* Process any final partial block and compute raw tag */\n\n    inbytes = inbytes % 16;  /* Bytes in final block */\n    if (inbytes > 0) {\n        /* Offset_* = Offset_m xor L_* */\n        xor_block(offset, offset, lstar);\n        /* Pad = ENCIPHER(K, Offset_*) */\n        AES_encrypt(offset, pad, &aes_encrypt_key);\n        \n        if (encrypting) {\n            /* Checksum_* = Checksum_m xor (P_* || 1 || zeros(127-bitlen(P_*))) */\n            memset(tmp, 0, 16);\n            memcpy(tmp, in, inbytes);\n            tmp[inbytes] = 0x80;\n            xor_block(sum, tmp, sum);\n            /* C_* = P_* xor Pad[1..bitlen(P_*)] */\n            xor_block(pad, tmp, pad);\n            memcpy(out, pad, inbytes);\n            out = out + inbytes;\n        } else {\n            /* P_* = C_* xor Pad[1..bitlen(C_*)] */\n            memcpy(tmp, pad, 16);\n            memcpy(tmp, in, inbytes);\n            xor_block(tmp, pad, tmp);\n            tmp[inbytes] = 0x80;     /* tmp == P_* || 1 || zeros(127-bitlen(P_*)) */\n            memcpy(out, tmp, inbytes);\n            /* Checksum_* = Checksum_m xor (P_* || 1 || zeros(127-bitlen(P_*))) */\n            xor_block(sum, tmp, sum);\n            in = in + inbytes;\n        }\n    }\n    \n    /* Tag = ENCIPHER(K, Checksum xor Offset xor L_$) xor HASH(K,A) */\n    xor_block(tmp, sum, offset);\n    xor_block(tmp, tmp, ldollar);\n    AES_encrypt(tmp, tag, &aes_encrypt_key);\n    xor_block(tag, ad_hash, tag);\n    \n    if (encrypting) {\n        memcpy(out, tag, TAGBYTES);\n        return 0;\n    } else\n        return (memcmp(in,tag,TAGBYTES) ? -1 : 0);     /* Check for validity */\n}\n\n/* ------------------------------------------------------------------------- */\n\n#define OCB_ENCRYPT 1\n#define OCB_DECRYPT 0\n\nvoid ocb_encrypt(unsigned char *c, unsigned char *k, unsigned char *n,\n                 unsigned char *a, unsigned abytes,\n                 unsigned char *p, unsigned pbytes) {\n    ocb_crypt(c, k, n, a, abytes, p, pbytes, OCB_ENCRYPT);\n}\n\n/* ------------------------------------------------------------------------- */\n\nint ocb_decrypt(unsigned char *p, unsigned char *k, unsigned char *n,\n                unsigned char *a, unsigned abytes,\n                unsigned char *c, unsigned cbytes) {\n    return ocb_crypt(p, k, n, a, abytes, c, cbytes, OCB_DECRYPT);\n}\n\n/* ------------------------------------------------------------------------- */\n\nint crypto_aead_encrypt(\nunsigned char *c,unsigned long long *clen,\nconst unsigned char *m,unsigned long long mlen,\nconst unsigned char *ad,unsigned long long adlen,\nconst unsigned char *nsec,\nconst unsigned char *npub,\nconst unsigned char *k\n)\n{\n    *clen = mlen + TAGBYTES;\n    ocb_crypt(c, (unsigned char *)k, (unsigned char *)npub, (unsigned char *)ad,\n            adlen, (unsigned char *)m, mlen, OCB_ENCRYPT);\n    return 0;\n}\n\nint crypto_aead_decrypt(\nunsigned char *m,unsigned long long *mlen,\nunsigned char *nsec,\nconst unsigned char *c,unsigned long long clen,\nconst unsigned char *ad,unsigned long long adlen,\nconst unsigned char *npub,\nconst unsigned char *k\n)\n{\n    *mlen = clen - TAGBYTES;\n    return ocb_crypt(m, (unsigned char *)k, (unsigned char *)npub,\n            (unsigned char *)ad, adlen, (unsigned char *)c, clen, OCB_DECRYPT);\n}\n\n\n} // namespace Aeadaes256ocbtaglen128v1_raw\n"
        },
        {
            "file_name": "aegis256_encrypt.cpp",
            "content": "namespace Aegis256_raw {\nint numRounds = -1;\n\n#include <string.h>\n#include \"aegis256_encrypt.h\"\n\n#ifdef _MSC_VER\n#define inline __inline\n#endif\n\nvoid AESROUND(unsigned char *out, unsigned char *in, unsigned char *rk);\n\n#define XOR128(x,y,z) {                                                                             \\\n    ((unsigned long long*)(x))[0] = ((unsigned long long*)(y))[0] ^ ((unsigned long long*)(z))[0];  \\\n    ((unsigned long long*)(x))[1] = ((unsigned long long*)(y))[1] ^ ((unsigned long long*)(z))[1];  \\\n}\n\n#define AND128(x,y,z) {                                                                             \\\n    ((unsigned long long*)(x))[0] = ((unsigned long long*)(y))[0] & ((unsigned long long*)(z))[0];  \\\n    ((unsigned long long*)(x))[1] = ((unsigned long long*)(y))[1] & ((unsigned long long*)(z))[1];  \\\n}\n\ninline void aegis256_initialization(const unsigned char *key,\n       const unsigned char *iv, unsigned char *state)\n{\n       int i;\n       unsigned char constant[32] = {0x0,0x1,0x01,0x02,0x03,0x05,0x08,0x0d,0x15,0x22,0x37,0x59,0x90,0xe9,0x79,0x62,0xdb,0x3d,0x18,0x55,0x6d,0xc2,0x2f,0xf1,0x20,0x11,0x31,0x42,0x73,0xb5,0x28,0xdd};\n       unsigned char tmp[16], temp[64];\n\n  \t    XOR128(state,    key,    iv);\n  \t    XOR128(state+16, key+16, iv+16);\n\n        memcpy(state+32, constant+16,  16);\n        memcpy(state+48, constant,     16);\n        XOR128(state+64, key,    constant);\n        XOR128(state+80, key+16, constant+16);\n\n        memcpy(temp,     key,  32);\n        XOR128(temp+32,  key,  iv);\n        XOR128(temp+48,  key+16, iv+16);\n\n        for (i = 0; i < 16; i++)\n        {\n             //state update function\n             memcpy(tmp, state+80, 16);\n             AESROUND(state+80, state+64, state+80);\n             AESROUND(state+64, state+48, state+64);\n             AESROUND(state+48, state+32, state+48);\n             AESROUND(state+32, state+16, state+32);\n             AESROUND(state+16, state+0,  state+16);\n             AESROUND(state+0,  tmp,      state+0);\n\n             XOR128(state, state, temp+16*(i&3));\n        }\n}\n\n\n//the finalization state of AEGIS\nvoid aegis256_tag_generation(unsigned long long msglen, unsigned long long adlen, unsigned char maclen, unsigned char *mac, unsigned char *state)\n{\n        int i;\n\n        unsigned char tmp[16];\n        unsigned char msgtmp[16];\n\n        ((unsigned long long*)msgtmp)[0] = adlen << 3;\n        ((unsigned long long*)msgtmp)[1] = msglen << 3;\n\n        XOR128(msgtmp, msgtmp, state+48);\n\n        for (i = 0; i < 7; i++) {\n             //state update function\n             memcpy(tmp, state+80, 16);\n\n             AESROUND(state+80, state+64, state+80);\n             AESROUND(state+64, state+48, state+64);\n             AESROUND(state+48, state+32, state+48);\n             AESROUND(state+32, state+16, state+32);\n             AESROUND(state+16, state+0,  state+16);\n             AESROUND(state+0,  tmp,      state+0);\n\n             //xor \"msg\" with state[0]\n             XOR128(state, state, msgtmp);\n        }\n\n        XOR128(state+80, state+80, state+64);\n        XOR128(state+80, state+80, state+48);\n        XOR128(state+80, state+80, state+32);\n        XOR128(state+80, state+80, state+16);\n        XOR128(state+80, state+80, state+0);\n\n        //in this program, the mac length is assumed to be multiple of bytes\n        memcpy(mac, state+80, maclen);\n}\n\n\n// one step of encryption\ninline void aegis256_enc_aut_step(const unsigned char *plaintextblk,\n       unsigned char *ciphertextblk, unsigned char *state)\n{\n        unsigned char tmp[16];\n\n        AND128(ciphertextblk, state+32, state+48);\n        XOR128(ciphertextblk, ciphertextblk, state+16);\n        XOR128(ciphertextblk, ciphertextblk, state+64);\n        XOR128(ciphertextblk, ciphertextblk, state+80);\n        XOR128(ciphertextblk, ciphertextblk, plaintextblk);\n\n        //state update function\n        memcpy(tmp, state+80, 16);\n\n        AESROUND(state+80, state+64, state+80);\n        AESROUND(state+64, state+48, state+64);\n        AESROUND(state+48, state+32, state+48);\n        AESROUND(state+32, state+16, state+32);\n        AESROUND(state+16, state+0,  state+16);\n        AESROUND(state+0,  tmp,      state+0);\n\n        //message is used to update the state.\n        XOR128(state, state, plaintextblk);\n}\n\n\n//one step of decryption\ninline void aegis256_dec_aut_step(unsigned char *plaintextblk,\n       const unsigned char *ciphertextblk, unsigned char *state)\n{\n        unsigned char tmp[16];\n\n        AND128(plaintextblk, state+32, state+48);\n        XOR128(plaintextblk, plaintextblk, state+16);\n        XOR128(plaintextblk, plaintextblk, state+64);\n        XOR128(plaintextblk, plaintextblk, state+80);\n        XOR128(plaintextblk, plaintextblk, ciphertextblk);\n\n        //state update function\n        memcpy(tmp, state+80, 16);\n\n        AESROUND(state+80, state+64, state+80);\n        AESROUND(state+64, state+48, state+64);\n        AESROUND(state+48, state+32, state+48);\n        AESROUND(state+32, state+16, state+32);\n        AESROUND(state+16, state+0,  state+16);\n        AESROUND(state+0,  tmp,      state+0);\n\n        //message is used to update the state.\n        XOR128(state, state, plaintextblk);\n}\n\n\n//encrypt a message.\nint crypto_aead_encrypt(\n\tunsigned char *c,unsigned long long *clen,\n\tconst unsigned char *m,unsigned long long mlen,\n\tconst unsigned char *ad,unsigned long long adlen,\n\tconst unsigned char *nsec,\n\tconst unsigned char *npub,\n\tconst unsigned char *k\n\t)\n{\n        unsigned long i;\n        unsigned char plaintextblock[16], ciphertextblock[16], mac[16];\n        unsigned char aegis256_state[96];\n\n        //initialization stage\n        aegis256_initialization(k, npub, aegis256_state);\n\n        //process the associated data\n        for (i = 0; (i+16) <= adlen; i += 16) {\n              aegis256_enc_aut_step(ad+i, ciphertextblock, aegis256_state);\n        }\n\n        //deal with the partial block of associated data\n        //in this program, we assume that the message length is multiple of bytes.\n        if ( (adlen & 0xf) != 0 )  {\n              memset(plaintextblock, 0, 16);\n              memcpy(plaintextblock, ad+i, adlen & 0xf);\n              aegis256_enc_aut_step(plaintextblock, ciphertextblock, aegis256_state);\n        }\n\n        //encrypt the plaintext\n        for (i = 0; (i+16) <= mlen; i += 16) {\n              aegis256_enc_aut_step(m+i, c+i, aegis256_state);\n        }\n\n        // Deal with the partial block\n        // In this program, we assume that the message length is multiple of bytes.\n        if (  (mlen & 0xf) != 0 )  {\n              memset(plaintextblock, 0, 16);\n              memcpy(plaintextblock, m+i, mlen & 0xf);\n              aegis256_enc_aut_step(plaintextblock, ciphertextblock, aegis256_state);\n              memcpy(c+i,ciphertextblock, mlen & 0xf);\n        }\n\n        //finalization stage, we assume that the tag length is a multiple of bytes\n        aegis256_tag_generation(mlen, adlen, 16, mac, aegis256_state);\n        *clen = mlen + 16;\n        memcpy(c+mlen, mac, 16);\n\n        return 0;\n}\n\n\n\nint crypto_aead_decrypt(\n\tunsigned char *m,unsigned long long *mlen,\n\tunsigned char *nsec,\n\tconst unsigned char *c,unsigned long long clen,\n\tconst unsigned char *ad,unsigned long long adlen,\n\tconst unsigned char *npub,\n\tconst unsigned char *k\n\t)\n{\n        unsigned long i;\n        unsigned char plaintextblock[16], ciphertextblock[16];\n        unsigned char tag[16];\n        unsigned char check = 0;\n        unsigned char aegis256_state[96];\n\n        if (clen < 16) return -1;\n\n        aegis256_initialization(k, npub, aegis256_state);\n\n        //process the associated data\n        for (i = 0; (i+16) <= adlen; i += 16) {\n              aegis256_enc_aut_step(ad+i, ciphertextblock, aegis256_state);\n        }\n\n        //deal with the partial block of associated data\n        //in this program, we assume that the message length is multiple of bytes.\n        if (  (adlen & 0xf) != 0 )  {\n              memset(plaintextblock, 0, 16);\n              memcpy(plaintextblock, ad+i, adlen & 0xf);\n              aegis256_enc_aut_step(plaintextblock, ciphertextblock, aegis256_state);\n        }\n\n        *mlen = clen - 16;\n\n        //decrypt the ciphertext\n        for (i = 0; (i+16) <= *mlen; i += 16) {\n              aegis256_dec_aut_step(m+i, c+i, aegis256_state);\n        }\n\n        // Deal with the partial block\n        // In this program, we assume that the message length is multiple of bytes.\n        if (  (*mlen & 0xf) != 0  )  {\n              memset(ciphertextblock, 0, 16);\n              memcpy(ciphertextblock, c+i, *mlen & 0xf);\n              aegis256_dec_aut_step(plaintextblock, ciphertextblock, aegis256_state);\n              memcpy(m+i, plaintextblock, *mlen & 0xf);\n\n              //need to modify the state here (because in the last block, keystream is wrongly used to update the state)\n              memset(plaintextblock, 0, *mlen & 0xf);\n              ((unsigned long long*)aegis256_state)[0] ^= ((unsigned long long*)plaintextblock)[0];\n              ((unsigned long long*)aegis256_state)[1] ^= ((unsigned long long*)plaintextblock)[1];\n        }\n\n        //we assume that the tag length is multiple of bytes\n        aegis256_tag_generation(*mlen, adlen, 16, tag, aegis256_state);\n\n        //verification\n        for (i = 0; i  < 16; i++) check |= (tag[i] ^ c[clen - 16 + i]);\n        if (check == 0) return 0;\n        else return -1;\n}\n\n\n\n} // namespace Aegis256_raw\n"
        },
        {
            "file_name": "aes.c",
            "content": "#include \"crypto_aead.h\"\n#include <immintrin.h>\n#include <wmmintrin.h>\n\ntypedef unsigned int U32;\n\nunsigned char TE0[1024] = {\n0xc6,0x63,0x63,0xa5,  0xf8,0x7c,0x7c,0x84,  0xee,0x77,0x77,0x99,  0xf6,0x7b,0x7b,0x8d,\n0xff,0xf2,0xf2,0xd,   0xd6,0x6b,0x6b,0xbd,  0xde,0x6f,0x6f,0xb1,  0x91,0xc5,0xc5,0x54,\n0x60,0x30,0x30,0x50,  0x2,0x1,0x1,0x3,      0xce,0x67,0x67,0xa9,  0x56,0x2b,0x2b,0x7d,\n0xe7,0xfe,0xfe,0x19,  0xb5,0xd7,0xd7,0x62,  0x4d,0xab,0xab,0xe6,  0xec,0x76,0x76,0x9a,\n0x8f,0xca,0xca,0x45,  0x1f,0x82,0x82,0x9d,  0x89,0xc9,0xc9,0x40,  0xfa,0x7d,0x7d,0x87,\n0xef,0xfa,0xfa,0x15,  0xb2,0x59,0x59,0xeb,  0x8e,0x47,0x47,0xc9,  0xfb,0xf0,0xf0,0xb,\n0x41,0xad,0xad,0xec,  0xb3,0xd4,0xd4,0x67,  0x5f,0xa2,0xa2,0xfd,  0x45,0xaf,0xaf,0xea,\n0x23,0x9c,0x9c,0xbf,  0x53,0xa4,0xa4,0xf7,  0xe4,0x72,0x72,0x96,  0x9b,0xc0,0xc0,0x5b,\n0x75,0xb7,0xb7,0xc2,  0xe1,0xfd,0xfd,0x1c,  0x3d,0x93,0x93,0xae,  0x4c,0x26,0x26,0x6a,\n0x6c,0x36,0x36,0x5a,  0x7e,0x3f,0x3f,0x41,  0xf5,0xf7,0xf7,0x2,   0x83,0xcc,0xcc,0x4f,\n0x68,0x34,0x34,0x5c,  0x51,0xa5,0xa5,0xf4,  0xd1,0xe5,0xe5,0x34,  0xf9,0xf1,0xf1,0x8,\n0xe2,0x71,0x71,0x93,  0xab,0xd8,0xd8,0x73,  0x62,0x31,0x31,0x53,  0x2a,0x15,0x15,0x3f,\n0x8,0x4,0x4,0xc,      0x95,0xc7,0xc7,0x52,  0x46,0x23,0x23,0x65,  0x9d,0xc3,0xc3,0x5e,\n0x30,0x18,0x18,0x28,  0x37,0x96,0x96,0xa1,  0xa,0x5,0x5,0xf,      0x2f,0x9a,0x9a,0xb5,\n0xe,0x7,0x7,0x9,      0x24,0x12,0x12,0x36,  0x1b,0x80,0x80,0x9b,  0xdf,0xe2,0xe2,0x3d,\n0xcd,0xeb,0xeb,0x26,  0x4e,0x27,0x27,0x69,  0x7f,0xb2,0xb2,0xcd,  0xea,0x75,0x75,0x9f,\n0x12,0x9,0x9,0x1b,    0x1d,0x83,0x83,0x9e,  0x58,0x2c,0x2c,0x74,  0x34,0x1a,0x1a,0x2e,\n0x36,0x1b,0x1b,0x2d,  0xdc,0x6e,0x6e,0xb2,  0xb4,0x5a,0x5a,0xee,  0x5b,0xa0,0xa0,0xfb,\n0xa4,0x52,0x52,0xf6,  0x76,0x3b,0x3b,0x4d,  0xb7,0xd6,0xd6,0x61,  0x7d,0xb3,0xb3,0xce,\n0x52,0x29,0x29,0x7b,  0xdd,0xe3,0xe3,0x3e,  0x5e,0x2f,0x2f,0x71,  0x13,0x84,0x84,0x97,\n0xa6,0x53,0x53,0xf5,  0xb9,0xd1,0xd1,0x68,  0x0,0x0,0x0,0x0,      0xc1,0xed,0xed,0x2c,\n0x40,0x20,0x20,0x60,  0xe3,0xfc,0xfc,0x1f,  0x79,0xb1,0xb1,0xc8,  0xb6,0x5b,0x5b,0xed,\n0xd4,0x6a,0x6a,0xbe,  0x8d,0xcb,0xcb,0x46,  0x67,0xbe,0xbe,0xd9,  0x72,0x39,0x39,0x4b,\n0x94,0x4a,0x4a,0xde,  0x98,0x4c,0x4c,0xd4,  0xb0,0x58,0x58,0xe8,  0x85,0xcf,0xcf,0x4a,\n0xbb,0xd0,0xd0,0x6b,  0xc5,0xef,0xef,0x2a,  0x4f,0xaa,0xaa,0xe5,  0xed,0xfb,0xfb,0x16,\n0x86,0x43,0x43,0xc5,  0x9a,0x4d,0x4d,0xd7,  0x66,0x33,0x33,0x55,  0x11,0x85,0x85,0x94,\n0x8a,0x45,0x45,0xcf,  0xe9,0xf9,0xf9,0x10,  0x4,0x2,0x2,0x6,      0xfe,0x7f,0x7f,0x81,\n0xa0,0x50,0x50,0xf0,  0x78,0x3c,0x3c,0x44,  0x25,0x9f,0x9f,0xba,  0x4b,0xa8,0xa8,0xe3,\n0xa2,0x51,0x51,0xf3,  0x5d,0xa3,0xa3,0xfe,  0x80,0x40,0x40,0xc0,  0x5,0x8f,0x8f,0x8a,\n0x3f,0x92,0x92,0xad,  0x21,0x9d,0x9d,0xbc,  0x70,0x38,0x38,0x48,  0xf1,0xf5,0xf5,0x4,\n0x63,0xbc,0xbc,0xdf,  0x77,0xb6,0xb6,0xc1,  0xaf,0xda,0xda,0x75,  0x42,0x21,0x21,0x63,\n0x20,0x10,0x10,0x30,  0xe5,0xff,0xff,0x1a,  0xfd,0xf3,0xf3,0xe,   0xbf,0xd2,0xd2,0x6d,\n0x81,0xcd,0xcd,0x4c,  0x18,0xc,0xc,0x14,    0x26,0x13,0x13,0x35,  0xc3,0xec,0xec,0x2f,\n0xbe,0x5f,0x5f,0xe1,  0x35,0x97,0x97,0xa2,  0x88,0x44,0x44,0xcc,  0x2e,0x17,0x17,0x39,\n0x93,0xc4,0xc4,0x57,  0x55,0xa7,0xa7,0xf2,  0xfc,0x7e,0x7e,0x82,  0x7a,0x3d,0x3d,0x47,\n0xc8,0x64,0x64,0xac,  0xba,0x5d,0x5d,0xe7,  0x32,0x19,0x19,0x2b,  0xe6,0x73,0x73,0x95,\n0xc0,0x60,0x60,0xa0,  0x19,0x81,0x81,0x98,  0x9e,0x4f,0x4f,0xd1,  0xa3,0xdc,0xdc,0x7f,\n0x44,0x22,0x22,0x66,  0x54,0x2a,0x2a,0x7e,  0x3b,0x90,0x90,0xab,  0xb,0x88,0x88,0x83,\n0x8c,0x46,0x46,0xca,  0xc7,0xee,0xee,0x29,  0x6b,0xb8,0xb8,0xd3,  0x28,0x14,0x14,0x3c,\n0xa7,0xde,0xde,0x79,  0xbc,0x5e,0x5e,0xe2,  0x16,0xb,0xb,0x1d,    0xad,0xdb,0xdb,0x76,\n0xdb,0xe0,0xe0,0x3b,  0x64,0x32,0x32,0x56,  0x74,0x3a,0x3a,0x4e,  0x14,0xa,0xa,0x1e,\n0x92,0x49,0x49,0xdb,  0xc,0x6,0x6,0xa,      0x48,0x24,0x24,0x6c,  0xb8,0x5c,0x5c,0xe4,\n0x9f,0xc2,0xc2,0x5d,  0xbd,0xd3,0xd3,0x6e,  0x43,0xac,0xac,0xef,  0xc4,0x62,0x62,0xa6,\n0x39,0x91,0x91,0xa8,  0x31,0x95,0x95,0xa4,  0xd3,0xe4,0xe4,0x37,  0xf2,0x79,0x79,0x8b,\n0xd5,0xe7,0xe7,0x32,  0x8b,0xc8,0xc8,0x43,  0x6e,0x37,0x37,0x59,  0xda,0x6d,0x6d,0xb7,\n0x1,0x8d,0x8d,0x8c,   0xb1,0xd5,0xd5,0x64,  0x9c,0x4e,0x4e,0xd2,  0x49,0xa9,0xa9,0xe0,\n0xd8,0x6c,0x6c,0xb4,  0xac,0x56,0x56,0xfa,  0xf3,0xf4,0xf4,0x7,   0xcf,0xea,0xea,0x25,\n0xca,0x65,0x65,0xaf,  0xf4,0x7a,0x7a,0x8e,  0x47,0xae,0xae,0xe9,  0x10,0x8,0x8,0x18,\n0x6f,0xba,0xba,0xd5,  0xf0,0x78,0x78,0x88,  0x4a,0x25,0x25,0x6f,  0x5c,0x2e,0x2e,0x72,\n0x38,0x1c,0x1c,0x24,  0x57,0xa6,0xa6,0xf1,  0x73,0xb4,0xb4,0xc7,  0x97,0xc6,0xc6,0x51,\n0xcb,0xe8,0xe8,0x23,  0xa1,0xdd,0xdd,0x7c,  0xe8,0x74,0x74,0x9c,  0x3e,0x1f,0x1f,0x21,\n0x96,0x4b,0x4b,0xdd,  0x61,0xbd,0xbd,0xdc,  0xd,0x8b,0x8b,0x86,   0xf,0x8a,0x8a,0x85,\n0xe0,0x70,0x70,0x90,  0x7c,0x3e,0x3e,0x42,  0x71,0xb5,0xb5,0xc4,  0xcc,0x66,0x66,0xaa,\n0x90,0x48,0x48,0xd8,  0x6,0x3,0x3,0x5,      0xf7,0xf6,0xf6,0x1,   0x1c,0xe,0xe,0x12,\n0xc2,0x61,0x61,0xa3,  0x6a,0x35,0x35,0x5f,  0xae,0x57,0x57,0xf9,  0x69,0xb9,0xb9,0xd0,\n0x17,0x86,0x86,0x91,  0x99,0xc1,0xc1,0x58,  0x3a,0x1d,0x1d,0x27,  0x27,0x9e,0x9e,0xb9,\n0xd9,0xe1,0xe1,0x38,  0xeb,0xf8,0xf8,0x13,  0x2b,0x98,0x98,0xb3,  0x22,0x11,0x11,0x33,\n0xd2,0x69,0x69,0xbb,  0xa9,0xd9,0xd9,0x70,  0x7,0x8e,0x8e,0x89,   0x33,0x94,0x94,0xa7,\n0x2d,0x9b,0x9b,0xb6,  0x3c,0x1e,0x1e,0x22,  0x15,0x87,0x87,0x92,  0xc9,0xe9,0xe9,0x20,\n0x87,0xce,0xce,0x49,  0xaa,0x55,0x55,0xff,  0x50,0x28,0x28,0x78,  0xa5,0xdf,0xdf,0x7a,\n0x3,0x8c,0x8c,0x8f,   0x59,0xa1,0xa1,0xf8,  0x9,0x89,0x89,0x80,   0x1a,0xd,0xd,0x17,\n0x65,0xbf,0xbf,0xda,  0xd7,0xe6,0xe6,0x31,  0x84,0x42,0x42,0xc6,  0xd0,0x68,0x68,0xb8,\n0x82,0x41,0x41,0xc3,  0x29,0x99,0x99,0xb0,  0x5a,0x2d,0x2d,0x77,  0x1e,0xf,0xf,0x11,\n0x7b,0xb0,0xb0,0xcb,  0xa8,0x54,0x54,0xfc,  0x6d,0xbb,0xbb,0xd6,  0x2c,0x16,0x16,0x3a};\n\n\nunsigned char TE1[1024] = {\n0xa5,0xc6,0x63,0x63,  0x84,0xf8,0x7c,0x7c,  0x99,0xee,0x77,0x77,  0x8d,0xf6,0x7b,0x7b,\n0xd,0xff,0xf2,0xf2,   0xbd,0xd6,0x6b,0x6b,  0xb1,0xde,0x6f,0x6f,  0x54,0x91,0xc5,0xc5,\n0x50,0x60,0x30,0x30,  0x3,0x2,0x1,0x1,      0xa9,0xce,0x67,0x67,  0x7d,0x56,0x2b,0x2b,\n0x19,0xe7,0xfe,0xfe,  0x62,0xb5,0xd7,0xd7,  0xe6,0x4d,0xab,0xab,  0x9a,0xec,0x76,0x76,\n0x45,0x8f,0xca,0xca,  0x9d,0x1f,0x82,0x82,  0x40,0x89,0xc9,0xc9,  0x87,0xfa,0x7d,0x7d,\n0x15,0xef,0xfa,0xfa,  0xeb,0xb2,0x59,0x59,  0xc9,0x8e,0x47,0x47,  0xb,0xfb,0xf0,0xf0,\n0xec,0x41,0xad,0xad,  0x67,0xb3,0xd4,0xd4,  0xfd,0x5f,0xa2,0xa2,  0xea,0x45,0xaf,0xaf,\n0xbf,0x23,0x9c,0x9c,  0xf7,0x53,0xa4,0xa4,  0x96,0xe4,0x72,0x72,  0x5b,0x9b,0xc0,0xc0,\n0xc2,0x75,0xb7,0xb7,  0x1c,0xe1,0xfd,0xfd,  0xae,0x3d,0x93,0x93,  0x6a,0x4c,0x26,0x26,\n0x5a,0x6c,0x36,0x36,  0x41,0x7e,0x3f,0x3f,  0x2,0xf5,0xf7,0xf7,   0x4f,0x83,0xcc,0xcc,\n0x5c,0x68,0x34,0x34,  0xf4,0x51,0xa5,0xa5,  0x34,0xd1,0xe5,0xe5,  0x8,0xf9,0xf1,0xf1,\n0x93,0xe2,0x71,0x71,  0x73,0xab,0xd8,0xd8,  0x53,0x62,0x31,0x31,  0x3f,0x2a,0x15,0x15,\n0xc,0x8,0x4,0x4,      0x52,0x95,0xc7,0xc7,  0x65,0x46,0x23,0x23,  0x5e,0x9d,0xc3,0xc3,\n0x28,0x30,0x18,0x18,  0xa1,0x37,0x96,0x96,  0xf,0xa,0x5,0x5,      0xb5,0x2f,0x9a,0x9a,\n0x9,0xe,0x7,0x7,      0x36,0x24,0x12,0x12,  0x9b,0x1b,0x80,0x80,  0x3d,0xdf,0xe2,0xe2,\n0x26,0xcd,0xeb,0xeb,  0x69,0x4e,0x27,0x27,  0xcd,0x7f,0xb2,0xb2,  0x9f,0xea,0x75,0x75,\n0x1b,0x12,0x9,0x9,    0x9e,0x1d,0x83,0x83,  0x74,0x58,0x2c,0x2c,  0x2e,0x34,0x1a,0x1a,\n0x2d,0x36,0x1b,0x1b,  0xb2,0xdc,0x6e,0x6e,  0xee,0xb4,0x5a,0x5a,  0xfb,0x5b,0xa0,0xa0,\n0xf6,0xa4,0x52,0x52,  0x4d,0x76,0x3b,0x3b,  0x61,0xb7,0xd6,0xd6,  0xce,0x7d,0xb3,0xb3,\n0x7b,0x52,0x29,0x29,  0x3e,0xdd,0xe3,0xe3,  0x71,0x5e,0x2f,0x2f,  0x97,0x13,0x84,0x84,\n0xf5,0xa6,0x53,0x53,  0x68,0xb9,0xd1,0xd1,  0x0,0x0,0x0,0x0,      0x2c,0xc1,0xed,0xed,\n0x60,0x40,0x20,0x20,  0x1f,0xe3,0xfc,0xfc,  0xc8,0x79,0xb1,0xb1,  0xed,0xb6,0x5b,0x5b,\n0xbe,0xd4,0x6a,0x6a,  0x46,0x8d,0xcb,0xcb,  0xd9,0x67,0xbe,0xbe,  0x4b,0x72,0x39,0x39,\n0xde,0x94,0x4a,0x4a,  0xd4,0x98,0x4c,0x4c,  0xe8,0xb0,0x58,0x58,  0x4a,0x85,0xcf,0xcf,\n0x6b,0xbb,0xd0,0xd0,  0x2a,0xc5,0xef,0xef,  0xe5,0x4f,0xaa,0xaa,  0x16,0xed,0xfb,0xfb,\n0xc5,0x86,0x43,0x43,  0xd7,0x9a,0x4d,0x4d,  0x55,0x66,0x33,0x33,  0x94,0x11,0x85,0x85,\n0xcf,0x8a,0x45,0x45,  0x10,0xe9,0xf9,0xf9,  0x6,0x4,0x2,0x2,      0x81,0xfe,0x7f,0x7f,\n0xf0,0xa0,0x50,0x50,  0x44,0x78,0x3c,0x3c,  0xba,0x25,0x9f,0x9f,  0xe3,0x4b,0xa8,0xa8,\n0xf3,0xa2,0x51,0x51,  0xfe,0x5d,0xa3,0xa3,  0xc0,0x80,0x40,0x40,  0x8a,0x5,0x8f,0x8f,\n0xad,0x3f,0x92,0x92,  0xbc,0x21,0x9d,0x9d,  0x48,0x70,0x38,0x38,  0x4,0xf1,0xf5,0xf5,\n0xdf,0x63,0xbc,0xbc,  0xc1,0x77,0xb6,0xb6,  0x75,0xaf,0xda,0xda,  0x63,0x42,0x21,0x21,\n0x30,0x20,0x10,0x10,  0x1a,0xe5,0xff,0xff,  0xe,0xfd,0xf3,0xf3,   0x6d,0xbf,0xd2,0xd2,\n0x4c,0x81,0xcd,0xcd,  0x14,0x18,0xc,0xc,    0x35,0x26,0x13,0x13,  0x2f,0xc3,0xec,0xec,\n0xe1,0xbe,0x5f,0x5f,  0xa2,0x35,0x97,0x97,  0xcc,0x88,0x44,0x44,  0x39,0x2e,0x17,0x17,\n0x57,0x93,0xc4,0xc4,  0xf2,0x55,0xa7,0xa7,  0x82,0xfc,0x7e,0x7e,  0x47,0x7a,0x3d,0x3d,\n0xac,0xc8,0x64,0x64,  0xe7,0xba,0x5d,0x5d,  0x2b,0x32,0x19,0x19,  0x95,0xe6,0x73,0x73,\n0xa0,0xc0,0x60,0x60,  0x98,0x19,0x81,0x81,  0xd1,0x9e,0x4f,0x4f,  0x7f,0xa3,0xdc,0xdc,\n0x66,0x44,0x22,0x22,  0x7e,0x54,0x2a,0x2a,  0xab,0x3b,0x90,0x90,  0x83,0xb,0x88,0x88,\n0xca,0x8c,0x46,0x46,  0x29,0xc7,0xee,0xee,  0xd3,0x6b,0xb8,0xb8,  0x3c,0x28,0x14,0x14,\n0x79,0xa7,0xde,0xde,  0xe2,0xbc,0x5e,0x5e,  0x1d,0x16,0xb,0xb,    0x76,0xad,0xdb,0xdb,\n0x3b,0xdb,0xe0,0xe0,  0x56,0x64,0x32,0x32,  0x4e,0x74,0x3a,0x3a,  0x1e,0x14,0xa,0xa,\n0xdb,0x92,0x49,0x49,  0xa,0xc,0x6,0x6,      0x6c,0x48,0x24,0x24,  0xe4,0xb8,0x5c,0x5c,\n0x5d,0x9f,0xc2,0xc2,  0x6e,0xbd,0xd3,0xd3,  0xef,0x43,0xac,0xac,  0xa6,0xc4,0x62,0x62,\n0xa8,0x39,0x91,0x91,  0xa4,0x31,0x95,0x95,  0x37,0xd3,0xe4,0xe4,  0x8b,0xf2,0x79,0x79,\n0x32,0xd5,0xe7,0xe7,  0x43,0x8b,0xc8,0xc8,  0x59,0x6e,0x37,0x37,  0xb7,0xda,0x6d,0x6d,\n0x8c,0x1,0x8d,0x8d,   0x64,0xb1,0xd5,0xd5,  0xd2,0x9c,0x4e,0x4e,  0xe0,0x49,0xa9,0xa9,\n0xb4,0xd8,0x6c,0x6c,  0xfa,0xac,0x56,0x56,  0x7,0xf3,0xf4,0xf4,   0x25,0xcf,0xea,0xea,\n0xaf,0xca,0x65,0x65,  0x8e,0xf4,0x7a,0x7a,  0xe9,0x47,0xae,0xae,  0x18,0x10,0x8,0x8,\n0xd5,0x6f,0xba,0xba,  0x88,0xf0,0x78,0x78,  0x6f,0x4a,0x25,0x25,  0x72,0x5c,0x2e,0x2e,\n0x24,0x38,0x1c,0x1c,  0xf1,0x57,0xa6,0xa6,  0xc7,0x73,0xb4,0xb4,  0x51,0x97,0xc6,0xc6,\n0x23,0xcb,0xe8,0xe8,  0x7c,0xa1,0xdd,0xdd,  0x9c,0xe8,0x74,0x74,  0x21,0x3e,0x1f,0x1f,\n0xdd,0x96,0x4b,0x4b,  0xdc,0x61,0xbd,0xbd,  0x86,0xd,0x8b,0x8b,   0x85,0xf,0x8a,0x8a,\n0x90,0xe0,0x70,0x70,  0x42,0x7c,0x3e,0x3e,  0xc4,0x71,0xb5,0xb5,  0xaa,0xcc,0x66,0x66,\n0xd8,0x90,0x48,0x48,  0x5,0x6,0x3,0x3,      0x1,0xf7,0xf6,0xf6,   0x12,0x1c,0xe,0xe,\n0xa3,0xc2,0x61,0x61,  0x5f,0x6a,0x35,0x35,  0xf9,0xae,0x57,0x57,  0xd0,0x69,0xb9,0xb9,\n0x91,0x17,0x86,0x86,  0x58,0x99,0xc1,0xc1,  0x27,0x3a,0x1d,0x1d,  0xb9,0x27,0x9e,0x9e,\n0x38,0xd9,0xe1,0xe1,  0x13,0xeb,0xf8,0xf8,  0xb3,0x2b,0x98,0x98,  0x33,0x22,0x11,0x11,\n0xbb,0xd2,0x69,0x69,  0x70,0xa9,0xd9,0xd9,  0x89,0x7,0x8e,0x8e,   0xa7,0x33,0x94,0x94,\n0xb6,0x2d,0x9b,0x9b,  0x22,0x3c,0x1e,0x1e,  0x92,0x15,0x87,0x87,  0x20,0xc9,0xe9,0xe9,\n0x49,0x87,0xce,0xce,  0xff,0xaa,0x55,0x55,  0x78,0x50,0x28,0x28,  0x7a,0xa5,0xdf,0xdf,\n0x8f,0x3,0x8c,0x8c,   0xf8,0x59,0xa1,0xa1,  0x80,0x9,0x89,0x89,   0x17,0x1a,0xd,0xd,\n0xda,0x65,0xbf,0xbf,  0x31,0xd7,0xe6,0xe6,  0xc6,0x84,0x42,0x42,  0xb8,0xd0,0x68,0x68,\n0xc3,0x82,0x41,0x41,  0xb0,0x29,0x99,0x99,  0x77,0x5a,0x2d,0x2d,  0x11,0x1e,0xf,0xf,\n0xcb,0x7b,0xb0,0xb0,  0xfc,0xa8,0x54,0x54,  0xd6,0x6d,0xbb,0xbb,  0x3a,0x2c,0x16,0x16};\n\n\nunsigned char TE2[1024] = {\n0x63,0xa5,0xc6,0x63,  0x7c,0x84,0xf8,0x7c,  0x77,0x99,0xee,0x77,  0x7b,0x8d,0xf6,0x7b,\n0xf2,0xd,0xff,0xf2,   0x6b,0xbd,0xd6,0x6b,  0x6f,0xb1,0xde,0x6f,  0xc5,0x54,0x91,0xc5,\n0x30,0x50,0x60,0x30,  0x1,0x3,0x2,0x1,      0x67,0xa9,0xce,0x67,  0x2b,0x7d,0x56,0x2b,\n0xfe,0x19,0xe7,0xfe,  0xd7,0x62,0xb5,0xd7,  0xab,0xe6,0x4d,0xab,  0x76,0x9a,0xec,0x76,\n0xca,0x45,0x8f,0xca,  0x82,0x9d,0x1f,0x82,  0xc9,0x40,0x89,0xc9,  0x7d,0x87,0xfa,0x7d,\n0xfa,0x15,0xef,0xfa,  0x59,0xeb,0xb2,0x59,  0x47,0xc9,0x8e,0x47,  0xf0,0xb,0xfb,0xf0,\n0xad,0xec,0x41,0xad,  0xd4,0x67,0xb3,0xd4,  0xa2,0xfd,0x5f,0xa2,  0xaf,0xea,0x45,0xaf,\n0x9c,0xbf,0x23,0x9c,  0xa4,0xf7,0x53,0xa4,  0x72,0x96,0xe4,0x72,  0xc0,0x5b,0x9b,0xc0,\n0xb7,0xc2,0x75,0xb7,  0xfd,0x1c,0xe1,0xfd,  0x93,0xae,0x3d,0x93,  0x26,0x6a,0x4c,0x26,\n0x36,0x5a,0x6c,0x36,  0x3f,0x41,0x7e,0x3f,  0xf7,0x2,0xf5,0xf7,   0xcc,0x4f,0x83,0xcc,\n0x34,0x5c,0x68,0x34,  0xa5,0xf4,0x51,0xa5,  0xe5,0x34,0xd1,0xe5,  0xf1,0x8,0xf9,0xf1,\n0x71,0x93,0xe2,0x71,  0xd8,0x73,0xab,0xd8,  0x31,0x53,0x62,0x31,  0x15,0x3f,0x2a,0x15,\n0x4,0xc,0x8,0x4,      0xc7,0x52,0x95,0xc7,  0x23,0x65,0x46,0x23,  0xc3,0x5e,0x9d,0xc3,\n0x18,0x28,0x30,0x18,  0x96,0xa1,0x37,0x96,  0x5,0xf,0xa,0x5,      0x9a,0xb5,0x2f,0x9a,\n0x7,0x9,0xe,0x7,      0x12,0x36,0x24,0x12,  0x80,0x9b,0x1b,0x80,  0xe2,0x3d,0xdf,0xe2,\n0xeb,0x26,0xcd,0xeb,  0x27,0x69,0x4e,0x27,  0xb2,0xcd,0x7f,0xb2,  0x75,0x9f,0xea,0x75,\n0x9,0x1b,0x12,0x9,    0x83,0x9e,0x1d,0x83,  0x2c,0x74,0x58,0x2c,  0x1a,0x2e,0x34,0x1a,\n0x1b,0x2d,0x36,0x1b,  0x6e,0xb2,0xdc,0x6e,  0x5a,0xee,0xb4,0x5a,  0xa0,0xfb,0x5b,0xa0,\n0x52,0xf6,0xa4,0x52,  0x3b,0x4d,0x76,0x3b,  0xd6,0x61,0xb7,0xd6,  0xb3,0xce,0x7d,0xb3,\n0x29,0x7b,0x52,0x29,  0xe3,0x3e,0xdd,0xe3,  0x2f,0x71,0x5e,0x2f,  0x84,0x97,0x13,0x84,\n0x53,0xf5,0xa6,0x53,  0xd1,0x68,0xb9,0xd1,  0x0,0x0,0x0,0x0,      0xed,0x2c,0xc1,0xed,\n0x20,0x60,0x40,0x20,  0xfc,0x1f,0xe3,0xfc,  0xb1,0xc8,0x79,0xb1,  0x5b,0xed,0xb6,0x5b,\n0x6a,0xbe,0xd4,0x6a,  0xcb,0x46,0x8d,0xcb,  0xbe,0xd9,0x67,0xbe,  0x39,0x4b,0x72,0x39,\n0x4a,0xde,0x94,0x4a,  0x4c,0xd4,0x98,0x4c,  0x58,0xe8,0xb0,0x58,  0xcf,0x4a,0x85,0xcf,\n0xd0,0x6b,0xbb,0xd0,  0xef,0x2a,0xc5,0xef,  0xaa,0xe5,0x4f,0xaa,  0xfb,0x16,0xed,0xfb,\n0x43,0xc5,0x86,0x43,  0x4d,0xd7,0x9a,0x4d,  0x33,0x55,0x66,0x33,  0x85,0x94,0x11,0x85,\n0x45,0xcf,0x8a,0x45,  0xf9,0x10,0xe9,0xf9,  0x2,0x6,0x4,0x2,      0x7f,0x81,0xfe,0x7f,\n0x50,0xf0,0xa0,0x50,  0x3c,0x44,0x78,0x3c,  0x9f,0xba,0x25,0x9f,  0xa8,0xe3,0x4b,0xa8,\n0x51,0xf3,0xa2,0x51,  0xa3,0xfe,0x5d,0xa3,  0x40,0xc0,0x80,0x40,  0x8f,0x8a,0x5,0x8f,\n0x92,0xad,0x3f,0x92,  0x9d,0xbc,0x21,0x9d,  0x38,0x48,0x70,0x38,  0xf5,0x4,0xf1,0xf5,\n0xbc,0xdf,0x63,0xbc,  0xb6,0xc1,0x77,0xb6,  0xda,0x75,0xaf,0xda,  0x21,0x63,0x42,0x21,\n0x10,0x30,0x20,0x10,  0xff,0x1a,0xe5,0xff,  0xf3,0xe,0xfd,0xf3,   0xd2,0x6d,0xbf,0xd2,\n0xcd,0x4c,0x81,0xcd,  0xc,0x14,0x18,0xc,    0x13,0x35,0x26,0x13,  0xec,0x2f,0xc3,0xec,\n0x5f,0xe1,0xbe,0x5f,  0x97,0xa2,0x35,0x97,  0x44,0xcc,0x88,0x44,  0x17,0x39,0x2e,0x17,\n0xc4,0x57,0x93,0xc4,  0xa7,0xf2,0x55,0xa7,  0x7e,0x82,0xfc,0x7e,  0x3d,0x47,0x7a,0x3d,\n0x64,0xac,0xc8,0x64,  0x5d,0xe7,0xba,0x5d,  0x19,0x2b,0x32,0x19,  0x73,0x95,0xe6,0x73,\n0x60,0xa0,0xc0,0x60,  0x81,0x98,0x19,0x81,  0x4f,0xd1,0x9e,0x4f,  0xdc,0x7f,0xa3,0xdc,\n0x22,0x66,0x44,0x22,  0x2a,0x7e,0x54,0x2a,  0x90,0xab,0x3b,0x90,  0x88,0x83,0xb,0x88,\n0x46,0xca,0x8c,0x46,  0xee,0x29,0xc7,0xee,  0xb8,0xd3,0x6b,0xb8,  0x14,0x3c,0x28,0x14,\n0xde,0x79,0xa7,0xde,  0x5e,0xe2,0xbc,0x5e,  0xb,0x1d,0x16,0xb,    0xdb,0x76,0xad,0xdb,\n0xe0,0x3b,0xdb,0xe0,  0x32,0x56,0x64,0x32,  0x3a,0x4e,0x74,0x3a,  0xa,0x1e,0x14,0xa,\n0x49,0xdb,0x92,0x49,  0x6,0xa,0xc,0x6,      0x24,0x6c,0x48,0x24,  0x5c,0xe4,0xb8,0x5c,\n0xc2,0x5d,0x9f,0xc2,  0xd3,0x6e,0xbd,0xd3,  0xac,0xef,0x43,0xac,  0x62,0xa6,0xc4,0x62,\n0x91,0xa8,0x39,0x91,  0x95,0xa4,0x31,0x95,  0xe4,0x37,0xd3,0xe4,  0x79,0x8b,0xf2,0x79,\n0xe7,0x32,0xd5,0xe7,  0xc8,0x43,0x8b,0xc8,  0x37,0x59,0x6e,0x37,  0x6d,0xb7,0xda,0x6d,\n0x8d,0x8c,0x1,0x8d,   0xd5,0x64,0xb1,0xd5,  0x4e,0xd2,0x9c,0x4e,  0xa9,0xe0,0x49,0xa9,\n0x6c,0xb4,0xd8,0x6c,  0x56,0xfa,0xac,0x56,  0xf4,0x7,0xf3,0xf4,   0xea,0x25,0xcf,0xea,\n0x65,0xaf,0xca,0x65,  0x7a,0x8e,0xf4,0x7a,  0xae,0xe9,0x47,0xae,  0x8,0x18,0x10,0x8,\n0xba,0xd5,0x6f,0xba,  0x78,0x88,0xf0,0x78,  0x25,0x6f,0x4a,0x25,  0x2e,0x72,0x5c,0x2e,\n0x1c,0x24,0x38,0x1c,  0xa6,0xf1,0x57,0xa6,  0xb4,0xc7,0x73,0xb4,  0xc6,0x51,0x97,0xc6,\n0xe8,0x23,0xcb,0xe8,  0xdd,0x7c,0xa1,0xdd,  0x74,0x9c,0xe8,0x74,  0x1f,0x21,0x3e,0x1f,\n0x4b,0xdd,0x96,0x4b,  0xbd,0xdc,0x61,0xbd,  0x8b,0x86,0xd,0x8b,   0x8a,0x85,0xf,0x8a,\n0x70,0x90,0xe0,0x70,  0x3e,0x42,0x7c,0x3e,  0xb5,0xc4,0x71,0xb5,  0x66,0xaa,0xcc,0x66,\n0x48,0xd8,0x90,0x48,  0x3,0x5,0x6,0x3,      0xf6,0x1,0xf7,0xf6,   0xe,0x12,0x1c,0xe,\n0x61,0xa3,0xc2,0x61,  0x35,0x5f,0x6a,0x35,  0x57,0xf9,0xae,0x57,  0xb9,0xd0,0x69,0xb9,\n0x86,0x91,0x17,0x86,  0xc1,0x58,0x99,0xc1,  0x1d,0x27,0x3a,0x1d,  0x9e,0xb9,0x27,0x9e,\n0xe1,0x38,0xd9,0xe1,  0xf8,0x13,0xeb,0xf8,  0x98,0xb3,0x2b,0x98,  0x11,0x33,0x22,0x11,\n0x69,0xbb,0xd2,0x69,  0xd9,0x70,0xa9,0xd9,  0x8e,0x89,0x7,0x8e,   0x94,0xa7,0x33,0x94,\n0x9b,0xb6,0x2d,0x9b,  0x1e,0x22,0x3c,0x1e,  0x87,0x92,0x15,0x87,  0xe9,0x20,0xc9,0xe9,\n0xce,0x49,0x87,0xce,  0x55,0xff,0xaa,0x55,  0x28,0x78,0x50,0x28,  0xdf,0x7a,0xa5,0xdf,\n0x8c,0x8f,0x3,0x8c,   0xa1,0xf8,0x59,0xa1,  0x89,0x80,0x9,0x89,   0xd,0x17,0x1a,0xd,\n0xbf,0xda,0x65,0xbf,  0xe6,0x31,0xd7,0xe6,  0x42,0xc6,0x84,0x42,  0x68,0xb8,0xd0,0x68,\n0x41,0xc3,0x82,0x41,  0x99,0xb0,0x29,0x99,  0x2d,0x77,0x5a,0x2d,  0xf,0x11,0x1e,0xf,\n0xb0,0xcb,0x7b,0xb0,  0x54,0xfc,0xa8,0x54,  0xbb,0xd6,0x6d,0xbb,  0x16,0x3a,0x2c,0x16};\n\n\nunsigned char TE3[1024] = {\n0x63,0x63,0xa5,0xc6,  0x7c,0x7c,0x84,0xf8,  0x77,0x77,0x99,0xee,  0x7b,0x7b,0x8d,0xf6,\n0xf2,0xf2,0xd,0xff,   0x6b,0x6b,0xbd,0xd6,  0x6f,0x6f,0xb1,0xde,  0xc5,0xc5,0x54,0x91,\n0x30,0x30,0x50,0x60,  0x1,0x1,0x3,0x2,      0x67,0x67,0xa9,0xce,  0x2b,0x2b,0x7d,0x56,\n0xfe,0xfe,0x19,0xe7,  0xd7,0xd7,0x62,0xb5,  0xab,0xab,0xe6,0x4d,  0x76,0x76,0x9a,0xec,\n0xca,0xca,0x45,0x8f,  0x82,0x82,0x9d,0x1f,  0xc9,0xc9,0x40,0x89,  0x7d,0x7d,0x87,0xfa,\n0xfa,0xfa,0x15,0xef,  0x59,0x59,0xeb,0xb2,  0x47,0x47,0xc9,0x8e,  0xf0,0xf0,0xb,0xfb,\n0xad,0xad,0xec,0x41,  0xd4,0xd4,0x67,0xb3,  0xa2,0xa2,0xfd,0x5f,  0xaf,0xaf,0xea,0x45,\n0x9c,0x9c,0xbf,0x23,  0xa4,0xa4,0xf7,0x53,  0x72,0x72,0x96,0xe4,  0xc0,0xc0,0x5b,0x9b,\n0xb7,0xb7,0xc2,0x75,  0xfd,0xfd,0x1c,0xe1,  0x93,0x93,0xae,0x3d,  0x26,0x26,0x6a,0x4c,\n0x36,0x36,0x5a,0x6c,  0x3f,0x3f,0x41,0x7e,  0xf7,0xf7,0x2,0xf5,   0xcc,0xcc,0x4f,0x83,\n0x34,0x34,0x5c,0x68,  0xa5,0xa5,0xf4,0x51,  0xe5,0xe5,0x34,0xd1,  0xf1,0xf1,0x8,0xf9,\n0x71,0x71,0x93,0xe2,  0xd8,0xd8,0x73,0xab,  0x31,0x31,0x53,0x62,  0x15,0x15,0x3f,0x2a,\n0x4,0x4,0xc,0x8,      0xc7,0xc7,0x52,0x95,  0x23,0x23,0x65,0x46,  0xc3,0xc3,0x5e,0x9d,\n0x18,0x18,0x28,0x30,  0x96,0x96,0xa1,0x37,  0x5,0x5,0xf,0xa,      0x9a,0x9a,0xb5,0x2f,\n0x7,0x7,0x9,0xe,      0x12,0x12,0x36,0x24,  0x80,0x80,0x9b,0x1b,  0xe2,0xe2,0x3d,0xdf,\n0xeb,0xeb,0x26,0xcd,  0x27,0x27,0x69,0x4e,  0xb2,0xb2,0xcd,0x7f,  0x75,0x75,0x9f,0xea,\n0x9,0x9,0x1b,0x12,    0x83,0x83,0x9e,0x1d,  0x2c,0x2c,0x74,0x58,  0x1a,0x1a,0x2e,0x34,\n0x1b,0x1b,0x2d,0x36,  0x6e,0x6e,0xb2,0xdc,  0x5a,0x5a,0xee,0xb4,  0xa0,0xa0,0xfb,0x5b,\n0x52,0x52,0xf6,0xa4,  0x3b,0x3b,0x4d,0x76,  0xd6,0xd6,0x61,0xb7,  0xb3,0xb3,0xce,0x7d,\n0x29,0x29,0x7b,0x52,  0xe3,0xe3,0x3e,0xdd,  0x2f,0x2f,0x71,0x5e,  0x84,0x84,0x97,0x13,\n0x53,0x53,0xf5,0xa6,  0xd1,0xd1,0x68,0xb9,  0x0,0x0,0x0,0x0,      0xed,0xed,0x2c,0xc1,\n0x20,0x20,0x60,0x40,  0xfc,0xfc,0x1f,0xe3,  0xb1,0xb1,0xc8,0x79,  0x5b,0x5b,0xed,0xb6,\n0x6a,0x6a,0xbe,0xd4,  0xcb,0xcb,0x46,0x8d,  0xbe,0xbe,0xd9,0x67,  0x39,0x39,0x4b,0x72,\n0x4a,0x4a,0xde,0x94,  0x4c,0x4c,0xd4,0x98,  0x58,0x58,0xe8,0xb0,  0xcf,0xcf,0x4a,0x85,\n0xd0,0xd0,0x6b,0xbb,  0xef,0xef,0x2a,0xc5,  0xaa,0xaa,0xe5,0x4f,  0xfb,0xfb,0x16,0xed,\n0x43,0x43,0xc5,0x86,  0x4d,0x4d,0xd7,0x9a,  0x33,0x33,0x55,0x66,  0x85,0x85,0x94,0x11,\n0x45,0x45,0xcf,0x8a,  0xf9,0xf9,0x10,0xe9,  0x2,0x2,0x6,0x4,      0x7f,0x7f,0x81,0xfe,\n0x50,0x50,0xf0,0xa0,  0x3c,0x3c,0x44,0x78,  0x9f,0x9f,0xba,0x25,  0xa8,0xa8,0xe3,0x4b,\n0x51,0x51,0xf3,0xa2,  0xa3,0xa3,0xfe,0x5d,  0x40,0x40,0xc0,0x80,  0x8f,0x8f,0x8a,0x5,\n0x92,0x92,0xad,0x3f,  0x9d,0x9d,0xbc,0x21,  0x38,0x38,0x48,0x70,  0xf5,0xf5,0x4,0xf1,\n0xbc,0xbc,0xdf,0x63,  0xb6,0xb6,0xc1,0x77,  0xda,0xda,0x75,0xaf,  0x21,0x21,0x63,0x42,\n0x10,0x10,0x30,0x20,  0xff,0xff,0x1a,0xe5,  0xf3,0xf3,0xe,0xfd,   0xd2,0xd2,0x6d,0xbf,\n0xcd,0xcd,0x4c,0x81,  0xc,0xc,0x14,0x18,    0x13,0x13,0x35,0x26,  0xec,0xec,0x2f,0xc3,\n0x5f,0x5f,0xe1,0xbe,  0x97,0x97,0xa2,0x35,  0x44,0x44,0xcc,0x88,  0x17,0x17,0x39,0x2e,\n0xc4,0xc4,0x57,0x93,  0xa7,0xa7,0xf2,0x55,  0x7e,0x7e,0x82,0xfc,  0x3d,0x3d,0x47,0x7a,\n0x64,0x64,0xac,0xc8,  0x5d,0x5d,0xe7,0xba,  0x19,0x19,0x2b,0x32,  0x73,0x73,0x95,0xe6,\n0x60,0x60,0xa0,0xc0,  0x81,0x81,0x98,0x19,  0x4f,0x4f,0xd1,0x9e,  0xdc,0xdc,0x7f,0xa3,\n0x22,0x22,0x66,0x44,  0x2a,0x2a,0x7e,0x54,  0x90,0x90,0xab,0x3b,  0x88,0x88,0x83,0xb,\n0x46,0x46,0xca,0x8c,  0xee,0xee,0x29,0xc7,  0xb8,0xb8,0xd3,0x6b,  0x14,0x14,0x3c,0x28,\n0xde,0xde,0x79,0xa7,  0x5e,0x5e,0xe2,0xbc,  0xb,0xb,0x1d,0x16,    0xdb,0xdb,0x76,0xad,\n0xe0,0xe0,0x3b,0xdb,  0x32,0x32,0x56,0x64,  0x3a,0x3a,0x4e,0x74,  0xa,0xa,0x1e,0x14,\n0x49,0x49,0xdb,0x92,  0x6,0x6,0xa,0xc,      0x24,0x24,0x6c,0x48,  0x5c,0x5c,0xe4,0xb8,\n0xc2,0xc2,0x5d,0x9f,  0xd3,0xd3,0x6e,0xbd,  0xac,0xac,0xef,0x43,  0x62,0x62,0xa6,0xc4,\n0x91,0x91,0xa8,0x39,  0x95,0x95,0xa4,0x31,  0xe4,0xe4,0x37,0xd3,  0x79,0x79,0x8b,0xf2,\n0xe7,0xe7,0x32,0xd5,  0xc8,0xc8,0x43,0x8b,  0x37,0x37,0x59,0x6e,  0x6d,0x6d,0xb7,0xda,\n0x8d,0x8d,0x8c,0x1,   0xd5,0xd5,0x64,0xb1,  0x4e,0x4e,0xd2,0x9c,  0xa9,0xa9,0xe0,0x49,\n0x6c,0x6c,0xb4,0xd8,  0x56,0x56,0xfa,0xac,  0xf4,0xf4,0x7,0xf3,   0xea,0xea,0x25,0xcf,\n0x65,0x65,0xaf,0xca,  0x7a,0x7a,0x8e,0xf4,  0xae,0xae,0xe9,0x47,  0x8,0x8,0x18,0x10,\n0xba,0xba,0xd5,0x6f,  0x78,0x78,0x88,0xf0,  0x25,0x25,0x6f,0x4a,  0x2e,0x2e,0x72,0x5c,\n0x1c,0x1c,0x24,0x38,  0xa6,0xa6,0xf1,0x57,  0xb4,0xb4,0xc7,0x73,  0xc6,0xc6,0x51,0x97,\n0xe8,0xe8,0x23,0xcb,  0xdd,0xdd,0x7c,0xa1,  0x74,0x74,0x9c,0xe8,  0x1f,0x1f,0x21,0x3e,\n0x4b,0x4b,0xdd,0x96,  0xbd,0xbd,0xdc,0x61,  0x8b,0x8b,0x86,0xd,   0x8a,0x8a,0x85,0xf,\n0x70,0x70,0x90,0xe0,  0x3e,0x3e,0x42,0x7c,  0xb5,0xb5,0xc4,0x71,  0x66,0x66,0xaa,0xcc,\n0x48,0x48,0xd8,0x90,  0x3,0x3,0x5,0x6,      0xf6,0xf6,0x1,0xf7,   0xe,0xe,0x12,0x1c,\n0x61,0x61,0xa3,0xc2,  0x35,0x35,0x5f,0x6a,  0x57,0x57,0xf9,0xae,  0xb9,0xb9,0xd0,0x69,\n0x86,0x86,0x91,0x17,  0xc1,0xc1,0x58,0x99,  0x1d,0x1d,0x27,0x3a,  0x9e,0x9e,0xb9,0x27,\n0xe1,0xe1,0x38,0xd9,  0xf8,0xf8,0x13,0xeb,  0x98,0x98,0xb3,0x2b,  0x11,0x11,0x33,0x22,\n0x69,0x69,0xbb,0xd2,  0xd9,0xd9,0x70,0xa9,  0x8e,0x8e,0x89,0x7,   0x94,0x94,0xa7,0x33,\n0x9b,0x9b,0xb6,0x2d,  0x1e,0x1e,0x22,0x3c,  0x87,0x87,0x92,0x15,  0xe9,0xe9,0x20,0xc9,\n0xce,0xce,0x49,0x87,  0x55,0x55,0xff,0xaa,  0x28,0x28,0x78,0x50,  0xdf,0xdf,0x7a,0xa5,\n0x8c,0x8c,0x8f,0x3,   0xa1,0xa1,0xf8,0x59,  0x89,0x89,0x80,0x9,   0xd,0xd,0x17,0x1a,\n0xbf,0xbf,0xda,0x65,  0xe6,0xe6,0x31,0xd7,  0x42,0x42,0xc6,0x84,  0x68,0x68,0xb8,0xd0,\n0x41,0x41,0xc3,0x82,  0x99,0x99,0xb0,0x29,  0x2d,0x2d,0x77,0x5a,  0xf,0xf,0x11,0x1e,\n0xb0,0xb0,0xcb,0x7b,  0x54,0x54,0xfc,0xa8,  0xbb,0xbb,0xd6,0x6d,  0x16,0x16,0x3a,0x2c};\n\n\nvoid AESROUND(unsigned char *out, unsigned char *in, unsigned char *rk)\n{    \n    __m128i pt = _mm_load_si128((__m128i*)in);\n    __m128i key = _mm_load_si128((__m128i*)rk);\n    __m128i zero = _mm_setzero_si128();\n    __m128i ct = _mm_aesenc_si128(pt,zero);\n    ct = _mm_xor_si128(ct, key);\n    _mm_store_si128((__m128i*)out,ct);\n}\n\nvoid AESROUND_INV(unsigned char *out, unsigned char *in, unsigned char *rk)\n{    \n    __m128i ct = _mm_load_si128((__m128i*)in);\n    __m128i key = _mm_load_si128((__m128i*)rk);\n    ct = _mm_xor_si128(ct, key);\n    __m128i zero = _mm_setzero_si128();\n    ct = _mm_aesenclast_si128(ct,zero);\n    __m128i pt = _mm_aesdec_si128(ct,zero);\n    pt = _mm_aesdeclast_si128(pt,zero);\n    _mm_store_si128((__m128i*)out,pt);\n}\n"
        },
        {
            "file_name": "aes128marble4rv1_aes_core.cpp",
            "content": "/* Taken from OpenSSL sources.  Thanks Vincent, Antoon and Paulo!\n * -Jason Holt\n */\n\n/* crypto/aes/aes_core.c -*- mode:C; c-file-style: \"eay\" -*- */\n/**\n * rijndael-alg-fst.c\n *\n * @version 3.0 (December 2000)\n *\n * Optimised ANSI C code for the Rijndael cipher (now AES)\n *\n * @author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be>\n * @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be>\n * @author Paulo Barreto <paulo.barreto@terra.com.br>\n *\n * This code is hereby placed in the public domain.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* Note: rewritten a little bit to provide error control and an OpenSSL-\n    compatible API */\n\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include \"aes128marble4rv1_aes.h\"\n#include \"aes128marble4rv1_aes_locl.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Aes128marble4rv1_raw {\n\n#define ROUNDS 4\n\n/*\n    Te0[x] = S [x].[02, 01, 01, 03];\n    Te1[x] = S [x].[03, 02, 01, 01];\n    Te2[x] = S [x].[01, 03, 02, 01];\n    Te3[x] = S [x].[01, 01, 03, 02];\n    Te4[x] = S [x].[01, 01, 01, 01];\n\n    Td0[x] = Si[x].[0e, 09, 0d, 0b];\n    Td1[x] = Si[x].[0b, 0e, 09, 0d];\n    Td2[x] = Si[x].[0d, 0b, 0e, 09];\n    Td3[x] = Si[x].[09, 0d, 0b, 0e];\n    Td4[x] = Si[x].[01, 01, 01, 01];\n */\n\nstatic const u32 Te0[256] = {\n    0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,\n    0xfff2f20dU, 0xd66b6bbdU, 0xde6f6fb1U, 0x91c5c554U,\n    0x60303050U, 0x02010103U, 0xce6767a9U, 0x562b2b7dU,\n    0xe7fefe19U, 0xb5d7d762U, 0x4dababe6U, 0xec76769aU,\n    0x8fcaca45U, 0x1f82829dU, 0x89c9c940U, 0xfa7d7d87U,\n    0xeffafa15U, 0xb25959ebU, 0x8e4747c9U, 0xfbf0f00bU,\n    0x41adadecU, 0xb3d4d467U, 0x5fa2a2fdU, 0x45afafeaU,\n    0x239c9cbfU, 0x53a4a4f7U, 0xe4727296U, 0x9bc0c05bU,\n    0x75b7b7c2U, 0xe1fdfd1cU, 0x3d9393aeU, 0x4c26266aU,\n    0x6c36365aU, 0x7e3f3f41U, 0xf5f7f702U, 0x83cccc4fU,\n    0x6834345cU, 0x51a5a5f4U, 0xd1e5e534U, 0xf9f1f108U,\n    0xe2717193U, 0xabd8d873U, 0x62313153U, 0x2a15153fU,\n    0x0804040cU, 0x95c7c752U, 0x46232365U, 0x9dc3c35eU,\n    0x30181828U, 0x379696a1U, 0x0a05050fU, 0x2f9a9ab5U,\n    0x0e070709U, 0x24121236U, 0x1b80809bU, 0xdfe2e23dU,\n    0xcdebeb26U, 0x4e272769U, 0x7fb2b2cdU, 0xea75759fU,\n    0x1209091bU, 0x1d83839eU, 0x582c2c74U, 0x341a1a2eU,\n    0x361b1b2dU, 0xdc6e6eb2U, 0xb45a5aeeU, 0x5ba0a0fbU,\n    0xa45252f6U, 0x763b3b4dU, 0xb7d6d661U, 0x7db3b3ceU,\n    0x5229297bU, 0xdde3e33eU, 0x5e2f2f71U, 0x13848497U,\n    0xa65353f5U, 0xb9d1d168U, 0x00000000U, 0xc1eded2cU,\n    0x40202060U, 0xe3fcfc1fU, 0x79b1b1c8U, 0xb65b5bedU,\n    0xd46a6abeU, 0x8dcbcb46U, 0x67bebed9U, 0x7239394bU,\n    0x944a4adeU, 0x984c4cd4U, 0xb05858e8U, 0x85cfcf4aU,\n    0xbbd0d06bU, 0xc5efef2aU, 0x4faaaae5U, 0xedfbfb16U,\n    0x864343c5U, 0x9a4d4dd7U, 0x66333355U, 0x11858594U,\n    0x8a4545cfU, 0xe9f9f910U, 0x04020206U, 0xfe7f7f81U,\n    0xa05050f0U, 0x783c3c44U, 0x259f9fbaU, 0x4ba8a8e3U,\n    0xa25151f3U, 0x5da3a3feU, 0x804040c0U, 0x058f8f8aU,\n    0x3f9292adU, 0x219d9dbcU, 0x70383848U, 0xf1f5f504U,\n    0x63bcbcdfU, 0x77b6b6c1U, 0xafdada75U, 0x42212163U,\n    0x20101030U, 0xe5ffff1aU, 0xfdf3f30eU, 0xbfd2d26dU,\n    0x81cdcd4cU, 0x180c0c14U, 0x26131335U, 0xc3ecec2fU,\n    0xbe5f5fe1U, 0x359797a2U, 0x884444ccU, 0x2e171739U,\n    0x93c4c457U, 0x55a7a7f2U, 0xfc7e7e82U, 0x7a3d3d47U,\n    0xc86464acU, 0xba5d5de7U, 0x3219192bU, 0xe6737395U,\n    0xc06060a0U, 0x19818198U, 0x9e4f4fd1U, 0xa3dcdc7fU,\n    0x44222266U, 0x542a2a7eU, 0x3b9090abU, 0x0b888883U,\n    0x8c4646caU, 0xc7eeee29U, 0x6bb8b8d3U, 0x2814143cU,\n    0xa7dede79U, 0xbc5e5ee2U, 0x160b0b1dU, 0xaddbdb76U,\n    0xdbe0e03bU, 0x64323256U, 0x743a3a4eU, 0x140a0a1eU,\n    0x924949dbU, 0x0c06060aU, 0x4824246cU, 0xb85c5ce4U,\n    0x9fc2c25dU, 0xbdd3d36eU, 0x43acacefU, 0xc46262a6U,\n    0x399191a8U, 0x319595a4U, 0xd3e4e437U, 0xf279798bU,\n    0xd5e7e732U, 0x8bc8c843U, 0x6e373759U, 0xda6d6db7U,\n    0x018d8d8cU, 0xb1d5d564U, 0x9c4e4ed2U, 0x49a9a9e0U,\n    0xd86c6cb4U, 0xac5656faU, 0xf3f4f407U, 0xcfeaea25U,\n    0xca6565afU, 0xf47a7a8eU, 0x47aeaee9U, 0x10080818U,\n    0x6fbabad5U, 0xf0787888U, 0x4a25256fU, 0x5c2e2e72U,\n    0x381c1c24U, 0x57a6a6f1U, 0x73b4b4c7U, 0x97c6c651U,\n    0xcbe8e823U, 0xa1dddd7cU, 0xe874749cU, 0x3e1f1f21U,\n    0x964b4bddU, 0x61bdbddcU, 0x0d8b8b86U, 0x0f8a8a85U,\n    0xe0707090U, 0x7c3e3e42U, 0x71b5b5c4U, 0xcc6666aaU,\n    0x904848d8U, 0x06030305U, 0xf7f6f601U, 0x1c0e0e12U,\n    0xc26161a3U, 0x6a35355fU, 0xae5757f9U, 0x69b9b9d0U,\n    0x17868691U, 0x99c1c158U, 0x3a1d1d27U, 0x279e9eb9U,\n    0xd9e1e138U, 0xebf8f813U, 0x2b9898b3U, 0x22111133U,\n    0xd26969bbU, 0xa9d9d970U, 0x078e8e89U, 0x339494a7U,\n    0x2d9b9bb6U, 0x3c1e1e22U, 0x15878792U, 0xc9e9e920U,\n    0x87cece49U, 0xaa5555ffU, 0x50282878U, 0xa5dfdf7aU,\n    0x038c8c8fU, 0x59a1a1f8U, 0x09898980U, 0x1a0d0d17U,\n    0x65bfbfdaU, 0xd7e6e631U, 0x844242c6U, 0xd06868b8U,\n    0x824141c3U, 0x299999b0U, 0x5a2d2d77U, 0x1e0f0f11U,\n    0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,\n};\nstatic const u32 Te1[256] = {\n    0xa5c66363U, 0x84f87c7cU, 0x99ee7777U, 0x8df67b7bU,\n    0x0dfff2f2U, 0xbdd66b6bU, 0xb1de6f6fU, 0x5491c5c5U,\n    0x50603030U, 0x03020101U, 0xa9ce6767U, 0x7d562b2bU,\n    0x19e7fefeU, 0x62b5d7d7U, 0xe64dababU, 0x9aec7676U,\n    0x458fcacaU, 0x9d1f8282U, 0x4089c9c9U, 0x87fa7d7dU,\n    0x15effafaU, 0xebb25959U, 0xc98e4747U, 0x0bfbf0f0U,\n    0xec41adadU, 0x67b3d4d4U, 0xfd5fa2a2U, 0xea45afafU,\n    0xbf239c9cU, 0xf753a4a4U, 0x96e47272U, 0x5b9bc0c0U,\n    0xc275b7b7U, 0x1ce1fdfdU, 0xae3d9393U, 0x6a4c2626U,\n    0x5a6c3636U, 0x417e3f3fU, 0x02f5f7f7U, 0x4f83ccccU,\n    0x5c683434U, 0xf451a5a5U, 0x34d1e5e5U, 0x08f9f1f1U,\n    0x93e27171U, 0x73abd8d8U, 0x53623131U, 0x3f2a1515U,\n    0x0c080404U, 0x5295c7c7U, 0x65462323U, 0x5e9dc3c3U,\n    0x28301818U, 0xa1379696U, 0x0f0a0505U, 0xb52f9a9aU,\n    0x090e0707U, 0x36241212U, 0x9b1b8080U, 0x3ddfe2e2U,\n    0x26cdebebU, 0x694e2727U, 0xcd7fb2b2U, 0x9fea7575U,\n    0x1b120909U, 0x9e1d8383U, 0x74582c2cU, 0x2e341a1aU,\n    0x2d361b1bU, 0xb2dc6e6eU, 0xeeb45a5aU, 0xfb5ba0a0U,\n    0xf6a45252U, 0x4d763b3bU, 0x61b7d6d6U, 0xce7db3b3U,\n    0x7b522929U, 0x3edde3e3U, 0x715e2f2fU, 0x97138484U,\n    0xf5a65353U, 0x68b9d1d1U, 0x00000000U, 0x2cc1ededU,\n    0x60402020U, 0x1fe3fcfcU, 0xc879b1b1U, 0xedb65b5bU,\n    0xbed46a6aU, 0x468dcbcbU, 0xd967bebeU, 0x4b723939U,\n    0xde944a4aU, 0xd4984c4cU, 0xe8b05858U, 0x4a85cfcfU,\n    0x6bbbd0d0U, 0x2ac5efefU, 0xe54faaaaU, 0x16edfbfbU,\n    0xc5864343U, 0xd79a4d4dU, 0x55663333U, 0x94118585U,\n    0xcf8a4545U, 0x10e9f9f9U, 0x06040202U, 0x81fe7f7fU,\n    0xf0a05050U, 0x44783c3cU, 0xba259f9fU, 0xe34ba8a8U,\n    0xf3a25151U, 0xfe5da3a3U, 0xc0804040U, 0x8a058f8fU,\n    0xad3f9292U, 0xbc219d9dU, 0x48703838U, 0x04f1f5f5U,\n    0xdf63bcbcU, 0xc177b6b6U, 0x75afdadaU, 0x63422121U,\n    0x30201010U, 0x1ae5ffffU, 0x0efdf3f3U, 0x6dbfd2d2U,\n    0x4c81cdcdU, 0x14180c0cU, 0x35261313U, 0x2fc3ececU,\n    0xe1be5f5fU, 0xa2359797U, 0xcc884444U, 0x392e1717U,\n    0x5793c4c4U, 0xf255a7a7U, 0x82fc7e7eU, 0x477a3d3dU,\n    0xacc86464U, 0xe7ba5d5dU, 0x2b321919U, 0x95e67373U,\n    0xa0c06060U, 0x98198181U, 0xd19e4f4fU, 0x7fa3dcdcU,\n    0x66442222U, 0x7e542a2aU, 0xab3b9090U, 0x830b8888U,\n    0xca8c4646U, 0x29c7eeeeU, 0xd36bb8b8U, 0x3c281414U,\n    0x79a7dedeU, 0xe2bc5e5eU, 0x1d160b0bU, 0x76addbdbU,\n    0x3bdbe0e0U, 0x56643232U, 0x4e743a3aU, 0x1e140a0aU,\n    0xdb924949U, 0x0a0c0606U, 0x6c482424U, 0xe4b85c5cU,\n    0x5d9fc2c2U, 0x6ebdd3d3U, 0xef43acacU, 0xa6c46262U,\n    0xa8399191U, 0xa4319595U, 0x37d3e4e4U, 0x8bf27979U,\n    0x32d5e7e7U, 0x438bc8c8U, 0x596e3737U, 0xb7da6d6dU,\n    0x8c018d8dU, 0x64b1d5d5U, 0xd29c4e4eU, 0xe049a9a9U,\n    0xb4d86c6cU, 0xfaac5656U, 0x07f3f4f4U, 0x25cfeaeaU,\n    0xafca6565U, 0x8ef47a7aU, 0xe947aeaeU, 0x18100808U,\n    0xd56fbabaU, 0x88f07878U, 0x6f4a2525U, 0x725c2e2eU,\n    0x24381c1cU, 0xf157a6a6U, 0xc773b4b4U, 0x5197c6c6U,\n    0x23cbe8e8U, 0x7ca1ddddU, 0x9ce87474U, 0x213e1f1fU,\n    0xdd964b4bU, 0xdc61bdbdU, 0x860d8b8bU, 0x850f8a8aU,\n    0x90e07070U, 0x427c3e3eU, 0xc471b5b5U, 0xaacc6666U,\n    0xd8904848U, 0x05060303U, 0x01f7f6f6U, 0x121c0e0eU,\n    0xa3c26161U, 0x5f6a3535U, 0xf9ae5757U, 0xd069b9b9U,\n    0x91178686U, 0x5899c1c1U, 0x273a1d1dU, 0xb9279e9eU,\n    0x38d9e1e1U, 0x13ebf8f8U, 0xb32b9898U, 0x33221111U,\n    0xbbd26969U, 0x70a9d9d9U, 0x89078e8eU, 0xa7339494U,\n    0xb62d9b9bU, 0x223c1e1eU, 0x92158787U, 0x20c9e9e9U,\n    0x4987ceceU, 0xffaa5555U, 0x78502828U, 0x7aa5dfdfU,\n    0x8f038c8cU, 0xf859a1a1U, 0x80098989U, 0x171a0d0dU,\n    0xda65bfbfU, 0x31d7e6e6U, 0xc6844242U, 0xb8d06868U,\n    0xc3824141U, 0xb0299999U, 0x775a2d2dU, 0x111e0f0fU,\n    0xcb7bb0b0U, 0xfca85454U, 0xd66dbbbbU, 0x3a2c1616U,\n};\nstatic const u32 Te2[256] = {\n    0x63a5c663U, 0x7c84f87cU, 0x7799ee77U, 0x7b8df67bU,\n    0xf20dfff2U, 0x6bbdd66bU, 0x6fb1de6fU, 0xc55491c5U,\n    0x30506030U, 0x01030201U, 0x67a9ce67U, 0x2b7d562bU,\n    0xfe19e7feU, 0xd762b5d7U, 0xabe64dabU, 0x769aec76U,\n    0xca458fcaU, 0x829d1f82U, 0xc94089c9U, 0x7d87fa7dU,\n    0xfa15effaU, 0x59ebb259U, 0x47c98e47U, 0xf00bfbf0U,\n    0xadec41adU, 0xd467b3d4U, 0xa2fd5fa2U, 0xafea45afU,\n    0x9cbf239cU, 0xa4f753a4U, 0x7296e472U, 0xc05b9bc0U,\n    0xb7c275b7U, 0xfd1ce1fdU, 0x93ae3d93U, 0x266a4c26U,\n    0x365a6c36U, 0x3f417e3fU, 0xf702f5f7U, 0xcc4f83ccU,\n    0x345c6834U, 0xa5f451a5U, 0xe534d1e5U, 0xf108f9f1U,\n    0x7193e271U, 0xd873abd8U, 0x31536231U, 0x153f2a15U,\n    0x040c0804U, 0xc75295c7U, 0x23654623U, 0xc35e9dc3U,\n    0x18283018U, 0x96a13796U, 0x050f0a05U, 0x9ab52f9aU,\n    0x07090e07U, 0x12362412U, 0x809b1b80U, 0xe23ddfe2U,\n    0xeb26cdebU, 0x27694e27U, 0xb2cd7fb2U, 0x759fea75U,\n    0x091b1209U, 0x839e1d83U, 0x2c74582cU, 0x1a2e341aU,\n    0x1b2d361bU, 0x6eb2dc6eU, 0x5aeeb45aU, 0xa0fb5ba0U,\n    0x52f6a452U, 0x3b4d763bU, 0xd661b7d6U, 0xb3ce7db3U,\n    0x297b5229U, 0xe33edde3U, 0x2f715e2fU, 0x84971384U,\n    0x53f5a653U, 0xd168b9d1U, 0x00000000U, 0xed2cc1edU,\n    0x20604020U, 0xfc1fe3fcU, 0xb1c879b1U, 0x5bedb65bU,\n    0x6abed46aU, 0xcb468dcbU, 0xbed967beU, 0x394b7239U,\n    0x4ade944aU, 0x4cd4984cU, 0x58e8b058U, 0xcf4a85cfU,\n    0xd06bbbd0U, 0xef2ac5efU, 0xaae54faaU, 0xfb16edfbU,\n    0x43c58643U, 0x4dd79a4dU, 0x33556633U, 0x85941185U,\n    0x45cf8a45U, 0xf910e9f9U, 0x02060402U, 0x7f81fe7fU,\n    0x50f0a050U, 0x3c44783cU, 0x9fba259fU, 0xa8e34ba8U,\n    0x51f3a251U, 0xa3fe5da3U, 0x40c08040U, 0x8f8a058fU,\n    0x92ad3f92U, 0x9dbc219dU, 0x38487038U, 0xf504f1f5U,\n    0xbcdf63bcU, 0xb6c177b6U, 0xda75afdaU, 0x21634221U,\n    0x10302010U, 0xff1ae5ffU, 0xf30efdf3U, 0xd26dbfd2U,\n    0xcd4c81cdU, 0x0c14180cU, 0x13352613U, 0xec2fc3ecU,\n    0x5fe1be5fU, 0x97a23597U, 0x44cc8844U, 0x17392e17U,\n    0xc45793c4U, 0xa7f255a7U, 0x7e82fc7eU, 0x3d477a3dU,\n    0x64acc864U, 0x5de7ba5dU, 0x192b3219U, 0x7395e673U,\n    0x60a0c060U, 0x81981981U, 0x4fd19e4fU, 0xdc7fa3dcU,\n    0x22664422U, 0x2a7e542aU, 0x90ab3b90U, 0x88830b88U,\n    0x46ca8c46U, 0xee29c7eeU, 0xb8d36bb8U, 0x143c2814U,\n    0xde79a7deU, 0x5ee2bc5eU, 0x0b1d160bU, 0xdb76addbU,\n    0xe03bdbe0U, 0x32566432U, 0x3a4e743aU, 0x0a1e140aU,\n    0x49db9249U, 0x060a0c06U, 0x246c4824U, 0x5ce4b85cU,\n    0xc25d9fc2U, 0xd36ebdd3U, 0xacef43acU, 0x62a6c462U,\n    0x91a83991U, 0x95a43195U, 0xe437d3e4U, 0x798bf279U,\n    0xe732d5e7U, 0xc8438bc8U, 0x37596e37U, 0x6db7da6dU,\n    0x8d8c018dU, 0xd564b1d5U, 0x4ed29c4eU, 0xa9e049a9U,\n    0x6cb4d86cU, 0x56faac56U, 0xf407f3f4U, 0xea25cfeaU,\n    0x65afca65U, 0x7a8ef47aU, 0xaee947aeU, 0x08181008U,\n    0xbad56fbaU, 0x7888f078U, 0x256f4a25U, 0x2e725c2eU,\n    0x1c24381cU, 0xa6f157a6U, 0xb4c773b4U, 0xc65197c6U,\n    0xe823cbe8U, 0xdd7ca1ddU, 0x749ce874U, 0x1f213e1fU,\n    0x4bdd964bU, 0xbddc61bdU, 0x8b860d8bU, 0x8a850f8aU,\n    0x7090e070U, 0x3e427c3eU, 0xb5c471b5U, 0x66aacc66U,\n    0x48d89048U, 0x03050603U, 0xf601f7f6U, 0x0e121c0eU,\n    0x61a3c261U, 0x355f6a35U, 0x57f9ae57U, 0xb9d069b9U,\n    0x86911786U, 0xc15899c1U, 0x1d273a1dU, 0x9eb9279eU,\n    0xe138d9e1U, 0xf813ebf8U, 0x98b32b98U, 0x11332211U,\n    0x69bbd269U, 0xd970a9d9U, 0x8e89078eU, 0x94a73394U,\n    0x9bb62d9bU, 0x1e223c1eU, 0x87921587U, 0xe920c9e9U,\n    0xce4987ceU, 0x55ffaa55U, 0x28785028U, 0xdf7aa5dfU,\n    0x8c8f038cU, 0xa1f859a1U, 0x89800989U, 0x0d171a0dU,\n    0xbfda65bfU, 0xe631d7e6U, 0x42c68442U, 0x68b8d068U,\n    0x41c38241U, 0x99b02999U, 0x2d775a2dU, 0x0f111e0fU,\n    0xb0cb7bb0U, 0x54fca854U, 0xbbd66dbbU, 0x163a2c16U,\n};\nstatic const u32 Te3[256] = {\n\n    0x6363a5c6U, 0x7c7c84f8U, 0x777799eeU, 0x7b7b8df6U,\n    0xf2f20dffU, 0x6b6bbdd6U, 0x6f6fb1deU, 0xc5c55491U,\n    0x30305060U, 0x01010302U, 0x6767a9ceU, 0x2b2b7d56U,\n    0xfefe19e7U, 0xd7d762b5U, 0xababe64dU, 0x76769aecU,\n    0xcaca458fU, 0x82829d1fU, 0xc9c94089U, 0x7d7d87faU,\n    0xfafa15efU, 0x5959ebb2U, 0x4747c98eU, 0xf0f00bfbU,\n    0xadadec41U, 0xd4d467b3U, 0xa2a2fd5fU, 0xafafea45U,\n    0x9c9cbf23U, 0xa4a4f753U, 0x727296e4U, 0xc0c05b9bU,\n    0xb7b7c275U, 0xfdfd1ce1U, 0x9393ae3dU, 0x26266a4cU,\n    0x36365a6cU, 0x3f3f417eU, 0xf7f702f5U, 0xcccc4f83U,\n    0x34345c68U, 0xa5a5f451U, 0xe5e534d1U, 0xf1f108f9U,\n    0x717193e2U, 0xd8d873abU, 0x31315362U, 0x15153f2aU,\n    0x04040c08U, 0xc7c75295U, 0x23236546U, 0xc3c35e9dU,\n    0x18182830U, 0x9696a137U, 0x05050f0aU, 0x9a9ab52fU,\n    0x0707090eU, 0x12123624U, 0x80809b1bU, 0xe2e23ddfU,\n    0xebeb26cdU, 0x2727694eU, 0xb2b2cd7fU, 0x75759feaU,\n    0x09091b12U, 0x83839e1dU, 0x2c2c7458U, 0x1a1a2e34U,\n    0x1b1b2d36U, 0x6e6eb2dcU, 0x5a5aeeb4U, 0xa0a0fb5bU,\n    0x5252f6a4U, 0x3b3b4d76U, 0xd6d661b7U, 0xb3b3ce7dU,\n    0x29297b52U, 0xe3e33eddU, 0x2f2f715eU, 0x84849713U,\n    0x5353f5a6U, 0xd1d168b9U, 0x00000000U, 0xeded2cc1U,\n    0x20206040U, 0xfcfc1fe3U, 0xb1b1c879U, 0x5b5bedb6U,\n    0x6a6abed4U, 0xcbcb468dU, 0xbebed967U, 0x39394b72U,\n    0x4a4ade94U, 0x4c4cd498U, 0x5858e8b0U, 0xcfcf4a85U,\n    0xd0d06bbbU, 0xefef2ac5U, 0xaaaae54fU, 0xfbfb16edU,\n    0x4343c586U, 0x4d4dd79aU, 0x33335566U, 0x85859411U,\n    0x4545cf8aU, 0xf9f910e9U, 0x02020604U, 0x7f7f81feU,\n    0x5050f0a0U, 0x3c3c4478U, 0x9f9fba25U, 0xa8a8e34bU,\n    0x5151f3a2U, 0xa3a3fe5dU, 0x4040c080U, 0x8f8f8a05U,\n    0x9292ad3fU, 0x9d9dbc21U, 0x38384870U, 0xf5f504f1U,\n    0xbcbcdf63U, 0xb6b6c177U, 0xdada75afU, 0x21216342U,\n    0x10103020U, 0xffff1ae5U, 0xf3f30efdU, 0xd2d26dbfU,\n    0xcdcd4c81U, 0x0c0c1418U, 0x13133526U, 0xecec2fc3U,\n    0x5f5fe1beU, 0x9797a235U, 0x4444cc88U, 0x1717392eU,\n    0xc4c45793U, 0xa7a7f255U, 0x7e7e82fcU, 0x3d3d477aU,\n    0x6464acc8U, 0x5d5de7baU, 0x19192b32U, 0x737395e6U,\n    0x6060a0c0U, 0x81819819U, 0x4f4fd19eU, 0xdcdc7fa3U,\n    0x22226644U, 0x2a2a7e54U, 0x9090ab3bU, 0x8888830bU,\n    0x4646ca8cU, 0xeeee29c7U, 0xb8b8d36bU, 0x14143c28U,\n    0xdede79a7U, 0x5e5ee2bcU, 0x0b0b1d16U, 0xdbdb76adU,\n    0xe0e03bdbU, 0x32325664U, 0x3a3a4e74U, 0x0a0a1e14U,\n    0x4949db92U, 0x06060a0cU, 0x24246c48U, 0x5c5ce4b8U,\n    0xc2c25d9fU, 0xd3d36ebdU, 0xacacef43U, 0x6262a6c4U,\n    0x9191a839U, 0x9595a431U, 0xe4e437d3U, 0x79798bf2U,\n    0xe7e732d5U, 0xc8c8438bU, 0x3737596eU, 0x6d6db7daU,\n    0x8d8d8c01U, 0xd5d564b1U, 0x4e4ed29cU, 0xa9a9e049U,\n    0x6c6cb4d8U, 0x5656faacU, 0xf4f407f3U, 0xeaea25cfU,\n    0x6565afcaU, 0x7a7a8ef4U, 0xaeaee947U, 0x08081810U,\n    0xbabad56fU, 0x787888f0U, 0x25256f4aU, 0x2e2e725cU,\n    0x1c1c2438U, 0xa6a6f157U, 0xb4b4c773U, 0xc6c65197U,\n    0xe8e823cbU, 0xdddd7ca1U, 0x74749ce8U, 0x1f1f213eU,\n    0x4b4bdd96U, 0xbdbddc61U, 0x8b8b860dU, 0x8a8a850fU,\n    0x707090e0U, 0x3e3e427cU, 0xb5b5c471U, 0x6666aaccU,\n    0x4848d890U, 0x03030506U, 0xf6f601f7U, 0x0e0e121cU,\n    0x6161a3c2U, 0x35355f6aU, 0x5757f9aeU, 0xb9b9d069U,\n    0x86869117U, 0xc1c15899U, 0x1d1d273aU, 0x9e9eb927U,\n    0xe1e138d9U, 0xf8f813ebU, 0x9898b32bU, 0x11113322U,\n    0x6969bbd2U, 0xd9d970a9U, 0x8e8e8907U, 0x9494a733U,\n    0x9b9bb62dU, 0x1e1e223cU, 0x87879215U, 0xe9e920c9U,\n    0xcece4987U, 0x5555ffaaU, 0x28287850U, 0xdfdf7aa5U,\n    0x8c8c8f03U, 0xa1a1f859U, 0x89898009U, 0x0d0d171aU,\n    0xbfbfda65U, 0xe6e631d7U, 0x4242c684U, 0x6868b8d0U,\n    0x4141c382U, 0x9999b029U, 0x2d2d775aU, 0x0f0f111eU,\n    0xb0b0cb7bU, 0x5454fca8U, 0xbbbbd66dU, 0x16163a2cU,\n};\nstatic const u32 Te4[256] = {\n    0x63636363U, 0x7c7c7c7cU, 0x77777777U, 0x7b7b7b7bU,\n    0xf2f2f2f2U, 0x6b6b6b6bU, 0x6f6f6f6fU, 0xc5c5c5c5U,\n    0x30303030U, 0x01010101U, 0x67676767U, 0x2b2b2b2bU,\n    0xfefefefeU, 0xd7d7d7d7U, 0xababababU, 0x76767676U,\n    0xcacacacaU, 0x82828282U, 0xc9c9c9c9U, 0x7d7d7d7dU,\n    0xfafafafaU, 0x59595959U, 0x47474747U, 0xf0f0f0f0U,\n    0xadadadadU, 0xd4d4d4d4U, 0xa2a2a2a2U, 0xafafafafU,\n    0x9c9c9c9cU, 0xa4a4a4a4U, 0x72727272U, 0xc0c0c0c0U,\n    0xb7b7b7b7U, 0xfdfdfdfdU, 0x93939393U, 0x26262626U,\n    0x36363636U, 0x3f3f3f3fU, 0xf7f7f7f7U, 0xccccccccU,\n    0x34343434U, 0xa5a5a5a5U, 0xe5e5e5e5U, 0xf1f1f1f1U,\n    0x71717171U, 0xd8d8d8d8U, 0x31313131U, 0x15151515U,\n    0x04040404U, 0xc7c7c7c7U, 0x23232323U, 0xc3c3c3c3U,\n    0x18181818U, 0x96969696U, 0x05050505U, 0x9a9a9a9aU,\n    0x07070707U, 0x12121212U, 0x80808080U, 0xe2e2e2e2U,\n    0xebebebebU, 0x27272727U, 0xb2b2b2b2U, 0x75757575U,\n    0x09090909U, 0x83838383U, 0x2c2c2c2cU, 0x1a1a1a1aU,\n    0x1b1b1b1bU, 0x6e6e6e6eU, 0x5a5a5a5aU, 0xa0a0a0a0U,\n    0x52525252U, 0x3b3b3b3bU, 0xd6d6d6d6U, 0xb3b3b3b3U,\n    0x29292929U, 0xe3e3e3e3U, 0x2f2f2f2fU, 0x84848484U,\n    0x53535353U, 0xd1d1d1d1U, 0x00000000U, 0xededededU,\n    0x20202020U, 0xfcfcfcfcU, 0xb1b1b1b1U, 0x5b5b5b5bU,\n    0x6a6a6a6aU, 0xcbcbcbcbU, 0xbebebebeU, 0x39393939U,\n    0x4a4a4a4aU, 0x4c4c4c4cU, 0x58585858U, 0xcfcfcfcfU,\n    0xd0d0d0d0U, 0xefefefefU, 0xaaaaaaaaU, 0xfbfbfbfbU,\n    0x43434343U, 0x4d4d4d4dU, 0x33333333U, 0x85858585U,\n    0x45454545U, 0xf9f9f9f9U, 0x02020202U, 0x7f7f7f7fU,\n    0x50505050U, 0x3c3c3c3cU, 0x9f9f9f9fU, 0xa8a8a8a8U,\n    0x51515151U, 0xa3a3a3a3U, 0x40404040U, 0x8f8f8f8fU,\n    0x92929292U, 0x9d9d9d9dU, 0x38383838U, 0xf5f5f5f5U,\n    0xbcbcbcbcU, 0xb6b6b6b6U, 0xdadadadaU, 0x21212121U,\n    0x10101010U, 0xffffffffU, 0xf3f3f3f3U, 0xd2d2d2d2U,\n    0xcdcdcdcdU, 0x0c0c0c0cU, 0x13131313U, 0xececececU,\n    0x5f5f5f5fU, 0x97979797U, 0x44444444U, 0x17171717U,\n    0xc4c4c4c4U, 0xa7a7a7a7U, 0x7e7e7e7eU, 0x3d3d3d3dU,\n    0x64646464U, 0x5d5d5d5dU, 0x19191919U, 0x73737373U,\n    0x60606060U, 0x81818181U, 0x4f4f4f4fU, 0xdcdcdcdcU,\n    0x22222222U, 0x2a2a2a2aU, 0x90909090U, 0x88888888U,\n    0x46464646U, 0xeeeeeeeeU, 0xb8b8b8b8U, 0x14141414U,\n    0xdedededeU, 0x5e5e5e5eU, 0x0b0b0b0bU, 0xdbdbdbdbU,\n    0xe0e0e0e0U, 0x32323232U, 0x3a3a3a3aU, 0x0a0a0a0aU,\n    0x49494949U, 0x06060606U, 0x24242424U, 0x5c5c5c5cU,\n    0xc2c2c2c2U, 0xd3d3d3d3U, 0xacacacacU, 0x62626262U,\n    0x91919191U, 0x95959595U, 0xe4e4e4e4U, 0x79797979U,\n    0xe7e7e7e7U, 0xc8c8c8c8U, 0x37373737U, 0x6d6d6d6dU,\n    0x8d8d8d8dU, 0xd5d5d5d5U, 0x4e4e4e4eU, 0xa9a9a9a9U,\n    0x6c6c6c6cU, 0x56565656U, 0xf4f4f4f4U, 0xeaeaeaeaU,\n    0x65656565U, 0x7a7a7a7aU, 0xaeaeaeaeU, 0x08080808U,\n    0xbabababaU, 0x78787878U, 0x25252525U, 0x2e2e2e2eU,\n    0x1c1c1c1cU, 0xa6a6a6a6U, 0xb4b4b4b4U, 0xc6c6c6c6U,\n    0xe8e8e8e8U, 0xddddddddU, 0x74747474U, 0x1f1f1f1fU,\n    0x4b4b4b4bU, 0xbdbdbdbdU, 0x8b8b8b8bU, 0x8a8a8a8aU,\n    0x70707070U, 0x3e3e3e3eU, 0xb5b5b5b5U, 0x66666666U,\n    0x48484848U, 0x03030303U, 0xf6f6f6f6U, 0x0e0e0e0eU,\n    0x61616161U, 0x35353535U, 0x57575757U, 0xb9b9b9b9U,\n    0x86868686U, 0xc1c1c1c1U, 0x1d1d1d1dU, 0x9e9e9e9eU,\n    0xe1e1e1e1U, 0xf8f8f8f8U, 0x98989898U, 0x11111111U,\n    0x69696969U, 0xd9d9d9d9U, 0x8e8e8e8eU, 0x94949494U,\n    0x9b9b9b9bU, 0x1e1e1e1eU, 0x87878787U, 0xe9e9e9e9U,\n    0xcecececeU, 0x55555555U, 0x28282828U, 0xdfdfdfdfU,\n    0x8c8c8c8cU, 0xa1a1a1a1U, 0x89898989U, 0x0d0d0d0dU,\n    0xbfbfbfbfU, 0xe6e6e6e6U, 0x42424242U, 0x68686868U,\n    0x41414141U, 0x99999999U, 0x2d2d2d2dU, 0x0f0f0f0fU,\n    0xb0b0b0b0U, 0x54545454U, 0xbbbbbbbbU, 0x16161616U,\n};\nstatic const u32 Td0[256] = {\n    0x51f4a750U, 0x7e416553U, 0x1a17a4c3U, 0x3a275e96U,\n    0x3bab6bcbU, 0x1f9d45f1U, 0xacfa58abU, 0x4be30393U,\n    0x2030fa55U, 0xad766df6U, 0x88cc7691U, 0xf5024c25U,\n    0x4fe5d7fcU, 0xc52acbd7U, 0x26354480U, 0xb562a38fU,\n    0xdeb15a49U, 0x25ba1b67U, 0x45ea0e98U, 0x5dfec0e1U,\n    0xc32f7502U, 0x814cf012U, 0x8d4697a3U, 0x6bd3f9c6U,\n    0x038f5fe7U, 0x15929c95U, 0xbf6d7aebU, 0x955259daU,\n    0xd4be832dU, 0x587421d3U, 0x49e06929U, 0x8ec9c844U,\n    0x75c2896aU, 0xf48e7978U, 0x99583e6bU, 0x27b971ddU,\n    0xbee14fb6U, 0xf088ad17U, 0xc920ac66U, 0x7dce3ab4U,\n    0x63df4a18U, 0xe51a3182U, 0x97513360U, 0x62537f45U,\n    0xb16477e0U, 0xbb6bae84U, 0xfe81a01cU, 0xf9082b94U,\n    0x70486858U, 0x8f45fd19U, 0x94de6c87U, 0x527bf8b7U,\n    0xab73d323U, 0x724b02e2U, 0xe31f8f57U, 0x6655ab2aU,\n    0xb2eb2807U, 0x2fb5c203U, 0x86c57b9aU, 0xd33708a5U,\n    0x302887f2U, 0x23bfa5b2U, 0x02036abaU, 0xed16825cU,\n    0x8acf1c2bU, 0xa779b492U, 0xf307f2f0U, 0x4e69e2a1U,\n    0x65daf4cdU, 0x0605bed5U, 0xd134621fU, 0xc4a6fe8aU,\n    0x342e539dU, 0xa2f355a0U, 0x058ae132U, 0xa4f6eb75U,\n    0x0b83ec39U, 0x4060efaaU, 0x5e719f06U, 0xbd6e1051U,\n    0x3e218af9U, 0x96dd063dU, 0xdd3e05aeU, 0x4de6bd46U,\n    0x91548db5U, 0x71c45d05U, 0x0406d46fU, 0x605015ffU,\n    0x1998fb24U, 0xd6bde997U, 0x894043ccU, 0x67d99e77U,\n    0xb0e842bdU, 0x07898b88U, 0xe7195b38U, 0x79c8eedbU,\n    0xa17c0a47U, 0x7c420fe9U, 0xf8841ec9U, 0x00000000U,\n    0x09808683U, 0x322bed48U, 0x1e1170acU, 0x6c5a724eU,\n    0xfd0efffbU, 0x0f853856U, 0x3daed51eU, 0x362d3927U,\n    0x0a0fd964U, 0x685ca621U, 0x9b5b54d1U, 0x24362e3aU,\n    0x0c0a67b1U, 0x9357e70fU, 0xb4ee96d2U, 0x1b9b919eU,\n    0x80c0c54fU, 0x61dc20a2U, 0x5a774b69U, 0x1c121a16U,\n    0xe293ba0aU, 0xc0a02ae5U, 0x3c22e043U, 0x121b171dU,\n    0x0e090d0bU, 0xf28bc7adU, 0x2db6a8b9U, 0x141ea9c8U,\n    0x57f11985U, 0xaf75074cU, 0xee99ddbbU, 0xa37f60fdU,\n    0xf701269fU, 0x5c72f5bcU, 0x44663bc5U, 0x5bfb7e34U,\n    0x8b432976U, 0xcb23c6dcU, 0xb6edfc68U, 0xb8e4f163U,\n    0xd731dccaU, 0x42638510U, 0x13972240U, 0x84c61120U,\n    0x854a247dU, 0xd2bb3df8U, 0xaef93211U, 0xc729a16dU,\n    0x1d9e2f4bU, 0xdcb230f3U, 0x0d8652ecU, 0x77c1e3d0U,\n    0x2bb3166cU, 0xa970b999U, 0x119448faU, 0x47e96422U,\n    0xa8fc8cc4U, 0xa0f03f1aU, 0x567d2cd8U, 0x223390efU,\n    0x87494ec7U, 0xd938d1c1U, 0x8ccaa2feU, 0x98d40b36U,\n    0xa6f581cfU, 0xa57ade28U, 0xdab78e26U, 0x3fadbfa4U,\n    0x2c3a9de4U, 0x5078920dU, 0x6a5fcc9bU, 0x547e4662U,\n    0xf68d13c2U, 0x90d8b8e8U, 0x2e39f75eU, 0x82c3aff5U,\n    0x9f5d80beU, 0x69d0937cU, 0x6fd52da9U, 0xcf2512b3U,\n    0xc8ac993bU, 0x10187da7U, 0xe89c636eU, 0xdb3bbb7bU,\n    0xcd267809U, 0x6e5918f4U, 0xec9ab701U, 0x834f9aa8U,\n    0xe6956e65U, 0xaaffe67eU, 0x21bccf08U, 0xef15e8e6U,\n    0xbae79bd9U, 0x4a6f36ceU, 0xea9f09d4U, 0x29b07cd6U,\n    0x31a4b2afU, 0x2a3f2331U, 0xc6a59430U, 0x35a266c0U,\n    0x744ebc37U, 0xfc82caa6U, 0xe090d0b0U, 0x33a7d815U,\n    0xf104984aU, 0x41ecdaf7U, 0x7fcd500eU, 0x1791f62fU,\n    0x764dd68dU, 0x43efb04dU, 0xccaa4d54U, 0xe49604dfU,\n    0x9ed1b5e3U, 0x4c6a881bU, 0xc12c1fb8U, 0x4665517fU,\n    0x9d5eea04U, 0x018c355dU, 0xfa877473U, 0xfb0b412eU,\n    0xb3671d5aU, 0x92dbd252U, 0xe9105633U, 0x6dd64713U,\n    0x9ad7618cU, 0x37a10c7aU, 0x59f8148eU, 0xeb133c89U,\n    0xcea927eeU, 0xb761c935U, 0xe11ce5edU, 0x7a47b13cU,\n    0x9cd2df59U, 0x55f2733fU, 0x1814ce79U, 0x73c737bfU,\n    0x53f7cdeaU, 0x5ffdaa5bU, 0xdf3d6f14U, 0x7844db86U,\n    0xcaaff381U, 0xb968c43eU, 0x3824342cU, 0xc2a3405fU,\n    0x161dc372U, 0xbce2250cU, 0x283c498bU, 0xff0d9541U,\n    0x39a80171U, 0x080cb3deU, 0xd8b4e49cU, 0x6456c190U,\n    0x7bcb8461U, 0xd532b670U, 0x486c5c74U, 0xd0b85742U,\n};\nstatic const u32 Td1[256] = {\n    0x5051f4a7U, 0x537e4165U, 0xc31a17a4U, 0x963a275eU,\n    0xcb3bab6bU, 0xf11f9d45U, 0xabacfa58U, 0x934be303U,\n    0x552030faU, 0xf6ad766dU, 0x9188cc76U, 0x25f5024cU,\n    0xfc4fe5d7U, 0xd7c52acbU, 0x80263544U, 0x8fb562a3U,\n    0x49deb15aU, 0x6725ba1bU, 0x9845ea0eU, 0xe15dfec0U,\n    0x02c32f75U, 0x12814cf0U, 0xa38d4697U, 0xc66bd3f9U,\n    0xe7038f5fU, 0x9515929cU, 0xebbf6d7aU, 0xda955259U,\n    0x2dd4be83U, 0xd3587421U, 0x2949e069U, 0x448ec9c8U,\n    0x6a75c289U, 0x78f48e79U, 0x6b99583eU, 0xdd27b971U,\n    0xb6bee14fU, 0x17f088adU, 0x66c920acU, 0xb47dce3aU,\n    0x1863df4aU, 0x82e51a31U, 0x60975133U, 0x4562537fU,\n    0xe0b16477U, 0x84bb6baeU, 0x1cfe81a0U, 0x94f9082bU,\n    0x58704868U, 0x198f45fdU, 0x8794de6cU, 0xb7527bf8U,\n    0x23ab73d3U, 0xe2724b02U, 0x57e31f8fU, 0x2a6655abU,\n    0x07b2eb28U, 0x032fb5c2U, 0x9a86c57bU, 0xa5d33708U,\n    0xf2302887U, 0xb223bfa5U, 0xba02036aU, 0x5ced1682U,\n    0x2b8acf1cU, 0x92a779b4U, 0xf0f307f2U, 0xa14e69e2U,\n    0xcd65daf4U, 0xd50605beU, 0x1fd13462U, 0x8ac4a6feU,\n    0x9d342e53U, 0xa0a2f355U, 0x32058ae1U, 0x75a4f6ebU,\n    0x390b83ecU, 0xaa4060efU, 0x065e719fU, 0x51bd6e10U,\n    0xf93e218aU, 0x3d96dd06U, 0xaedd3e05U, 0x464de6bdU,\n    0xb591548dU, 0x0571c45dU, 0x6f0406d4U, 0xff605015U,\n    0x241998fbU, 0x97d6bde9U, 0xcc894043U, 0x7767d99eU,\n    0xbdb0e842U, 0x8807898bU, 0x38e7195bU, 0xdb79c8eeU,\n    0x47a17c0aU, 0xe97c420fU, 0xc9f8841eU, 0x00000000U,\n    0x83098086U, 0x48322bedU, 0xac1e1170U, 0x4e6c5a72U,\n    0xfbfd0effU, 0x560f8538U, 0x1e3daed5U, 0x27362d39U,\n    0x640a0fd9U, 0x21685ca6U, 0xd19b5b54U, 0x3a24362eU,\n    0xb10c0a67U, 0x0f9357e7U, 0xd2b4ee96U, 0x9e1b9b91U,\n    0x4f80c0c5U, 0xa261dc20U, 0x695a774bU, 0x161c121aU,\n    0x0ae293baU, 0xe5c0a02aU, 0x433c22e0U, 0x1d121b17U,\n    0x0b0e090dU, 0xadf28bc7U, 0xb92db6a8U, 0xc8141ea9U,\n    0x8557f119U, 0x4caf7507U, 0xbbee99ddU, 0xfda37f60U,\n    0x9ff70126U, 0xbc5c72f5U, 0xc544663bU, 0x345bfb7eU,\n    0x768b4329U, 0xdccb23c6U, 0x68b6edfcU, 0x63b8e4f1U,\n    0xcad731dcU, 0x10426385U, 0x40139722U, 0x2084c611U,\n    0x7d854a24U, 0xf8d2bb3dU, 0x11aef932U, 0x6dc729a1U,\n    0x4b1d9e2fU, 0xf3dcb230U, 0xec0d8652U, 0xd077c1e3U,\n    0x6c2bb316U, 0x99a970b9U, 0xfa119448U, 0x2247e964U,\n    0xc4a8fc8cU, 0x1aa0f03fU, 0xd8567d2cU, 0xef223390U,\n    0xc787494eU, 0xc1d938d1U, 0xfe8ccaa2U, 0x3698d40bU,\n    0xcfa6f581U, 0x28a57adeU, 0x26dab78eU, 0xa43fadbfU,\n    0xe42c3a9dU, 0x0d507892U, 0x9b6a5fccU, 0x62547e46U,\n    0xc2f68d13U, 0xe890d8b8U, 0x5e2e39f7U, 0xf582c3afU,\n    0xbe9f5d80U, 0x7c69d093U, 0xa96fd52dU, 0xb3cf2512U,\n    0x3bc8ac99U, 0xa710187dU, 0x6ee89c63U, 0x7bdb3bbbU,\n    0x09cd2678U, 0xf46e5918U, 0x01ec9ab7U, 0xa8834f9aU,\n    0x65e6956eU, 0x7eaaffe6U, 0x0821bccfU, 0xe6ef15e8U,\n    0xd9bae79bU, 0xce4a6f36U, 0xd4ea9f09U, 0xd629b07cU,\n    0xaf31a4b2U, 0x312a3f23U, 0x30c6a594U, 0xc035a266U,\n    0x37744ebcU, 0xa6fc82caU, 0xb0e090d0U, 0x1533a7d8U,\n    0x4af10498U, 0xf741ecdaU, 0x0e7fcd50U, 0x2f1791f6U,\n    0x8d764dd6U, 0x4d43efb0U, 0x54ccaa4dU, 0xdfe49604U,\n    0xe39ed1b5U, 0x1b4c6a88U, 0xb8c12c1fU, 0x7f466551U,\n    0x049d5eeaU, 0x5d018c35U, 0x73fa8774U, 0x2efb0b41U,\n    0x5ab3671dU, 0x5292dbd2U, 0x33e91056U, 0x136dd647U,\n    0x8c9ad761U, 0x7a37a10cU, 0x8e59f814U, 0x89eb133cU,\n    0xeecea927U, 0x35b761c9U, 0xede11ce5U, 0x3c7a47b1U,\n    0x599cd2dfU, 0x3f55f273U, 0x791814ceU, 0xbf73c737U,\n    0xea53f7cdU, 0x5b5ffdaaU, 0x14df3d6fU, 0x867844dbU,\n    0x81caaff3U, 0x3eb968c4U, 0x2c382434U, 0x5fc2a340U,\n    0x72161dc3U, 0x0cbce225U, 0x8b283c49U, 0x41ff0d95U,\n    0x7139a801U, 0xde080cb3U, 0x9cd8b4e4U, 0x906456c1U,\n    0x617bcb84U, 0x70d532b6U, 0x74486c5cU, 0x42d0b857U,\n};\nstatic const u32 Td2[256] = {\n    0xa75051f4U, 0x65537e41U, 0xa4c31a17U, 0x5e963a27U,\n    0x6bcb3babU, 0x45f11f9dU, 0x58abacfaU, 0x03934be3U,\n    0xfa552030U, 0x6df6ad76U, 0x769188ccU, 0x4c25f502U,\n    0xd7fc4fe5U, 0xcbd7c52aU, 0x44802635U, 0xa38fb562U,\n    0x5a49deb1U, 0x1b6725baU, 0x0e9845eaU, 0xc0e15dfeU,\n    0x7502c32fU, 0xf012814cU, 0x97a38d46U, 0xf9c66bd3U,\n    0x5fe7038fU, 0x9c951592U, 0x7aebbf6dU, 0x59da9552U,\n    0x832dd4beU, 0x21d35874U, 0x692949e0U, 0xc8448ec9U,\n    0x896a75c2U, 0x7978f48eU, 0x3e6b9958U, 0x71dd27b9U,\n    0x4fb6bee1U, 0xad17f088U, 0xac66c920U, 0x3ab47dceU,\n    0x4a1863dfU, 0x3182e51aU, 0x33609751U, 0x7f456253U,\n    0x77e0b164U, 0xae84bb6bU, 0xa01cfe81U, 0x2b94f908U,\n    0x68587048U, 0xfd198f45U, 0x6c8794deU, 0xf8b7527bU,\n    0xd323ab73U, 0x02e2724bU, 0x8f57e31fU, 0xab2a6655U,\n    0x2807b2ebU, 0xc2032fb5U, 0x7b9a86c5U, 0x08a5d337U,\n    0x87f23028U, 0xa5b223bfU, 0x6aba0203U, 0x825ced16U,\n    0x1c2b8acfU, 0xb492a779U, 0xf2f0f307U, 0xe2a14e69U,\n    0xf4cd65daU, 0xbed50605U, 0x621fd134U, 0xfe8ac4a6U,\n    0x539d342eU, 0x55a0a2f3U, 0xe132058aU, 0xeb75a4f6U,\n    0xec390b83U, 0xefaa4060U, 0x9f065e71U, 0x1051bd6eU,\n\n    0x8af93e21U, 0x063d96ddU, 0x05aedd3eU, 0xbd464de6U,\n    0x8db59154U, 0x5d0571c4U, 0xd46f0406U, 0x15ff6050U,\n    0xfb241998U, 0xe997d6bdU, 0x43cc8940U, 0x9e7767d9U,\n    0x42bdb0e8U, 0x8b880789U, 0x5b38e719U, 0xeedb79c8U,\n    0x0a47a17cU, 0x0fe97c42U, 0x1ec9f884U, 0x00000000U,\n    0x86830980U, 0xed48322bU, 0x70ac1e11U, 0x724e6c5aU,\n    0xfffbfd0eU, 0x38560f85U, 0xd51e3daeU, 0x3927362dU,\n    0xd9640a0fU, 0xa621685cU, 0x54d19b5bU, 0x2e3a2436U,\n    0x67b10c0aU, 0xe70f9357U, 0x96d2b4eeU, 0x919e1b9bU,\n    0xc54f80c0U, 0x20a261dcU, 0x4b695a77U, 0x1a161c12U,\n    0xba0ae293U, 0x2ae5c0a0U, 0xe0433c22U, 0x171d121bU,\n    0x0d0b0e09U, 0xc7adf28bU, 0xa8b92db6U, 0xa9c8141eU,\n    0x198557f1U, 0x074caf75U, 0xddbbee99U, 0x60fda37fU,\n    0x269ff701U, 0xf5bc5c72U, 0x3bc54466U, 0x7e345bfbU,\n    0x29768b43U, 0xc6dccb23U, 0xfc68b6edU, 0xf163b8e4U,\n    0xdccad731U, 0x85104263U, 0x22401397U, 0x112084c6U,\n    0x247d854aU, 0x3df8d2bbU, 0x3211aef9U, 0xa16dc729U,\n    0x2f4b1d9eU, 0x30f3dcb2U, 0x52ec0d86U, 0xe3d077c1U,\n    0x166c2bb3U, 0xb999a970U, 0x48fa1194U, 0x642247e9U,\n    0x8cc4a8fcU, 0x3f1aa0f0U, 0x2cd8567dU, 0x90ef2233U,\n    0x4ec78749U, 0xd1c1d938U, 0xa2fe8ccaU, 0x0b3698d4U,\n    0x81cfa6f5U, 0xde28a57aU, 0x8e26dab7U, 0xbfa43fadU,\n    0x9de42c3aU, 0x920d5078U, 0xcc9b6a5fU, 0x4662547eU,\n    0x13c2f68dU, 0xb8e890d8U, 0xf75e2e39U, 0xaff582c3U,\n    0x80be9f5dU, 0x937c69d0U, 0x2da96fd5U, 0x12b3cf25U,\n    0x993bc8acU, 0x7da71018U, 0x636ee89cU, 0xbb7bdb3bU,\n    0x7809cd26U, 0x18f46e59U, 0xb701ec9aU, 0x9aa8834fU,\n    0x6e65e695U, 0xe67eaaffU, 0xcf0821bcU, 0xe8e6ef15U,\n    0x9bd9bae7U, 0x36ce4a6fU, 0x09d4ea9fU, 0x7cd629b0U,\n    0xb2af31a4U, 0x23312a3fU, 0x9430c6a5U, 0x66c035a2U,\n    0xbc37744eU, 0xcaa6fc82U, 0xd0b0e090U, 0xd81533a7U,\n    0x984af104U, 0xdaf741ecU, 0x500e7fcdU, 0xf62f1791U,\n    0xd68d764dU, 0xb04d43efU, 0x4d54ccaaU, 0x04dfe496U,\n    0xb5e39ed1U, 0x881b4c6aU, 0x1fb8c12cU, 0x517f4665U,\n    0xea049d5eU, 0x355d018cU, 0x7473fa87U, 0x412efb0bU,\n    0x1d5ab367U, 0xd25292dbU, 0x5633e910U, 0x47136dd6U,\n    0x618c9ad7U, 0x0c7a37a1U, 0x148e59f8U, 0x3c89eb13U,\n    0x27eecea9U, 0xc935b761U, 0xe5ede11cU, 0xb13c7a47U,\n    0xdf599cd2U, 0x733f55f2U, 0xce791814U, 0x37bf73c7U,\n    0xcdea53f7U, 0xaa5b5ffdU, 0x6f14df3dU, 0xdb867844U,\n    0xf381caafU, 0xc43eb968U, 0x342c3824U, 0x405fc2a3U,\n    0xc372161dU, 0x250cbce2U, 0x498b283cU, 0x9541ff0dU,\n    0x017139a8U, 0xb3de080cU, 0xe49cd8b4U, 0xc1906456U,\n    0x84617bcbU, 0xb670d532U, 0x5c74486cU, 0x5742d0b8U,\n};\nstatic const u32 Td3[256] = {\n    0xf4a75051U, 0x4165537eU, 0x17a4c31aU, 0x275e963aU,\n    0xab6bcb3bU, 0x9d45f11fU, 0xfa58abacU, 0xe303934bU,\n    0x30fa5520U, 0x766df6adU, 0xcc769188U, 0x024c25f5U,\n    0xe5d7fc4fU, 0x2acbd7c5U, 0x35448026U, 0x62a38fb5U,\n    0xb15a49deU, 0xba1b6725U, 0xea0e9845U, 0xfec0e15dU,\n    0x2f7502c3U, 0x4cf01281U, 0x4697a38dU, 0xd3f9c66bU,\n    0x8f5fe703U, 0x929c9515U, 0x6d7aebbfU, 0x5259da95U,\n    0xbe832dd4U, 0x7421d358U, 0xe0692949U, 0xc9c8448eU,\n    0xc2896a75U, 0x8e7978f4U, 0x583e6b99U, 0xb971dd27U,\n    0xe14fb6beU, 0x88ad17f0U, 0x20ac66c9U, 0xce3ab47dU,\n    0xdf4a1863U, 0x1a3182e5U, 0x51336097U, 0x537f4562U,\n    0x6477e0b1U, 0x6bae84bbU, 0x81a01cfeU, 0x082b94f9U,\n    0x48685870U, 0x45fd198fU, 0xde6c8794U, 0x7bf8b752U,\n    0x73d323abU, 0x4b02e272U, 0x1f8f57e3U, 0x55ab2a66U,\n    0xeb2807b2U, 0xb5c2032fU, 0xc57b9a86U, 0x3708a5d3U,\n    0x2887f230U, 0xbfa5b223U, 0x036aba02U, 0x16825cedU,\n    0xcf1c2b8aU, 0x79b492a7U, 0x07f2f0f3U, 0x69e2a14eU,\n    0xdaf4cd65U, 0x05bed506U, 0x34621fd1U, 0xa6fe8ac4U,\n    0x2e539d34U, 0xf355a0a2U, 0x8ae13205U, 0xf6eb75a4U,\n    0x83ec390bU, 0x60efaa40U, 0x719f065eU, 0x6e1051bdU,\n    0x218af93eU, 0xdd063d96U, 0x3e05aeddU, 0xe6bd464dU,\n    0x548db591U, 0xc45d0571U, 0x06d46f04U, 0x5015ff60U,\n    0x98fb2419U, 0xbde997d6U, 0x4043cc89U, 0xd99e7767U,\n    0xe842bdb0U, 0x898b8807U, 0x195b38e7U, 0xc8eedb79U,\n    0x7c0a47a1U, 0x420fe97cU, 0x841ec9f8U, 0x00000000U,\n    0x80868309U, 0x2bed4832U, 0x1170ac1eU, 0x5a724e6cU,\n    0x0efffbfdU, 0x8538560fU, 0xaed51e3dU, 0x2d392736U,\n    0x0fd9640aU, 0x5ca62168U, 0x5b54d19bU, 0x362e3a24U,\n    0x0a67b10cU, 0x57e70f93U, 0xee96d2b4U, 0x9b919e1bU,\n    0xc0c54f80U, 0xdc20a261U, 0x774b695aU, 0x121a161cU,\n    0x93ba0ae2U, 0xa02ae5c0U, 0x22e0433cU, 0x1b171d12U,\n    0x090d0b0eU, 0x8bc7adf2U, 0xb6a8b92dU, 0x1ea9c814U,\n    0xf1198557U, 0x75074cafU, 0x99ddbbeeU, 0x7f60fda3U,\n    0x01269ff7U, 0x72f5bc5cU, 0x663bc544U, 0xfb7e345bU,\n    0x4329768bU, 0x23c6dccbU, 0xedfc68b6U, 0xe4f163b8U,\n    0x31dccad7U, 0x63851042U, 0x97224013U, 0xc6112084U,\n    0x4a247d85U, 0xbb3df8d2U, 0xf93211aeU, 0x29a16dc7U,\n    0x9e2f4b1dU, 0xb230f3dcU, 0x8652ec0dU, 0xc1e3d077U,\n    0xb3166c2bU, 0x70b999a9U, 0x9448fa11U, 0xe9642247U,\n    0xfc8cc4a8U, 0xf03f1aa0U, 0x7d2cd856U, 0x3390ef22U,\n    0x494ec787U, 0x38d1c1d9U, 0xcaa2fe8cU, 0xd40b3698U,\n    0xf581cfa6U, 0x7ade28a5U, 0xb78e26daU, 0xadbfa43fU,\n    0x3a9de42cU, 0x78920d50U, 0x5fcc9b6aU, 0x7e466254U,\n    0x8d13c2f6U, 0xd8b8e890U, 0x39f75e2eU, 0xc3aff582U,\n    0x5d80be9fU, 0xd0937c69U, 0xd52da96fU, 0x2512b3cfU,\n    0xac993bc8U, 0x187da710U, 0x9c636ee8U, 0x3bbb7bdbU,\n    0x267809cdU, 0x5918f46eU, 0x9ab701ecU, 0x4f9aa883U,\n    0x956e65e6U, 0xffe67eaaU, 0xbccf0821U, 0x15e8e6efU,\n    0xe79bd9baU, 0x6f36ce4aU, 0x9f09d4eaU, 0xb07cd629U,\n    0xa4b2af31U, 0x3f23312aU, 0xa59430c6U, 0xa266c035U,\n    0x4ebc3774U, 0x82caa6fcU, 0x90d0b0e0U, 0xa7d81533U,\n    0x04984af1U, 0xecdaf741U, 0xcd500e7fU, 0x91f62f17U,\n    0x4dd68d76U, 0xefb04d43U, 0xaa4d54ccU, 0x9604dfe4U,\n    0xd1b5e39eU, 0x6a881b4cU, 0x2c1fb8c1U, 0x65517f46U,\n    0x5eea049dU, 0x8c355d01U, 0x877473faU, 0x0b412efbU,\n    0x671d5ab3U, 0xdbd25292U, 0x105633e9U, 0xd647136dU,\n    0xd7618c9aU, 0xa10c7a37U, 0xf8148e59U, 0x133c89ebU,\n    0xa927eeceU, 0x61c935b7U, 0x1ce5ede1U, 0x47b13c7aU,\n    0xd2df599cU, 0xf2733f55U, 0x14ce7918U, 0xc737bf73U,\n    0xf7cdea53U, 0xfdaa5b5fU, 0x3d6f14dfU, 0x44db8678U,\n    0xaff381caU, 0x68c43eb9U, 0x24342c38U, 0xa3405fc2U,\n    0x1dc37216U, 0xe2250cbcU, 0x3c498b28U, 0x0d9541ffU,\n    0xa8017139U, 0x0cb3de08U, 0xb4e49cd8U, 0x56c19064U,\n    0xcb84617bU, 0x32b670d5U, 0x6c5c7448U, 0xb85742d0U,\n};\nstatic const u32 Td4[256] = {\n    0x52525252U, 0x09090909U, 0x6a6a6a6aU, 0xd5d5d5d5U,\n    0x30303030U, 0x36363636U, 0xa5a5a5a5U, 0x38383838U,\n    0xbfbfbfbfU, 0x40404040U, 0xa3a3a3a3U, 0x9e9e9e9eU,\n    0x81818181U, 0xf3f3f3f3U, 0xd7d7d7d7U, 0xfbfbfbfbU,\n    0x7c7c7c7cU, 0xe3e3e3e3U, 0x39393939U, 0x82828282U,\n    0x9b9b9b9bU, 0x2f2f2f2fU, 0xffffffffU, 0x87878787U,\n    0x34343434U, 0x8e8e8e8eU, 0x43434343U, 0x44444444U,\n    0xc4c4c4c4U, 0xdedededeU, 0xe9e9e9e9U, 0xcbcbcbcbU,\n    0x54545454U, 0x7b7b7b7bU, 0x94949494U, 0x32323232U,\n    0xa6a6a6a6U, 0xc2c2c2c2U, 0x23232323U, 0x3d3d3d3dU,\n    0xeeeeeeeeU, 0x4c4c4c4cU, 0x95959595U, 0x0b0b0b0bU,\n    0x42424242U, 0xfafafafaU, 0xc3c3c3c3U, 0x4e4e4e4eU,\n    0x08080808U, 0x2e2e2e2eU, 0xa1a1a1a1U, 0x66666666U,\n    0x28282828U, 0xd9d9d9d9U, 0x24242424U, 0xb2b2b2b2U,\n    0x76767676U, 0x5b5b5b5bU, 0xa2a2a2a2U, 0x49494949U,\n    0x6d6d6d6dU, 0x8b8b8b8bU, 0xd1d1d1d1U, 0x25252525U,\n    0x72727272U, 0xf8f8f8f8U, 0xf6f6f6f6U, 0x64646464U,\n    0x86868686U, 0x68686868U, 0x98989898U, 0x16161616U,\n    0xd4d4d4d4U, 0xa4a4a4a4U, 0x5c5c5c5cU, 0xccccccccU,\n    0x5d5d5d5dU, 0x65656565U, 0xb6b6b6b6U, 0x92929292U,\n    0x6c6c6c6cU, 0x70707070U, 0x48484848U, 0x50505050U,\n    0xfdfdfdfdU, 0xededededU, 0xb9b9b9b9U, 0xdadadadaU,\n    0x5e5e5e5eU, 0x15151515U, 0x46464646U, 0x57575757U,\n    0xa7a7a7a7U, 0x8d8d8d8dU, 0x9d9d9d9dU, 0x84848484U,\n    0x90909090U, 0xd8d8d8d8U, 0xababababU, 0x00000000U,\n    0x8c8c8c8cU, 0xbcbcbcbcU, 0xd3d3d3d3U, 0x0a0a0a0aU,\n    0xf7f7f7f7U, 0xe4e4e4e4U, 0x58585858U, 0x05050505U,\n    0xb8b8b8b8U, 0xb3b3b3b3U, 0x45454545U, 0x06060606U,\n    0xd0d0d0d0U, 0x2c2c2c2cU, 0x1e1e1e1eU, 0x8f8f8f8fU,\n    0xcacacacaU, 0x3f3f3f3fU, 0x0f0f0f0fU, 0x02020202U,\n    0xc1c1c1c1U, 0xafafafafU, 0xbdbdbdbdU, 0x03030303U,\n    0x01010101U, 0x13131313U, 0x8a8a8a8aU, 0x6b6b6b6bU,\n    0x3a3a3a3aU, 0x91919191U, 0x11111111U, 0x41414141U,\n    0x4f4f4f4fU, 0x67676767U, 0xdcdcdcdcU, 0xeaeaeaeaU,\n    0x97979797U, 0xf2f2f2f2U, 0xcfcfcfcfU, 0xcecececeU,\n    0xf0f0f0f0U, 0xb4b4b4b4U, 0xe6e6e6e6U, 0x73737373U,\n    0x96969696U, 0xacacacacU, 0x74747474U, 0x22222222U,\n    0xe7e7e7e7U, 0xadadadadU, 0x35353535U, 0x85858585U,\n    0xe2e2e2e2U, 0xf9f9f9f9U, 0x37373737U, 0xe8e8e8e8U,\n    0x1c1c1c1cU, 0x75757575U, 0xdfdfdfdfU, 0x6e6e6e6eU,\n    0x47474747U, 0xf1f1f1f1U, 0x1a1a1a1aU, 0x71717171U,\n    0x1d1d1d1dU, 0x29292929U, 0xc5c5c5c5U, 0x89898989U,\n    0x6f6f6f6fU, 0xb7b7b7b7U, 0x62626262U, 0x0e0e0e0eU,\n    0xaaaaaaaaU, 0x18181818U, 0xbebebebeU, 0x1b1b1b1bU,\n    0xfcfcfcfcU, 0x56565656U, 0x3e3e3e3eU, 0x4b4b4b4bU,\n    0xc6c6c6c6U, 0xd2d2d2d2U, 0x79797979U, 0x20202020U,\n    0x9a9a9a9aU, 0xdbdbdbdbU, 0xc0c0c0c0U, 0xfefefefeU,\n    0x78787878U, 0xcdcdcdcdU, 0x5a5a5a5aU, 0xf4f4f4f4U,\n    0x1f1f1f1fU, 0xddddddddU, 0xa8a8a8a8U, 0x33333333U,\n    0x88888888U, 0x07070707U, 0xc7c7c7c7U, 0x31313131U,\n    0xb1b1b1b1U, 0x12121212U, 0x10101010U, 0x59595959U,\n    0x27272727U, 0x80808080U, 0xececececU, 0x5f5f5f5fU,\n    0x60606060U, 0x51515151U, 0x7f7f7f7fU, 0xa9a9a9a9U,\n    0x19191919U, 0xb5b5b5b5U, 0x4a4a4a4aU, 0x0d0d0d0dU,\n    0x2d2d2d2dU, 0xe5e5e5e5U, 0x7a7a7a7aU, 0x9f9f9f9fU,\n    0x93939393U, 0xc9c9c9c9U, 0x9c9c9c9cU, 0xefefefefU,\n    0xa0a0a0a0U, 0xe0e0e0e0U, 0x3b3b3b3bU, 0x4d4d4d4dU,\n    0xaeaeaeaeU, 0x2a2a2a2aU, 0xf5f5f5f5U, 0xb0b0b0b0U,\n    0xc8c8c8c8U, 0xebebebebU, 0xbbbbbbbbU, 0x3c3c3c3cU,\n    0x83838383U, 0x53535353U, 0x99999999U, 0x61616161U,\n    0x17171717U, 0x2b2b2b2bU, 0x04040404U, 0x7e7e7e7eU,\n    0xbabababaU, 0x77777777U, 0xd6d6d6d6U, 0x26262626U,\n    0xe1e1e1e1U, 0x69696969U, 0x14141414U, 0x63636363U,\n    0x55555555U, 0x21212121U, 0x0c0c0c0cU, 0x7d7d7d7dU,\n};\nstatic const u32 rcon[] = {\n    0x01000000, 0x02000000, 0x04000000, 0x08000000,\n    0x10000000, 0x20000000, 0x40000000, 0x80000000,\n    0x1B000000, 0x36000000, /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */\n};\n\n\nvoid print_state(const unsigned char* state)\n{\n#ifdef _PRINT\n    int i;\n    for(i = 0; i < 16; i++)\n        printf(\"%02x\", state[i]);\n    printf(\"\\n\");\n#endif\n}\n/**\n * Expand the cipher key into the encryption key schedule.\n */\nint AES_set_encrypt_key(const unsigned char *userKey, const int bits,\n        AES_KEY *key) {\n\n    u32 *rk;\n    int i = 0;\n    u32 temp;\n\n    if (!userKey || !key)\n        return -1;\n    if (bits != 128 && bits != 192 && bits != 256)\n        return -2;\n\n    rk = (u32*)key->rd_key;\n\n    if (bits==128)\n        key->rounds = 10;\n    else if (bits==192)\n        key->rounds = 12;\n    else\n        key->rounds = 14;\n\n    rk[0] = GETU32(userKey     );\n    rk[1] = GETU32(userKey +  4);\n    rk[2] = GETU32(userKey +  8);\n    rk[3] = GETU32(userKey + 12);\n    if (bits == 128) {\n        for (;;) {\n            temp  = rk[3];\n            rk[4] = rk[0] ^\n                (Te4[(temp >> 16) & 0xff] & 0xff000000) ^\n                (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^\n                (Te4[(temp      ) & 0xff] & 0x0000ff00) ^\n                (Te4[(temp >> 24)       ] & 0x000000ff) ^\n                rcon[i];\n            rk[5] = rk[1] ^ rk[4];\n            rk[6] = rk[2] ^ rk[5];\n            rk[7] = rk[3] ^ rk[6];\n            if (++i == 10) {\n                return 0;\n            }\n            rk += 4;\n        }\n    }\n    rk[4] = GETU32(userKey + 16);\n    rk[5] = GETU32(userKey + 20);\n    if (bits == 192) {\n        for (;;) {\n            temp = rk[ 5];\n            rk[ 6] = rk[ 0] ^\n                (Te4[(temp >> 16) & 0xff] & 0xff000000) ^\n                (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^\n                (Te4[(temp      ) & 0xff] & 0x0000ff00) ^\n                (Te4[(temp >> 24)       ] & 0x000000ff) ^\n                rcon[i];\n            rk[ 7] = rk[ 1] ^ rk[ 6];\n            rk[ 8] = rk[ 2] ^ rk[ 7];\n            rk[ 9] = rk[ 3] ^ rk[ 8];\n            if (++i == 8) {\n                return 0;\n            }\n            rk[10] = rk[ 4] ^ rk[ 9];\n            rk[11] = rk[ 5] ^ rk[10];\n            rk += 6;\n        }\n    }\n    rk[6] = GETU32(userKey + 24);\n    rk[7] = GETU32(userKey + 28);\n    if (bits == 256) {\n        for (;;) {\n            temp = rk[ 7];\n            rk[ 8] = rk[ 0] ^\n                (Te4[(temp >> 16) & 0xff] & 0xff000000) ^\n                (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^\n                (Te4[(temp      ) & 0xff] & 0x0000ff00) ^\n                (Te4[(temp >> 24)       ] & 0x000000ff) ^\n                rcon[i];\n            rk[ 9] = rk[ 1] ^ rk[ 8];\n            rk[10] = rk[ 2] ^ rk[ 9];\n            rk[11] = rk[ 3] ^ rk[10];\n            if (++i == 7) {\n                return 0;\n            }\n            temp = rk[11];\n            rk[12] = rk[ 4] ^\n                (Te4[(temp >> 24)       ] & 0xff000000) ^\n                (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^\n                (Te4[(temp >>  8) & 0xff] & 0x0000ff00) ^\n                (Te4[(temp      ) & 0xff] & 0x000000ff);\n            rk[13] = rk[ 5] ^ rk[12];\n            rk[14] = rk[ 6] ^ rk[13];\n            rk[15] = rk[ 7] ^ rk[14];\n\n            rk += 8;\n        }\n    }\n    return 0;\n}\n\n/**\n * Expand the cipher key into the decryption key schedule.\n */\nint AES_set_decrypt_key(const unsigned char *userKey, const int bits,\n        AES_KEY *key) {\n\n    u32 *rk;\n    int i, j, status;\n    u32 temp;\n\n    /* first, start with an encryption schedule */\n    status = AES_set_encrypt_key(userKey, bits, key);\n    if (status < 0)\n        return status;\n\n    rk = (u32*) key->rd_key;\n\n    /* invert the order of the round keys: */\n    for (i = 0, j = 4*(key->rounds); i < j; i += 4, j -= 4) {\n        temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;\n        temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\n        temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\n        temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\n    }\n    /* apply the inverse MixColumn transform to all round keys but the first and the last: */\n    for (i = 1; i < (key->rounds); i++) {\n        rk += 4;\n        rk[0] =\n            Td0[Te4[(rk[0] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[0] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[0]      ) & 0xff] & 0xff];\n        rk[1] =\n            Td0[Te4[(rk[1] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[1] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[1]      ) & 0xff] & 0xff];\n        rk[2] =\n            Td0[Te4[(rk[2] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[2] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[2]      ) & 0xff] & 0xff];\n        rk[3] =\n            Td0[Te4[(rk[3] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[3] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[3]      ) & 0xff] & 0xff];\n    }\n    return 0;\n}\n\n/**\n * set decryption key schedule from encryption subkeys.\n */\nint AES_set_4round_decrypt_key(const AES_KEY *ekey, AES_KEY *dkey) {\n\n    u32 *rk;\n    int i, j, status;\n    u32 temp;\n\n    memcpy(dkey->rd_key, ekey->rd_key, ROUNDS * 16);\n\n    rk = (u32*) dkey->rd_key;\n\n    /* invert the order of the round keys: */\n    for (i = 0, j = 4*(ROUNDS-1); i < j; i += 4, j -= 4) {\n        temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;\n        temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\n        temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\n        temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\n    }\n    /* apply the inverse MixColumn transform to all round keys but the first: */\n    for (i = 0; i < (ROUNDS-1); i++) {\n        rk += 4;\n        rk[0] =\n            Td0[Te4[(rk[0] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[0] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[0]      ) & 0xff] & 0xff];\n        rk[1] =\n            Td0[Te4[(rk[1] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[1] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[1]      ) & 0xff] & 0xff];\n        rk[2] =\n            Td0[Te4[(rk[2] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[2] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[2]      ) & 0xff] & 0xff];\n        rk[3] =\n            Td0[Te4[(rk[3] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[3] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[3]      ) & 0xff] & 0xff];\n    }\n    return 0;\n}\n/*\n * Encrypt a single block\n * in and out can overlap\n */\nvoid AES_encrypt(const unsigned char *in, unsigned char *out,\n        const AES_KEY *key) {\n#ifdef _PRINT\n    printf(\"AES  input: \");\n    print_state(in);\n#endif\n\n    const u32 *rk;\n    u32 s0, s1, s2, s3, t0, t1, t2, t3;\n#ifndef FULL_UNROLL\n    int r;\n#endif /* ?FULL_UNROLL */\n\n    if(!(in && out && key)){\n        return;\n    }\n    rk = (u32*) key->rd_key;\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n    s0 = GETU32(in     ) ^ rk[0];\n    s1 = GETU32(in +  4) ^ rk[1];\n    s2 = GETU32(in +  8) ^ rk[2];\n    s3 = GETU32(in + 12) ^ rk[3];\n#ifdef FULL_UNROLL\n    /* round 1: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 4];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 5];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 6];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 7];\n    /* round 2: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 8];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 9];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];\n    /* round 3: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[12];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[13];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[14];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[15];\n    /* round 4: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[16];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[17];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[18];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[19];\n    /* round 5: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[20];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[21];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[22];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[23];\n    /* round 6: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[24];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[25];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[26];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[27];\n    /* round 7: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[28];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[29];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[30];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[31];\n    /* round 8: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[32];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[33];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[34];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[35];\n    /* round 9: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[36];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[37];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[38];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[39];\n    if (key->rounds > 10) {\n        /* round 10: */\n        s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[40];\n        s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[41];\n        s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[42];\n        s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[43];\n        /* round 11: */\n        t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[44];\n        t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[45];\n        t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[46];\n        t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[47];\n        if (key->rounds > 12) {\n            /* round 12: */\n            s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[48];\n            s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[49];\n            s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[50];\n            s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[51];\n            /* round 13: */\n            t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[52];\n            t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[53];\n            t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[54];\n            t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[55];\n        }\n    }\n    rk += key->rounds << 2;\n#else  /* !FULL_UNROLL */\n    /*\n     * Nr - 1 full rounds:\n     */\n    r = key->rounds >> 1;\n    for (;;) {\n        t0 =\n            Te0[(s0 >> 24)       ] ^\n            Te1[(s1 >> 16) & 0xff] ^\n            Te2[(s2 >>  8) & 0xff] ^\n            Te3[(s3      ) & 0xff] ^\n            rk[4];\n        t1 =\n            Te0[(s1 >> 24)       ] ^\n            Te1[(s2 >> 16) & 0xff] ^\n            Te2[(s3 >>  8) & 0xff] ^\n            Te3[(s0      ) & 0xff] ^\n            rk[5];\n        t2 =\n            Te0[(s2 >> 24)       ] ^\n            Te1[(s3 >> 16) & 0xff] ^\n            Te2[(s0 >>  8) & 0xff] ^\n            Te3[(s1      ) & 0xff] ^\n            rk[6];\n        t3 =\n            Te0[(s3 >> 24)       ] ^\n            Te1[(s0 >> 16) & 0xff] ^\n            Te2[(s1 >>  8) & 0xff] ^\n            Te3[(s2      ) & 0xff] ^\n            rk[7];\n\n        rk += 8;\n        if (--r == 0) {\n            break;\n        }\n\n        s0 =\n            Te0[(t0 >> 24)       ] ^\n            Te1[(t1 >> 16) & 0xff] ^\n            Te2[(t2 >>  8) & 0xff] ^\n            Te3[(t3      ) & 0xff] ^\n            rk[0];\n        s1 =\n            Te0[(t1 >> 24)       ] ^\n            Te1[(t2 >> 16) & 0xff] ^\n            Te2[(t3 >>  8) & 0xff] ^\n            Te3[(t0      ) & 0xff] ^\n            rk[1];\n        s2 =\n            Te0[(t2 >> 24)       ] ^\n            Te1[(t3 >> 16) & 0xff] ^\n            Te2[(t0 >>  8) & 0xff] ^\n            Te3[(t1      ) & 0xff] ^\n            rk[2];\n        s3 =\n            Te0[(t3 >> 24)       ] ^\n            Te1[(t0 >> 16) & 0xff] ^\n            Te2[(t1 >>  8) & 0xff] ^\n            Te3[(t2      ) & 0xff] ^\n            rk[3];\n    }\n#endif /* ?FULL_UNROLL */\n    /*\n     * apply last round and\n     * map cipher state to byte array block:\n     */\n    s0 =\n        (Te4[(t0 >> 24)       ] & 0xff000000) ^\n        (Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t2 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t3      ) & 0xff] & 0x000000ff) ^\n        rk[0];\n    PUTU32(out     , s0);\n    s1 =\n        (Te4[(t1 >> 24)       ] & 0xff000000) ^\n        (Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t3 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t0      ) & 0xff] & 0x000000ff) ^\n        rk[1];\n    PUTU32(out +  4, s1);\n    s2 =\n        (Te4[(t2 >> 24)       ] & 0xff000000) ^\n        (Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t0 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t1      ) & 0xff] & 0x000000ff) ^\n        rk[2];\n    PUTU32(out +  8, s2);\n    s3 =\n        (Te4[(t3 >> 24)       ] & 0xff000000) ^\n        (Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t1 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t2      ) & 0xff] & 0x000000ff) ^\n        rk[3];\n    PUTU32(out + 12, s3);\n\n#ifdef _PRINT\n    printf(\"AES output: \");\n    print_state(out);\n#endif\n}\n\n/*\n * Decrypt a single block\n * in and out can overlap\n */\nvoid AES_decrypt(const unsigned char *in, unsigned char *out,\n        const AES_KEY *key) {\n\n    const u32 *rk;\n    u32 s0, s1, s2, s3, t0, t1, t2, t3;\n#ifndef FULL_UNROLL\n    int r;\n#endif /* ?FULL_UNROLL */\n\n    if(!(in && out && key)) return;\n    rk = (u32*) key->rd_key;\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n    s0 = GETU32(in     ) ^ rk[0];\n    s1 = GETU32(in +  4) ^ rk[1];\n    s2 = GETU32(in +  8) ^ rk[2];\n    s3 = GETU32(in + 12) ^ rk[3];\n#ifdef FULL_UNROLL\n    /* round 1: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[ 4];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[ 5];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[ 6];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[ 7];\n    /* round 2: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[ 8];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[ 9];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[10];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[11];\n    /* round 3: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[12];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[13];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[14];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[15];\n    /* round 4: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[16];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[17];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[18];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[19];\n    /* round 5: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[20];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[21];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[22];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[23];\n    /* round 6: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[24];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[25];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[26];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[27];\n    /* round 7: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[28];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[29];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[30];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[31];\n    /* round 8: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[32];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[33];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[34];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[35];\n    /* round 9: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[36];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[37];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[38];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[39];\n    if (key->rounds > 10) {\n        /* round 10: */\n        s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[40];\n        s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[41];\n        s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[42];\n        s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[43];\n        /* round 11: */\n        t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[44];\n        t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[45];\n        t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[46];\n        t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[47];\n        if (key->rounds > 12) {\n            /* round 12: */\n            s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[48];\n            s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[49];\n            s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[50];\n            s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[51];\n            /* round 13: */\n            t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[52];\n            t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[53];\n            t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[54];\n            t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[55];\n        }\n    }\n    rk += key->rounds << 2;\n#else  /* !FULL_UNROLL */\n    /*\n     * Nr - 1 full rounds:\n     */\n    r = key->rounds >> 1;\n    for (;;) {\n        t0 =\n            Td0[(s0 >> 24)       ] ^\n            Td1[(s3 >> 16) & 0xff] ^\n            Td2[(s2 >>  8) & 0xff] ^\n            Td3[(s1      ) & 0xff] ^\n            rk[4];\n        t1 =\n            Td0[(s1 >> 24)       ] ^\n            Td1[(s0 >> 16) & 0xff] ^\n            Td2[(s3 >>  8) & 0xff] ^\n            Td3[(s2      ) & 0xff] ^\n            rk[5];\n        t2 =\n            Td0[(s2 >> 24)       ] ^\n            Td1[(s1 >> 16) & 0xff] ^\n            Td2[(s0 >>  8) & 0xff] ^\n            Td3[(s3      ) & 0xff] ^\n            rk[6];\n        t3 =\n            Td0[(s3 >> 24)       ] ^\n            Td1[(s2 >> 16) & 0xff] ^\n            Td2[(s1 >>  8) & 0xff] ^\n            Td3[(s0      ) & 0xff] ^\n            rk[7];\n\n        rk += 8;\n        if (--r == 0) {\n            break;\n        }\n\n        s0 =\n            Td0[(t0 >> 24)       ] ^\n            Td1[(t3 >> 16) & 0xff] ^\n            Td2[(t2 >>  8) & 0xff] ^\n            Td3[(t1      ) & 0xff] ^\n            rk[0];\n        s1 =\n            Td0[(t1 >> 24)       ] ^\n            Td1[(t0 >> 16) & 0xff] ^\n            Td2[(t3 >>  8) & 0xff] ^\n            Td3[(t2      ) & 0xff] ^\n            rk[1];\n        s2 =\n            Td0[(t2 >> 24)       ] ^\n            Td1[(t1 >> 16) & 0xff] ^\n            Td2[(t0 >>  8) & 0xff] ^\n            Td3[(t3      ) & 0xff] ^\n            rk[2];\n        s3 =\n            Td0[(t3 >> 24)       ] ^\n            Td1[(t2 >> 16) & 0xff] ^\n            Td2[(t1 >>  8) & 0xff] ^\n            Td3[(t0      ) & 0xff] ^\n            rk[3];\n    }\n#endif /* ?FULL_UNROLL */\n    /*\n     * apply last round and\n     * map cipher state to byte array block:\n     */\n    s0 =\n        (Td4[(t0 >> 24)       ] & 0xff000000) ^\n        (Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t2 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t1      ) & 0xff] & 0x000000ff) ^\n        rk[0];\n    PUTU32(out     , s0);\n    s1 =\n        (Td4[(t1 >> 24)       ] & 0xff000000) ^\n        (Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t3 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t2      ) & 0xff] & 0x000000ff) ^\n        rk[1];\n    PUTU32(out +  4, s1);\n    s2 =\n        (Td4[(t2 >> 24)       ] & 0xff000000) ^\n        (Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t0 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t3      ) & 0xff] & 0x000000ff) ^\n        rk[2];\n    PUTU32(out +  8, s2);\n    s3 =\n        (Td4[(t3 >> 24)       ] & 0xff000000) ^\n        (Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t1 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t0      ) & 0xff] & 0x000000ff) ^\n        rk[3];\n    PUTU32(out + 12, s3);\n}\n\nvoid AES_encrypt_4round (const unsigned char *in, unsigned char *out,\n        const AES_KEY *key)\n{\n    const u32 *rk;\n    u32 s0, s1, s2, s3, t0, t1, t2, t3;\n\n    assert(in && out && key);\n    rk = key->rd_key;\n\n    /*\n     * map byte array block to cipher state\n     */\n    s0 = GETU32(in     );\n    s1 = GETU32(in +  4);\n    s2 = GETU32(in +  8);\n    s3 = GETU32(in + 12);\n\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 0];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 1];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 2];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 3];\n\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 4];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 5];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[ 6];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[ 7];\n\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 8];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 9];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[10];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[11];\n\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[12];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[13];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[14];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[15];\n\n    PUTU32(out, s0);\n    PUTU32(out +  4, s1);\n    PUTU32(out +  8, s2);\n    PUTU32(out + 12, s3);\n\n}\n\n/*\n * Decrypt a single block\n * in and out can overlap\n */\nvoid AES_decrypt_4round(const unsigned char *in, unsigned char *out, const AES_KEY *key)\n{\n\n    const u32 *rk;\n    u32 s0, s1, s2, s3, t0, t1, t2, t3;\n#ifndef FULL_UNROLL\n    int r;\n#endif /* ?FULL_UNROLL */\n\n    if(!(in && out && key)) return;\n    rk = (u32*) key->rd_key;\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n    s0 = GETU32(in     ) ^ rk[0];\n    s1 = GETU32(in +  4) ^ rk[1];\n    s2 = GETU32(in +  8) ^ rk[2];\n    s3 = GETU32(in + 12) ^ rk[3];\n\n\n    /* apply inverse MixColumn */\n    s0 =\n        Td0[Te4[(s0 >> 24)       ] & 0xff] ^\n        Td1[Te4[(s0 >> 16) & 0xff] & 0xff] ^\n        Td2[Te4[(s0 >>  8) & 0xff] & 0xff] ^\n        Td3[Te4[(s0      ) & 0xff] & 0xff];\n    s1 =\n        Td0[Te4[(s1 >> 24)       ] & 0xff] ^\n        Td1[Te4[(s1 >> 16) & 0xff] & 0xff] ^\n        Td2[Te4[(s1 >>  8) & 0xff] & 0xff] ^\n        Td3[Te4[(s1      ) & 0xff] & 0xff];\n    s2 =\n        Td0[Te4[(s2 >> 24)       ] & 0xff] ^\n        Td1[Te4[(s2 >> 16) & 0xff] & 0xff] ^\n        Td2[Te4[(s2 >>  8) & 0xff] & 0xff] ^\n        Td3[Te4[(s2      ) & 0xff] & 0xff];\n    s3 =\n        Td0[Te4[(s3 >> 24)       ] & 0xff] ^\n        Td1[Te4[(s3 >> 16) & 0xff] & 0xff] ^\n        Td2[Te4[(s3 >>  8) & 0xff] & 0xff] ^\n        Td3[Te4[(s3      ) & 0xff] & 0xff];\n\n\n    /* round 1: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[ 4];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[ 5];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[ 6];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[ 7];\n    /* round 2: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[ 8];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[ 9];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[10];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[11];\n    /* round 3: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[12];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[13];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[14];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[15];\n    /* round 4: */\n    s0 =\n        (Td4[(t0 >> 24)       ] & 0xff000000) ^\n        (Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t2 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t1      ) & 0xff] & 0x000000ff);\n    PUTU32(out     , s0);\n    s1 =\n        (Td4[(t1 >> 24)       ] & 0xff000000) ^\n        (Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t3 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t2      ) & 0xff] & 0x000000ff);\n    PUTU32(out +  4, s1);\n    s2 =\n        (Td4[(t2 >> 24)       ] & 0xff000000) ^\n        (Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t0 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t3      ) & 0xff] & 0x000000ff);\n    PUTU32(out +  8, s2);\n    s3 =\n        (Td4[(t3 >> 24)       ] & 0xff000000) ^\n        (Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t1 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t0      ) & 0xff] & 0x000000ff);\n    PUTU32(out + 12, s3);\n}\n\n} // namespace Aes128marble4rv1_raw\n"
        },
        {
            "file_name": "aes128marble4rv1_marble.cpp",
            "content": "#include <string.h>\n#include \"aes128marble4rv1_aes.h\"\n#include \"aes128marble4rv1_marble.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Aes128marble4rv1_raw {\n\n/* doubling, multiple by 2 in GF field */\nvoid Time2(byte s[SLEN])\n{\n    byte msb = s[0] & 0x80;\n    int i;\n    for(i = 0; i < SLEN-1; i++)\n        s[i] = (s[i] << 1)^(s[i+1] >> 7);\n    s[i] = (s[i] << 1);\n    if(msb) s[i] ^= GFPOLY;\n}\n\n/* division by 2, inverse operation of doubling */\nvoid Division2(byte s[SLEN])\n{\n    byte lsb = s[SLEN-1] & 0x01;\n    if(lsb) s[SLEN-1] ^= GFPOLY;\n    int i;\n    for(i = SLEN - 1; i >0; i--)\n        s[i] = (s[i] >> 1) ^ (s[i-1] << 7);\n    s[i] = (s[i] >> 1) ^ (lsb << 7);\n}\n\nvoid Time3(byte s[SLEN])\n{\n    byte temp[SLEN];\n    memcpy(temp, s, SLEN);\n    Time2(s);\n    xor_bytes(s, temp, SLEN);\n}\n\nvoid Time7(byte s[SLEN])\n{\n    byte temp[SLEN];\n    memcpy(temp, s, SLEN);\n    Time3(s);\n    Time2(s);\n    xor_bytes(s, temp, SLEN);\n}\n\nvoid Trans(byte* x, byte* y)\n{\n    byte temp[SLEN];\n    memcpy(temp, x, SLEN);\n    xor_bytes(x, y, SLEN);\n    Time2(temp);\n    xor_bytes2(y, temp, x, SLEN);\n}\n\nvoid invTrans(byte* x, byte* y)\n{\n    byte tx[SLEN];\n    memcpy(tx, x, SLEN);\n    Time2(x);\n    xor_bytes(x, y, SLEN);\n    xor_bytes2(y, x, tx, SLEN);\n}\n\n/* encrypt one block */\nvoid Enc(const byte* pt, byte* ct, ae_cxt* cxt)\n{\n    xor_bytes2(ct, pt, cxt->iMask, SLEN);\n    AES_encrypt_4round(ct, ct, &(cxt->ekey0));\n    Trans(cxt->S1, ct);\n    AES_encrypt_4round(ct, ct, &(cxt->ekey1));\n    Trans(cxt->S2, ct);\n    AES_encrypt_4round(ct, ct, &(cxt->ekey2));\n    xor_bytes(ct, cxt->oMask, SLEN);\n}\n\n/* decrypt one block */\nvoid Dec(const byte* ct, byte* pt, ae_cxt* cxt)\n{\n    xor_bytes2(pt, ct, cxt->oMask, SLEN);\n    AES_decrypt_4round(pt, pt, &(cxt->dkey2));\n    invTrans(cxt->S2, pt);\n    AES_decrypt_4round(pt, pt, &(cxt->dkey1));\n    invTrans(cxt->S1, pt);\n    AES_decrypt_4round(pt, pt, &(cxt->dkey0));\n    xor_bytes(pt, cxt->iMask, SLEN);\n}\n\n/* initialize the key and L */\nint ae_init(ae_cxt* cxt, const byte* userkey, int keylen)\n{\n    memset(cxt, 0, sizeof(ae_cxt));\n\n    cxt->S1[SLEN-1] = 0x01;\n    cxt->S2[SLEN-1] = 0x02;\n\n    AES_set_encrypt_key(userkey, 128, &(cxt->ekey0));\t\t// set ekey0\n    AES_set_4round_decrypt_key(&(cxt->ekey0), &(cxt->dkey0)); \t// set dkey0\n\n    memcpy(cxt->ekey1.rd_key, ((byte*)(cxt->ekey0.rd_key))+SLEN*4, SLEN*4); // set ekey1\n    AES_set_4round_decrypt_key(&(cxt->ekey1), &(cxt->dkey1));\t// set dkey1\n\n    memcpy(cxt->ekey2.rd_key, ((byte*)(cxt->ekey0.rd_key))+SLEN*8, SLEN*3); // set ekey2\n    memcpy(((byte*)(cxt->ekey2.rd_key))+SLEN*3, cxt->ekey0.rd_key, SLEN);\n    AES_set_4round_decrypt_key(&(cxt->ekey2), &(cxt->dkey2));\t// set dkey2\n\n    Enc(cxt->L, cxt->L, cxt);\n\n    memcpy(cxt->iMask, cxt->L, SLEN);\n\n    Time3(cxt->iMask); Time3(cxt->iMask); \t// set the input mask to 3^2 L\n\n    return SUCCESS;\n}\n\n/* there will be no nonce */\nint process_ad(ae_cxt* cxt, const byte* ad, unsigned long long adlen, const byte* nonce, unsigned long long nlen)\n{\n    unsigned long long i;\n    byte temp[SLEN], lastblock[SLEN];\n    for(i = 0; i < adlen/SLEN; i++)\n    {\n        Enc(ad+i*SLEN, temp, cxt);\n        Time2(cxt->iMask);\n        xor_bytes(cxt->Tau, temp, SLEN);\n    }\n    memset(lastblock, 0, SLEN);\n    unsigned long long lastblocklen = adlen % SLEN;\n    if(lastblocklen)\n        memcpy(lastblock, ad+i*SLEN, lastblocklen);\n    lastblock[lastblocklen] = 0x80;\n    Enc(lastblock, temp, cxt);\n    xor_bytes(cxt->Tau, temp, SLEN);\n\n    return SUCCESS;\n}\n\n/* rotate to the left by 1 bit */\nvoid rotate1(byte* x, int nbytes)\n{\n    byte msb = x[0] & 0x80;\n    int i;\n    for(i = 0; i < nbytes-1; i++)\n    {\n        x[i] = (x[i] << 1) ^ (x[i+1] >> 7);\n    }\n    x[i] = (x[i] << 1) ^ (msb>>7);\n}\nvoid mix(byte* A, byte* B, int nbytes)\n{\n    byte temp[SLEN];\n    xor_bytes2(temp, A, B, nbytes);\n    rotate1(temp, nbytes);\n    xor_bytes(A, temp, nbytes);\n    xor_bytes(B, temp, nbytes);\n}\n\n/* in this stage cxt->S1 and cxt->S2 are NOT updated */\nvoid XLS(ae_cxt* cxt, byte* out, const byte* M, int nbytes, const byte* block)\n{\n    byte bs1[SLEN], bs2[SLEN];\n    memcpy(bs1, cxt->S1, SLEN);\t\t// backup S1\n    memcpy(bs2, cxt->S2, SLEN);\t\t// backup S2\n\n    memset(cxt->iMask, 0, SLEN);\t// remove input mask\n    memset(cxt->oMask, 0, SLEN);\t// remove output mask\n\n    byte temp[2*SLEN];\n    memcpy(temp, M, nbytes);\n    memcpy(temp+nbytes, block, SLEN);\n\n    Enc(temp, temp, cxt);\n    mix(temp+SLEN-nbytes, temp+SLEN, nbytes);\n    temp[SLEN-nbytes-1] ^= 0x01;\n    memcpy(cxt->S1, bs1, SLEN);\t\t// store S1\n    memcpy(cxt->S2, bs2, SLEN);\t\t// store S2\n\n    Enc(temp, temp, cxt);\n    mix(temp+SLEN-nbytes, temp+SLEN, nbytes);\n    temp[SLEN-nbytes-1] ^= 0x01;\n    memcpy(cxt->S1, bs1, SLEN);\t\t// store S1\n    memcpy(cxt->S2, bs2, SLEN);\t\t// store S2\n\n    Enc(temp, temp, cxt);\n\n    memcpy(out, temp, SLEN+nbytes);\n}\n\nvoid invXLS(ae_cxt* cxt, byte* out, const byte* C, int nbytes, byte* tag)\n{\n    byte bs1[SLEN], bs2[SLEN];\n    memcpy(bs1, cxt->S1, SLEN);\t\t// backup S1\n    memcpy(bs2, cxt->S2, SLEN);\t\t// backup S2\n\n    memset(cxt->iMask, 0, SLEN);\t// remove input mask\n    memset(cxt->oMask, 0, SLEN);\t// remove output mask\n\n    byte temp[2*SLEN];\n    memcpy(temp, C, SLEN+nbytes);\n\n    Dec(temp, temp, cxt);\n    temp[SLEN-nbytes-1] ^= 0x01;\n    mix(temp+SLEN-nbytes, temp+SLEN, nbytes);\n    memcpy(cxt->S1, bs1, SLEN);\t\t// store S1\n    memcpy(cxt->S2, bs2, SLEN);\t\t// store S2\n\n    Dec(temp, temp, cxt);\n    temp[SLEN-nbytes-1] ^= 0x01;\n    mix(temp+SLEN-nbytes, temp+SLEN, nbytes);\n    memcpy(cxt->S1, bs1, SLEN);\t\t// store S1\n    memcpy(cxt->S2, bs2, SLEN);\t\t// store S2\n\n    Dec(temp, temp, cxt);\n\n    memcpy(out, temp, nbytes);\n    memcpy(tag, temp+nbytes, SLEN);\n}\n\nint ae_encrypt(ae_cxt* cxt, byte* pt, unsigned long long mlen, byte* ct)\n{\n    memcpy(cxt->iMask, cxt->L, SLEN);\n    Time2(cxt->iMask);\n    memcpy(cxt->oMask, cxt->L, SLEN);\n    Time3(cxt->oMask);\n\n    byte temp[SLEN];\n    byte otag[SLEN];\n    unsigned long long i;\n\n    if(mlen < SLEN){\t\t\t// tag splitting\n        Division2(cxt->iMask);\t// iMask = L\n        Division2(cxt->oMask);\t// oMask = 2^-1*3*L\n        byte mblock[SLEN];\n        if(mlen){\t\t\t\t\t// if message length is 0, do nothing\n            memset(mblock, 0, SLEN);\n            memcpy(mblock, pt, mlen);\n            mblock[mlen] = 0x80;\n            Enc(mblock, ct, cxt);\n        }\n        Time7(cxt->iMask);\n        Time7(cxt->oMask);\n        xor_bytes(cxt->MSum, pt, mlen);\n        xor_bytes(cxt->MSum, cxt->Tau, SLEN);\n        Enc(cxt->MSum, otag, cxt);\n        if(mlen)\n            memcpy(ct+SLEN, otag, mlen);\n        else\n            memcpy(ct, otag, SLEN);\n        return SUCCESS;\n    }\n    else{\n        for(i = 0; i < mlen/SLEN; i++) // process the full blocks\n        {\n            xor_bytes(cxt->MSum, pt+i*SLEN, SLEN);\n            Enc(pt+i*SLEN, ct+i*SLEN, cxt);\n            if((i+1)*SLEN != mlen){ \t// not the last block\n                Time2(cxt->iMask);\n                Time2(cxt->oMask);\n            }\n        }\n\n        /* process the tag */\n        Time7(cxt->iMask);\n        Time7(cxt->oMask);\n        xor_bytes(cxt->MSum, cxt->Tau, SLEN);\n        if(mlen % SLEN){\t\t\t// apply XLS\n            Enc(cxt->MSum, otag, cxt);\n            XLS(cxt, ct+i*SLEN, pt+i*SLEN, mlen%SLEN, otag);\n        }\n        else{\t\t\t\t\t\t\t\t\t// normal processing\n            Enc(cxt->MSum, ct+i*SLEN, cxt);\n        }\n    }\n    return SUCCESS;\n}\n\nint ae_decrypt(ae_cxt* cxt, byte* pt, unsigned long long clen, byte* ct, byte* tag)\n{\n    memcpy(cxt->iMask, cxt->L, SLEN);\n    Time2(cxt->iMask);\n    memcpy(cxt->oMask, cxt->L, SLEN);\n    Time3(cxt->oMask);\n\n    byte temp[SLEN];\n    byte otag[SLEN];\n    unsigned long long i;\n    unsigned long long mlen = clen - SLEN;\n\n    if(mlen < SLEN){\t\t\t// tag splitting\n        Division2(cxt->iMask);\t// iMask = L\n        Division2(cxt->oMask);\t// oMask = 2^-1*3*L\n        byte mblock[SLEN];\n        if(mlen){\t\t\t\t\t// if message length is 0, do nothing\n            Dec(ct, mblock, cxt);\n            memcpy(pt, mblock, mlen);\n        }\n        Time7(cxt->iMask);\n        Time7(cxt->oMask);\n        xor_bytes(cxt->MSum, pt, mlen);\n        xor_bytes(cxt->MSum, cxt->Tau, SLEN);\n        Enc(cxt->MSum, otag, cxt);\n        if(mlen){\n            memcpy(tag, ct+mlen, SLEN-mlen);\n            memcpy(tag+SLEN-mlen, otag, mlen);\n        }\n        else\n            memcpy(tag, otag, SLEN);\n        return SUCCESS;\n    }\n    else{\n        for(i = 0; i < mlen/SLEN; i++) // process the full blocks\n        {\n            Dec(ct+i*SLEN, pt+i*SLEN, cxt);\n            xor_bytes(cxt->MSum, pt+i*SLEN, SLEN);\n            if((i+1)*SLEN != mlen){ \t// not the last block\n                Time2(cxt->iMask);\n                Time2(cxt->oMask);\n            }\n        }\n\n        /* process the tag */\n        Time7(cxt->iMask);\n        Time7(cxt->oMask);\n        xor_bytes(cxt->MSum, cxt->Tau, SLEN);\n        if(mlen % SLEN){\t\t\t// apply XLS\n            Enc(cxt->MSum, tag, cxt);\n            invXLS(cxt, pt+i*SLEN, ct+i*SLEN, mlen%SLEN, otag);\n            memcpy(tag+SLEN, otag, SLEN);\n        }\n        else{\t\t\t\t\t\t\t\t\t// normal processing\n            Enc(cxt->MSum, tag, cxt);\n        }\n    }\n    return SUCCESS;\n}\n\n} // namespace Aes128marble4rv1_raw\n"
        },
        {
            "file_name": "aes128marble4rv1_utils.cpp",
            "content": "#include <stdio.h>\n#include \"aes128marble4rv1_marble.h\"\n#include <stdlib.h>\n\n// CHANGE namespace moved due to includes\nnamespace Aes128marble4rv1_raw {\n\nae_cxt* ae_allocate(){\n    ae_cxt* pt = (ae_cxt*) calloc(sizeof(ae_cxt), 1);\n    return pt;\n}\n\nvoid xor_bytes2(byte* result, const byte* x, const byte* y, int nb)\n{\n    int i = 0;\n    for(i = 0; i < nb; i++)\n        result[i] = x[i] ^ y[i];\n}\n\nvoid xor_bytes(byte*x, const byte*y, int nb)\n{\n    xor_bytes2(x, x, y, nb);\n}\n\n\n/* print state with a prefix string */\nvoid pstate2(const unsigned char *str, const byte* state)\n{\n#ifdef _PRINT\n    printf(\"%s\\n\", str);\n    if(state)\n    pstate(state, SLEN);\n#endif\n}\nvoid pstate(const unsigned char* st, int len)\n{\n#ifdef _PRINT\n    int i;\n    for(i = 0; i < len; i++){\n        printf(\"%02x\", st[i]);\n        if(((i%16) == (16-1)) && (i+1 !=len)) printf(\"\\n\");\n    }\n    printf(\"\\n\");\n#endif\n}\n\n\n#if 0\nvoid print_cxt(const ae_cxt* cxt)\n{\n    printf(\"user key of %d bytes:\\n\", cxt->klen);\n    pstate(cxt->userkey, cxt->klen);\n    printf(\"associated data of %llu bytes:\\n\", cxt->adlen);\n    pstate(cxt->ad, cxt->adlen);\n    printf(\"nonce of %llu bytes:\\n\", cxt->nlen);\n    pstate(cxt->nonce, cxt->nlen);\n    printf(\"plaintext of %llu bytes:\\n\", cxt->ptlen);\n    pstate(cxt->pt, cxt->ptlen);\n    printf(\"ciphertext of %llu bytes:\\n\", cxt->ctlen);\n    pstate(cxt->ct, cxt->ctlen);\n    printf(\"MAC of %d bytes:\\n\", cxt->tlen);\n    pstate(cxt->tag, cxt->tlen);\n}\n#endif\n\n} // namespace Aes128marble4rv1_raw\n"
        },
        {
            "file_name": "aes128n12silcv1_aes_core.cpp",
            "content": "/* Taken from OpenSSL sources.  Thanks Vincent, Antoon and Paulo!\n * -Jason Holt\n */\n\n/* crypto/aes/aes_core.c -*- mode:C; c-file-style: \"eay\" -*- */\n/**\n * rijndael-alg-fst.c\n *\n * @version 3.0 (December 2000)\n *\n * Optimised ANSI C code for the Rijndael cipher (now AES)\n *\n * @author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be>\n * @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be>\n * @author Paulo Barreto <paulo.barreto@terra.com.br>\n *\n * This code is hereby placed in the public domain.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* Note: rewritten a little bit to provide error control and an OpenSSL-\n   compatible API */\n\n#include <stdio.h>\n#include \"aes128n12silcv1_aes.h\"\n#include \"aes128n12silcv1_aes_locl.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Aes128n12silcv1_raw {\n\n/*\nTe0[x] = S [x].[02, 01, 01, 03];\nTe1[x] = S [x].[03, 02, 01, 01];\nTe2[x] = S [x].[01, 03, 02, 01];\nTe3[x] = S [x].[01, 01, 03, 02];\nTe4[x] = S [x].[01, 01, 01, 01];\n\nTd0[x] = Si[x].[0e, 09, 0d, 0b];\nTd1[x] = Si[x].[0b, 0e, 09, 0d];\nTd2[x] = Si[x].[0d, 0b, 0e, 09];\nTd3[x] = Si[x].[09, 0d, 0b, 0e];\nTd4[x] = Si[x].[01, 01, 01, 01];\n*/\n\nstatic const u32 Te0[256] = {\n    0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,\n    0xfff2f20dU, 0xd66b6bbdU, 0xde6f6fb1U, 0x91c5c554U,\n    0x60303050U, 0x02010103U, 0xce6767a9U, 0x562b2b7dU,\n    0xe7fefe19U, 0xb5d7d762U, 0x4dababe6U, 0xec76769aU,\n    0x8fcaca45U, 0x1f82829dU, 0x89c9c940U, 0xfa7d7d87U,\n    0xeffafa15U, 0xb25959ebU, 0x8e4747c9U, 0xfbf0f00bU,\n    0x41adadecU, 0xb3d4d467U, 0x5fa2a2fdU, 0x45afafeaU,\n    0x239c9cbfU, 0x53a4a4f7U, 0xe4727296U, 0x9bc0c05bU,\n    0x75b7b7c2U, 0xe1fdfd1cU, 0x3d9393aeU, 0x4c26266aU,\n    0x6c36365aU, 0x7e3f3f41U, 0xf5f7f702U, 0x83cccc4fU,\n    0x6834345cU, 0x51a5a5f4U, 0xd1e5e534U, 0xf9f1f108U,\n    0xe2717193U, 0xabd8d873U, 0x62313153U, 0x2a15153fU,\n    0x0804040cU, 0x95c7c752U, 0x46232365U, 0x9dc3c35eU,\n    0x30181828U, 0x379696a1U, 0x0a05050fU, 0x2f9a9ab5U,\n    0x0e070709U, 0x24121236U, 0x1b80809bU, 0xdfe2e23dU,\n    0xcdebeb26U, 0x4e272769U, 0x7fb2b2cdU, 0xea75759fU,\n    0x1209091bU, 0x1d83839eU, 0x582c2c74U, 0x341a1a2eU,\n    0x361b1b2dU, 0xdc6e6eb2U, 0xb45a5aeeU, 0x5ba0a0fbU,\n    0xa45252f6U, 0x763b3b4dU, 0xb7d6d661U, 0x7db3b3ceU,\n    0x5229297bU, 0xdde3e33eU, 0x5e2f2f71U, 0x13848497U,\n    0xa65353f5U, 0xb9d1d168U, 0x00000000U, 0xc1eded2cU,\n    0x40202060U, 0xe3fcfc1fU, 0x79b1b1c8U, 0xb65b5bedU,\n    0xd46a6abeU, 0x8dcbcb46U, 0x67bebed9U, 0x7239394bU,\n    0x944a4adeU, 0x984c4cd4U, 0xb05858e8U, 0x85cfcf4aU,\n    0xbbd0d06bU, 0xc5efef2aU, 0x4faaaae5U, 0xedfbfb16U,\n    0x864343c5U, 0x9a4d4dd7U, 0x66333355U, 0x11858594U,\n    0x8a4545cfU, 0xe9f9f910U, 0x04020206U, 0xfe7f7f81U,\n    0xa05050f0U, 0x783c3c44U, 0x259f9fbaU, 0x4ba8a8e3U,\n    0xa25151f3U, 0x5da3a3feU, 0x804040c0U, 0x058f8f8aU,\n    0x3f9292adU, 0x219d9dbcU, 0x70383848U, 0xf1f5f504U,\n    0x63bcbcdfU, 0x77b6b6c1U, 0xafdada75U, 0x42212163U,\n    0x20101030U, 0xe5ffff1aU, 0xfdf3f30eU, 0xbfd2d26dU,\n    0x81cdcd4cU, 0x180c0c14U, 0x26131335U, 0xc3ecec2fU,\n    0xbe5f5fe1U, 0x359797a2U, 0x884444ccU, 0x2e171739U,\n    0x93c4c457U, 0x55a7a7f2U, 0xfc7e7e82U, 0x7a3d3d47U,\n    0xc86464acU, 0xba5d5de7U, 0x3219192bU, 0xe6737395U,\n    0xc06060a0U, 0x19818198U, 0x9e4f4fd1U, 0xa3dcdc7fU,\n    0x44222266U, 0x542a2a7eU, 0x3b9090abU, 0x0b888883U,\n    0x8c4646caU, 0xc7eeee29U, 0x6bb8b8d3U, 0x2814143cU,\n    0xa7dede79U, 0xbc5e5ee2U, 0x160b0b1dU, 0xaddbdb76U,\n    0xdbe0e03bU, 0x64323256U, 0x743a3a4eU, 0x140a0a1eU,\n    0x924949dbU, 0x0c06060aU, 0x4824246cU, 0xb85c5ce4U,\n    0x9fc2c25dU, 0xbdd3d36eU, 0x43acacefU, 0xc46262a6U,\n    0x399191a8U, 0x319595a4U, 0xd3e4e437U, 0xf279798bU,\n    0xd5e7e732U, 0x8bc8c843U, 0x6e373759U, 0xda6d6db7U,\n    0x018d8d8cU, 0xb1d5d564U, 0x9c4e4ed2U, 0x49a9a9e0U,\n    0xd86c6cb4U, 0xac5656faU, 0xf3f4f407U, 0xcfeaea25U,\n    0xca6565afU, 0xf47a7a8eU, 0x47aeaee9U, 0x10080818U,\n    0x6fbabad5U, 0xf0787888U, 0x4a25256fU, 0x5c2e2e72U,\n    0x381c1c24U, 0x57a6a6f1U, 0x73b4b4c7U, 0x97c6c651U,\n    0xcbe8e823U, 0xa1dddd7cU, 0xe874749cU, 0x3e1f1f21U,\n    0x964b4bddU, 0x61bdbddcU, 0x0d8b8b86U, 0x0f8a8a85U,\n    0xe0707090U, 0x7c3e3e42U, 0x71b5b5c4U, 0xcc6666aaU,\n    0x904848d8U, 0x06030305U, 0xf7f6f601U, 0x1c0e0e12U,\n    0xc26161a3U, 0x6a35355fU, 0xae5757f9U, 0x69b9b9d0U,\n    0x17868691U, 0x99c1c158U, 0x3a1d1d27U, 0x279e9eb9U,\n    0xd9e1e138U, 0xebf8f813U, 0x2b9898b3U, 0x22111133U,\n    0xd26969bbU, 0xa9d9d970U, 0x078e8e89U, 0x339494a7U,\n    0x2d9b9bb6U, 0x3c1e1e22U, 0x15878792U, 0xc9e9e920U,\n    0x87cece49U, 0xaa5555ffU, 0x50282878U, 0xa5dfdf7aU,\n    0x038c8c8fU, 0x59a1a1f8U, 0x09898980U, 0x1a0d0d17U,\n    0x65bfbfdaU, 0xd7e6e631U, 0x844242c6U, 0xd06868b8U,\n    0x824141c3U, 0x299999b0U, 0x5a2d2d77U, 0x1e0f0f11U,\n    0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,\n};\nstatic const u32 Te1[256] = {\n    0xa5c66363U, 0x84f87c7cU, 0x99ee7777U, 0x8df67b7bU,\n    0x0dfff2f2U, 0xbdd66b6bU, 0xb1de6f6fU, 0x5491c5c5U,\n    0x50603030U, 0x03020101U, 0xa9ce6767U, 0x7d562b2bU,\n    0x19e7fefeU, 0x62b5d7d7U, 0xe64dababU, 0x9aec7676U,\n    0x458fcacaU, 0x9d1f8282U, 0x4089c9c9U, 0x87fa7d7dU,\n    0x15effafaU, 0xebb25959U, 0xc98e4747U, 0x0bfbf0f0U,\n    0xec41adadU, 0x67b3d4d4U, 0xfd5fa2a2U, 0xea45afafU,\n    0xbf239c9cU, 0xf753a4a4U, 0x96e47272U, 0x5b9bc0c0U,\n    0xc275b7b7U, 0x1ce1fdfdU, 0xae3d9393U, 0x6a4c2626U,\n    0x5a6c3636U, 0x417e3f3fU, 0x02f5f7f7U, 0x4f83ccccU,\n    0x5c683434U, 0xf451a5a5U, 0x34d1e5e5U, 0x08f9f1f1U,\n    0x93e27171U, 0x73abd8d8U, 0x53623131U, 0x3f2a1515U,\n    0x0c080404U, 0x5295c7c7U, 0x65462323U, 0x5e9dc3c3U,\n    0x28301818U, 0xa1379696U, 0x0f0a0505U, 0xb52f9a9aU,\n    0x090e0707U, 0x36241212U, 0x9b1b8080U, 0x3ddfe2e2U,\n    0x26cdebebU, 0x694e2727U, 0xcd7fb2b2U, 0x9fea7575U,\n    0x1b120909U, 0x9e1d8383U, 0x74582c2cU, 0x2e341a1aU,\n    0x2d361b1bU, 0xb2dc6e6eU, 0xeeb45a5aU, 0xfb5ba0a0U,\n    0xf6a45252U, 0x4d763b3bU, 0x61b7d6d6U, 0xce7db3b3U,\n    0x7b522929U, 0x3edde3e3U, 0x715e2f2fU, 0x97138484U,\n    0xf5a65353U, 0x68b9d1d1U, 0x00000000U, 0x2cc1ededU,\n    0x60402020U, 0x1fe3fcfcU, 0xc879b1b1U, 0xedb65b5bU,\n    0xbed46a6aU, 0x468dcbcbU, 0xd967bebeU, 0x4b723939U,\n    0xde944a4aU, 0xd4984c4cU, 0xe8b05858U, 0x4a85cfcfU,\n    0x6bbbd0d0U, 0x2ac5efefU, 0xe54faaaaU, 0x16edfbfbU,\n    0xc5864343U, 0xd79a4d4dU, 0x55663333U, 0x94118585U,\n    0xcf8a4545U, 0x10e9f9f9U, 0x06040202U, 0x81fe7f7fU,\n    0xf0a05050U, 0x44783c3cU, 0xba259f9fU, 0xe34ba8a8U,\n    0xf3a25151U, 0xfe5da3a3U, 0xc0804040U, 0x8a058f8fU,\n    0xad3f9292U, 0xbc219d9dU, 0x48703838U, 0x04f1f5f5U,\n    0xdf63bcbcU, 0xc177b6b6U, 0x75afdadaU, 0x63422121U,\n    0x30201010U, 0x1ae5ffffU, 0x0efdf3f3U, 0x6dbfd2d2U,\n    0x4c81cdcdU, 0x14180c0cU, 0x35261313U, 0x2fc3ececU,\n    0xe1be5f5fU, 0xa2359797U, 0xcc884444U, 0x392e1717U,\n    0x5793c4c4U, 0xf255a7a7U, 0x82fc7e7eU, 0x477a3d3dU,\n    0xacc86464U, 0xe7ba5d5dU, 0x2b321919U, 0x95e67373U,\n    0xa0c06060U, 0x98198181U, 0xd19e4f4fU, 0x7fa3dcdcU,\n    0x66442222U, 0x7e542a2aU, 0xab3b9090U, 0x830b8888U,\n    0xca8c4646U, 0x29c7eeeeU, 0xd36bb8b8U, 0x3c281414U,\n    0x79a7dedeU, 0xe2bc5e5eU, 0x1d160b0bU, 0x76addbdbU,\n    0x3bdbe0e0U, 0x56643232U, 0x4e743a3aU, 0x1e140a0aU,\n    0xdb924949U, 0x0a0c0606U, 0x6c482424U, 0xe4b85c5cU,\n    0x5d9fc2c2U, 0x6ebdd3d3U, 0xef43acacU, 0xa6c46262U,\n    0xa8399191U, 0xa4319595U, 0x37d3e4e4U, 0x8bf27979U,\n    0x32d5e7e7U, 0x438bc8c8U, 0x596e3737U, 0xb7da6d6dU,\n    0x8c018d8dU, 0x64b1d5d5U, 0xd29c4e4eU, 0xe049a9a9U,\n    0xb4d86c6cU, 0xfaac5656U, 0x07f3f4f4U, 0x25cfeaeaU,\n    0xafca6565U, 0x8ef47a7aU, 0xe947aeaeU, 0x18100808U,\n    0xd56fbabaU, 0x88f07878U, 0x6f4a2525U, 0x725c2e2eU,\n    0x24381c1cU, 0xf157a6a6U, 0xc773b4b4U, 0x5197c6c6U,\n    0x23cbe8e8U, 0x7ca1ddddU, 0x9ce87474U, 0x213e1f1fU,\n    0xdd964b4bU, 0xdc61bdbdU, 0x860d8b8bU, 0x850f8a8aU,\n    0x90e07070U, 0x427c3e3eU, 0xc471b5b5U, 0xaacc6666U,\n    0xd8904848U, 0x05060303U, 0x01f7f6f6U, 0x121c0e0eU,\n    0xa3c26161U, 0x5f6a3535U, 0xf9ae5757U, 0xd069b9b9U,\n    0x91178686U, 0x5899c1c1U, 0x273a1d1dU, 0xb9279e9eU,\n    0x38d9e1e1U, 0x13ebf8f8U, 0xb32b9898U, 0x33221111U,\n    0xbbd26969U, 0x70a9d9d9U, 0x89078e8eU, 0xa7339494U,\n    0xb62d9b9bU, 0x223c1e1eU, 0x92158787U, 0x20c9e9e9U,\n    0x4987ceceU, 0xffaa5555U, 0x78502828U, 0x7aa5dfdfU,\n    0x8f038c8cU, 0xf859a1a1U, 0x80098989U, 0x171a0d0dU,\n    0xda65bfbfU, 0x31d7e6e6U, 0xc6844242U, 0xb8d06868U,\n    0xc3824141U, 0xb0299999U, 0x775a2d2dU, 0x111e0f0fU,\n    0xcb7bb0b0U, 0xfca85454U, 0xd66dbbbbU, 0x3a2c1616U,\n};\nstatic const u32 Te2[256] = {\n    0x63a5c663U, 0x7c84f87cU, 0x7799ee77U, 0x7b8df67bU,\n    0xf20dfff2U, 0x6bbdd66bU, 0x6fb1de6fU, 0xc55491c5U,\n    0x30506030U, 0x01030201U, 0x67a9ce67U, 0x2b7d562bU,\n    0xfe19e7feU, 0xd762b5d7U, 0xabe64dabU, 0x769aec76U,\n    0xca458fcaU, 0x829d1f82U, 0xc94089c9U, 0x7d87fa7dU,\n    0xfa15effaU, 0x59ebb259U, 0x47c98e47U, 0xf00bfbf0U,\n    0xadec41adU, 0xd467b3d4U, 0xa2fd5fa2U, 0xafea45afU,\n    0x9cbf239cU, 0xa4f753a4U, 0x7296e472U, 0xc05b9bc0U,\n    0xb7c275b7U, 0xfd1ce1fdU, 0x93ae3d93U, 0x266a4c26U,\n    0x365a6c36U, 0x3f417e3fU, 0xf702f5f7U, 0xcc4f83ccU,\n    0x345c6834U, 0xa5f451a5U, 0xe534d1e5U, 0xf108f9f1U,\n    0x7193e271U, 0xd873abd8U, 0x31536231U, 0x153f2a15U,\n    0x040c0804U, 0xc75295c7U, 0x23654623U, 0xc35e9dc3U,\n    0x18283018U, 0x96a13796U, 0x050f0a05U, 0x9ab52f9aU,\n    0x07090e07U, 0x12362412U, 0x809b1b80U, 0xe23ddfe2U,\n    0xeb26cdebU, 0x27694e27U, 0xb2cd7fb2U, 0x759fea75U,\n    0x091b1209U, 0x839e1d83U, 0x2c74582cU, 0x1a2e341aU,\n    0x1b2d361bU, 0x6eb2dc6eU, 0x5aeeb45aU, 0xa0fb5ba0U,\n    0x52f6a452U, 0x3b4d763bU, 0xd661b7d6U, 0xb3ce7db3U,\n    0x297b5229U, 0xe33edde3U, 0x2f715e2fU, 0x84971384U,\n    0x53f5a653U, 0xd168b9d1U, 0x00000000U, 0xed2cc1edU,\n    0x20604020U, 0xfc1fe3fcU, 0xb1c879b1U, 0x5bedb65bU,\n    0x6abed46aU, 0xcb468dcbU, 0xbed967beU, 0x394b7239U,\n    0x4ade944aU, 0x4cd4984cU, 0x58e8b058U, 0xcf4a85cfU,\n    0xd06bbbd0U, 0xef2ac5efU, 0xaae54faaU, 0xfb16edfbU,\n    0x43c58643U, 0x4dd79a4dU, 0x33556633U, 0x85941185U,\n    0x45cf8a45U, 0xf910e9f9U, 0x02060402U, 0x7f81fe7fU,\n    0x50f0a050U, 0x3c44783cU, 0x9fba259fU, 0xa8e34ba8U,\n    0x51f3a251U, 0xa3fe5da3U, 0x40c08040U, 0x8f8a058fU,\n    0x92ad3f92U, 0x9dbc219dU, 0x38487038U, 0xf504f1f5U,\n    0xbcdf63bcU, 0xb6c177b6U, 0xda75afdaU, 0x21634221U,\n    0x10302010U, 0xff1ae5ffU, 0xf30efdf3U, 0xd26dbfd2U,\n    0xcd4c81cdU, 0x0c14180cU, 0x13352613U, 0xec2fc3ecU,\n    0x5fe1be5fU, 0x97a23597U, 0x44cc8844U, 0x17392e17U,\n    0xc45793c4U, 0xa7f255a7U, 0x7e82fc7eU, 0x3d477a3dU,\n    0x64acc864U, 0x5de7ba5dU, 0x192b3219U, 0x7395e673U,\n    0x60a0c060U, 0x81981981U, 0x4fd19e4fU, 0xdc7fa3dcU,\n    0x22664422U, 0x2a7e542aU, 0x90ab3b90U, 0x88830b88U,\n    0x46ca8c46U, 0xee29c7eeU, 0xb8d36bb8U, 0x143c2814U,\n    0xde79a7deU, 0x5ee2bc5eU, 0x0b1d160bU, 0xdb76addbU,\n    0xe03bdbe0U, 0x32566432U, 0x3a4e743aU, 0x0a1e140aU,\n    0x49db9249U, 0x060a0c06U, 0x246c4824U, 0x5ce4b85cU,\n    0xc25d9fc2U, 0xd36ebdd3U, 0xacef43acU, 0x62a6c462U,\n    0x91a83991U, 0x95a43195U, 0xe437d3e4U, 0x798bf279U,\n    0xe732d5e7U, 0xc8438bc8U, 0x37596e37U, 0x6db7da6dU,\n    0x8d8c018dU, 0xd564b1d5U, 0x4ed29c4eU, 0xa9e049a9U,\n    0x6cb4d86cU, 0x56faac56U, 0xf407f3f4U, 0xea25cfeaU,\n    0x65afca65U, 0x7a8ef47aU, 0xaee947aeU, 0x08181008U,\n    0xbad56fbaU, 0x7888f078U, 0x256f4a25U, 0x2e725c2eU,\n    0x1c24381cU, 0xa6f157a6U, 0xb4c773b4U, 0xc65197c6U,\n    0xe823cbe8U, 0xdd7ca1ddU, 0x749ce874U, 0x1f213e1fU,\n    0x4bdd964bU, 0xbddc61bdU, 0x8b860d8bU, 0x8a850f8aU,\n    0x7090e070U, 0x3e427c3eU, 0xb5c471b5U, 0x66aacc66U,\n    0x48d89048U, 0x03050603U, 0xf601f7f6U, 0x0e121c0eU,\n    0x61a3c261U, 0x355f6a35U, 0x57f9ae57U, 0xb9d069b9U,\n    0x86911786U, 0xc15899c1U, 0x1d273a1dU, 0x9eb9279eU,\n    0xe138d9e1U, 0xf813ebf8U, 0x98b32b98U, 0x11332211U,\n    0x69bbd269U, 0xd970a9d9U, 0x8e89078eU, 0x94a73394U,\n    0x9bb62d9bU, 0x1e223c1eU, 0x87921587U, 0xe920c9e9U,\n    0xce4987ceU, 0x55ffaa55U, 0x28785028U, 0xdf7aa5dfU,\n    0x8c8f038cU, 0xa1f859a1U, 0x89800989U, 0x0d171a0dU,\n    0xbfda65bfU, 0xe631d7e6U, 0x42c68442U, 0x68b8d068U,\n    0x41c38241U, 0x99b02999U, 0x2d775a2dU, 0x0f111e0fU,\n    0xb0cb7bb0U, 0x54fca854U, 0xbbd66dbbU, 0x163a2c16U,\n};\nstatic const u32 Te3[256] = {\n\n    0x6363a5c6U, 0x7c7c84f8U, 0x777799eeU, 0x7b7b8df6U,\n    0xf2f20dffU, 0x6b6bbdd6U, 0x6f6fb1deU, 0xc5c55491U,\n    0x30305060U, 0x01010302U, 0x6767a9ceU, 0x2b2b7d56U,\n    0xfefe19e7U, 0xd7d762b5U, 0xababe64dU, 0x76769aecU,\n    0xcaca458fU, 0x82829d1fU, 0xc9c94089U, 0x7d7d87faU,\n    0xfafa15efU, 0x5959ebb2U, 0x4747c98eU, 0xf0f00bfbU,\n    0xadadec41U, 0xd4d467b3U, 0xa2a2fd5fU, 0xafafea45U,\n    0x9c9cbf23U, 0xa4a4f753U, 0x727296e4U, 0xc0c05b9bU,\n    0xb7b7c275U, 0xfdfd1ce1U, 0x9393ae3dU, 0x26266a4cU,\n    0x36365a6cU, 0x3f3f417eU, 0xf7f702f5U, 0xcccc4f83U,\n    0x34345c68U, 0xa5a5f451U, 0xe5e534d1U, 0xf1f108f9U,\n    0x717193e2U, 0xd8d873abU, 0x31315362U, 0x15153f2aU,\n    0x04040c08U, 0xc7c75295U, 0x23236546U, 0xc3c35e9dU,\n    0x18182830U, 0x9696a137U, 0x05050f0aU, 0x9a9ab52fU,\n    0x0707090eU, 0x12123624U, 0x80809b1bU, 0xe2e23ddfU,\n    0xebeb26cdU, 0x2727694eU, 0xb2b2cd7fU, 0x75759feaU,\n    0x09091b12U, 0x83839e1dU, 0x2c2c7458U, 0x1a1a2e34U,\n    0x1b1b2d36U, 0x6e6eb2dcU, 0x5a5aeeb4U, 0xa0a0fb5bU,\n    0x5252f6a4U, 0x3b3b4d76U, 0xd6d661b7U, 0xb3b3ce7dU,\n    0x29297b52U, 0xe3e33eddU, 0x2f2f715eU, 0x84849713U,\n    0x5353f5a6U, 0xd1d168b9U, 0x00000000U, 0xeded2cc1U,\n    0x20206040U, 0xfcfc1fe3U, 0xb1b1c879U, 0x5b5bedb6U,\n    0x6a6abed4U, 0xcbcb468dU, 0xbebed967U, 0x39394b72U,\n    0x4a4ade94U, 0x4c4cd498U, 0x5858e8b0U, 0xcfcf4a85U,\n    0xd0d06bbbU, 0xefef2ac5U, 0xaaaae54fU, 0xfbfb16edU,\n    0x4343c586U, 0x4d4dd79aU, 0x33335566U, 0x85859411U,\n    0x4545cf8aU, 0xf9f910e9U, 0x02020604U, 0x7f7f81feU,\n    0x5050f0a0U, 0x3c3c4478U, 0x9f9fba25U, 0xa8a8e34bU,\n    0x5151f3a2U, 0xa3a3fe5dU, 0x4040c080U, 0x8f8f8a05U,\n    0x9292ad3fU, 0x9d9dbc21U, 0x38384870U, 0xf5f504f1U,\n    0xbcbcdf63U, 0xb6b6c177U, 0xdada75afU, 0x21216342U,\n    0x10103020U, 0xffff1ae5U, 0xf3f30efdU, 0xd2d26dbfU,\n    0xcdcd4c81U, 0x0c0c1418U, 0x13133526U, 0xecec2fc3U,\n    0x5f5fe1beU, 0x9797a235U, 0x4444cc88U, 0x1717392eU,\n    0xc4c45793U, 0xa7a7f255U, 0x7e7e82fcU, 0x3d3d477aU,\n    0x6464acc8U, 0x5d5de7baU, 0x19192b32U, 0x737395e6U,\n    0x6060a0c0U, 0x81819819U, 0x4f4fd19eU, 0xdcdc7fa3U,\n    0x22226644U, 0x2a2a7e54U, 0x9090ab3bU, 0x8888830bU,\n    0x4646ca8cU, 0xeeee29c7U, 0xb8b8d36bU, 0x14143c28U,\n    0xdede79a7U, 0x5e5ee2bcU, 0x0b0b1d16U, 0xdbdb76adU,\n    0xe0e03bdbU, 0x32325664U, 0x3a3a4e74U, 0x0a0a1e14U,\n    0x4949db92U, 0x06060a0cU, 0x24246c48U, 0x5c5ce4b8U,\n    0xc2c25d9fU, 0xd3d36ebdU, 0xacacef43U, 0x6262a6c4U,\n    0x9191a839U, 0x9595a431U, 0xe4e437d3U, 0x79798bf2U,\n    0xe7e732d5U, 0xc8c8438bU, 0x3737596eU, 0x6d6db7daU,\n    0x8d8d8c01U, 0xd5d564b1U, 0x4e4ed29cU, 0xa9a9e049U,\n    0x6c6cb4d8U, 0x5656faacU, 0xf4f407f3U, 0xeaea25cfU,\n    0x6565afcaU, 0x7a7a8ef4U, 0xaeaee947U, 0x08081810U,\n    0xbabad56fU, 0x787888f0U, 0x25256f4aU, 0x2e2e725cU,\n    0x1c1c2438U, 0xa6a6f157U, 0xb4b4c773U, 0xc6c65197U,\n    0xe8e823cbU, 0xdddd7ca1U, 0x74749ce8U, 0x1f1f213eU,\n    0x4b4bdd96U, 0xbdbddc61U, 0x8b8b860dU, 0x8a8a850fU,\n    0x707090e0U, 0x3e3e427cU, 0xb5b5c471U, 0x6666aaccU,\n    0x4848d890U, 0x03030506U, 0xf6f601f7U, 0x0e0e121cU,\n    0x6161a3c2U, 0x35355f6aU, 0x5757f9aeU, 0xb9b9d069U,\n    0x86869117U, 0xc1c15899U, 0x1d1d273aU, 0x9e9eb927U,\n    0xe1e138d9U, 0xf8f813ebU, 0x9898b32bU, 0x11113322U,\n    0x6969bbd2U, 0xd9d970a9U, 0x8e8e8907U, 0x9494a733U,\n    0x9b9bb62dU, 0x1e1e223cU, 0x87879215U, 0xe9e920c9U,\n    0xcece4987U, 0x5555ffaaU, 0x28287850U, 0xdfdf7aa5U,\n    0x8c8c8f03U, 0xa1a1f859U, 0x89898009U, 0x0d0d171aU,\n    0xbfbfda65U, 0xe6e631d7U, 0x4242c684U, 0x6868b8d0U,\n    0x4141c382U, 0x9999b029U, 0x2d2d775aU, 0x0f0f111eU,\n    0xb0b0cb7bU, 0x5454fca8U, 0xbbbbd66dU, 0x16163a2cU,\n};\nstatic const u32 Te4[256] = {\n    0x63636363U, 0x7c7c7c7cU, 0x77777777U, 0x7b7b7b7bU,\n    0xf2f2f2f2U, 0x6b6b6b6bU, 0x6f6f6f6fU, 0xc5c5c5c5U,\n    0x30303030U, 0x01010101U, 0x67676767U, 0x2b2b2b2bU,\n    0xfefefefeU, 0xd7d7d7d7U, 0xababababU, 0x76767676U,\n    0xcacacacaU, 0x82828282U, 0xc9c9c9c9U, 0x7d7d7d7dU,\n    0xfafafafaU, 0x59595959U, 0x47474747U, 0xf0f0f0f0U,\n    0xadadadadU, 0xd4d4d4d4U, 0xa2a2a2a2U, 0xafafafafU,\n    0x9c9c9c9cU, 0xa4a4a4a4U, 0x72727272U, 0xc0c0c0c0U,\n    0xb7b7b7b7U, 0xfdfdfdfdU, 0x93939393U, 0x26262626U,\n    0x36363636U, 0x3f3f3f3fU, 0xf7f7f7f7U, 0xccccccccU,\n    0x34343434U, 0xa5a5a5a5U, 0xe5e5e5e5U, 0xf1f1f1f1U,\n    0x71717171U, 0xd8d8d8d8U, 0x31313131U, 0x15151515U,\n    0x04040404U, 0xc7c7c7c7U, 0x23232323U, 0xc3c3c3c3U,\n    0x18181818U, 0x96969696U, 0x05050505U, 0x9a9a9a9aU,\n    0x07070707U, 0x12121212U, 0x80808080U, 0xe2e2e2e2U,\n    0xebebebebU, 0x27272727U, 0xb2b2b2b2U, 0x75757575U,\n    0x09090909U, 0x83838383U, 0x2c2c2c2cU, 0x1a1a1a1aU,\n    0x1b1b1b1bU, 0x6e6e6e6eU, 0x5a5a5a5aU, 0xa0a0a0a0U,\n    0x52525252U, 0x3b3b3b3bU, 0xd6d6d6d6U, 0xb3b3b3b3U,\n    0x29292929U, 0xe3e3e3e3U, 0x2f2f2f2fU, 0x84848484U,\n    0x53535353U, 0xd1d1d1d1U, 0x00000000U, 0xededededU,\n    0x20202020U, 0xfcfcfcfcU, 0xb1b1b1b1U, 0x5b5b5b5bU,\n    0x6a6a6a6aU, 0xcbcbcbcbU, 0xbebebebeU, 0x39393939U,\n    0x4a4a4a4aU, 0x4c4c4c4cU, 0x58585858U, 0xcfcfcfcfU,\n    0xd0d0d0d0U, 0xefefefefU, 0xaaaaaaaaU, 0xfbfbfbfbU,\n    0x43434343U, 0x4d4d4d4dU, 0x33333333U, 0x85858585U,\n    0x45454545U, 0xf9f9f9f9U, 0x02020202U, 0x7f7f7f7fU,\n    0x50505050U, 0x3c3c3c3cU, 0x9f9f9f9fU, 0xa8a8a8a8U,\n    0x51515151U, 0xa3a3a3a3U, 0x40404040U, 0x8f8f8f8fU,\n    0x92929292U, 0x9d9d9d9dU, 0x38383838U, 0xf5f5f5f5U,\n    0xbcbcbcbcU, 0xb6b6b6b6U, 0xdadadadaU, 0x21212121U,\n    0x10101010U, 0xffffffffU, 0xf3f3f3f3U, 0xd2d2d2d2U,\n    0xcdcdcdcdU, 0x0c0c0c0cU, 0x13131313U, 0xececececU,\n    0x5f5f5f5fU, 0x97979797U, 0x44444444U, 0x17171717U,\n    0xc4c4c4c4U, 0xa7a7a7a7U, 0x7e7e7e7eU, 0x3d3d3d3dU,\n    0x64646464U, 0x5d5d5d5dU, 0x19191919U, 0x73737373U,\n    0x60606060U, 0x81818181U, 0x4f4f4f4fU, 0xdcdcdcdcU,\n    0x22222222U, 0x2a2a2a2aU, 0x90909090U, 0x88888888U,\n    0x46464646U, 0xeeeeeeeeU, 0xb8b8b8b8U, 0x14141414U,\n    0xdedededeU, 0x5e5e5e5eU, 0x0b0b0b0bU, 0xdbdbdbdbU,\n    0xe0e0e0e0U, 0x32323232U, 0x3a3a3a3aU, 0x0a0a0a0aU,\n    0x49494949U, 0x06060606U, 0x24242424U, 0x5c5c5c5cU,\n    0xc2c2c2c2U, 0xd3d3d3d3U, 0xacacacacU, 0x62626262U,\n    0x91919191U, 0x95959595U, 0xe4e4e4e4U, 0x79797979U,\n    0xe7e7e7e7U, 0xc8c8c8c8U, 0x37373737U, 0x6d6d6d6dU,\n    0x8d8d8d8dU, 0xd5d5d5d5U, 0x4e4e4e4eU, 0xa9a9a9a9U,\n    0x6c6c6c6cU, 0x56565656U, 0xf4f4f4f4U, 0xeaeaeaeaU,\n    0x65656565U, 0x7a7a7a7aU, 0xaeaeaeaeU, 0x08080808U,\n    0xbabababaU, 0x78787878U, 0x25252525U, 0x2e2e2e2eU,\n    0x1c1c1c1cU, 0xa6a6a6a6U, 0xb4b4b4b4U, 0xc6c6c6c6U,\n    0xe8e8e8e8U, 0xddddddddU, 0x74747474U, 0x1f1f1f1fU,\n    0x4b4b4b4bU, 0xbdbdbdbdU, 0x8b8b8b8bU, 0x8a8a8a8aU,\n    0x70707070U, 0x3e3e3e3eU, 0xb5b5b5b5U, 0x66666666U,\n    0x48484848U, 0x03030303U, 0xf6f6f6f6U, 0x0e0e0e0eU,\n    0x61616161U, 0x35353535U, 0x57575757U, 0xb9b9b9b9U,\n    0x86868686U, 0xc1c1c1c1U, 0x1d1d1d1dU, 0x9e9e9e9eU,\n    0xe1e1e1e1U, 0xf8f8f8f8U, 0x98989898U, 0x11111111U,\n    0x69696969U, 0xd9d9d9d9U, 0x8e8e8e8eU, 0x94949494U,\n    0x9b9b9b9bU, 0x1e1e1e1eU, 0x87878787U, 0xe9e9e9e9U,\n    0xcecececeU, 0x55555555U, 0x28282828U, 0xdfdfdfdfU,\n    0x8c8c8c8cU, 0xa1a1a1a1U, 0x89898989U, 0x0d0d0d0dU,\n    0xbfbfbfbfU, 0xe6e6e6e6U, 0x42424242U, 0x68686868U,\n    0x41414141U, 0x99999999U, 0x2d2d2d2dU, 0x0f0f0f0fU,\n    0xb0b0b0b0U, 0x54545454U, 0xbbbbbbbbU, 0x16161616U,\n};\nstatic const u32 Td0[256] = {\n    0x51f4a750U, 0x7e416553U, 0x1a17a4c3U, 0x3a275e96U,\n    0x3bab6bcbU, 0x1f9d45f1U, 0xacfa58abU, 0x4be30393U,\n    0x2030fa55U, 0xad766df6U, 0x88cc7691U, 0xf5024c25U,\n    0x4fe5d7fcU, 0xc52acbd7U, 0x26354480U, 0xb562a38fU,\n    0xdeb15a49U, 0x25ba1b67U, 0x45ea0e98U, 0x5dfec0e1U,\n    0xc32f7502U, 0x814cf012U, 0x8d4697a3U, 0x6bd3f9c6U,\n    0x038f5fe7U, 0x15929c95U, 0xbf6d7aebU, 0x955259daU,\n    0xd4be832dU, 0x587421d3U, 0x49e06929U, 0x8ec9c844U,\n    0x75c2896aU, 0xf48e7978U, 0x99583e6bU, 0x27b971ddU,\n    0xbee14fb6U, 0xf088ad17U, 0xc920ac66U, 0x7dce3ab4U,\n    0x63df4a18U, 0xe51a3182U, 0x97513360U, 0x62537f45U,\n    0xb16477e0U, 0xbb6bae84U, 0xfe81a01cU, 0xf9082b94U,\n    0x70486858U, 0x8f45fd19U, 0x94de6c87U, 0x527bf8b7U,\n    0xab73d323U, 0x724b02e2U, 0xe31f8f57U, 0x6655ab2aU,\n    0xb2eb2807U, 0x2fb5c203U, 0x86c57b9aU, 0xd33708a5U,\n    0x302887f2U, 0x23bfa5b2U, 0x02036abaU, 0xed16825cU,\n    0x8acf1c2bU, 0xa779b492U, 0xf307f2f0U, 0x4e69e2a1U,\n    0x65daf4cdU, 0x0605bed5U, 0xd134621fU, 0xc4a6fe8aU,\n    0x342e539dU, 0xa2f355a0U, 0x058ae132U, 0xa4f6eb75U,\n    0x0b83ec39U, 0x4060efaaU, 0x5e719f06U, 0xbd6e1051U,\n    0x3e218af9U, 0x96dd063dU, 0xdd3e05aeU, 0x4de6bd46U,\n    0x91548db5U, 0x71c45d05U, 0x0406d46fU, 0x605015ffU,\n    0x1998fb24U, 0xd6bde997U, 0x894043ccU, 0x67d99e77U,\n    0xb0e842bdU, 0x07898b88U, 0xe7195b38U, 0x79c8eedbU,\n    0xa17c0a47U, 0x7c420fe9U, 0xf8841ec9U, 0x00000000U,\n    0x09808683U, 0x322bed48U, 0x1e1170acU, 0x6c5a724eU,\n    0xfd0efffbU, 0x0f853856U, 0x3daed51eU, 0x362d3927U,\n    0x0a0fd964U, 0x685ca621U, 0x9b5b54d1U, 0x24362e3aU,\n    0x0c0a67b1U, 0x9357e70fU, 0xb4ee96d2U, 0x1b9b919eU,\n    0x80c0c54fU, 0x61dc20a2U, 0x5a774b69U, 0x1c121a16U,\n    0xe293ba0aU, 0xc0a02ae5U, 0x3c22e043U, 0x121b171dU,\n    0x0e090d0bU, 0xf28bc7adU, 0x2db6a8b9U, 0x141ea9c8U,\n    0x57f11985U, 0xaf75074cU, 0xee99ddbbU, 0xa37f60fdU,\n    0xf701269fU, 0x5c72f5bcU, 0x44663bc5U, 0x5bfb7e34U,\n    0x8b432976U, 0xcb23c6dcU, 0xb6edfc68U, 0xb8e4f163U,\n    0xd731dccaU, 0x42638510U, 0x13972240U, 0x84c61120U,\n    0x854a247dU, 0xd2bb3df8U, 0xaef93211U, 0xc729a16dU,\n    0x1d9e2f4bU, 0xdcb230f3U, 0x0d8652ecU, 0x77c1e3d0U,\n    0x2bb3166cU, 0xa970b999U, 0x119448faU, 0x47e96422U,\n    0xa8fc8cc4U, 0xa0f03f1aU, 0x567d2cd8U, 0x223390efU,\n    0x87494ec7U, 0xd938d1c1U, 0x8ccaa2feU, 0x98d40b36U,\n    0xa6f581cfU, 0xa57ade28U, 0xdab78e26U, 0x3fadbfa4U,\n    0x2c3a9de4U, 0x5078920dU, 0x6a5fcc9bU, 0x547e4662U,\n    0xf68d13c2U, 0x90d8b8e8U, 0x2e39f75eU, 0x82c3aff5U,\n    0x9f5d80beU, 0x69d0937cU, 0x6fd52da9U, 0xcf2512b3U,\n    0xc8ac993bU, 0x10187da7U, 0xe89c636eU, 0xdb3bbb7bU,\n    0xcd267809U, 0x6e5918f4U, 0xec9ab701U, 0x834f9aa8U,\n    0xe6956e65U, 0xaaffe67eU, 0x21bccf08U, 0xef15e8e6U,\n    0xbae79bd9U, 0x4a6f36ceU, 0xea9f09d4U, 0x29b07cd6U,\n    0x31a4b2afU, 0x2a3f2331U, 0xc6a59430U, 0x35a266c0U,\n    0x744ebc37U, 0xfc82caa6U, 0xe090d0b0U, 0x33a7d815U,\n    0xf104984aU, 0x41ecdaf7U, 0x7fcd500eU, 0x1791f62fU,\n    0x764dd68dU, 0x43efb04dU, 0xccaa4d54U, 0xe49604dfU,\n    0x9ed1b5e3U, 0x4c6a881bU, 0xc12c1fb8U, 0x4665517fU,\n    0x9d5eea04U, 0x018c355dU, 0xfa877473U, 0xfb0b412eU,\n    0xb3671d5aU, 0x92dbd252U, 0xe9105633U, 0x6dd64713U,\n    0x9ad7618cU, 0x37a10c7aU, 0x59f8148eU, 0xeb133c89U,\n    0xcea927eeU, 0xb761c935U, 0xe11ce5edU, 0x7a47b13cU,\n    0x9cd2df59U, 0x55f2733fU, 0x1814ce79U, 0x73c737bfU,\n    0x53f7cdeaU, 0x5ffdaa5bU, 0xdf3d6f14U, 0x7844db86U,\n    0xcaaff381U, 0xb968c43eU, 0x3824342cU, 0xc2a3405fU,\n    0x161dc372U, 0xbce2250cU, 0x283c498bU, 0xff0d9541U,\n    0x39a80171U, 0x080cb3deU, 0xd8b4e49cU, 0x6456c190U,\n    0x7bcb8461U, 0xd532b670U, 0x486c5c74U, 0xd0b85742U,\n};\nstatic const u32 Td1[256] = {\n    0x5051f4a7U, 0x537e4165U, 0xc31a17a4U, 0x963a275eU,\n    0xcb3bab6bU, 0xf11f9d45U, 0xabacfa58U, 0x934be303U,\n    0x552030faU, 0xf6ad766dU, 0x9188cc76U, 0x25f5024cU,\n    0xfc4fe5d7U, 0xd7c52acbU, 0x80263544U, 0x8fb562a3U,\n    0x49deb15aU, 0x6725ba1bU, 0x9845ea0eU, 0xe15dfec0U,\n    0x02c32f75U, 0x12814cf0U, 0xa38d4697U, 0xc66bd3f9U,\n    0xe7038f5fU, 0x9515929cU, 0xebbf6d7aU, 0xda955259U,\n    0x2dd4be83U, 0xd3587421U, 0x2949e069U, 0x448ec9c8U,\n    0x6a75c289U, 0x78f48e79U, 0x6b99583eU, 0xdd27b971U,\n    0xb6bee14fU, 0x17f088adU, 0x66c920acU, 0xb47dce3aU,\n    0x1863df4aU, 0x82e51a31U, 0x60975133U, 0x4562537fU,\n    0xe0b16477U, 0x84bb6baeU, 0x1cfe81a0U, 0x94f9082bU,\n    0x58704868U, 0x198f45fdU, 0x8794de6cU, 0xb7527bf8U,\n    0x23ab73d3U, 0xe2724b02U, 0x57e31f8fU, 0x2a6655abU,\n    0x07b2eb28U, 0x032fb5c2U, 0x9a86c57bU, 0xa5d33708U,\n    0xf2302887U, 0xb223bfa5U, 0xba02036aU, 0x5ced1682U,\n    0x2b8acf1cU, 0x92a779b4U, 0xf0f307f2U, 0xa14e69e2U,\n    0xcd65daf4U, 0xd50605beU, 0x1fd13462U, 0x8ac4a6feU,\n    0x9d342e53U, 0xa0a2f355U, 0x32058ae1U, 0x75a4f6ebU,\n    0x390b83ecU, 0xaa4060efU, 0x065e719fU, 0x51bd6e10U,\n    0xf93e218aU, 0x3d96dd06U, 0xaedd3e05U, 0x464de6bdU,\n    0xb591548dU, 0x0571c45dU, 0x6f0406d4U, 0xff605015U,\n    0x241998fbU, 0x97d6bde9U, 0xcc894043U, 0x7767d99eU,\n    0xbdb0e842U, 0x8807898bU, 0x38e7195bU, 0xdb79c8eeU,\n    0x47a17c0aU, 0xe97c420fU, 0xc9f8841eU, 0x00000000U,\n    0x83098086U, 0x48322bedU, 0xac1e1170U, 0x4e6c5a72U,\n    0xfbfd0effU, 0x560f8538U, 0x1e3daed5U, 0x27362d39U,\n    0x640a0fd9U, 0x21685ca6U, 0xd19b5b54U, 0x3a24362eU,\n    0xb10c0a67U, 0x0f9357e7U, 0xd2b4ee96U, 0x9e1b9b91U,\n    0x4f80c0c5U, 0xa261dc20U, 0x695a774bU, 0x161c121aU,\n    0x0ae293baU, 0xe5c0a02aU, 0x433c22e0U, 0x1d121b17U,\n    0x0b0e090dU, 0xadf28bc7U, 0xb92db6a8U, 0xc8141ea9U,\n    0x8557f119U, 0x4caf7507U, 0xbbee99ddU, 0xfda37f60U,\n    0x9ff70126U, 0xbc5c72f5U, 0xc544663bU, 0x345bfb7eU,\n    0x768b4329U, 0xdccb23c6U, 0x68b6edfcU, 0x63b8e4f1U,\n    0xcad731dcU, 0x10426385U, 0x40139722U, 0x2084c611U,\n    0x7d854a24U, 0xf8d2bb3dU, 0x11aef932U, 0x6dc729a1U,\n    0x4b1d9e2fU, 0xf3dcb230U, 0xec0d8652U, 0xd077c1e3U,\n    0x6c2bb316U, 0x99a970b9U, 0xfa119448U, 0x2247e964U,\n    0xc4a8fc8cU, 0x1aa0f03fU, 0xd8567d2cU, 0xef223390U,\n    0xc787494eU, 0xc1d938d1U, 0xfe8ccaa2U, 0x3698d40bU,\n    0xcfa6f581U, 0x28a57adeU, 0x26dab78eU, 0xa43fadbfU,\n    0xe42c3a9dU, 0x0d507892U, 0x9b6a5fccU, 0x62547e46U,\n    0xc2f68d13U, 0xe890d8b8U, 0x5e2e39f7U, 0xf582c3afU,\n    0xbe9f5d80U, 0x7c69d093U, 0xa96fd52dU, 0xb3cf2512U,\n    0x3bc8ac99U, 0xa710187dU, 0x6ee89c63U, 0x7bdb3bbbU,\n    0x09cd2678U, 0xf46e5918U, 0x01ec9ab7U, 0xa8834f9aU,\n    0x65e6956eU, 0x7eaaffe6U, 0x0821bccfU, 0xe6ef15e8U,\n    0xd9bae79bU, 0xce4a6f36U, 0xd4ea9f09U, 0xd629b07cU,\n    0xaf31a4b2U, 0x312a3f23U, 0x30c6a594U, 0xc035a266U,\n    0x37744ebcU, 0xa6fc82caU, 0xb0e090d0U, 0x1533a7d8U,\n    0x4af10498U, 0xf741ecdaU, 0x0e7fcd50U, 0x2f1791f6U,\n    0x8d764dd6U, 0x4d43efb0U, 0x54ccaa4dU, 0xdfe49604U,\n    0xe39ed1b5U, 0x1b4c6a88U, 0xb8c12c1fU, 0x7f466551U,\n    0x049d5eeaU, 0x5d018c35U, 0x73fa8774U, 0x2efb0b41U,\n    0x5ab3671dU, 0x5292dbd2U, 0x33e91056U, 0x136dd647U,\n    0x8c9ad761U, 0x7a37a10cU, 0x8e59f814U, 0x89eb133cU,\n    0xeecea927U, 0x35b761c9U, 0xede11ce5U, 0x3c7a47b1U,\n    0x599cd2dfU, 0x3f55f273U, 0x791814ceU, 0xbf73c737U,\n    0xea53f7cdU, 0x5b5ffdaaU, 0x14df3d6fU, 0x867844dbU,\n    0x81caaff3U, 0x3eb968c4U, 0x2c382434U, 0x5fc2a340U,\n    0x72161dc3U, 0x0cbce225U, 0x8b283c49U, 0x41ff0d95U,\n    0x7139a801U, 0xde080cb3U, 0x9cd8b4e4U, 0x906456c1U,\n    0x617bcb84U, 0x70d532b6U, 0x74486c5cU, 0x42d0b857U,\n};\nstatic const u32 Td2[256] = {\n    0xa75051f4U, 0x65537e41U, 0xa4c31a17U, 0x5e963a27U,\n    0x6bcb3babU, 0x45f11f9dU, 0x58abacfaU, 0x03934be3U,\n    0xfa552030U, 0x6df6ad76U, 0x769188ccU, 0x4c25f502U,\n    0xd7fc4fe5U, 0xcbd7c52aU, 0x44802635U, 0xa38fb562U,\n    0x5a49deb1U, 0x1b6725baU, 0x0e9845eaU, 0xc0e15dfeU,\n    0x7502c32fU, 0xf012814cU, 0x97a38d46U, 0xf9c66bd3U,\n    0x5fe7038fU, 0x9c951592U, 0x7aebbf6dU, 0x59da9552U,\n    0x832dd4beU, 0x21d35874U, 0x692949e0U, 0xc8448ec9U,\n    0x896a75c2U, 0x7978f48eU, 0x3e6b9958U, 0x71dd27b9U,\n    0x4fb6bee1U, 0xad17f088U, 0xac66c920U, 0x3ab47dceU,\n    0x4a1863dfU, 0x3182e51aU, 0x33609751U, 0x7f456253U,\n    0x77e0b164U, 0xae84bb6bU, 0xa01cfe81U, 0x2b94f908U,\n    0x68587048U, 0xfd198f45U, 0x6c8794deU, 0xf8b7527bU,\n    0xd323ab73U, 0x02e2724bU, 0x8f57e31fU, 0xab2a6655U,\n    0x2807b2ebU, 0xc2032fb5U, 0x7b9a86c5U, 0x08a5d337U,\n    0x87f23028U, 0xa5b223bfU, 0x6aba0203U, 0x825ced16U,\n    0x1c2b8acfU, 0xb492a779U, 0xf2f0f307U, 0xe2a14e69U,\n    0xf4cd65daU, 0xbed50605U, 0x621fd134U, 0xfe8ac4a6U,\n    0x539d342eU, 0x55a0a2f3U, 0xe132058aU, 0xeb75a4f6U,\n    0xec390b83U, 0xefaa4060U, 0x9f065e71U, 0x1051bd6eU,\n\n    0x8af93e21U, 0x063d96ddU, 0x05aedd3eU, 0xbd464de6U,\n    0x8db59154U, 0x5d0571c4U, 0xd46f0406U, 0x15ff6050U,\n    0xfb241998U, 0xe997d6bdU, 0x43cc8940U, 0x9e7767d9U,\n    0x42bdb0e8U, 0x8b880789U, 0x5b38e719U, 0xeedb79c8U,\n    0x0a47a17cU, 0x0fe97c42U, 0x1ec9f884U, 0x00000000U,\n    0x86830980U, 0xed48322bU, 0x70ac1e11U, 0x724e6c5aU,\n    0xfffbfd0eU, 0x38560f85U, 0xd51e3daeU, 0x3927362dU,\n    0xd9640a0fU, 0xa621685cU, 0x54d19b5bU, 0x2e3a2436U,\n    0x67b10c0aU, 0xe70f9357U, 0x96d2b4eeU, 0x919e1b9bU,\n    0xc54f80c0U, 0x20a261dcU, 0x4b695a77U, 0x1a161c12U,\n    0xba0ae293U, 0x2ae5c0a0U, 0xe0433c22U, 0x171d121bU,\n    0x0d0b0e09U, 0xc7adf28bU, 0xa8b92db6U, 0xa9c8141eU,\n    0x198557f1U, 0x074caf75U, 0xddbbee99U, 0x60fda37fU,\n    0x269ff701U, 0xf5bc5c72U, 0x3bc54466U, 0x7e345bfbU,\n    0x29768b43U, 0xc6dccb23U, 0xfc68b6edU, 0xf163b8e4U,\n    0xdccad731U, 0x85104263U, 0x22401397U, 0x112084c6U,\n    0x247d854aU, 0x3df8d2bbU, 0x3211aef9U, 0xa16dc729U,\n    0x2f4b1d9eU, 0x30f3dcb2U, 0x52ec0d86U, 0xe3d077c1U,\n    0x166c2bb3U, 0xb999a970U, 0x48fa1194U, 0x642247e9U,\n    0x8cc4a8fcU, 0x3f1aa0f0U, 0x2cd8567dU, 0x90ef2233U,\n    0x4ec78749U, 0xd1c1d938U, 0xa2fe8ccaU, 0x0b3698d4U,\n    0x81cfa6f5U, 0xde28a57aU, 0x8e26dab7U, 0xbfa43fadU,\n    0x9de42c3aU, 0x920d5078U, 0xcc9b6a5fU, 0x4662547eU,\n    0x13c2f68dU, 0xb8e890d8U, 0xf75e2e39U, 0xaff582c3U,\n    0x80be9f5dU, 0x937c69d0U, 0x2da96fd5U, 0x12b3cf25U,\n    0x993bc8acU, 0x7da71018U, 0x636ee89cU, 0xbb7bdb3bU,\n    0x7809cd26U, 0x18f46e59U, 0xb701ec9aU, 0x9aa8834fU,\n    0x6e65e695U, 0xe67eaaffU, 0xcf0821bcU, 0xe8e6ef15U,\n    0x9bd9bae7U, 0x36ce4a6fU, 0x09d4ea9fU, 0x7cd629b0U,\n    0xb2af31a4U, 0x23312a3fU, 0x9430c6a5U, 0x66c035a2U,\n    0xbc37744eU, 0xcaa6fc82U, 0xd0b0e090U, 0xd81533a7U,\n    0x984af104U, 0xdaf741ecU, 0x500e7fcdU, 0xf62f1791U,\n    0xd68d764dU, 0xb04d43efU, 0x4d54ccaaU, 0x04dfe496U,\n    0xb5e39ed1U, 0x881b4c6aU, 0x1fb8c12cU, 0x517f4665U,\n    0xea049d5eU, 0x355d018cU, 0x7473fa87U, 0x412efb0bU,\n    0x1d5ab367U, 0xd25292dbU, 0x5633e910U, 0x47136dd6U,\n    0x618c9ad7U, 0x0c7a37a1U, 0x148e59f8U, 0x3c89eb13U,\n    0x27eecea9U, 0xc935b761U, 0xe5ede11cU, 0xb13c7a47U,\n    0xdf599cd2U, 0x733f55f2U, 0xce791814U, 0x37bf73c7U,\n    0xcdea53f7U, 0xaa5b5ffdU, 0x6f14df3dU, 0xdb867844U,\n    0xf381caafU, 0xc43eb968U, 0x342c3824U, 0x405fc2a3U,\n    0xc372161dU, 0x250cbce2U, 0x498b283cU, 0x9541ff0dU,\n    0x017139a8U, 0xb3de080cU, 0xe49cd8b4U, 0xc1906456U,\n    0x84617bcbU, 0xb670d532U, 0x5c74486cU, 0x5742d0b8U,\n};\nstatic const u32 Td3[256] = {\n    0xf4a75051U, 0x4165537eU, 0x17a4c31aU, 0x275e963aU,\n    0xab6bcb3bU, 0x9d45f11fU, 0xfa58abacU, 0xe303934bU,\n    0x30fa5520U, 0x766df6adU, 0xcc769188U, 0x024c25f5U,\n    0xe5d7fc4fU, 0x2acbd7c5U, 0x35448026U, 0x62a38fb5U,\n    0xb15a49deU, 0xba1b6725U, 0xea0e9845U, 0xfec0e15dU,\n    0x2f7502c3U, 0x4cf01281U, 0x4697a38dU, 0xd3f9c66bU,\n    0x8f5fe703U, 0x929c9515U, 0x6d7aebbfU, 0x5259da95U,\n    0xbe832dd4U, 0x7421d358U, 0xe0692949U, 0xc9c8448eU,\n    0xc2896a75U, 0x8e7978f4U, 0x583e6b99U, 0xb971dd27U,\n    0xe14fb6beU, 0x88ad17f0U, 0x20ac66c9U, 0xce3ab47dU,\n    0xdf4a1863U, 0x1a3182e5U, 0x51336097U, 0x537f4562U,\n    0x6477e0b1U, 0x6bae84bbU, 0x81a01cfeU, 0x082b94f9U,\n    0x48685870U, 0x45fd198fU, 0xde6c8794U, 0x7bf8b752U,\n    0x73d323abU, 0x4b02e272U, 0x1f8f57e3U, 0x55ab2a66U,\n    0xeb2807b2U, 0xb5c2032fU, 0xc57b9a86U, 0x3708a5d3U,\n    0x2887f230U, 0xbfa5b223U, 0x036aba02U, 0x16825cedU,\n    0xcf1c2b8aU, 0x79b492a7U, 0x07f2f0f3U, 0x69e2a14eU,\n    0xdaf4cd65U, 0x05bed506U, 0x34621fd1U, 0xa6fe8ac4U,\n    0x2e539d34U, 0xf355a0a2U, 0x8ae13205U, 0xf6eb75a4U,\n    0x83ec390bU, 0x60efaa40U, 0x719f065eU, 0x6e1051bdU,\n    0x218af93eU, 0xdd063d96U, 0x3e05aeddU, 0xe6bd464dU,\n    0x548db591U, 0xc45d0571U, 0x06d46f04U, 0x5015ff60U,\n    0x98fb2419U, 0xbde997d6U, 0x4043cc89U, 0xd99e7767U,\n    0xe842bdb0U, 0x898b8807U, 0x195b38e7U, 0xc8eedb79U,\n    0x7c0a47a1U, 0x420fe97cU, 0x841ec9f8U, 0x00000000U,\n    0x80868309U, 0x2bed4832U, 0x1170ac1eU, 0x5a724e6cU,\n    0x0efffbfdU, 0x8538560fU, 0xaed51e3dU, 0x2d392736U,\n    0x0fd9640aU, 0x5ca62168U, 0x5b54d19bU, 0x362e3a24U,\n    0x0a67b10cU, 0x57e70f93U, 0xee96d2b4U, 0x9b919e1bU,\n    0xc0c54f80U, 0xdc20a261U, 0x774b695aU, 0x121a161cU,\n    0x93ba0ae2U, 0xa02ae5c0U, 0x22e0433cU, 0x1b171d12U,\n    0x090d0b0eU, 0x8bc7adf2U, 0xb6a8b92dU, 0x1ea9c814U,\n    0xf1198557U, 0x75074cafU, 0x99ddbbeeU, 0x7f60fda3U,\n    0x01269ff7U, 0x72f5bc5cU, 0x663bc544U, 0xfb7e345bU,\n    0x4329768bU, 0x23c6dccbU, 0xedfc68b6U, 0xe4f163b8U,\n    0x31dccad7U, 0x63851042U, 0x97224013U, 0xc6112084U,\n    0x4a247d85U, 0xbb3df8d2U, 0xf93211aeU, 0x29a16dc7U,\n    0x9e2f4b1dU, 0xb230f3dcU, 0x8652ec0dU, 0xc1e3d077U,\n    0xb3166c2bU, 0x70b999a9U, 0x9448fa11U, 0xe9642247U,\n    0xfc8cc4a8U, 0xf03f1aa0U, 0x7d2cd856U, 0x3390ef22U,\n    0x494ec787U, 0x38d1c1d9U, 0xcaa2fe8cU, 0xd40b3698U,\n    0xf581cfa6U, 0x7ade28a5U, 0xb78e26daU, 0xadbfa43fU,\n    0x3a9de42cU, 0x78920d50U, 0x5fcc9b6aU, 0x7e466254U,\n    0x8d13c2f6U, 0xd8b8e890U, 0x39f75e2eU, 0xc3aff582U,\n    0x5d80be9fU, 0xd0937c69U, 0xd52da96fU, 0x2512b3cfU,\n    0xac993bc8U, 0x187da710U, 0x9c636ee8U, 0x3bbb7bdbU,\n    0x267809cdU, 0x5918f46eU, 0x9ab701ecU, 0x4f9aa883U,\n    0x956e65e6U, 0xffe67eaaU, 0xbccf0821U, 0x15e8e6efU,\n    0xe79bd9baU, 0x6f36ce4aU, 0x9f09d4eaU, 0xb07cd629U,\n    0xa4b2af31U, 0x3f23312aU, 0xa59430c6U, 0xa266c035U,\n    0x4ebc3774U, 0x82caa6fcU, 0x90d0b0e0U, 0xa7d81533U,\n    0x04984af1U, 0xecdaf741U, 0xcd500e7fU, 0x91f62f17U,\n    0x4dd68d76U, 0xefb04d43U, 0xaa4d54ccU, 0x9604dfe4U,\n    0xd1b5e39eU, 0x6a881b4cU, 0x2c1fb8c1U, 0x65517f46U,\n    0x5eea049dU, 0x8c355d01U, 0x877473faU, 0x0b412efbU,\n    0x671d5ab3U, 0xdbd25292U, 0x105633e9U, 0xd647136dU,\n    0xd7618c9aU, 0xa10c7a37U, 0xf8148e59U, 0x133c89ebU,\n    0xa927eeceU, 0x61c935b7U, 0x1ce5ede1U, 0x47b13c7aU,\n    0xd2df599cU, 0xf2733f55U, 0x14ce7918U, 0xc737bf73U,\n    0xf7cdea53U, 0xfdaa5b5fU, 0x3d6f14dfU, 0x44db8678U,\n    0xaff381caU, 0x68c43eb9U, 0x24342c38U, 0xa3405fc2U,\n    0x1dc37216U, 0xe2250cbcU, 0x3c498b28U, 0x0d9541ffU,\n    0xa8017139U, 0x0cb3de08U, 0xb4e49cd8U, 0x56c19064U,\n    0xcb84617bU, 0x32b670d5U, 0x6c5c7448U, 0xb85742d0U,\n};\nstatic const u32 Td4[256] = {\n    0x52525252U, 0x09090909U, 0x6a6a6a6aU, 0xd5d5d5d5U,\n    0x30303030U, 0x36363636U, 0xa5a5a5a5U, 0x38383838U,\n    0xbfbfbfbfU, 0x40404040U, 0xa3a3a3a3U, 0x9e9e9e9eU,\n    0x81818181U, 0xf3f3f3f3U, 0xd7d7d7d7U, 0xfbfbfbfbU,\n    0x7c7c7c7cU, 0xe3e3e3e3U, 0x39393939U, 0x82828282U,\n    0x9b9b9b9bU, 0x2f2f2f2fU, 0xffffffffU, 0x87878787U,\n    0x34343434U, 0x8e8e8e8eU, 0x43434343U, 0x44444444U,\n    0xc4c4c4c4U, 0xdedededeU, 0xe9e9e9e9U, 0xcbcbcbcbU,\n    0x54545454U, 0x7b7b7b7bU, 0x94949494U, 0x32323232U,\n    0xa6a6a6a6U, 0xc2c2c2c2U, 0x23232323U, 0x3d3d3d3dU,\n    0xeeeeeeeeU, 0x4c4c4c4cU, 0x95959595U, 0x0b0b0b0bU,\n    0x42424242U, 0xfafafafaU, 0xc3c3c3c3U, 0x4e4e4e4eU,\n    0x08080808U, 0x2e2e2e2eU, 0xa1a1a1a1U, 0x66666666U,\n    0x28282828U, 0xd9d9d9d9U, 0x24242424U, 0xb2b2b2b2U,\n    0x76767676U, 0x5b5b5b5bU, 0xa2a2a2a2U, 0x49494949U,\n    0x6d6d6d6dU, 0x8b8b8b8bU, 0xd1d1d1d1U, 0x25252525U,\n    0x72727272U, 0xf8f8f8f8U, 0xf6f6f6f6U, 0x64646464U,\n    0x86868686U, 0x68686868U, 0x98989898U, 0x16161616U,\n    0xd4d4d4d4U, 0xa4a4a4a4U, 0x5c5c5c5cU, 0xccccccccU,\n    0x5d5d5d5dU, 0x65656565U, 0xb6b6b6b6U, 0x92929292U,\n    0x6c6c6c6cU, 0x70707070U, 0x48484848U, 0x50505050U,\n    0xfdfdfdfdU, 0xededededU, 0xb9b9b9b9U, 0xdadadadaU,\n    0x5e5e5e5eU, 0x15151515U, 0x46464646U, 0x57575757U,\n    0xa7a7a7a7U, 0x8d8d8d8dU, 0x9d9d9d9dU, 0x84848484U,\n    0x90909090U, 0xd8d8d8d8U, 0xababababU, 0x00000000U,\n    0x8c8c8c8cU, 0xbcbcbcbcU, 0xd3d3d3d3U, 0x0a0a0a0aU,\n    0xf7f7f7f7U, 0xe4e4e4e4U, 0x58585858U, 0x05050505U,\n    0xb8b8b8b8U, 0xb3b3b3b3U, 0x45454545U, 0x06060606U,\n    0xd0d0d0d0U, 0x2c2c2c2cU, 0x1e1e1e1eU, 0x8f8f8f8fU,\n    0xcacacacaU, 0x3f3f3f3fU, 0x0f0f0f0fU, 0x02020202U,\n    0xc1c1c1c1U, 0xafafafafU, 0xbdbdbdbdU, 0x03030303U,\n    0x01010101U, 0x13131313U, 0x8a8a8a8aU, 0x6b6b6b6bU,\n    0x3a3a3a3aU, 0x91919191U, 0x11111111U, 0x41414141U,\n    0x4f4f4f4fU, 0x67676767U, 0xdcdcdcdcU, 0xeaeaeaeaU,\n    0x97979797U, 0xf2f2f2f2U, 0xcfcfcfcfU, 0xcecececeU,\n    0xf0f0f0f0U, 0xb4b4b4b4U, 0xe6e6e6e6U, 0x73737373U,\n    0x96969696U, 0xacacacacU, 0x74747474U, 0x22222222U,\n    0xe7e7e7e7U, 0xadadadadU, 0x35353535U, 0x85858585U,\n    0xe2e2e2e2U, 0xf9f9f9f9U, 0x37373737U, 0xe8e8e8e8U,\n    0x1c1c1c1cU, 0x75757575U, 0xdfdfdfdfU, 0x6e6e6e6eU,\n    0x47474747U, 0xf1f1f1f1U, 0x1a1a1a1aU, 0x71717171U,\n    0x1d1d1d1dU, 0x29292929U, 0xc5c5c5c5U, 0x89898989U,\n    0x6f6f6f6fU, 0xb7b7b7b7U, 0x62626262U, 0x0e0e0e0eU,\n    0xaaaaaaaaU, 0x18181818U, 0xbebebebeU, 0x1b1b1b1bU,\n    0xfcfcfcfcU, 0x56565656U, 0x3e3e3e3eU, 0x4b4b4b4bU,\n    0xc6c6c6c6U, 0xd2d2d2d2U, 0x79797979U, 0x20202020U,\n    0x9a9a9a9aU, 0xdbdbdbdbU, 0xc0c0c0c0U, 0xfefefefeU,\n    0x78787878U, 0xcdcdcdcdU, 0x5a5a5a5aU, 0xf4f4f4f4U,\n    0x1f1f1f1fU, 0xddddddddU, 0xa8a8a8a8U, 0x33333333U,\n    0x88888888U, 0x07070707U, 0xc7c7c7c7U, 0x31313131U,\n    0xb1b1b1b1U, 0x12121212U, 0x10101010U, 0x59595959U,\n    0x27272727U, 0x80808080U, 0xececececU, 0x5f5f5f5fU,\n    0x60606060U, 0x51515151U, 0x7f7f7f7fU, 0xa9a9a9a9U,\n    0x19191919U, 0xb5b5b5b5U, 0x4a4a4a4aU, 0x0d0d0d0dU,\n    0x2d2d2d2dU, 0xe5e5e5e5U, 0x7a7a7a7aU, 0x9f9f9f9fU,\n    0x93939393U, 0xc9c9c9c9U, 0x9c9c9c9cU, 0xefefefefU,\n    0xa0a0a0a0U, 0xe0e0e0e0U, 0x3b3b3b3bU, 0x4d4d4d4dU,\n    0xaeaeaeaeU, 0x2a2a2a2aU, 0xf5f5f5f5U, 0xb0b0b0b0U,\n    0xc8c8c8c8U, 0xebebebebU, 0xbbbbbbbbU, 0x3c3c3c3cU,\n    0x83838383U, 0x53535353U, 0x99999999U, 0x61616161U,\n    0x17171717U, 0x2b2b2b2bU, 0x04040404U, 0x7e7e7e7eU,\n    0xbabababaU, 0x77777777U, 0xd6d6d6d6U, 0x26262626U,\n    0xe1e1e1e1U, 0x69696969U, 0x14141414U, 0x63636363U,\n    0x55555555U, 0x21212121U, 0x0c0c0c0cU, 0x7d7d7d7dU,\n};\nstatic const u32 rcon[] = {\n    0x01000000, 0x02000000, 0x04000000, 0x08000000,\n    0x10000000, 0x20000000, 0x40000000, 0x80000000,\n    0x1B000000, 0x36000000, /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */\n};\n\n\nvoid print_state(const unsigned char* state)\n{\n#ifdef _PRINT\n    int i;\n    for(i = 0; i < 16; i++)\n        printf(\"%02x\", state[i]);\n    printf(\"\\n\");\n#endif\n}\n/**\n * Expand the cipher key into the encryption key schedule.\n */\nint AES_set_encrypt_key(const unsigned char *userKey, const int bits,\n            AES_KEY *key) {\n\n    u32 *rk;\n    int i = 0;\n    u32 temp;\n\n    if (!userKey || !key)\n        return -1;\n    if (bits != 128 && bits != 192 && bits != 256)\n        return -2;\n\n    rk = (u32*)key->rd_key;\n\n    if (bits==128)\n        key->rounds = 10;\n    else if (bits==192)\n        key->rounds = 12;\n    else\n        key->rounds = 14;\n\n    rk[0] = GETU32(userKey     );\n    rk[1] = GETU32(userKey +  4);\n    rk[2] = GETU32(userKey +  8);\n    rk[3] = GETU32(userKey + 12);\n    if (bits == 128) {\n        for (;;) {\n            temp  = rk[3];\n            rk[4] = rk[0] ^\n                (Te4[(temp >> 16) & 0xff] & 0xff000000) ^\n                (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^\n                (Te4[(temp      ) & 0xff] & 0x0000ff00) ^\n                (Te4[(temp >> 24)       ] & 0x000000ff) ^\n                rcon[i];\n            rk[5] = rk[1] ^ rk[4];\n            rk[6] = rk[2] ^ rk[5];\n            rk[7] = rk[3] ^ rk[6];\n            if (++i == 10) {\n                return 0;\n            }\n            rk += 4;\n        }\n    }\n    rk[4] = GETU32(userKey + 16);\n    rk[5] = GETU32(userKey + 20);\n    if (bits == 192) {\n        for (;;) {\n            temp = rk[ 5];\n            rk[ 6] = rk[ 0] ^\n                (Te4[(temp >> 16) & 0xff] & 0xff000000) ^\n                (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^\n                (Te4[(temp      ) & 0xff] & 0x0000ff00) ^\n                (Te4[(temp >> 24)       ] & 0x000000ff) ^\n                rcon[i];\n            rk[ 7] = rk[ 1] ^ rk[ 6];\n            rk[ 8] = rk[ 2] ^ rk[ 7];\n            rk[ 9] = rk[ 3] ^ rk[ 8];\n            if (++i == 8) {\n                return 0;\n            }\n            rk[10] = rk[ 4] ^ rk[ 9];\n            rk[11] = rk[ 5] ^ rk[10];\n            rk += 6;\n        }\n    }\n    rk[6] = GETU32(userKey + 24);\n    rk[7] = GETU32(userKey + 28);\n    if (bits == 256) {\n        for (;;) {\n            temp = rk[ 7];\n            rk[ 8] = rk[ 0] ^\n                (Te4[(temp >> 16) & 0xff] & 0xff000000) ^\n                (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^\n                (Te4[(temp      ) & 0xff] & 0x0000ff00) ^\n                (Te4[(temp >> 24)       ] & 0x000000ff) ^\n                rcon[i];\n            rk[ 9] = rk[ 1] ^ rk[ 8];\n            rk[10] = rk[ 2] ^ rk[ 9];\n            rk[11] = rk[ 3] ^ rk[10];\n            if (++i == 7) {\n                return 0;\n            }\n            temp = rk[11];\n            rk[12] = rk[ 4] ^\n                (Te4[(temp >> 24)       ] & 0xff000000) ^\n                (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^\n                (Te4[(temp >>  8) & 0xff] & 0x0000ff00) ^\n                (Te4[(temp      ) & 0xff] & 0x000000ff);\n            rk[13] = rk[ 5] ^ rk[12];\n            rk[14] = rk[ 6] ^ rk[13];\n            rk[15] = rk[ 7] ^ rk[14];\n\n            rk += 8;\n            }\n    }\n    return 0;\n}\n\n/**\n * Expand the cipher key into the decryption key schedule.\n */\nint AES_set_decrypt_key(const unsigned char *userKey, const int bits,\n             AES_KEY *key) {\n\n        u32 *rk;\n    int i, j, status;\n    u32 temp;\n\n    /* first, start with an encryption schedule */\n    status = AES_set_encrypt_key(userKey, bits, key);\n    if (status < 0)\n        return status;\n\n    rk = (u32*) key->rd_key;\n\n    /* invert the order of the round keys: */\n    for (i = 0, j = 4*(key->rounds); i < j; i += 4, j -= 4) {\n        temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;\n        temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\n        temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\n        temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\n    }\n    /* apply the inverse MixColumn transform to all round keys but the first and the last: */\n    for (i = 1; i < (key->rounds); i++) {\n        rk += 4;\n        rk[0] =\n            Td0[Te4[(rk[0] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[0] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[0]      ) & 0xff] & 0xff];\n        rk[1] =\n            Td0[Te4[(rk[1] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[1] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[1]      ) & 0xff] & 0xff];\n        rk[2] =\n            Td0[Te4[(rk[2] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[2] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[2]      ) & 0xff] & 0xff];\n        rk[3] =\n            Td0[Te4[(rk[3] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[3] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[3]      ) & 0xff] & 0xff];\n    }\n    return 0;\n}\n\n/*\n * Encrypt a single block\n * in and out can overlap\n */\nvoid AES_encrypt(const unsigned char *in, unsigned char *out,\n         const AES_KEY *key) {\n#ifdef _PRINT\n    printf(\"AES  input: \");\n    print_state(in);\n#endif\n\n    const u32 *rk;\n    u32 s0, s1, s2, s3, t0, t1, t2, t3;\n#ifndef FULL_UNROLL\n    int r;\n#endif /* ?FULL_UNROLL */\n\n    if(!(in && out && key)){\n        return;\n    }\n    rk = (u32*) key->rd_key;\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n    s0 = GETU32(in     ) ^ rk[0];\n    s1 = GETU32(in +  4) ^ rk[1];\n    s2 = GETU32(in +  8) ^ rk[2];\n    s3 = GETU32(in + 12) ^ rk[3];\n#ifdef FULL_UNROLL\n    /* round 1: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 4];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 5];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 6];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 7];\n    /* round 2: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 8];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 9];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];\n    /* round 3: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[12];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[13];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[14];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[15];\n    /* round 4: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[16];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[17];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[18];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[19];\n    /* round 5: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[20];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[21];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[22];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[23];\n    /* round 6: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[24];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[25];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[26];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[27];\n    /* round 7: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[28];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[29];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[30];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[31];\n    /* round 8: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[32];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[33];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[34];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[35];\n    /* round 9: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[36];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[37];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[38];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[39];\n    if (key->rounds > 10) {\n        /* round 10: */\n        s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[40];\n        s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[41];\n        s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[42];\n        s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[43];\n        /* round 11: */\n        t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[44];\n        t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[45];\n        t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[46];\n        t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[47];\n        if (key->rounds > 12) {\n            /* round 12: */\n            s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[48];\n            s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[49];\n            s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[50];\n            s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[51];\n            /* round 13: */\n            t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[52];\n            t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[53];\n            t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[54];\n            t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[55];\n        }\n    }\n    rk += key->rounds << 2;\n#else  /* !FULL_UNROLL */\n    /*\n     * Nr - 1 full rounds:\n     */\n    r = key->rounds >> 1;\n    for (;;) {\n        t0 =\n            Te0[(s0 >> 24)       ] ^\n            Te1[(s1 >> 16) & 0xff] ^\n            Te2[(s2 >>  8) & 0xff] ^\n            Te3[(s3      ) & 0xff] ^\n            rk[4];\n        t1 =\n            Te0[(s1 >> 24)       ] ^\n            Te1[(s2 >> 16) & 0xff] ^\n            Te2[(s3 >>  8) & 0xff] ^\n            Te3[(s0      ) & 0xff] ^\n            rk[5];\n        t2 =\n            Te0[(s2 >> 24)       ] ^\n            Te1[(s3 >> 16) & 0xff] ^\n            Te2[(s0 >>  8) & 0xff] ^\n            Te3[(s1      ) & 0xff] ^\n            rk[6];\n        t3 =\n            Te0[(s3 >> 24)       ] ^\n            Te1[(s0 >> 16) & 0xff] ^\n            Te2[(s1 >>  8) & 0xff] ^\n            Te3[(s2      ) & 0xff] ^\n            rk[7];\n\n        rk += 8;\n        if (--r == 0) {\n            break;\n        }\n\n        s0 =\n            Te0[(t0 >> 24)       ] ^\n            Te1[(t1 >> 16) & 0xff] ^\n            Te2[(t2 >>  8) & 0xff] ^\n            Te3[(t3      ) & 0xff] ^\n            rk[0];\n        s1 =\n            Te0[(t1 >> 24)       ] ^\n            Te1[(t2 >> 16) & 0xff] ^\n            Te2[(t3 >>  8) & 0xff] ^\n            Te3[(t0      ) & 0xff] ^\n            rk[1];\n        s2 =\n            Te0[(t2 >> 24)       ] ^\n            Te1[(t3 >> 16) & 0xff] ^\n            Te2[(t0 >>  8) & 0xff] ^\n            Te3[(t1      ) & 0xff] ^\n            rk[2];\n        s3 =\n            Te0[(t3 >> 24)       ] ^\n            Te1[(t0 >> 16) & 0xff] ^\n            Te2[(t1 >>  8) & 0xff] ^\n            Te3[(t2      ) & 0xff] ^\n            rk[3];\n    }\n#endif /* ?FULL_UNROLL */\n    /*\n     * apply last round and\n     * map cipher state to byte array block:\n     */\n    s0 =\n        (Te4[(t0 >> 24)       ] & 0xff000000) ^\n        (Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t2 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t3      ) & 0xff] & 0x000000ff) ^\n        rk[0];\n    PUTU32(out     , s0);\n    s1 =\n        (Te4[(t1 >> 24)       ] & 0xff000000) ^\n        (Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t3 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t0      ) & 0xff] & 0x000000ff) ^\n        rk[1];\n    PUTU32(out +  4, s1);\n    s2 =\n        (Te4[(t2 >> 24)       ] & 0xff000000) ^\n        (Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t0 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t1      ) & 0xff] & 0x000000ff) ^\n        rk[2];\n    PUTU32(out +  8, s2);\n    s3 =\n        (Te4[(t3 >> 24)       ] & 0xff000000) ^\n        (Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t1 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t2      ) & 0xff] & 0x000000ff) ^\n        rk[3];\n    PUTU32(out + 12, s3);\n\n#ifdef _PRINT\n    printf(\"AES output: \");\n    print_state(out);\n#endif\n}\n\n/*\n * Decrypt a single block\n * in and out can overlap\n */\nvoid AES_decrypt(const unsigned char *in, unsigned char *out,\n         const AES_KEY *key) {\n\n    const u32 *rk;\n    u32 s0, s1, s2, s3, t0, t1, t2, t3;\n#ifndef FULL_UNROLL\n    int r;\n#endif /* ?FULL_UNROLL */\n\n    if(!(in && out && key)) return;\n    rk = (u32*) key->rd_key;\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n    s0 = GETU32(in     ) ^ rk[0];\n    s1 = GETU32(in +  4) ^ rk[1];\n    s2 = GETU32(in +  8) ^ rk[2];\n    s3 = GETU32(in + 12) ^ rk[3];\n#ifdef FULL_UNROLL\n    /* round 1: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[ 4];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[ 5];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[ 6];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[ 7];\n    /* round 2: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[ 8];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[ 9];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[10];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[11];\n    /* round 3: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[12];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[13];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[14];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[15];\n    /* round 4: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[16];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[17];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[18];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[19];\n    /* round 5: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[20];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[21];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[22];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[23];\n    /* round 6: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[24];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[25];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[26];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[27];\n    /* round 7: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[28];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[29];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[30];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[31];\n    /* round 8: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[32];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[33];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[34];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[35];\n    /* round 9: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[36];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[37];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[38];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[39];\n    if (key->rounds > 10) {\n        /* round 10: */\n        s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[40];\n        s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[41];\n        s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[42];\n        s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[43];\n        /* round 11: */\n        t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[44];\n        t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[45];\n        t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[46];\n        t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[47];\n        if (key->rounds > 12) {\n            /* round 12: */\n            s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[48];\n            s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[49];\n            s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[50];\n            s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[51];\n            /* round 13: */\n            t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[52];\n            t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[53];\n            t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[54];\n            t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[55];\n        }\n    }\n    rk += key->rounds << 2;\n#else  /* !FULL_UNROLL */\n    /*\n     * Nr - 1 full rounds:\n     */\n    r = key->rounds >> 1;\n    for (;;) {\n        t0 =\n            Td0[(s0 >> 24)       ] ^\n            Td1[(s3 >> 16) & 0xff] ^\n            Td2[(s2 >>  8) & 0xff] ^\n            Td3[(s1      ) & 0xff] ^\n            rk[4];\n        t1 =\n            Td0[(s1 >> 24)       ] ^\n            Td1[(s0 >> 16) & 0xff] ^\n            Td2[(s3 >>  8) & 0xff] ^\n            Td3[(s2      ) & 0xff] ^\n            rk[5];\n        t2 =\n            Td0[(s2 >> 24)       ] ^\n            Td1[(s1 >> 16) & 0xff] ^\n            Td2[(s0 >>  8) & 0xff] ^\n            Td3[(s3      ) & 0xff] ^\n            rk[6];\n        t3 =\n            Td0[(s3 >> 24)       ] ^\n            Td1[(s2 >> 16) & 0xff] ^\n            Td2[(s1 >>  8) & 0xff] ^\n            Td3[(s0      ) & 0xff] ^\n            rk[7];\n\n        rk += 8;\n        if (--r == 0) {\n            break;\n        }\n\n        s0 =\n            Td0[(t0 >> 24)       ] ^\n            Td1[(t3 >> 16) & 0xff] ^\n            Td2[(t2 >>  8) & 0xff] ^\n            Td3[(t1      ) & 0xff] ^\n            rk[0];\n        s1 =\n            Td0[(t1 >> 24)       ] ^\n            Td1[(t0 >> 16) & 0xff] ^\n            Td2[(t3 >>  8) & 0xff] ^\n            Td3[(t2      ) & 0xff] ^\n            rk[1];\n        s2 =\n            Td0[(t2 >> 24)       ] ^\n            Td1[(t1 >> 16) & 0xff] ^\n            Td2[(t0 >>  8) & 0xff] ^\n            Td3[(t3      ) & 0xff] ^\n            rk[2];\n        s3 =\n            Td0[(t3 >> 24)       ] ^\n            Td1[(t2 >> 16) & 0xff] ^\n            Td2[(t1 >>  8) & 0xff] ^\n            Td3[(t0      ) & 0xff] ^\n            rk[3];\n    }\n#endif /* ?FULL_UNROLL */\n    /*\n     * apply last round and\n     * map cipher state to byte array block:\n     */\n    s0 =\n        (Td4[(t0 >> 24)       ] & 0xff000000) ^\n        (Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t2 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t1      ) & 0xff] & 0x000000ff) ^\n        rk[0];\n    PUTU32(out     , s0);\n    s1 =\n        (Td4[(t1 >> 24)       ] & 0xff000000) ^\n        (Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t3 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t2      ) & 0xff] & 0x000000ff) ^\n        rk[1];\n    PUTU32(out +  4, s1);\n    s2 =\n        (Td4[(t2 >> 24)       ] & 0xff000000) ^\n        (Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t0 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t3      ) & 0xff] & 0x000000ff) ^\n        rk[2];\n    PUTU32(out +  8, s2);\n    s3 =\n        (Td4[(t3 >> 24)       ] & 0xff000000) ^\n        (Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t1 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t0      ) & 0xff] & 0x000000ff) ^\n        rk[3];\n    PUTU32(out + 12, s3);\n}\n\n\n} // namespace Aes128n12silcv1_raw\n"
        },
        {
            "file_name": "aes128n12silcv1_encrypt.cpp",
            "content": "#include \"aes128n12silcv1_encrypt.h\"\n#include <string.h>\n#include <stdlib.h>\n#include \"aes128n12silcv1_api.h\"\n#include \"aes128n12silcv1_silc.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Aes128n12silcv1_raw {\nint numRounds = -1;\n\nint crypto_aead_encrypt(\n        unsigned char *c, unsigned long long *clen,\n        const unsigned char *m, unsigned long long mlen,\n        const unsigned char *ad, unsigned long long adlen,\n        const unsigned char *nsec,                          //not relavent to CLOC\n        const unsigned char *npub,\n        const unsigned char *k\n        )\n{\n    /* set ciphertext length */\n    *clen = mlen + CRYPTO_ABYTES;\n\n    unsigned char tag[CRYPTO_ABYTES];\n    ae_cxt* cxt = ae_allocate();\n    if(!cxt)\n        return RETURN_MEMORY_FAIL;\n\n    /* set key and compute round keys */\n    if(ae_init(cxt, k, CRYPTO_KEYBYTES)) {\n        // CHANGE memory free added\n        free(cxt);\n        return RETURN_KEYSIZE_ERR;\n    }\n\n    /* process the associated data */\n    process_ad(cxt, ad, adlen, npub, CRYPTO_NPUBBYTES);\n\n    /* encrypt message */\n    ae_encrypt(cxt, (unsigned char*)m, mlen, c, tag, CRYPTO_ABYTES, ENC);\n\n    /* copy the tag to the end of ciphertext */\n    memcpy(c+mlen, tag, CRYPTO_ABYTES);\n\n    // CHANGE memory free added\n    free(cxt);\n    return RETURN_SUCCESS;\n}\n\nint crypto_aead_decrypt(\n        unsigned char *m,unsigned long long *mlen,\n        unsigned char *nsec,                                //not relavent to CLOC\n        const unsigned char *c,unsigned long long clen,\n        const unsigned char *ad,unsigned long long adlen,\n        const unsigned char *npub,\n        const unsigned char *k\n        )\n{\n    /* set plaintext length */\n    *mlen = clen - CRYPTO_ABYTES;\n\n    unsigned char tag[CRYPTO_ABYTES];\n    ae_cxt* cxt = ae_allocate();\n    if(!cxt)\n        return RETURN_MEMORY_FAIL;\n\n    /* set key and compute round keys */\n    if(ae_init(cxt, k, CRYPTO_KEYBYTES)) {\n        // CHANGE memory free added\n        free(cxt);\n        return RETURN_KEYSIZE_ERR;\n    }\n\n    /* process the associated data */\n    process_ad(cxt, ad, adlen, npub, CRYPTO_NPUBBYTES);\n\n    /* decrypt ciphertext */\n    ae_encrypt(cxt, m, *mlen, (unsigned char*)c, tag, CRYPTO_ABYTES, DEC);\n\n    /* compare the tag */\n    int i;\n    for(i = 0; i < CRYPTO_ABYTES; i++)\n        if(tag[i] != c[(*mlen) + i]){\n            // CHANGE memory free added\n            free(cxt);\n            return RETURN_TAG_NO_MATCH;\n        }\n\n    // CHANGE memory free added\n    free(cxt);\n    return RETURN_SUCCESS;\n}\n\n\n} // namespace Aes128n12silcv1_raw\n"
        },
        {
            "file_name": "aes128poetv1aes128_aes.cpp",
            "content": "/* crypto/aes/aes_core.c -*- mode:C; c-file-style: \"eay\" -*- */\n/**\n * rijndael-alg-fst.c\n *\n * @version 3.0 (December 2000)\n *\n * Optimised ANSI C code for the Rijndael cipher (now AES)\n *\n * @author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be>\n * @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be>\n * @author Paulo Barreto <paulo.barreto@terra.com.br>\n *\n * This code is hereby placed in the public domain.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* Note: rewritten a little bit to provide error control and an OpenSSL-\n   compatible API */\n\n#ifndef AES_DEBUG\n# ifndef NDEBUG\n#  define NDEBUG\n# endif\n#endif\n#include <assert.h>\n\n#include <stdlib.h>\n//#include <openssl/aes.h>\n#include \"aes128poetv1aes128_aes.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Aes128poetv1aes128_raw {\n\ninline void dump_hex2 (char *label, u32 *c, int len)\n{\n  int i;\n\n  printf(\"%s: \\n\", label);\n\n\n  for (i = 0; i < len; i++) {\n    printf(\"%08x \", c[i]);\n  }\n\n  puts(\"\\n\");\n}\n\n#ifndef AES_ASM\n/*\n   Te0[x] = S [x].[02, 01, 01, 03];\n   Te1[x] = S [x].[03, 02, 01, 01];\n   Te2[x] = S [x].[01, 03, 02, 01];\n   Te3[x] = S [x].[01, 01, 03, 02];\n\n   Td0[x] = Si[x].[0e, 09, 0d, 0b];\n   Td1[x] = Si[x].[0b, 0e, 09, 0d];\n   Td2[x] = Si[x].[0d, 0b, 0e, 09];\n   Td3[x] = Si[x].[09, 0d, 0b, 0e];\n   Td4[x] = Si[x].[01];\n */\n\nstatic const u32 Te0[256] = {\n    0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,\n    0xfff2f20dU, 0xd66b6bbdU, 0xde6f6fb1U, 0x91c5c554U,\n    0x60303050U, 0x02010103U, 0xce6767a9U, 0x562b2b7dU,\n    0xe7fefe19U, 0xb5d7d762U, 0x4dababe6U, 0xec76769aU,\n    0x8fcaca45U, 0x1f82829dU, 0x89c9c940U, 0xfa7d7d87U,\n    0xeffafa15U, 0xb25959ebU, 0x8e4747c9U, 0xfbf0f00bU,\n    0x41adadecU, 0xb3d4d467U, 0x5fa2a2fdU, 0x45afafeaU,\n    0x239c9cbfU, 0x53a4a4f7U, 0xe4727296U, 0x9bc0c05bU,\n    0x75b7b7c2U, 0xe1fdfd1cU, 0x3d9393aeU, 0x4c26266aU,\n    0x6c36365aU, 0x7e3f3f41U, 0xf5f7f702U, 0x83cccc4fU,\n    0x6834345cU, 0x51a5a5f4U, 0xd1e5e534U, 0xf9f1f108U,\n    0xe2717193U, 0xabd8d873U, 0x62313153U, 0x2a15153fU,\n    0x0804040cU, 0x95c7c752U, 0x46232365U, 0x9dc3c35eU,\n    0x30181828U, 0x379696a1U, 0x0a05050fU, 0x2f9a9ab5U,\n    0x0e070709U, 0x24121236U, 0x1b80809bU, 0xdfe2e23dU,\n    0xcdebeb26U, 0x4e272769U, 0x7fb2b2cdU, 0xea75759fU,\n    0x1209091bU, 0x1d83839eU, 0x582c2c74U, 0x341a1a2eU,\n    0x361b1b2dU, 0xdc6e6eb2U, 0xb45a5aeeU, 0x5ba0a0fbU,\n    0xa45252f6U, 0x763b3b4dU, 0xb7d6d661U, 0x7db3b3ceU,\n    0x5229297bU, 0xdde3e33eU, 0x5e2f2f71U, 0x13848497U,\n    0xa65353f5U, 0xb9d1d168U, 0x00000000U, 0xc1eded2cU,\n    0x40202060U, 0xe3fcfc1fU, 0x79b1b1c8U, 0xb65b5bedU,\n    0xd46a6abeU, 0x8dcbcb46U, 0x67bebed9U, 0x7239394bU,\n    0x944a4adeU, 0x984c4cd4U, 0xb05858e8U, 0x85cfcf4aU,\n    0xbbd0d06bU, 0xc5efef2aU, 0x4faaaae5U, 0xedfbfb16U,\n    0x864343c5U, 0x9a4d4dd7U, 0x66333355U, 0x11858594U,\n    0x8a4545cfU, 0xe9f9f910U, 0x04020206U, 0xfe7f7f81U,\n    0xa05050f0U, 0x783c3c44U, 0x259f9fbaU, 0x4ba8a8e3U,\n    0xa25151f3U, 0x5da3a3feU, 0x804040c0U, 0x058f8f8aU,\n    0x3f9292adU, 0x219d9dbcU, 0x70383848U, 0xf1f5f504U,\n    0x63bcbcdfU, 0x77b6b6c1U, 0xafdada75U, 0x42212163U,\n    0x20101030U, 0xe5ffff1aU, 0xfdf3f30eU, 0xbfd2d26dU,\n    0x81cdcd4cU, 0x180c0c14U, 0x26131335U, 0xc3ecec2fU,\n    0xbe5f5fe1U, 0x359797a2U, 0x884444ccU, 0x2e171739U,\n    0x93c4c457U, 0x55a7a7f2U, 0xfc7e7e82U, 0x7a3d3d47U,\n    0xc86464acU, 0xba5d5de7U, 0x3219192bU, 0xe6737395U,\n    0xc06060a0U, 0x19818198U, 0x9e4f4fd1U, 0xa3dcdc7fU,\n    0x44222266U, 0x542a2a7eU, 0x3b9090abU, 0x0b888883U,\n    0x8c4646caU, 0xc7eeee29U, 0x6bb8b8d3U, 0x2814143cU,\n    0xa7dede79U, 0xbc5e5ee2U, 0x160b0b1dU, 0xaddbdb76U,\n    0xdbe0e03bU, 0x64323256U, 0x743a3a4eU, 0x140a0a1eU,\n    0x924949dbU, 0x0c06060aU, 0x4824246cU, 0xb85c5ce4U,\n    0x9fc2c25dU, 0xbdd3d36eU, 0x43acacefU, 0xc46262a6U,\n    0x399191a8U, 0x319595a4U, 0xd3e4e437U, 0xf279798bU,\n    0xd5e7e732U, 0x8bc8c843U, 0x6e373759U, 0xda6d6db7U,\n    0x018d8d8cU, 0xb1d5d564U, 0x9c4e4ed2U, 0x49a9a9e0U,\n    0xd86c6cb4U, 0xac5656faU, 0xf3f4f407U, 0xcfeaea25U,\n    0xca6565afU, 0xf47a7a8eU, 0x47aeaee9U, 0x10080818U,\n    0x6fbabad5U, 0xf0787888U, 0x4a25256fU, 0x5c2e2e72U,\n    0x381c1c24U, 0x57a6a6f1U, 0x73b4b4c7U, 0x97c6c651U,\n    0xcbe8e823U, 0xa1dddd7cU, 0xe874749cU, 0x3e1f1f21U,\n    0x964b4bddU, 0x61bdbddcU, 0x0d8b8b86U, 0x0f8a8a85U,\n    0xe0707090U, 0x7c3e3e42U, 0x71b5b5c4U, 0xcc6666aaU,\n    0x904848d8U, 0x06030305U, 0xf7f6f601U, 0x1c0e0e12U,\n    0xc26161a3U, 0x6a35355fU, 0xae5757f9U, 0x69b9b9d0U,\n    0x17868691U, 0x99c1c158U, 0x3a1d1d27U, 0x279e9eb9U,\n    0xd9e1e138U, 0xebf8f813U, 0x2b9898b3U, 0x22111133U,\n    0xd26969bbU, 0xa9d9d970U, 0x078e8e89U, 0x339494a7U,\n    0x2d9b9bb6U, 0x3c1e1e22U, 0x15878792U, 0xc9e9e920U,\n    0x87cece49U, 0xaa5555ffU, 0x50282878U, 0xa5dfdf7aU,\n    0x038c8c8fU, 0x59a1a1f8U, 0x09898980U, 0x1a0d0d17U,\n    0x65bfbfdaU, 0xd7e6e631U, 0x844242c6U, 0xd06868b8U,\n    0x824141c3U, 0x299999b0U, 0x5a2d2d77U, 0x1e0f0f11U,\n    0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,\n};\nstatic const u32 Te1[256] = {\n    0xa5c66363U, 0x84f87c7cU, 0x99ee7777U, 0x8df67b7bU,\n    0x0dfff2f2U, 0xbdd66b6bU, 0xb1de6f6fU, 0x5491c5c5U,\n    0x50603030U, 0x03020101U, 0xa9ce6767U, 0x7d562b2bU,\n    0x19e7fefeU, 0x62b5d7d7U, 0xe64dababU, 0x9aec7676U,\n    0x458fcacaU, 0x9d1f8282U, 0x4089c9c9U, 0x87fa7d7dU,\n    0x15effafaU, 0xebb25959U, 0xc98e4747U, 0x0bfbf0f0U,\n    0xec41adadU, 0x67b3d4d4U, 0xfd5fa2a2U, 0xea45afafU,\n    0xbf239c9cU, 0xf753a4a4U, 0x96e47272U, 0x5b9bc0c0U,\n    0xc275b7b7U, 0x1ce1fdfdU, 0xae3d9393U, 0x6a4c2626U,\n    0x5a6c3636U, 0x417e3f3fU, 0x02f5f7f7U, 0x4f83ccccU,\n    0x5c683434U, 0xf451a5a5U, 0x34d1e5e5U, 0x08f9f1f1U,\n    0x93e27171U, 0x73abd8d8U, 0x53623131U, 0x3f2a1515U,\n    0x0c080404U, 0x5295c7c7U, 0x65462323U, 0x5e9dc3c3U,\n    0x28301818U, 0xa1379696U, 0x0f0a0505U, 0xb52f9a9aU,\n    0x090e0707U, 0x36241212U, 0x9b1b8080U, 0x3ddfe2e2U,\n    0x26cdebebU, 0x694e2727U, 0xcd7fb2b2U, 0x9fea7575U,\n    0x1b120909U, 0x9e1d8383U, 0x74582c2cU, 0x2e341a1aU,\n    0x2d361b1bU, 0xb2dc6e6eU, 0xeeb45a5aU, 0xfb5ba0a0U,\n    0xf6a45252U, 0x4d763b3bU, 0x61b7d6d6U, 0xce7db3b3U,\n    0x7b522929U, 0x3edde3e3U, 0x715e2f2fU, 0x97138484U,\n    0xf5a65353U, 0x68b9d1d1U, 0x00000000U, 0x2cc1ededU,\n    0x60402020U, 0x1fe3fcfcU, 0xc879b1b1U, 0xedb65b5bU,\n    0xbed46a6aU, 0x468dcbcbU, 0xd967bebeU, 0x4b723939U,\n    0xde944a4aU, 0xd4984c4cU, 0xe8b05858U, 0x4a85cfcfU,\n    0x6bbbd0d0U, 0x2ac5efefU, 0xe54faaaaU, 0x16edfbfbU,\n    0xc5864343U, 0xd79a4d4dU, 0x55663333U, 0x94118585U,\n    0xcf8a4545U, 0x10e9f9f9U, 0x06040202U, 0x81fe7f7fU,\n    0xf0a05050U, 0x44783c3cU, 0xba259f9fU, 0xe34ba8a8U,\n    0xf3a25151U, 0xfe5da3a3U, 0xc0804040U, 0x8a058f8fU,\n    0xad3f9292U, 0xbc219d9dU, 0x48703838U, 0x04f1f5f5U,\n    0xdf63bcbcU, 0xc177b6b6U, 0x75afdadaU, 0x63422121U,\n    0x30201010U, 0x1ae5ffffU, 0x0efdf3f3U, 0x6dbfd2d2U,\n    0x4c81cdcdU, 0x14180c0cU, 0x35261313U, 0x2fc3ececU,\n    0xe1be5f5fU, 0xa2359797U, 0xcc884444U, 0x392e1717U,\n    0x5793c4c4U, 0xf255a7a7U, 0x82fc7e7eU, 0x477a3d3dU,\n    0xacc86464U, 0xe7ba5d5dU, 0x2b321919U, 0x95e67373U,\n    0xa0c06060U, 0x98198181U, 0xd19e4f4fU, 0x7fa3dcdcU,\n    0x66442222U, 0x7e542a2aU, 0xab3b9090U, 0x830b8888U,\n    0xca8c4646U, 0x29c7eeeeU, 0xd36bb8b8U, 0x3c281414U,\n    0x79a7dedeU, 0xe2bc5e5eU, 0x1d160b0bU, 0x76addbdbU,\n    0x3bdbe0e0U, 0x56643232U, 0x4e743a3aU, 0x1e140a0aU,\n    0xdb924949U, 0x0a0c0606U, 0x6c482424U, 0xe4b85c5cU,\n    0x5d9fc2c2U, 0x6ebdd3d3U, 0xef43acacU, 0xa6c46262U,\n    0xa8399191U, 0xa4319595U, 0x37d3e4e4U, 0x8bf27979U,\n    0x32d5e7e7U, 0x438bc8c8U, 0x596e3737U, 0xb7da6d6dU,\n    0x8c018d8dU, 0x64b1d5d5U, 0xd29c4e4eU, 0xe049a9a9U,\n    0xb4d86c6cU, 0xfaac5656U, 0x07f3f4f4U, 0x25cfeaeaU,\n    0xafca6565U, 0x8ef47a7aU, 0xe947aeaeU, 0x18100808U,\n    0xd56fbabaU, 0x88f07878U, 0x6f4a2525U, 0x725c2e2eU,\n    0x24381c1cU, 0xf157a6a6U, 0xc773b4b4U, 0x5197c6c6U,\n    0x23cbe8e8U, 0x7ca1ddddU, 0x9ce87474U, 0x213e1f1fU,\n    0xdd964b4bU, 0xdc61bdbdU, 0x860d8b8bU, 0x850f8a8aU,\n    0x90e07070U, 0x427c3e3eU, 0xc471b5b5U, 0xaacc6666U,\n    0xd8904848U, 0x05060303U, 0x01f7f6f6U, 0x121c0e0eU,\n    0xa3c26161U, 0x5f6a3535U, 0xf9ae5757U, 0xd069b9b9U,\n    0x91178686U, 0x5899c1c1U, 0x273a1d1dU, 0xb9279e9eU,\n    0x38d9e1e1U, 0x13ebf8f8U, 0xb32b9898U, 0x33221111U,\n    0xbbd26969U, 0x70a9d9d9U, 0x89078e8eU, 0xa7339494U,\n    0xb62d9b9bU, 0x223c1e1eU, 0x92158787U, 0x20c9e9e9U,\n    0x4987ceceU, 0xffaa5555U, 0x78502828U, 0x7aa5dfdfU,\n    0x8f038c8cU, 0xf859a1a1U, 0x80098989U, 0x171a0d0dU,\n    0xda65bfbfU, 0x31d7e6e6U, 0xc6844242U, 0xb8d06868U,\n    0xc3824141U, 0xb0299999U, 0x775a2d2dU, 0x111e0f0fU,\n    0xcb7bb0b0U, 0xfca85454U, 0xd66dbbbbU, 0x3a2c1616U,\n};\nstatic const u32 Te2[256] = {\n    0x63a5c663U, 0x7c84f87cU, 0x7799ee77U, 0x7b8df67bU,\n    0xf20dfff2U, 0x6bbdd66bU, 0x6fb1de6fU, 0xc55491c5U,\n    0x30506030U, 0x01030201U, 0x67a9ce67U, 0x2b7d562bU,\n    0xfe19e7feU, 0xd762b5d7U, 0xabe64dabU, 0x769aec76U,\n    0xca458fcaU, 0x829d1f82U, 0xc94089c9U, 0x7d87fa7dU,\n    0xfa15effaU, 0x59ebb259U, 0x47c98e47U, 0xf00bfbf0U,\n    0xadec41adU, 0xd467b3d4U, 0xa2fd5fa2U, 0xafea45afU,\n    0x9cbf239cU, 0xa4f753a4U, 0x7296e472U, 0xc05b9bc0U,\n    0xb7c275b7U, 0xfd1ce1fdU, 0x93ae3d93U, 0x266a4c26U,\n    0x365a6c36U, 0x3f417e3fU, 0xf702f5f7U, 0xcc4f83ccU,\n    0x345c6834U, 0xa5f451a5U, 0xe534d1e5U, 0xf108f9f1U,\n    0x7193e271U, 0xd873abd8U, 0x31536231U, 0x153f2a15U,\n    0x040c0804U, 0xc75295c7U, 0x23654623U, 0xc35e9dc3U,\n    0x18283018U, 0x96a13796U, 0x050f0a05U, 0x9ab52f9aU,\n    0x07090e07U, 0x12362412U, 0x809b1b80U, 0xe23ddfe2U,\n    0xeb26cdebU, 0x27694e27U, 0xb2cd7fb2U, 0x759fea75U,\n    0x091b1209U, 0x839e1d83U, 0x2c74582cU, 0x1a2e341aU,\n    0x1b2d361bU, 0x6eb2dc6eU, 0x5aeeb45aU, 0xa0fb5ba0U,\n    0x52f6a452U, 0x3b4d763bU, 0xd661b7d6U, 0xb3ce7db3U,\n    0x297b5229U, 0xe33edde3U, 0x2f715e2fU, 0x84971384U,\n    0x53f5a653U, 0xd168b9d1U, 0x00000000U, 0xed2cc1edU,\n    0x20604020U, 0xfc1fe3fcU, 0xb1c879b1U, 0x5bedb65bU,\n    0x6abed46aU, 0xcb468dcbU, 0xbed967beU, 0x394b7239U,\n    0x4ade944aU, 0x4cd4984cU, 0x58e8b058U, 0xcf4a85cfU,\n    0xd06bbbd0U, 0xef2ac5efU, 0xaae54faaU, 0xfb16edfbU,\n    0x43c58643U, 0x4dd79a4dU, 0x33556633U, 0x85941185U,\n    0x45cf8a45U, 0xf910e9f9U, 0x02060402U, 0x7f81fe7fU,\n    0x50f0a050U, 0x3c44783cU, 0x9fba259fU, 0xa8e34ba8U,\n    0x51f3a251U, 0xa3fe5da3U, 0x40c08040U, 0x8f8a058fU,\n    0x92ad3f92U, 0x9dbc219dU, 0x38487038U, 0xf504f1f5U,\n    0xbcdf63bcU, 0xb6c177b6U, 0xda75afdaU, 0x21634221U,\n    0x10302010U, 0xff1ae5ffU, 0xf30efdf3U, 0xd26dbfd2U,\n    0xcd4c81cdU, 0x0c14180cU, 0x13352613U, 0xec2fc3ecU,\n    0x5fe1be5fU, 0x97a23597U, 0x44cc8844U, 0x17392e17U,\n    0xc45793c4U, 0xa7f255a7U, 0x7e82fc7eU, 0x3d477a3dU,\n    0x64acc864U, 0x5de7ba5dU, 0x192b3219U, 0x7395e673U,\n    0x60a0c060U, 0x81981981U, 0x4fd19e4fU, 0xdc7fa3dcU,\n    0x22664422U, 0x2a7e542aU, 0x90ab3b90U, 0x88830b88U,\n    0x46ca8c46U, 0xee29c7eeU, 0xb8d36bb8U, 0x143c2814U,\n    0xde79a7deU, 0x5ee2bc5eU, 0x0b1d160bU, 0xdb76addbU,\n    0xe03bdbe0U, 0x32566432U, 0x3a4e743aU, 0x0a1e140aU,\n    0x49db9249U, 0x060a0c06U, 0x246c4824U, 0x5ce4b85cU,\n    0xc25d9fc2U, 0xd36ebdd3U, 0xacef43acU, 0x62a6c462U,\n    0x91a83991U, 0x95a43195U, 0xe437d3e4U, 0x798bf279U,\n    0xe732d5e7U, 0xc8438bc8U, 0x37596e37U, 0x6db7da6dU,\n    0x8d8c018dU, 0xd564b1d5U, 0x4ed29c4eU, 0xa9e049a9U,\n    0x6cb4d86cU, 0x56faac56U, 0xf407f3f4U, 0xea25cfeaU,\n    0x65afca65U, 0x7a8ef47aU, 0xaee947aeU, 0x08181008U,\n    0xbad56fbaU, 0x7888f078U, 0x256f4a25U, 0x2e725c2eU,\n    0x1c24381cU, 0xa6f157a6U, 0xb4c773b4U, 0xc65197c6U,\n    0xe823cbe8U, 0xdd7ca1ddU, 0x749ce874U, 0x1f213e1fU,\n    0x4bdd964bU, 0xbddc61bdU, 0x8b860d8bU, 0x8a850f8aU,\n    0x7090e070U, 0x3e427c3eU, 0xb5c471b5U, 0x66aacc66U,\n    0x48d89048U, 0x03050603U, 0xf601f7f6U, 0x0e121c0eU,\n    0x61a3c261U, 0x355f6a35U, 0x57f9ae57U, 0xb9d069b9U,\n    0x86911786U, 0xc15899c1U, 0x1d273a1dU, 0x9eb9279eU,\n    0xe138d9e1U, 0xf813ebf8U, 0x98b32b98U, 0x11332211U,\n    0x69bbd269U, 0xd970a9d9U, 0x8e89078eU, 0x94a73394U,\n    0x9bb62d9bU, 0x1e223c1eU, 0x87921587U, 0xe920c9e9U,\n    0xce4987ceU, 0x55ffaa55U, 0x28785028U, 0xdf7aa5dfU,\n    0x8c8f038cU, 0xa1f859a1U, 0x89800989U, 0x0d171a0dU,\n    0xbfda65bfU, 0xe631d7e6U, 0x42c68442U, 0x68b8d068U,\n    0x41c38241U, 0x99b02999U, 0x2d775a2dU, 0x0f111e0fU,\n    0xb0cb7bb0U, 0x54fca854U, 0xbbd66dbbU, 0x163a2c16U,\n};\nstatic const u32 Te3[256] = {\n    0x6363a5c6U, 0x7c7c84f8U, 0x777799eeU, 0x7b7b8df6U,\n    0xf2f20dffU, 0x6b6bbdd6U, 0x6f6fb1deU, 0xc5c55491U,\n    0x30305060U, 0x01010302U, 0x6767a9ceU, 0x2b2b7d56U,\n    0xfefe19e7U, 0xd7d762b5U, 0xababe64dU, 0x76769aecU,\n    0xcaca458fU, 0x82829d1fU, 0xc9c94089U, 0x7d7d87faU,\n    0xfafa15efU, 0x5959ebb2U, 0x4747c98eU, 0xf0f00bfbU,\n    0xadadec41U, 0xd4d467b3U, 0xa2a2fd5fU, 0xafafea45U,\n    0x9c9cbf23U, 0xa4a4f753U, 0x727296e4U, 0xc0c05b9bU,\n    0xb7b7c275U, 0xfdfd1ce1U, 0x9393ae3dU, 0x26266a4cU,\n    0x36365a6cU, 0x3f3f417eU, 0xf7f702f5U, 0xcccc4f83U,\n    0x34345c68U, 0xa5a5f451U, 0xe5e534d1U, 0xf1f108f9U,\n    0x717193e2U, 0xd8d873abU, 0x31315362U, 0x15153f2aU,\n    0x04040c08U, 0xc7c75295U, 0x23236546U, 0xc3c35e9dU,\n    0x18182830U, 0x9696a137U, 0x05050f0aU, 0x9a9ab52fU,\n    0x0707090eU, 0x12123624U, 0x80809b1bU, 0xe2e23ddfU,\n    0xebeb26cdU, 0x2727694eU, 0xb2b2cd7fU, 0x75759feaU,\n    0x09091b12U, 0x83839e1dU, 0x2c2c7458U, 0x1a1a2e34U,\n    0x1b1b2d36U, 0x6e6eb2dcU, 0x5a5aeeb4U, 0xa0a0fb5bU,\n    0x5252f6a4U, 0x3b3b4d76U, 0xd6d661b7U, 0xb3b3ce7dU,\n    0x29297b52U, 0xe3e33eddU, 0x2f2f715eU, 0x84849713U,\n    0x5353f5a6U, 0xd1d168b9U, 0x00000000U, 0xeded2cc1U,\n    0x20206040U, 0xfcfc1fe3U, 0xb1b1c879U, 0x5b5bedb6U,\n    0x6a6abed4U, 0xcbcb468dU, 0xbebed967U, 0x39394b72U,\n    0x4a4ade94U, 0x4c4cd498U, 0x5858e8b0U, 0xcfcf4a85U,\n    0xd0d06bbbU, 0xefef2ac5U, 0xaaaae54fU, 0xfbfb16edU,\n    0x4343c586U, 0x4d4dd79aU, 0x33335566U, 0x85859411U,\n    0x4545cf8aU, 0xf9f910e9U, 0x02020604U, 0x7f7f81feU,\n    0x5050f0a0U, 0x3c3c4478U, 0x9f9fba25U, 0xa8a8e34bU,\n    0x5151f3a2U, 0xa3a3fe5dU, 0x4040c080U, 0x8f8f8a05U,\n    0x9292ad3fU, 0x9d9dbc21U, 0x38384870U, 0xf5f504f1U,\n    0xbcbcdf63U, 0xb6b6c177U, 0xdada75afU, 0x21216342U,\n    0x10103020U, 0xffff1ae5U, 0xf3f30efdU, 0xd2d26dbfU,\n    0xcdcd4c81U, 0x0c0c1418U, 0x13133526U, 0xecec2fc3U,\n    0x5f5fe1beU, 0x9797a235U, 0x4444cc88U, 0x1717392eU,\n    0xc4c45793U, 0xa7a7f255U, 0x7e7e82fcU, 0x3d3d477aU,\n    0x6464acc8U, 0x5d5de7baU, 0x19192b32U, 0x737395e6U,\n    0x6060a0c0U, 0x81819819U, 0x4f4fd19eU, 0xdcdc7fa3U,\n    0x22226644U, 0x2a2a7e54U, 0x9090ab3bU, 0x8888830bU,\n    0x4646ca8cU, 0xeeee29c7U, 0xb8b8d36bU, 0x14143c28U,\n    0xdede79a7U, 0x5e5ee2bcU, 0x0b0b1d16U, 0xdbdb76adU,\n    0xe0e03bdbU, 0x32325664U, 0x3a3a4e74U, 0x0a0a1e14U,\n    0x4949db92U, 0x06060a0cU, 0x24246c48U, 0x5c5ce4b8U,\n    0xc2c25d9fU, 0xd3d36ebdU, 0xacacef43U, 0x6262a6c4U,\n    0x9191a839U, 0x9595a431U, 0xe4e437d3U, 0x79798bf2U,\n    0xe7e732d5U, 0xc8c8438bU, 0x3737596eU, 0x6d6db7daU,\n    0x8d8d8c01U, 0xd5d564b1U, 0x4e4ed29cU, 0xa9a9e049U,\n    0x6c6cb4d8U, 0x5656faacU, 0xf4f407f3U, 0xeaea25cfU,\n    0x6565afcaU, 0x7a7a8ef4U, 0xaeaee947U, 0x08081810U,\n    0xbabad56fU, 0x787888f0U, 0x25256f4aU, 0x2e2e725cU,\n    0x1c1c2438U, 0xa6a6f157U, 0xb4b4c773U, 0xc6c65197U,\n    0xe8e823cbU, 0xdddd7ca1U, 0x74749ce8U, 0x1f1f213eU,\n    0x4b4bdd96U, 0xbdbddc61U, 0x8b8b860dU, 0x8a8a850fU,\n    0x707090e0U, 0x3e3e427cU, 0xb5b5c471U, 0x6666aaccU,\n    0x4848d890U, 0x03030506U, 0xf6f601f7U, 0x0e0e121cU,\n    0x6161a3c2U, 0x35355f6aU, 0x5757f9aeU, 0xb9b9d069U,\n    0x86869117U, 0xc1c15899U, 0x1d1d273aU, 0x9e9eb927U,\n    0xe1e138d9U, 0xf8f813ebU, 0x9898b32bU, 0x11113322U,\n    0x6969bbd2U, 0xd9d970a9U, 0x8e8e8907U, 0x9494a733U,\n    0x9b9bb62dU, 0x1e1e223cU, 0x87879215U, 0xe9e920c9U,\n    0xcece4987U, 0x5555ffaaU, 0x28287850U, 0xdfdf7aa5U,\n    0x8c8c8f03U, 0xa1a1f859U, 0x89898009U, 0x0d0d171aU,\n    0xbfbfda65U, 0xe6e631d7U, 0x4242c684U, 0x6868b8d0U,\n    0x4141c382U, 0x9999b029U, 0x2d2d775aU, 0x0f0f111eU,\n    0xb0b0cb7bU, 0x5454fca8U, 0xbbbbd66dU, 0x16163a2cU,\n};\n\nstatic const u32 Td0[256] = {\n    0x51f4a750U, 0x7e416553U, 0x1a17a4c3U, 0x3a275e96U,\n    0x3bab6bcbU, 0x1f9d45f1U, 0xacfa58abU, 0x4be30393U,\n    0x2030fa55U, 0xad766df6U, 0x88cc7691U, 0xf5024c25U,\n    0x4fe5d7fcU, 0xc52acbd7U, 0x26354480U, 0xb562a38fU,\n    0xdeb15a49U, 0x25ba1b67U, 0x45ea0e98U, 0x5dfec0e1U,\n    0xc32f7502U, 0x814cf012U, 0x8d4697a3U, 0x6bd3f9c6U,\n    0x038f5fe7U, 0x15929c95U, 0xbf6d7aebU, 0x955259daU,\n    0xd4be832dU, 0x587421d3U, 0x49e06929U, 0x8ec9c844U,\n    0x75c2896aU, 0xf48e7978U, 0x99583e6bU, 0x27b971ddU,\n    0xbee14fb6U, 0xf088ad17U, 0xc920ac66U, 0x7dce3ab4U,\n    0x63df4a18U, 0xe51a3182U, 0x97513360U, 0x62537f45U,\n    0xb16477e0U, 0xbb6bae84U, 0xfe81a01cU, 0xf9082b94U,\n    0x70486858U, 0x8f45fd19U, 0x94de6c87U, 0x527bf8b7U,\n    0xab73d323U, 0x724b02e2U, 0xe31f8f57U, 0x6655ab2aU,\n    0xb2eb2807U, 0x2fb5c203U, 0x86c57b9aU, 0xd33708a5U,\n    0x302887f2U, 0x23bfa5b2U, 0x02036abaU, 0xed16825cU,\n    0x8acf1c2bU, 0xa779b492U, 0xf307f2f0U, 0x4e69e2a1U,\n    0x65daf4cdU, 0x0605bed5U, 0xd134621fU, 0xc4a6fe8aU,\n    0x342e539dU, 0xa2f355a0U, 0x058ae132U, 0xa4f6eb75U,\n    0x0b83ec39U, 0x4060efaaU, 0x5e719f06U, 0xbd6e1051U,\n    0x3e218af9U, 0x96dd063dU, 0xdd3e05aeU, 0x4de6bd46U,\n    0x91548db5U, 0x71c45d05U, 0x0406d46fU, 0x605015ffU,\n    0x1998fb24U, 0xd6bde997U, 0x894043ccU, 0x67d99e77U,\n    0xb0e842bdU, 0x07898b88U, 0xe7195b38U, 0x79c8eedbU,\n    0xa17c0a47U, 0x7c420fe9U, 0xf8841ec9U, 0x00000000U,\n    0x09808683U, 0x322bed48U, 0x1e1170acU, 0x6c5a724eU,\n    0xfd0efffbU, 0x0f853856U, 0x3daed51eU, 0x362d3927U,\n    0x0a0fd964U, 0x685ca621U, 0x9b5b54d1U, 0x24362e3aU,\n    0x0c0a67b1U, 0x9357e70fU, 0xb4ee96d2U, 0x1b9b919eU,\n    0x80c0c54fU, 0x61dc20a2U, 0x5a774b69U, 0x1c121a16U,\n    0xe293ba0aU, 0xc0a02ae5U, 0x3c22e043U, 0x121b171dU,\n    0x0e090d0bU, 0xf28bc7adU, 0x2db6a8b9U, 0x141ea9c8U,\n    0x57f11985U, 0xaf75074cU, 0xee99ddbbU, 0xa37f60fdU,\n    0xf701269fU, 0x5c72f5bcU, 0x44663bc5U, 0x5bfb7e34U,\n    0x8b432976U, 0xcb23c6dcU, 0xb6edfc68U, 0xb8e4f163U,\n    0xd731dccaU, 0x42638510U, 0x13972240U, 0x84c61120U,\n    0x854a247dU, 0xd2bb3df8U, 0xaef93211U, 0xc729a16dU,\n    0x1d9e2f4bU, 0xdcb230f3U, 0x0d8652ecU, 0x77c1e3d0U,\n    0x2bb3166cU, 0xa970b999U, 0x119448faU, 0x47e96422U,\n    0xa8fc8cc4U, 0xa0f03f1aU, 0x567d2cd8U, 0x223390efU,\n    0x87494ec7U, 0xd938d1c1U, 0x8ccaa2feU, 0x98d40b36U,\n    0xa6f581cfU, 0xa57ade28U, 0xdab78e26U, 0x3fadbfa4U,\n    0x2c3a9de4U, 0x5078920dU, 0x6a5fcc9bU, 0x547e4662U,\n    0xf68d13c2U, 0x90d8b8e8U, 0x2e39f75eU, 0x82c3aff5U,\n    0x9f5d80beU, 0x69d0937cU, 0x6fd52da9U, 0xcf2512b3U,\n    0xc8ac993bU, 0x10187da7U, 0xe89c636eU, 0xdb3bbb7bU,\n    0xcd267809U, 0x6e5918f4U, 0xec9ab701U, 0x834f9aa8U,\n    0xe6956e65U, 0xaaffe67eU, 0x21bccf08U, 0xef15e8e6U,\n    0xbae79bd9U, 0x4a6f36ceU, 0xea9f09d4U, 0x29b07cd6U,\n    0x31a4b2afU, 0x2a3f2331U, 0xc6a59430U, 0x35a266c0U,\n    0x744ebc37U, 0xfc82caa6U, 0xe090d0b0U, 0x33a7d815U,\n    0xf104984aU, 0x41ecdaf7U, 0x7fcd500eU, 0x1791f62fU,\n    0x764dd68dU, 0x43efb04dU, 0xccaa4d54U, 0xe49604dfU,\n    0x9ed1b5e3U, 0x4c6a881bU, 0xc12c1fb8U, 0x4665517fU,\n    0x9d5eea04U, 0x018c355dU, 0xfa877473U, 0xfb0b412eU,\n    0xb3671d5aU, 0x92dbd252U, 0xe9105633U, 0x6dd64713U,\n    0x9ad7618cU, 0x37a10c7aU, 0x59f8148eU, 0xeb133c89U,\n    0xcea927eeU, 0xb761c935U, 0xe11ce5edU, 0x7a47b13cU,\n    0x9cd2df59U, 0x55f2733fU, 0x1814ce79U, 0x73c737bfU,\n    0x53f7cdeaU, 0x5ffdaa5bU, 0xdf3d6f14U, 0x7844db86U,\n    0xcaaff381U, 0xb968c43eU, 0x3824342cU, 0xc2a3405fU,\n    0x161dc372U, 0xbce2250cU, 0x283c498bU, 0xff0d9541U,\n    0x39a80171U, 0x080cb3deU, 0xd8b4e49cU, 0x6456c190U,\n    0x7bcb8461U, 0xd532b670U, 0x486c5c74U, 0xd0b85742U,\n};\nstatic const u32 Td1[256] = {\n    0x5051f4a7U, 0x537e4165U, 0xc31a17a4U, 0x963a275eU,\n    0xcb3bab6bU, 0xf11f9d45U, 0xabacfa58U, 0x934be303U,\n    0x552030faU, 0xf6ad766dU, 0x9188cc76U, 0x25f5024cU,\n    0xfc4fe5d7U, 0xd7c52acbU, 0x80263544U, 0x8fb562a3U,\n    0x49deb15aU, 0x6725ba1bU, 0x9845ea0eU, 0xe15dfec0U,\n    0x02c32f75U, 0x12814cf0U, 0xa38d4697U, 0xc66bd3f9U,\n    0xe7038f5fU, 0x9515929cU, 0xebbf6d7aU, 0xda955259U,\n    0x2dd4be83U, 0xd3587421U, 0x2949e069U, 0x448ec9c8U,\n    0x6a75c289U, 0x78f48e79U, 0x6b99583eU, 0xdd27b971U,\n    0xb6bee14fU, 0x17f088adU, 0x66c920acU, 0xb47dce3aU,\n    0x1863df4aU, 0x82e51a31U, 0x60975133U, 0x4562537fU,\n    0xe0b16477U, 0x84bb6baeU, 0x1cfe81a0U, 0x94f9082bU,\n    0x58704868U, 0x198f45fdU, 0x8794de6cU, 0xb7527bf8U,\n    0x23ab73d3U, 0xe2724b02U, 0x57e31f8fU, 0x2a6655abU,\n    0x07b2eb28U, 0x032fb5c2U, 0x9a86c57bU, 0xa5d33708U,\n    0xf2302887U, 0xb223bfa5U, 0xba02036aU, 0x5ced1682U,\n    0x2b8acf1cU, 0x92a779b4U, 0xf0f307f2U, 0xa14e69e2U,\n    0xcd65daf4U, 0xd50605beU, 0x1fd13462U, 0x8ac4a6feU,\n    0x9d342e53U, 0xa0a2f355U, 0x32058ae1U, 0x75a4f6ebU,\n    0x390b83ecU, 0xaa4060efU, 0x065e719fU, 0x51bd6e10U,\n    0xf93e218aU, 0x3d96dd06U, 0xaedd3e05U, 0x464de6bdU,\n    0xb591548dU, 0x0571c45dU, 0x6f0406d4U, 0xff605015U,\n    0x241998fbU, 0x97d6bde9U, 0xcc894043U, 0x7767d99eU,\n    0xbdb0e842U, 0x8807898bU, 0x38e7195bU, 0xdb79c8eeU,\n    0x47a17c0aU, 0xe97c420fU, 0xc9f8841eU, 0x00000000U,\n    0x83098086U, 0x48322bedU, 0xac1e1170U, 0x4e6c5a72U,\n    0xfbfd0effU, 0x560f8538U, 0x1e3daed5U, 0x27362d39U,\n    0x640a0fd9U, 0x21685ca6U, 0xd19b5b54U, 0x3a24362eU,\n    0xb10c0a67U, 0x0f9357e7U, 0xd2b4ee96U, 0x9e1b9b91U,\n    0x4f80c0c5U, 0xa261dc20U, 0x695a774bU, 0x161c121aU,\n    0x0ae293baU, 0xe5c0a02aU, 0x433c22e0U, 0x1d121b17U,\n    0x0b0e090dU, 0xadf28bc7U, 0xb92db6a8U, 0xc8141ea9U,\n    0x8557f119U, 0x4caf7507U, 0xbbee99ddU, 0xfda37f60U,\n    0x9ff70126U, 0xbc5c72f5U, 0xc544663bU, 0x345bfb7eU,\n    0x768b4329U, 0xdccb23c6U, 0x68b6edfcU, 0x63b8e4f1U,\n    0xcad731dcU, 0x10426385U, 0x40139722U, 0x2084c611U,\n    0x7d854a24U, 0xf8d2bb3dU, 0x11aef932U, 0x6dc729a1U,\n    0x4b1d9e2fU, 0xf3dcb230U, 0xec0d8652U, 0xd077c1e3U,\n    0x6c2bb316U, 0x99a970b9U, 0xfa119448U, 0x2247e964U,\n    0xc4a8fc8cU, 0x1aa0f03fU, 0xd8567d2cU, 0xef223390U,\n    0xc787494eU, 0xc1d938d1U, 0xfe8ccaa2U, 0x3698d40bU,\n    0xcfa6f581U, 0x28a57adeU, 0x26dab78eU, 0xa43fadbfU,\n    0xe42c3a9dU, 0x0d507892U, 0x9b6a5fccU, 0x62547e46U,\n    0xc2f68d13U, 0xe890d8b8U, 0x5e2e39f7U, 0xf582c3afU,\n    0xbe9f5d80U, 0x7c69d093U, 0xa96fd52dU, 0xb3cf2512U,\n    0x3bc8ac99U, 0xa710187dU, 0x6ee89c63U, 0x7bdb3bbbU,\n    0x09cd2678U, 0xf46e5918U, 0x01ec9ab7U, 0xa8834f9aU,\n    0x65e6956eU, 0x7eaaffe6U, 0x0821bccfU, 0xe6ef15e8U,\n    0xd9bae79bU, 0xce4a6f36U, 0xd4ea9f09U, 0xd629b07cU,\n    0xaf31a4b2U, 0x312a3f23U, 0x30c6a594U, 0xc035a266U,\n    0x37744ebcU, 0xa6fc82caU, 0xb0e090d0U, 0x1533a7d8U,\n    0x4af10498U, 0xf741ecdaU, 0x0e7fcd50U, 0x2f1791f6U,\n    0x8d764dd6U, 0x4d43efb0U, 0x54ccaa4dU, 0xdfe49604U,\n    0xe39ed1b5U, 0x1b4c6a88U, 0xb8c12c1fU, 0x7f466551U,\n    0x049d5eeaU, 0x5d018c35U, 0x73fa8774U, 0x2efb0b41U,\n    0x5ab3671dU, 0x5292dbd2U, 0x33e91056U, 0x136dd647U,\n    0x8c9ad761U, 0x7a37a10cU, 0x8e59f814U, 0x89eb133cU,\n    0xeecea927U, 0x35b761c9U, 0xede11ce5U, 0x3c7a47b1U,\n    0x599cd2dfU, 0x3f55f273U, 0x791814ceU, 0xbf73c737U,\n    0xea53f7cdU, 0x5b5ffdaaU, 0x14df3d6fU, 0x867844dbU,\n    0x81caaff3U, 0x3eb968c4U, 0x2c382434U, 0x5fc2a340U,\n    0x72161dc3U, 0x0cbce225U, 0x8b283c49U, 0x41ff0d95U,\n    0x7139a801U, 0xde080cb3U, 0x9cd8b4e4U, 0x906456c1U,\n    0x617bcb84U, 0x70d532b6U, 0x74486c5cU, 0x42d0b857U,\n};\nstatic const u32 Td2[256] = {\n    0xa75051f4U, 0x65537e41U, 0xa4c31a17U, 0x5e963a27U,\n    0x6bcb3babU, 0x45f11f9dU, 0x58abacfaU, 0x03934be3U,\n    0xfa552030U, 0x6df6ad76U, 0x769188ccU, 0x4c25f502U,\n    0xd7fc4fe5U, 0xcbd7c52aU, 0x44802635U, 0xa38fb562U,\n    0x5a49deb1U, 0x1b6725baU, 0x0e9845eaU, 0xc0e15dfeU,\n    0x7502c32fU, 0xf012814cU, 0x97a38d46U, 0xf9c66bd3U,\n    0x5fe7038fU, 0x9c951592U, 0x7aebbf6dU, 0x59da9552U,\n    0x832dd4beU, 0x21d35874U, 0x692949e0U, 0xc8448ec9U,\n    0x896a75c2U, 0x7978f48eU, 0x3e6b9958U, 0x71dd27b9U,\n    0x4fb6bee1U, 0xad17f088U, 0xac66c920U, 0x3ab47dceU,\n    0x4a1863dfU, 0x3182e51aU, 0x33609751U, 0x7f456253U,\n    0x77e0b164U, 0xae84bb6bU, 0xa01cfe81U, 0x2b94f908U,\n    0x68587048U, 0xfd198f45U, 0x6c8794deU, 0xf8b7527bU,\n    0xd323ab73U, 0x02e2724bU, 0x8f57e31fU, 0xab2a6655U,\n    0x2807b2ebU, 0xc2032fb5U, 0x7b9a86c5U, 0x08a5d337U,\n    0x87f23028U, 0xa5b223bfU, 0x6aba0203U, 0x825ced16U,\n    0x1c2b8acfU, 0xb492a779U, 0xf2f0f307U, 0xe2a14e69U,\n    0xf4cd65daU, 0xbed50605U, 0x621fd134U, 0xfe8ac4a6U,\n    0x539d342eU, 0x55a0a2f3U, 0xe132058aU, 0xeb75a4f6U,\n    0xec390b83U, 0xefaa4060U, 0x9f065e71U, 0x1051bd6eU,\n    0x8af93e21U, 0x063d96ddU, 0x05aedd3eU, 0xbd464de6U,\n    0x8db59154U, 0x5d0571c4U, 0xd46f0406U, 0x15ff6050U,\n    0xfb241998U, 0xe997d6bdU, 0x43cc8940U, 0x9e7767d9U,\n    0x42bdb0e8U, 0x8b880789U, 0x5b38e719U, 0xeedb79c8U,\n    0x0a47a17cU, 0x0fe97c42U, 0x1ec9f884U, 0x00000000U,\n    0x86830980U, 0xed48322bU, 0x70ac1e11U, 0x724e6c5aU,\n    0xfffbfd0eU, 0x38560f85U, 0xd51e3daeU, 0x3927362dU,\n    0xd9640a0fU, 0xa621685cU, 0x54d19b5bU, 0x2e3a2436U,\n    0x67b10c0aU, 0xe70f9357U, 0x96d2b4eeU, 0x919e1b9bU,\n    0xc54f80c0U, 0x20a261dcU, 0x4b695a77U, 0x1a161c12U,\n    0xba0ae293U, 0x2ae5c0a0U, 0xe0433c22U, 0x171d121bU,\n    0x0d0b0e09U, 0xc7adf28bU, 0xa8b92db6U, 0xa9c8141eU,\n    0x198557f1U, 0x074caf75U, 0xddbbee99U, 0x60fda37fU,\n    0x269ff701U, 0xf5bc5c72U, 0x3bc54466U, 0x7e345bfbU,\n    0x29768b43U, 0xc6dccb23U, 0xfc68b6edU, 0xf163b8e4U,\n    0xdccad731U, 0x85104263U, 0x22401397U, 0x112084c6U,\n    0x247d854aU, 0x3df8d2bbU, 0x3211aef9U, 0xa16dc729U,\n    0x2f4b1d9eU, 0x30f3dcb2U, 0x52ec0d86U, 0xe3d077c1U,\n    0x166c2bb3U, 0xb999a970U, 0x48fa1194U, 0x642247e9U,\n    0x8cc4a8fcU, 0x3f1aa0f0U, 0x2cd8567dU, 0x90ef2233U,\n    0x4ec78749U, 0xd1c1d938U, 0xa2fe8ccaU, 0x0b3698d4U,\n    0x81cfa6f5U, 0xde28a57aU, 0x8e26dab7U, 0xbfa43fadU,\n    0x9de42c3aU, 0x920d5078U, 0xcc9b6a5fU, 0x4662547eU,\n    0x13c2f68dU, 0xb8e890d8U, 0xf75e2e39U, 0xaff582c3U,\n    0x80be9f5dU, 0x937c69d0U, 0x2da96fd5U, 0x12b3cf25U,\n    0x993bc8acU, 0x7da71018U, 0x636ee89cU, 0xbb7bdb3bU,\n    0x7809cd26U, 0x18f46e59U, 0xb701ec9aU, 0x9aa8834fU,\n    0x6e65e695U, 0xe67eaaffU, 0xcf0821bcU, 0xe8e6ef15U,\n    0x9bd9bae7U, 0x36ce4a6fU, 0x09d4ea9fU, 0x7cd629b0U,\n    0xb2af31a4U, 0x23312a3fU, 0x9430c6a5U, 0x66c035a2U,\n    0xbc37744eU, 0xcaa6fc82U, 0xd0b0e090U, 0xd81533a7U,\n    0x984af104U, 0xdaf741ecU, 0x500e7fcdU, 0xf62f1791U,\n    0xd68d764dU, 0xb04d43efU, 0x4d54ccaaU, 0x04dfe496U,\n    0xb5e39ed1U, 0x881b4c6aU, 0x1fb8c12cU, 0x517f4665U,\n    0xea049d5eU, 0x355d018cU, 0x7473fa87U, 0x412efb0bU,\n    0x1d5ab367U, 0xd25292dbU, 0x5633e910U, 0x47136dd6U,\n    0x618c9ad7U, 0x0c7a37a1U, 0x148e59f8U, 0x3c89eb13U,\n    0x27eecea9U, 0xc935b761U, 0xe5ede11cU, 0xb13c7a47U,\n    0xdf599cd2U, 0x733f55f2U, 0xce791814U, 0x37bf73c7U,\n    0xcdea53f7U, 0xaa5b5ffdU, 0x6f14df3dU, 0xdb867844U,\n    0xf381caafU, 0xc43eb968U, 0x342c3824U, 0x405fc2a3U,\n    0xc372161dU, 0x250cbce2U, 0x498b283cU, 0x9541ff0dU,\n    0x017139a8U, 0xb3de080cU, 0xe49cd8b4U, 0xc1906456U,\n    0x84617bcbU, 0xb670d532U, 0x5c74486cU, 0x5742d0b8U,\n};\nstatic const u32 Td3[256] = {\n    0xf4a75051U, 0x4165537eU, 0x17a4c31aU, 0x275e963aU,\n    0xab6bcb3bU, 0x9d45f11fU, 0xfa58abacU, 0xe303934bU,\n    0x30fa5520U, 0x766df6adU, 0xcc769188U, 0x024c25f5U,\n    0xe5d7fc4fU, 0x2acbd7c5U, 0x35448026U, 0x62a38fb5U,\n    0xb15a49deU, 0xba1b6725U, 0xea0e9845U, 0xfec0e15dU,\n    0x2f7502c3U, 0x4cf01281U, 0x4697a38dU, 0xd3f9c66bU,\n    0x8f5fe703U, 0x929c9515U, 0x6d7aebbfU, 0x5259da95U,\n    0xbe832dd4U, 0x7421d358U, 0xe0692949U, 0xc9c8448eU,\n    0xc2896a75U, 0x8e7978f4U, 0x583e6b99U, 0xb971dd27U,\n    0xe14fb6beU, 0x88ad17f0U, 0x20ac66c9U, 0xce3ab47dU,\n    0xdf4a1863U, 0x1a3182e5U, 0x51336097U, 0x537f4562U,\n    0x6477e0b1U, 0x6bae84bbU, 0x81a01cfeU, 0x082b94f9U,\n    0x48685870U, 0x45fd198fU, 0xde6c8794U, 0x7bf8b752U,\n    0x73d323abU, 0x4b02e272U, 0x1f8f57e3U, 0x55ab2a66U,\n    0xeb2807b2U, 0xb5c2032fU, 0xc57b9a86U, 0x3708a5d3U,\n    0x2887f230U, 0xbfa5b223U, 0x036aba02U, 0x16825cedU,\n    0xcf1c2b8aU, 0x79b492a7U, 0x07f2f0f3U, 0x69e2a14eU,\n    0xdaf4cd65U, 0x05bed506U, 0x34621fd1U, 0xa6fe8ac4U,\n    0x2e539d34U, 0xf355a0a2U, 0x8ae13205U, 0xf6eb75a4U,\n    0x83ec390bU, 0x60efaa40U, 0x719f065eU, 0x6e1051bdU,\n    0x218af93eU, 0xdd063d96U, 0x3e05aeddU, 0xe6bd464dU,\n    0x548db591U, 0xc45d0571U, 0x06d46f04U, 0x5015ff60U,\n    0x98fb2419U, 0xbde997d6U, 0x4043cc89U, 0xd99e7767U,\n    0xe842bdb0U, 0x898b8807U, 0x195b38e7U, 0xc8eedb79U,\n    0x7c0a47a1U, 0x420fe97cU, 0x841ec9f8U, 0x00000000U,\n    0x80868309U, 0x2bed4832U, 0x1170ac1eU, 0x5a724e6cU,\n    0x0efffbfdU, 0x8538560fU, 0xaed51e3dU, 0x2d392736U,\n    0x0fd9640aU, 0x5ca62168U, 0x5b54d19bU, 0x362e3a24U,\n    0x0a67b10cU, 0x57e70f93U, 0xee96d2b4U, 0x9b919e1bU,\n    0xc0c54f80U, 0xdc20a261U, 0x774b695aU, 0x121a161cU,\n    0x93ba0ae2U, 0xa02ae5c0U, 0x22e0433cU, 0x1b171d12U,\n    0x090d0b0eU, 0x8bc7adf2U, 0xb6a8b92dU, 0x1ea9c814U,\n    0xf1198557U, 0x75074cafU, 0x99ddbbeeU, 0x7f60fda3U,\n    0x01269ff7U, 0x72f5bc5cU, 0x663bc544U, 0xfb7e345bU,\n    0x4329768bU, 0x23c6dccbU, 0xedfc68b6U, 0xe4f163b8U,\n    0x31dccad7U, 0x63851042U, 0x97224013U, 0xc6112084U,\n    0x4a247d85U, 0xbb3df8d2U, 0xf93211aeU, 0x29a16dc7U,\n    0x9e2f4b1dU, 0xb230f3dcU, 0x8652ec0dU, 0xc1e3d077U,\n    0xb3166c2bU, 0x70b999a9U, 0x9448fa11U, 0xe9642247U,\n    0xfc8cc4a8U, 0xf03f1aa0U, 0x7d2cd856U, 0x3390ef22U,\n    0x494ec787U, 0x38d1c1d9U, 0xcaa2fe8cU, 0xd40b3698U,\n    0xf581cfa6U, 0x7ade28a5U, 0xb78e26daU, 0xadbfa43fU,\n    0x3a9de42cU, 0x78920d50U, 0x5fcc9b6aU, 0x7e466254U,\n    0x8d13c2f6U, 0xd8b8e890U, 0x39f75e2eU, 0xc3aff582U,\n    0x5d80be9fU, 0xd0937c69U, 0xd52da96fU, 0x2512b3cfU,\n    0xac993bc8U, 0x187da710U, 0x9c636ee8U, 0x3bbb7bdbU,\n    0x267809cdU, 0x5918f46eU, 0x9ab701ecU, 0x4f9aa883U,\n    0x956e65e6U, 0xffe67eaaU, 0xbccf0821U, 0x15e8e6efU,\n    0xe79bd9baU, 0x6f36ce4aU, 0x9f09d4eaU, 0xb07cd629U,\n    0xa4b2af31U, 0x3f23312aU, 0xa59430c6U, 0xa266c035U,\n    0x4ebc3774U, 0x82caa6fcU, 0x90d0b0e0U, 0xa7d81533U,\n    0x04984af1U, 0xecdaf741U, 0xcd500e7fU, 0x91f62f17U,\n    0x4dd68d76U, 0xefb04d43U, 0xaa4d54ccU, 0x9604dfe4U,\n    0xd1b5e39eU, 0x6a881b4cU, 0x2c1fb8c1U, 0x65517f46U,\n    0x5eea049dU, 0x8c355d01U, 0x877473faU, 0x0b412efbU,\n    0x671d5ab3U, 0xdbd25292U, 0x105633e9U, 0xd647136dU,\n    0xd7618c9aU, 0xa10c7a37U, 0xf8148e59U, 0x133c89ebU,\n    0xa927eeceU, 0x61c935b7U, 0x1ce5ede1U, 0x47b13c7aU,\n    0xd2df599cU, 0xf2733f55U, 0x14ce7918U, 0xc737bf73U,\n    0xf7cdea53U, 0xfdaa5b5fU, 0x3d6f14dfU, 0x44db8678U,\n    0xaff381caU, 0x68c43eb9U, 0x24342c38U, 0xa3405fc2U,\n    0x1dc37216U, 0xe2250cbcU, 0x3c498b28U, 0x0d9541ffU,\n    0xa8017139U, 0x0cb3de08U, 0xb4e49cd8U, 0x56c19064U,\n    0xcb84617bU, 0x32b670d5U, 0x6c5c7448U, 0xb85742d0U,\n};\nstatic const u8 Td4[256] = {\n    0x52U, 0x09U, 0x6aU, 0xd5U, 0x30U, 0x36U, 0xa5U, 0x38U,\n    0xbfU, 0x40U, 0xa3U, 0x9eU, 0x81U, 0xf3U, 0xd7U, 0xfbU,\n    0x7cU, 0xe3U, 0x39U, 0x82U, 0x9bU, 0x2fU, 0xffU, 0x87U,\n    0x34U, 0x8eU, 0x43U, 0x44U, 0xc4U, 0xdeU, 0xe9U, 0xcbU,\n    0x54U, 0x7bU, 0x94U, 0x32U, 0xa6U, 0xc2U, 0x23U, 0x3dU,\n    0xeeU, 0x4cU, 0x95U, 0x0bU, 0x42U, 0xfaU, 0xc3U, 0x4eU,\n    0x08U, 0x2eU, 0xa1U, 0x66U, 0x28U, 0xd9U, 0x24U, 0xb2U,\n    0x76U, 0x5bU, 0xa2U, 0x49U, 0x6dU, 0x8bU, 0xd1U, 0x25U,\n    0x72U, 0xf8U, 0xf6U, 0x64U, 0x86U, 0x68U, 0x98U, 0x16U,\n    0xd4U, 0xa4U, 0x5cU, 0xccU, 0x5dU, 0x65U, 0xb6U, 0x92U,\n    0x6cU, 0x70U, 0x48U, 0x50U, 0xfdU, 0xedU, 0xb9U, 0xdaU,\n    0x5eU, 0x15U, 0x46U, 0x57U, 0xa7U, 0x8dU, 0x9dU, 0x84U,\n    0x90U, 0xd8U, 0xabU, 0x00U, 0x8cU, 0xbcU, 0xd3U, 0x0aU,\n    0xf7U, 0xe4U, 0x58U, 0x05U, 0xb8U, 0xb3U, 0x45U, 0x06U,\n    0xd0U, 0x2cU, 0x1eU, 0x8fU, 0xcaU, 0x3fU, 0x0fU, 0x02U,\n    0xc1U, 0xafU, 0xbdU, 0x03U, 0x01U, 0x13U, 0x8aU, 0x6bU,\n    0x3aU, 0x91U, 0x11U, 0x41U, 0x4fU, 0x67U, 0xdcU, 0xeaU,\n    0x97U, 0xf2U, 0xcfU, 0xceU, 0xf0U, 0xb4U, 0xe6U, 0x73U,\n    0x96U, 0xacU, 0x74U, 0x22U, 0xe7U, 0xadU, 0x35U, 0x85U,\n    0xe2U, 0xf9U, 0x37U, 0xe8U, 0x1cU, 0x75U, 0xdfU, 0x6eU,\n    0x47U, 0xf1U, 0x1aU, 0x71U, 0x1dU, 0x29U, 0xc5U, 0x89U,\n    0x6fU, 0xb7U, 0x62U, 0x0eU, 0xaaU, 0x18U, 0xbeU, 0x1bU,\n    0xfcU, 0x56U, 0x3eU, 0x4bU, 0xc6U, 0xd2U, 0x79U, 0x20U,\n    0x9aU, 0xdbU, 0xc0U, 0xfeU, 0x78U, 0xcdU, 0x5aU, 0xf4U,\n    0x1fU, 0xddU, 0xa8U, 0x33U, 0x88U, 0x07U, 0xc7U, 0x31U,\n    0xb1U, 0x12U, 0x10U, 0x59U, 0x27U, 0x80U, 0xecU, 0x5fU,\n    0x60U, 0x51U, 0x7fU, 0xa9U, 0x19U, 0xb5U, 0x4aU, 0x0dU,\n    0x2dU, 0xe5U, 0x7aU, 0x9fU, 0x93U, 0xc9U, 0x9cU, 0xefU,\n    0xa0U, 0xe0U, 0x3bU, 0x4dU, 0xaeU, 0x2aU, 0xf5U, 0xb0U,\n    0xc8U, 0xebU, 0xbbU, 0x3cU, 0x83U, 0x53U, 0x99U, 0x61U,\n    0x17U, 0x2bU, 0x04U, 0x7eU, 0xbaU, 0x77U, 0xd6U, 0x26U,\n    0xe1U, 0x69U, 0x14U, 0x63U, 0x55U, 0x21U, 0x0cU, 0x7dU,\n};\nstatic const u32 rcon[] = {\n    0x01000000, 0x02000000, 0x04000000, 0x08000000,\n    0x10000000, 0x20000000, 0x40000000, 0x80000000,\n    0x1B000000, 0x36000000, /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */\n};\n\n/**\n * Expand the cipher key into the encryption key schedule.\n */\nint AES_set_encrypt_key (const unsigned char *userKey, const int bits,\n                         AES_KEY *key)\n{\n\n    u32 *rk;\n    int i = 0;\n    u32 temp;\n\n    if (!userKey || !key) {\n        return -1;\n    }\n    if (bits != 128 && bits != 192 && bits != 256) {\n        return -2;\n    }\n\n    rk = key->rd_key;\n\n    if (bits == 128) {\n        key->rounds = 10;\n    } else if (bits == 192) {\n        key->rounds = 12;\n    } else{\n        key->rounds = 14;\n    }\n\n    rk[0] = GETU32(userKey     );\n    rk[1] = GETU32(userKey +  4);\n    rk[2] = GETU32(userKey +  8);\n    rk[3] = GETU32(userKey + 12);\n    if (bits == 128) {\n        while (1) {\n            temp  = rk[3];\n            rk[4] = rk[0] ^\n                    (Te2[(temp >> 16) & 0xff] & 0xff000000) ^\n                    (Te3[(temp >>  8) & 0xff] & 0x00ff0000) ^\n                    (Te0[(temp      ) & 0xff] & 0x0000ff00) ^\n                    (Te1[(temp >> 24)       ] & 0x000000ff) ^\n                    rcon[i];\n            rk[5] = rk[1] ^ rk[4];\n            rk[6] = rk[2] ^ rk[5];\n            rk[7] = rk[3] ^ rk[6];\n            if (++i == 10) {\n                return 0;\n            }\n            rk += 4;\n        }\n    }\n    rk[4] = GETU32(userKey + 16);\n    rk[5] = GETU32(userKey + 20);\n    if (bits == 192) {\n        while (1) {\n            temp = rk[ 5];\n            rk[ 6] = rk[ 0] ^\n                     (Te2[(temp >> 16) & 0xff] & 0xff000000) ^\n                     (Te3[(temp >>  8) & 0xff] & 0x00ff0000) ^\n                     (Te0[(temp      ) & 0xff] & 0x0000ff00) ^\n                     (Te1[(temp >> 24)       ] & 0x000000ff) ^\n                     rcon[i];\n            rk[ 7] = rk[ 1] ^ rk[ 6];\n            rk[ 8] = rk[ 2] ^ rk[ 7];\n            rk[ 9] = rk[ 3] ^ rk[ 8];\n            if (++i == 8) {\n                return 0;\n            }\n            rk[10] = rk[ 4] ^ rk[ 9];\n            rk[11] = rk[ 5] ^ rk[10];\n            rk += 6;\n        }\n    }\n    rk[6] = GETU32(userKey + 24);\n    rk[7] = GETU32(userKey + 28);\n    if (bits == 256) {\n        while (1) {\n            temp = rk[ 7];\n            rk[ 8] = rk[ 0] ^\n                     (Te2[(temp >> 16) & 0xff] & 0xff000000) ^\n                     (Te3[(temp >>  8) & 0xff] & 0x00ff0000) ^\n                     (Te0[(temp      ) & 0xff] & 0x0000ff00) ^\n                     (Te1[(temp >> 24)       ] & 0x000000ff) ^\n                     rcon[i];\n            rk[ 9] = rk[ 1] ^ rk[ 8];\n            rk[10] = rk[ 2] ^ rk[ 9];\n            rk[11] = rk[ 3] ^ rk[10];\n            if (++i == 7) {\n                return 0;\n            }\n            temp = rk[11];\n            rk[12] = rk[ 4] ^\n                     (Te2[(temp >> 24)       ] & 0xff000000) ^\n                     (Te3[(temp >> 16) & 0xff] & 0x00ff0000) ^\n                     (Te0[(temp >>  8) & 0xff] & 0x0000ff00) ^\n                     (Te1[(temp      ) & 0xff] & 0x000000ff);\n            rk[13] = rk[ 5] ^ rk[12];\n            rk[14] = rk[ 6] ^ rk[13];\n            rk[15] = rk[ 7] ^ rk[14];\n\n            rk += 8;\n        }\n    }\n    return 0;\n}\n\n/**\n * Expand the cipher key into the decryption key schedule.\n */\nint AES_set_decrypt_key (const unsigned char *userKey, const int bits,\n                         AES_KEY *key)\n{\n\n    u32 *rk;\n    int i, j, status;\n    u32 temp;\n\n    /* first, start with an encryption schedule */\n    status = AES_set_encrypt_key(userKey, bits, key);\n    if (status < 0) {\n        return status;\n    }\n\n    rk = key->rd_key;\n\n    /* invert the order of the round keys: */\n    for (i = 0, j = 4 * (key->rounds); i < j; i += 4, j -= 4) {\n        temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;\n        temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\n        temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\n        temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\n    }\n    /* apply the inverse MixColumn transform to all round keys but the first and the last: */\n    for (i = 1; i < (key->rounds); i++) {\n        rk += 4;\n        rk[0] =\n            Td0[Te1[(rk[0] >> 24)       ] & 0xff] ^\n            Td1[Te1[(rk[0] >> 16) & 0xff] & 0xff] ^\n            Td2[Te1[(rk[0] >>  8) & 0xff] & 0xff] ^\n            Td3[Te1[(rk[0]      ) & 0xff] & 0xff];\n        rk[1] =\n            Td0[Te1[(rk[1] >> 24)       ] & 0xff] ^\n            Td1[Te1[(rk[1] >> 16) & 0xff] & 0xff] ^\n            Td2[Te1[(rk[1] >>  8) & 0xff] & 0xff] ^\n            Td3[Te1[(rk[1]      ) & 0xff] & 0xff];\n        rk[2] =\n            Td0[Te1[(rk[2] >> 24)       ] & 0xff] ^\n            Td1[Te1[(rk[2] >> 16) & 0xff] & 0xff] ^\n            Td2[Te1[(rk[2] >>  8) & 0xff] & 0xff] ^\n            Td3[Te1[(rk[2]      ) & 0xff] & 0xff];\n        rk[3] =\n            Td0[Te1[(rk[3] >> 24)       ] & 0xff] ^\n            Td1[Te1[(rk[3] >> 16) & 0xff] & 0xff] ^\n            Td2[Te1[(rk[3] >>  8) & 0xff] & 0xff] ^\n            Td3[Te1[(rk[3]      ) & 0xff] & 0xff];\n    }\n    return 0;\n}\n\n\nvoid AES_encrypt_4round (const unsigned char *in, unsigned char *out,\n                         const AES_KEY *key)\n{\n    const u32 *rk;\n    u32 s0, s1, s2, s3, t0, t1, t2, t3;\n\n    assert(in && out && key);\n    rk = key->rd_key;\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n    s0 = GETU32(in     ) ^ rk[0];\n    s1 = GETU32(in +  4) ^ rk[1];\n    s2 = GETU32(in +  8) ^ rk[2];\n    s3 = GETU32(in + 12) ^ rk[3];\n\n#if ENABLE_AES4_DEBUG\n    dump_hex2(\"s0\", &s0, 4);\n    dump_hex2(\"s1\", &s1, 4);\n    dump_hex2(\"s2\", &s2, 4);\n    dump_hex2(\"s3\", &s3, 4);\n#endif\n\n    /* round 1: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 4];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 5];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 6];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 7];\n\n#if ENABLE_AES4_DEBUG\n    //this dump matches input into round 2\n    dump_hex2(\"t0\", &t0, 4);\n    dump_hex2(\"t1\", &t1, 4);\n    dump_hex2(\"t2\", &t2, 4);\n    dump_hex2(\"t3\", &t3, 4);\n#endif\n\n    /* round 2: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 8];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 9];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];\n\n#if ENABLE_AES4_DEBUG\n    //this dump matches input into round 3\n    dump_hex2(\"s0\", &s0, 4);\n    dump_hex2(\"s1\", &s1, 4);\n    dump_hex2(\"s2\", &s2, 4);\n    dump_hex2(\"s3\", &s3, 4);\n#endif\n\n    /* round 3: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[12];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[13];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[14];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[15];\n\n#if ENABLE_AES4_DEBUG\n    //this dump matches input into round 4\n    dump_hex2(\"t0\", &t0, 4);\n    dump_hex2(\"t1\", &t1, 4);\n    dump_hex2(\"t2\", &t2, 4);\n    dump_hex2(\"t3\", &t3, 4);\n#endif\n\n /* round 4: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[16];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[17];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[18];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[19];\n\n#if ENABLE_AES4_DEBUG\n    //this dumps the output from round 4\n    dump_hex2(\"s0\", &s0, 4);\n    dump_hex2(\"s1\", &s1, 4);\n    dump_hex2(\"s2\", &s2, 4);\n    dump_hex2(\"s3\", &s3, 4);\n#endif\n\n    PUTU32(out, s0);\n    PUTU32(out +  4, s1);\n    PUTU32(out +  8, s2);\n    PUTU32(out + 12, s3);\n}\n\n\n/*\n * Encrypt a single block\n * in and out can overlap\n */\nvoid AES_encrypt (const unsigned char *in, unsigned char *out,\n                  const AES_KEY *key)\n{\n\n    const u32 *rk;\n    u32 s0, s1, s2, s3, t0, t1, t2, t3;\n\n#ifndef FULL_UNROLL\n    int r;\n#endif /* ?FULL_UNROLL */\n\n    assert(in && out && key);\n    rk = key->rd_key;\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n    s0 = GETU32(in     ) ^ rk[0];\n    s1 = GETU32(in +  4) ^ rk[1];\n    s2 = GETU32(in +  8) ^ rk[2];\n    s3 = GETU32(in + 12) ^ rk[3];\n#ifdef FULL_UNROLL\n    /* round 1: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 4];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 5];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 6];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 7];\n    /* round 2: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 8];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 9];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];\n    /* round 3: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[12];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[13];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[14];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[15];\n    /* round 4: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[16];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[17];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[18];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[19];\n    /* round 5: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[20];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[21];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[22];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[23];\n    /* round 6: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[24];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[25];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[26];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[27];\n    /* round 7: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[28];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[29];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[30];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[31];\n    /* round 8: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[32];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[33];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[34];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[35];\n    /* round 9: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[36];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[37];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[38];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[39];\n    if (key->rounds > 10) {\n        /* round 10: */\n        s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[40];\n        s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[41];\n        s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[42];\n        s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[43];\n        /* round 11: */\n        t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[44];\n        t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[45];\n        t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[46];\n        t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[47];\n        if (key->rounds > 12) {\n            /* round 12: */\n            s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[48];\n            s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[49];\n            s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[50];\n            s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[51];\n            /* round 13: */\n            t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[52];\n            t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[53];\n            t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[54];\n            t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[55];\n        }\n    }\n    rk += key->rounds << 2;\n#else  /* !FULL_UNROLL */\n       /*\n        * Nr - 1 full rounds:\n        */\n    r = key->rounds >> 1;\n    for (;; ) {\n        t0 =\n            Te0[(s0 >> 24)       ] ^\n            Te1[(s1 >> 16) & 0xff] ^\n            Te2[(s2 >>  8) & 0xff] ^\n            Te3[(s3      ) & 0xff] ^\n            rk[4];\n        t1 =\n            Te0[(s1 >> 24)       ] ^\n            Te1[(s2 >> 16) & 0xff] ^\n            Te2[(s3 >>  8) & 0xff] ^\n            Te3[(s0      ) & 0xff] ^\n            rk[5];\n        t2 =\n            Te0[(s2 >> 24)       ] ^\n            Te1[(s3 >> 16) & 0xff] ^\n            Te2[(s0 >>  8) & 0xff] ^\n            Te3[(s1      ) & 0xff] ^\n            rk[6];\n        t3 =\n            Te0[(s3 >> 24)       ] ^\n            Te1[(s0 >> 16) & 0xff] ^\n            Te2[(s1 >>  8) & 0xff] ^\n            Te3[(s2      ) & 0xff] ^\n            rk[7];\n\n        rk += 8;\n        if (--r == 0) {\n            break;\n        }\n\n        s0 =\n            Te0[(t0 >> 24)       ] ^\n            Te1[(t1 >> 16) & 0xff] ^\n            Te2[(t2 >>  8) & 0xff] ^\n            Te3[(t3      ) & 0xff] ^\n            rk[0];\n        s1 =\n            Te0[(t1 >> 24)       ] ^\n            Te1[(t2 >> 16) & 0xff] ^\n            Te2[(t3 >>  8) & 0xff] ^\n            Te3[(t0      ) & 0xff] ^\n            rk[1];\n        s2 =\n            Te0[(t2 >> 24)       ] ^\n            Te1[(t3 >> 16) & 0xff] ^\n            Te2[(t0 >>  8) & 0xff] ^\n            Te3[(t1      ) & 0xff] ^\n            rk[2];\n        s3 =\n            Te0[(t3 >> 24)       ] ^\n            Te1[(t0 >> 16) & 0xff] ^\n            Te2[(t1 >>  8) & 0xff] ^\n            Te3[(t2      ) & 0xff] ^\n            rk[3];\n    }\n#endif /* ?FULL_UNROLL */\n       /*\n        * apply last round and\n        * map cipher state to byte array block:\n        */\n    s0 =\n        (Te2[(t0 >> 24)       ] & 0xff000000) ^\n        (Te3[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te0[(t2 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te1[(t3      ) & 0xff] & 0x000000ff) ^\n        rk[0];\n    PUTU32(out, s0);\n    s1 =\n        (Te2[(t1 >> 24)       ] & 0xff000000) ^\n        (Te3[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te0[(t3 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te1[(t0      ) & 0xff] & 0x000000ff) ^\n        rk[1];\n    PUTU32(out +  4, s1);\n    s2 =\n        (Te2[(t2 >> 24)       ] & 0xff000000) ^\n        (Te3[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te0[(t0 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te1[(t1      ) & 0xff] & 0x000000ff) ^\n        rk[2];\n    PUTU32(out +  8, s2);\n    s3 =\n        (Te2[(t3 >> 24)       ] & 0xff000000) ^\n        (Te3[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te0[(t1 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te1[(t2      ) & 0xff] & 0x000000ff) ^\n        rk[3];\n    PUTU32(out + 12, s3);\n}\n\n/*\n * Decrypt a single block\n * in and out can overlap\n */\nvoid AES_decrypt (const unsigned char *in, unsigned char *out,\n                  const AES_KEY *key)\n{\n\n    const u32 *rk;\n    u32 s0, s1, s2, s3, t0, t1, t2, t3;\n\n#ifndef FULL_UNROLL\n    int r;\n#endif /* ?FULL_UNROLL */\n\n    assert(in && out && key);\n    rk = key->rd_key;\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n    s0 = GETU32(in     ) ^ rk[0];\n    s1 = GETU32(in +  4) ^ rk[1];\n    s2 = GETU32(in +  8) ^ rk[2];\n    s3 = GETU32(in + 12) ^ rk[3];\n#ifdef FULL_UNROLL\n    /* round 1: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[ 4];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[ 5];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[ 6];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[ 7];\n    /* round 2: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[ 8];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[ 9];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[10];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[11];\n    /* round 3: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[12];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[13];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[14];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[15];\n    /* round 4: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[16];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[17];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[18];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[19];\n    /* round 5: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[20];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[21];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[22];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[23];\n    /* round 6: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[24];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[25];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[26];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[27];\n    /* round 7: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[28];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[29];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[30];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[31];\n    /* round 8: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[32];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[33];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[34];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[35];\n    /* round 9: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[36];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[37];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[38];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[39];\n    if (key->rounds > 10) {\n        /* round 10: */\n        s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[40];\n        s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[41];\n        s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[42];\n        s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[43];\n        /* round 11: */\n        t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[44];\n        t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[45];\n        t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[46];\n        t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[47];\n        if (key->rounds > 12) {\n            /* round 12: */\n            s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[48];\n            s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[49];\n            s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[50];\n            s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[51];\n            /* round 13: */\n            t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[52];\n            t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[53];\n            t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[54];\n            t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[55];\n        }\n    }\n    rk += key->rounds << 2;\n#else  /* !FULL_UNROLL */\n       /*\n        * Nr - 1 full rounds:\n        */\n    r = key->rounds >> 1;\n    for (;; ) {\n        t0 =\n            Td0[(s0 >> 24)       ] ^\n            Td1[(s3 >> 16) & 0xff] ^\n            Td2[(s2 >>  8) & 0xff] ^\n            Td3[(s1      ) & 0xff] ^\n            rk[4];\n        t1 =\n            Td0[(s1 >> 24)       ] ^\n            Td1[(s0 >> 16) & 0xff] ^\n            Td2[(s3 >>  8) & 0xff] ^\n            Td3[(s2      ) & 0xff] ^\n            rk[5];\n        t2 =\n            Td0[(s2 >> 24)       ] ^\n            Td1[(s1 >> 16) & 0xff] ^\n            Td2[(s0 >>  8) & 0xff] ^\n            Td3[(s3      ) & 0xff] ^\n            rk[6];\n        t3 =\n            Td0[(s3 >> 24)       ] ^\n            Td1[(s2 >> 16) & 0xff] ^\n            Td2[(s1 >>  8) & 0xff] ^\n            Td3[(s0      ) & 0xff] ^\n            rk[7];\n\n        rk += 8;\n        if (--r == 0) {\n            break;\n        }\n\n        s0 =\n            Td0[(t0 >> 24)       ] ^\n            Td1[(t3 >> 16) & 0xff] ^\n            Td2[(t2 >>  8) & 0xff] ^\n            Td3[(t1      ) & 0xff] ^\n            rk[0];\n        s1 =\n            Td0[(t1 >> 24)       ] ^\n            Td1[(t0 >> 16) & 0xff] ^\n            Td2[(t3 >>  8) & 0xff] ^\n            Td3[(t2      ) & 0xff] ^\n            rk[1];\n        s2 =\n            Td0[(t2 >> 24)       ] ^\n            Td1[(t1 >> 16) & 0xff] ^\n            Td2[(t0 >>  8) & 0xff] ^\n            Td3[(t3      ) & 0xff] ^\n            rk[2];\n        s3 =\n            Td0[(t3 >> 24)       ] ^\n            Td1[(t2 >> 16) & 0xff] ^\n            Td2[(t1 >>  8) & 0xff] ^\n            Td3[(t0      ) & 0xff] ^\n            rk[3];\n    }\n#endif /* ?FULL_UNROLL */\n       /*\n        * apply last round and\n        * map cipher state to byte array block:\n        */\n    s0 =\n        (Td4[(t0 >> 24)       ] << 24) ^\n        (Td4[(t3 >> 16) & 0xff] << 16) ^\n        (Td4[(t2 >>  8) & 0xff] <<  8) ^\n        (Td4[(t1      ) & 0xff])       ^\n        rk[0];\n    PUTU32(out, s0);\n    s1 =\n        (Td4[(t1 >> 24)       ] << 24) ^\n        (Td4[(t0 >> 16) & 0xff] << 16) ^\n        (Td4[(t3 >>  8) & 0xff] <<  8) ^\n        (Td4[(t2      ) & 0xff])       ^\n        rk[1];\n    PUTU32(out +  4, s1);\n    s2 =\n        (Td4[(t2 >> 24)       ] << 24) ^\n        (Td4[(t1 >> 16) & 0xff] << 16) ^\n        (Td4[(t0 >>  8) & 0xff] <<  8) ^\n        (Td4[(t3      ) & 0xff])       ^\n        rk[2];\n    PUTU32(out +  8, s2);\n    s3 =\n        (Td4[(t3 >> 24)       ] << 24) ^\n        (Td4[(t2 >> 16) & 0xff] << 16) ^\n        (Td4[(t1 >>  8) & 0xff] <<  8) ^\n        (Td4[(t0      ) & 0xff])       ^\n        rk[3];\n    PUTU32(out + 12, s3);\n}\n\n#else /* AES_ASM */\n\nstatic const u8 Te4[256] = {\n    0x63U, 0x7cU, 0x77U, 0x7bU, 0xf2U, 0x6bU, 0x6fU, 0xc5U,\n    0x30U, 0x01U, 0x67U, 0x2bU, 0xfeU, 0xd7U, 0xabU, 0x76U,\n    0xcaU, 0x82U, 0xc9U, 0x7dU, 0xfaU, 0x59U, 0x47U, 0xf0U,\n    0xadU, 0xd4U, 0xa2U, 0xafU, 0x9cU, 0xa4U, 0x72U, 0xc0U,\n    0xb7U, 0xfdU, 0x93U, 0x26U, 0x36U, 0x3fU, 0xf7U, 0xccU,\n    0x34U, 0xa5U, 0xe5U, 0xf1U, 0x71U, 0xd8U, 0x31U, 0x15U,\n    0x04U, 0xc7U, 0x23U, 0xc3U, 0x18U, 0x96U, 0x05U, 0x9aU,\n    0x07U, 0x12U, 0x80U, 0xe2U, 0xebU, 0x27U, 0xb2U, 0x75U,\n    0x09U, 0x83U, 0x2cU, 0x1aU, 0x1bU, 0x6eU, 0x5aU, 0xa0U,\n    0x52U, 0x3bU, 0xd6U, 0xb3U, 0x29U, 0xe3U, 0x2fU, 0x84U,\n    0x53U, 0xd1U, 0x00U, 0xedU, 0x20U, 0xfcU, 0xb1U, 0x5bU,\n    0x6aU, 0xcbU, 0xbeU, 0x39U, 0x4aU, 0x4cU, 0x58U, 0xcfU,\n    0xd0U, 0xefU, 0xaaU, 0xfbU, 0x43U, 0x4dU, 0x33U, 0x85U,\n    0x45U, 0xf9U, 0x02U, 0x7fU, 0x50U, 0x3cU, 0x9fU, 0xa8U,\n    0x51U, 0xa3U, 0x40U, 0x8fU, 0x92U, 0x9dU, 0x38U, 0xf5U,\n    0xbcU, 0xb6U, 0xdaU, 0x21U, 0x10U, 0xffU, 0xf3U, 0xd2U,\n    0xcdU, 0x0cU, 0x13U, 0xecU, 0x5fU, 0x97U, 0x44U, 0x17U,\n    0xc4U, 0xa7U, 0x7eU, 0x3dU, 0x64U, 0x5dU, 0x19U, 0x73U,\n    0x60U, 0x81U, 0x4fU, 0xdcU, 0x22U, 0x2aU, 0x90U, 0x88U,\n    0x46U, 0xeeU, 0xb8U, 0x14U, 0xdeU, 0x5eU, 0x0bU, 0xdbU,\n    0xe0U, 0x32U, 0x3aU, 0x0aU, 0x49U, 0x06U, 0x24U, 0x5cU,\n    0xc2U, 0xd3U, 0xacU, 0x62U, 0x91U, 0x95U, 0xe4U, 0x79U,\n    0xe7U, 0xc8U, 0x37U, 0x6dU, 0x8dU, 0xd5U, 0x4eU, 0xa9U,\n    0x6cU, 0x56U, 0xf4U, 0xeaU, 0x65U, 0x7aU, 0xaeU, 0x08U,\n    0xbaU, 0x78U, 0x25U, 0x2eU, 0x1cU, 0xa6U, 0xb4U, 0xc6U,\n    0xe8U, 0xddU, 0x74U, 0x1fU, 0x4bU, 0xbdU, 0x8bU, 0x8aU,\n    0x70U, 0x3eU, 0xb5U, 0x66U, 0x48U, 0x03U, 0xf6U, 0x0eU,\n    0x61U, 0x35U, 0x57U, 0xb9U, 0x86U, 0xc1U, 0x1dU, 0x9eU,\n    0xe1U, 0xf8U, 0x98U, 0x11U, 0x69U, 0xd9U, 0x8eU, 0x94U,\n    0x9bU, 0x1eU, 0x87U, 0xe9U, 0xceU, 0x55U, 0x28U, 0xdfU,\n    0x8cU, 0xa1U, 0x89U, 0x0dU, 0xbfU, 0xe6U, 0x42U, 0x68U,\n    0x41U, 0x99U, 0x2dU, 0x0fU, 0xb0U, 0x54U, 0xbbU, 0x16U\n};\nstatic const u32 rcon[] = {\n    0x01000000, 0x02000000, 0x04000000, 0x08000000,\n    0x10000000, 0x20000000, 0x40000000, 0x80000000,\n    0x1B000000, 0x36000000, /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */\n};\n\n/**\n * Expand the cipher key into the encryption key schedule.\n */\nint AES_set_encrypt_key (const unsigned char *userKey, const int bits,\n                         AES_KEY *key)\n{\n    u32 *rk;\n    int i = 0;\n    u32 temp;\n\n    if (!userKey || !key) {\n        return -1;\n    }\n    if (bits != 128 && bits != 192 && bits != 256) {\n        return -2;\n    }\n\n    rk = key->rd_key;\n\n    if (bits == 128) {\n        key->rounds = 10;\n    } else if (bits == 192) {\n        key->rounds = 12;\n    } else{\n        key->rounds = 14;\n    }\n\n    rk[0] = GETU32(userKey     );\n    rk[1] = GETU32(userKey +  4);\n    rk[2] = GETU32(userKey +  8);\n    rk[3] = GETU32(userKey + 12);\n    if (bits == 128) {\n        while (1) {\n            temp  = rk[3];\n            rk[4] = rk[0] ^\n                    (Te4[(temp >> 16) & 0xff] << 24) ^\n                    (Te4[(temp >>  8) & 0xff] << 16) ^\n                    (Te4[(temp      ) & 0xff] << 8) ^\n                    (Te4[(temp >> 24)       ]) ^\n                    rcon[i];\n            rk[5] = rk[1] ^ rk[4];\n            rk[6] = rk[2] ^ rk[5];\n            rk[7] = rk[3] ^ rk[6];\n            if (++i == 10) {\n                return 0;\n            }\n            rk += 4;\n        }\n    }\n    rk[4] = GETU32(userKey + 16);\n    rk[5] = GETU32(userKey + 20);\n    if (bits == 192) {\n        while (1) {\n            temp = rk[ 5];\n            rk[ 6] = rk[ 0] ^\n                     (Te4[(temp >> 16) & 0xff] << 24) ^\n                     (Te4[(temp >>  8) & 0xff] << 16) ^\n                     (Te4[(temp      ) & 0xff] << 8) ^\n                     (Te4[(temp >> 24)       ]) ^\n                     rcon[i];\n            rk[ 7] = rk[ 1] ^ rk[ 6];\n            rk[ 8] = rk[ 2] ^ rk[ 7];\n            rk[ 9] = rk[ 3] ^ rk[ 8];\n            if (++i == 8) {\n                return 0;\n            }\n            rk[10] = rk[ 4] ^ rk[ 9];\n            rk[11] = rk[ 5] ^ rk[10];\n            rk += 6;\n        }\n    }\n    rk[6] = GETU32(userKey + 24);\n    rk[7] = GETU32(userKey + 28);\n    if (bits == 256) {\n        while (1) {\n            temp = rk[ 7];\n            rk[ 8] = rk[ 0] ^\n                     (Te4[(temp >> 16) & 0xff] << 24) ^\n                     (Te4[(temp >>  8) & 0xff] << 16) ^\n                     (Te4[(temp      ) & 0xff] << 8) ^\n                     (Te4[(temp >> 24)       ]) ^\n                     rcon[i];\n            rk[ 9] = rk[ 1] ^ rk[ 8];\n            rk[10] = rk[ 2] ^ rk[ 9];\n            rk[11] = rk[ 3] ^ rk[10];\n            if (++i == 7) {\n                return 0;\n            }\n            temp = rk[11];\n            rk[12] = rk[ 4] ^\n                     (Te4[(temp >> 24)       ] << 24) ^\n                     (Te4[(temp >> 16) & 0xff] << 16) ^\n                     (Te4[(temp >>  8) & 0xff] << 8) ^\n                     (Te4[(temp      ) & 0xff]);\n            rk[13] = rk[ 5] ^ rk[12];\n            rk[14] = rk[ 6] ^ rk[13];\n            rk[15] = rk[ 7] ^ rk[14];\n\n            rk += 8;\n        }\n    }\n    return 0;\n}\n\n/**\n * Expand the cipher key into the decryption key schedule.\n */\nint AES_set_decrypt_key (const unsigned char *userKey, const int bits,\n                         AES_KEY *key)\n{\n\n    u32 *rk;\n    int i, j, status;\n    u32 temp;\n\n    /* first, start with an encryption schedule */\n    status = AES_set_encrypt_key(userKey, bits, key);\n    if (status < 0) {\n        return status;\n    }\n\n    rk = key->rd_key;\n\n    /* invert the order of the round keys: */\n    for (i = 0, j = 4 * (key->rounds); i < j; i += 4, j -= 4) {\n        temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;\n        temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\n        temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\n        temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\n    }\n    /* apply the inverse MixColumn transform to all round keys but the first and the last: */\n    for (i = 1; i < (key->rounds); i++) {\n        rk += 4;\n        for (j = 0; j < 4; j++) {\n            u32 tp1, tp2, tp4, tp8, tp9, tpb, tpd, tpe, m;\n\n            tp1 = rk[j];\n            m = tp1 & 0x80808080;\n            tp2 = ((tp1 & 0x7f7f7f7f) << 1) ^\n                  ((m - (m >> 7)) & 0x1b1b1b1b);\n            m = tp2 & 0x80808080;\n            tp4 = ((tp2 & 0x7f7f7f7f) << 1) ^\n                  ((m - (m >> 7)) & 0x1b1b1b1b);\n            m = tp4 & 0x80808080;\n            tp8 = ((tp4 & 0x7f7f7f7f) << 1) ^\n                  ((m - (m >> 7)) & 0x1b1b1b1b);\n            tp9 = tp8 ^ tp1;\n            tpb = tp9 ^ tp2;\n            tpd = tp9 ^ tp4;\n            tpe = tp8 ^ tp4 ^ tp2;\n#if defined(ROTATE)\n            rk[j] = tpe ^ ROTATE(tpd, 16) ^\n                    ROTATE(tp9, 24) ^ ROTATE(tpb, 8);\n#else\n            rk[j] = tpe ^ (tpd >> 16) ^ (tpd << 16) ^\n                    (tp9 >> 8) ^ (tp9 << 24) ^\n                    (tpb >> 24) ^ (tpb << 8);\n#endif\n        }\n    }\n    return 0;\n}\n\n#endif /* AES_ASM */\n\n\n} // namespace Aes128poetv1aes128_raw\n"
        },
        {
            "file_name": "aes128poetv1aes128_poet.cpp",
            "content": "#ifdef DEBUG\n#include<stdio.h>\n#endif\n\n#include <string.h>\n\n#include \"aes128poetv1aes128_poet.h\"\n#include \"aes128poetv1aes128_gf_mul.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Aes128poetv1aes128_raw {\n\n#define TOP_HASH     AES_encrypt(ctx->x, ctx->x, &(ctx->aes_lt))\n#define BOTTOM_HASH  AES_encrypt(ctx->y, ctx->y, &(ctx->aes_lb))\n\n\nvoid keysetup(struct poet_ctx *ctx, const uint8_t key[KEYLEN_BITS])\n{\n  uint8_t ctr[BLOCKLEN];\n  AES_KEY aes_enc;\n\n  memset(ctx->tau,0,BLOCKLEN);\n  memset(ctr,0, BLOCKLEN);\n\n  /* Generate block cipher key */\n  AES_set_encrypt_key(key, KEYLEN_BITS, &aes_enc);\n  AES_encrypt(ctr, ctx->k,  &aes_enc);\n\n  AES_set_encrypt_key(ctx->k, KEYLEN_BITS, &(ctx->aes_enc));\n  AES_set_decrypt_key(ctx->k, KEYLEN_BITS, &(ctx->aes_dec));\n\n  /* Generate header key */\n  ctr[BLOCKLEN-1]+=1; AES_encrypt(ctr, ctx->l,  &aes_enc);\n\n  /* Generate almost XOR universal hash function keys */\n  ctr[BLOCKLEN-1]+=1; AES_encrypt(ctr, ctx->lt,  &aes_enc);\n  ctr[BLOCKLEN-1]+=1; AES_encrypt(ctr, ctx->lb,  &aes_enc);\n  AES_set_encrypt_key(ctx->lt, KEYLEN_BITS, &(ctx->aes_lt));\n  AES_set_encrypt_key(ctx->lb, KEYLEN_BITS, &(ctx->aes_lb));\n\n  /* Generate tag masking keys */\n  ctr[BLOCKLEN-1]+=1; AES_encrypt(ctr, ctx->tm,  &aes_enc);\n\n}\n\n\n/***************************************************************************/\n/************************* XOR BLOCKS **************************************/\n/***************************************************************************/\n\n\ninline void xor_block(uint8_t *c, const uint8_t  *a, const uint8_t  *b)\n{\n  unsigned int i;\n  for(i=0; i<BLOCKLEN;i++) c[i] = a[i] ^ b[i];\n}\n\n\n\n/***************************************************************************/\n/********************* Process Header **************************************/\n/***************************************************************************/\n\n\nvoid process_header(struct poet_ctx *ctx, const uint8_t  *header,\n            uint64_t header_len )\n{\n  block mask;\n  block factor;\n  block in;\n  block out;\n  block product;\n  uint64_t offset=0;\n\n  ctx->mlen=0;\n  memset(factor,0,BLOCKLEN);\n  memset(product,0,BLOCKLEN);\n  memset(mask,0,BLOCKLEN);\n  memset(ctx->tau,0,BLOCKLEN);\n\n  product[0] = 0x80; // since 1000 0000 = 1\n  factor[0]  = 0x40; // since 0100 0000 = 2\n\n  while(header_len > BLOCKLEN)\n    {\n      gf_mul(mask, product, ctx->l);\n      xor_block(in,header+offset,mask);\n      AES_encrypt(in,out,&(ctx->aes_enc));\n      xor_block(ctx->tau,out,ctx->tau);\n\n      offset += BLOCKLEN;\n      header_len -= BLOCKLEN;\n\n      gf_mul(product,product,factor);\n    }\n\n  /* LASTBLOCK */\n  if(header_len < 16)\n    {\n      factor[0]=0xA0; // 1010 0000 = 5 in Big Endian\n      memset(in,0,BLOCKLEN);\n      memcpy(in,header+offset,header_len);\n      in[header_len]=0x80;\n    }\n  else\n    {\n      factor[0]=0xC0; // 1100 0000 = 3 in Big Endian\n      memcpy(in,header+offset,BLOCKLEN);\n    }\n\n  gf_mul(product,product,factor);\n  gf_mul(mask,product,ctx->l);\n  xor_block(in,mask,in);\n\n  xor_block(in,in,ctx->tau);\n  AES_encrypt(in ,ctx->tau, &(ctx->aes_enc));\n\n  memcpy(ctx->x, ctx->tau, BLOCKLEN);\n  memcpy(ctx->y, ctx->tau, BLOCKLEN);\n}\n\n\n\n/***************************************************************************/\n/********************* Encrypt block ***************************************/\n/***************************************************************************/\n\nvoid encrypt_block(struct poet_ctx *ctx, const uint8_t plaintext[16],\n           uint8_t ciphertext[16])\n{\n  block tmp;\n  TOP_HASH;\n  xor_block(ctx->x, plaintext,ctx->x);\n\n  AES_encrypt(ctx->x, tmp, &(ctx->aes_enc)); // in, out, key\n\n  BOTTOM_HASH;\n  xor_block(ciphertext, tmp,ctx->y); // result, a, b\n\n  memcpy(ctx->y, tmp, BLOCKLEN);\n  ctx->mlen+=BLOCKLEN_BITS;\n}\n\n/***************************************************************************/\n/********************* Encrypt final ***************************************/\n/***************************************************************************/\n\nvoid encrypt_final(struct poet_ctx *ctx, const uint8_t *plaintext,\n           uint64_t plen, uint8_t *ciphertext, uint8_t tag[BLOCKLEN])\n{\n#ifdef DEBUG\n  int i;\n#endif\n  uint64_t offset=0;\n  uint64_t len;\n  block s;\n  block tmp;\n  block tmp2;\n\n  while( plen > BLOCKLEN )\n    {\n      encrypt_block(ctx,  (plaintext+offset), (ciphertext+offset));\n      plen   -= BLOCKLEN;\n      offset += BLOCKLEN;\n    }\n\n  /* Encrypt length of message */\n  ctx->mlen+=(plen*8);\n  memset(s,0,BLOCKLEN);\n  len =  TO_LITTLE_ENDIAN_64(ctx->mlen);\n  memcpy(s, &len,8);\n\n  AES_encrypt(s, s ,&(ctx->aes_enc));\n\n  /* Last message block must be padded if necesscary */\n  memcpy(tmp,plaintext+offset,plen);\n  memcpy(tmp+plen,ctx->tau,BLOCKLEN-plen);\n\n\n  /* Process last block + tag generation */\n\n  TOP_HASH;\n  xor_block(tmp,s,tmp);\n  xor_block(ctx->x,tmp,ctx->x);\n\n  AES_encrypt(ctx->x, tmp, &(ctx->aes_enc));\n\n  BOTTOM_HASH;\n  xor_block(tmp2, tmp,ctx->y);\n  memcpy(ctx->y, tmp, BLOCKLEN);\n  xor_block(tmp,s,tmp2);\n\n\n#ifdef DEBUG\n  puts(\"S\"); for(i=0;i<16;i++) printf(\"%02x \",s[i]); puts(\"\");\n  puts(\"X\"); for(i=0;i<16;i++) printf(\"%02x \",ctx->x[i]); puts(\"\");\n  puts(\"Y\"); for(i=0;i<16;i++) printf(\"%02x \",ctx->y[i]); puts(\"\");\n#endif\n\n  /* Do tag splitting if needed */\n  memcpy(ciphertext+offset,tmp,plen);\n  memcpy(tag,tmp+plen,BLOCKLEN-plen);\n\n\n  /* Generate tag */\n  TOP_HASH;\n  xor_block(ctx->x, ctx->tau, ctx->x);\n  xor_block(ctx->x, ctx->tm, ctx->x);\n\n  AES_encrypt(ctx->x, tmp, &(ctx->aes_enc));\n\n  BOTTOM_HASH;\n  xor_block(tmp, ctx->y, tmp);\n  xor_block(tmp, ctx->tm, tmp);\n\n  memcpy(tag+(BLOCKLEN-plen),tmp,plen);\n\n}\n\n\n\n/***************************************************************************/\n/********************* Decrypt block ***************************************/\n/***************************************************************************/\n\nvoid decrypt_block(struct poet_ctx *ctx, const uint8_t ciphertext[16],\n           uint8_t plaintext[16])\n{\n  block tmp;\n  BOTTOM_HASH;\n  xor_block(ctx->y, ciphertext,ctx->y);\n\n  AES_decrypt(ctx->y, tmp, &(ctx->aes_dec));\n\n  TOP_HASH;\n  xor_block(plaintext, tmp,ctx->x);\n\n  memcpy(ctx->x, tmp, BLOCKLEN);\n  ctx->mlen+=BLOCKLEN_BITS;\n}\n\n\n/***************************************************************************/\n/********************* Decrypt final ***************************************/\n/***************************************************************************/\n\nint decrypt_final(struct poet_ctx *ctx, const uint8_t *ciphertext,\n           uint64_t clen, const uint8_t tag[BLOCKLEN],\n           uint8_t *plaintext)\n{\n#ifdef DEBUG\n  int i;\n#endif\n  uint64_t offset=0;\n  block s;\n  block tmp;\n  block tmp2;\n  int alpha;\n  int beta;\n  uint64_t len;\n\n  while( clen > BLOCKLEN )\n    {\n      decrypt_block(ctx, ciphertext+offset, plaintext+offset);\n      clen   -= BLOCKLEN;\n      offset += BLOCKLEN;\n    }\n\n  /* Encrypt length of message */\n  ctx->mlen+=(clen*8);\n  memset(s,0,BLOCKLEN);\n  len =  TO_LITTLE_ENDIAN_64(ctx->mlen);\n  memcpy(s, &len, 8);\n  AES_encrypt(s, s ,&(ctx->aes_enc));\n\n\n  /* Last ciphertext block must be padded if necesscary */\n  memcpy(tmp,ciphertext+offset,clen);\n  memcpy(tmp+clen,tag,BLOCKLEN-clen);\n\n\n  /* Process last block + tag generation */\n  BOTTOM_HASH;\n  xor_block(tmp,s,tmp);\n  xor_block(ctx->y, tmp,ctx->y);\n\n  AES_decrypt(ctx->y, tmp, &(ctx->aes_dec));\n\n  TOP_HASH;\n  xor_block(tmp2, tmp, ctx->x);\n  xor_block(tmp2, s, tmp2);\n  memcpy(ctx->x,tmp,BLOCKLEN);\n\n\n#ifdef DEBUG\n  puts(\"S\"); for(i=0;i<16;i++) printf(\"%02x \",s[i]); puts(\"\");\n  puts(\"X\"); for(i=0;i<16;i++) printf(\"%02x \",ctx->x[i]); puts(\"\");\n  puts(\"Y\"); for(i=0;i<16;i++) printf(\"%02x \",ctx->y[i]); puts(\"\");\n#endif\n\n  /* Do tag splitting if needed */\n  memcpy(plaintext+offset,tmp2,clen);\n\n  alpha = memcmp(tmp2+clen,ctx->tau,BLOCKLEN-clen);\n\n  /* Generate tag */\n  TOP_HASH;\n  xor_block(ctx->x, ctx->tau ,ctx->x);\n  xor_block(ctx->x, ctx->tm ,ctx->x);\n\n  AES_encrypt(ctx->x, tmp, &(ctx->aes_enc));\n\n  BOTTOM_HASH;\n  xor_block(tmp, ctx->y, tmp);\n  xor_block(tmp, ctx->tm, tmp);\n\n#ifdef DEBUG\n  puts(\"tmp\"); for(i=0;i<16;i++) printf(\"%02x \",tmp[i]); puts(\"\");\n  puts(\"tag\"); for(i=0;i<16;i++) printf(\"%02x \",tag[i]); puts(\"\");\n#endif\n\n  beta = memcmp(tmp,tag+(BLOCKLEN-clen),clen);\n\n  return alpha|beta;\n}\n\n\n} // namespace Aes128poetv1aes128_raw\n"
        },
        {
            "file_name": "aes256avalanchev1_avalanche.cpp",
            "content": "//-------------------------------------------------------------------------------\n//-- Title        : AVALANCHE\n//-- File         : AVALANCHE.c\n//-- Project      : aes256avalanchev1.1\n//-- Author       : C4C Development Team\n//-- Organization : King Abdulaziz City for Science and Technology (KACST)\n//-- Created      : 08.01.2014\n//-------------------------------------------------------------------------------\n//-- Description  : The starting point of the project (main) where it\n//\t\t\t\t\thandles the multiprocessing tasks.\n//-------------------------------------------------------------------------------\n//-- Copyright (C) KACST-C4C\n//-- All rights reserved. Reproduction in whole or part is prohibited\n//-- without the written permission of the copyright owner.\n//-------------------------------------------------------------------------------\n/*----------------- Header Files --------------------------*/\n#include \"aes256avalanchev1_avalanche.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Aes256avalanchev1_raw {\nint numRounds = -1;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// PCMACEnc - PCMAC part of avalanche (does the encryption and generate the PCMAC tag)\n//            * INPUT: plainText m, mlen, nonce npub, PCMACKey\n//            * OUTPUT: PCMACTag, cipherText c\n/////////////////////////////////////////////////////////////////////////////////////////////////\nvoid PCMACEnc(Chunk PCMACTag, unsigned char *c, unsigned long long *clen,\n        const unsigned char *m, unsigned long long mlen, unsigned char *nonce,\n        unsigned char *r, unsigned char *PCMACKey)\n{\n    int i, j;\n    unsigned long long numOfChunks = 0; //number of blocks/chunks to process in a message\n    Byte finalKey[kSIZE]; //array for the xored key\n\n    AESArguments *input;\n    AES_KEY key;\n\n    if (mlen % SIZE == 0)\n        numOfChunks = (unsigned long long) (mlen / SIZE) + 2; //length of plain message plus r+eot\n    else\n        numOfChunks = (unsigned long long) ceil((float) mlen / SIZE) + 1; //length of plain message plus r\n\n    input = (struct AES_Arguments*) malloc(\n            ((numOfChunks) + 1) * sizeof(struct AES_Arguments));\n\n    memset(input[numOfChunks].cipherText, 0, SIZE);\n\n    SetupForEnc(input, m, r, mlen, numOfChunks);\n\n    Increment(nonce);\n    for (i = 0; i < kSIZE; i++)\n        input[0].nonce[i] = nonce[i];\n    for (j = 1; j <= numOfChunks; j++)\n    {\n        Increment(nonce);\n        for (i = 0; i < kSIZE; i++)\n            input[j].nonce[i] = nonce[i];\n    }\n    for (j = 0; j < numOfChunks; j++)\n    {\n        XORKey(input[j].nonce, PCMACKey, finalKey);\n        AES_set_encrypt_key(finalKey, 256, &key);\n        AES_encrypt(input[j].plainText, input[j].cipherText, &key);\n    }\n\n    for (j = 0; j < mlen + CRYPTO_ABYTES - SIZE; j++)\n        c[j] = input[j / SIZE].cipherText[j % SIZE];\n\n    *clen = mlen + CRYPTO_ABYTES;\n\n    TagGeneration(m, r, PCMACTag, numOfChunks);\n\n    free(input);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// PCMACDec - PCMAC part of avalanche (does the decryption and generate the PCMAC tag)\n//            * INPUT: cipherText c, mlen, nonce npub, PCMACKey\n//            * OUTPUT: PCMACTag,  plainText m\n/////////////////////////////////////////////////////////////////////////////////////////////////\nint PCMACDec(Chunk PCMACTag, unsigned char *m, unsigned long long *mlen,\n        const unsigned char *c, unsigned long long clen, unsigned char *nonce,\n        unsigned char *PCMACKey)\n{\n    Byte finalKey[kSIZE]; //array for the xored key\n    int i, j; //counters\n    int isValid = -1; //not valid message (missing EOT)\n    int test = 0;\n    unsigned long long numOfChunks = 0; //number of blocks/chunks to process in a message\n    Chunk r;\n    AESArguments *input;\n    AES_KEY key;\n    numOfChunks = (unsigned long long) clen / SIZE;\n\n    input = (struct AES_Arguments*) malloc(\n            (numOfChunks + 1) * sizeof(struct AES_Arguments));\n\n    SetupForDec(input, c, numOfChunks);\n\n    for (j = 0; j < numOfChunks; j++)\n    {\n        Increment(nonce);\n\n        for (i = 0; i < SIZE; i++)\n        {\n            for (i = 0; i < kSIZE; i++)\n                input[j].nonce[i] = nonce[i];\n        }\n\n    }\n    for (j = 0; j < numOfChunks; j++) //decryption process\n    {\n        XORKey(input[j].nonce, PCMACKey, finalKey);\n\n        AES_set_decrypt_key(finalKey, 256, &key);\n        AES_decrypt(input[j].cipherText, input[j].plainText, &key);\n    }\n\n    for (j = 0; j < numOfChunks; j++) //to be edited\n        for (i = 0; i < SIZE; i++)\n            m[(j * SIZE) + i] = input[j + 1].plainText[i];\n\n    *mlen = clen - CRYPTO_ABYTES + SIZE;\n\n    if (m[*mlen] == EOT)\n        isValid = 0;\n\n    if (isValid != 0)\n    {\n        free(input);\n        return isValid;\n    }\n\n    memcpy(r, input[0].plainText, SIZE);\n\n    TagGeneration(m, r, PCMACTag, numOfChunks);\n\n    free(input);\n\n    return isValid;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// crypto_aead_encrypt - The code for the cipher implementation (encryption part) goes here.\n//            * INPUT: plaintext m , associated data ad,\n//\t\t\t\tsecret message number nsec, public message number or nonce npub,\n//\t\t\t\tand secret key k.\n//            * OUTPUT: ciphertext c\n/////////////////////////////////////////////////////////////////////////////////////////////////\nint crypto_aead_encrypt(unsigned char *c, unsigned long long *clen,\n        const unsigned char *m, unsigned long long mlen,\n        const unsigned char *ad, unsigned long long adlen,\n        const unsigned char *nsec, const unsigned char *npub,\n        const unsigned char *k)\n{\n    Byte PCMACKey[kSIZE];\n    Chunk RMACKey;\n    Chunk prime;\n    int i; //counter\n    Chunk PCMACTag; //tag of PCMAC\n    Chunk RMACTag; //tag of RMAC\n    Chunk r;\n    Byte nonce[kSIZE] =\n    { 0 };\n    unsigned long long numOfChunks = (unsigned long long) ceil(\n            (float) mlen / SIZE) + 2; //length of plain message plus r plus tag\n\n    for (i = 0; i < kSIZE; i++)\n        PCMACKey[i] = k[i];\n\n    for (i = 0; i < SIZE; i++)\n    {\n        RMACKey[i] = k[i + kSIZE];\n        prime[i] = k[i + SIZE + kSIZE];\n        r[i] = npub[i];\n    }\n    for (i = SIZE; i < CRYPTO_NPUBBYTES; i++)\n        nonce[i - SIZE] = npub[i];\n\n    PCMACEnc(PCMACTag, c, clen, m, mlen, nonce, r, PCMACKey);\n\n    Sign(prime, RMACKey, ad, adlen, RMACTag);\n\n    ModularAddition(RMACTag, PCMACTag);\n\n    for (i = 0; i < SIZE; i++)\n        c[*clen - SIZE + i] = RMACTag[i];\n\n    return 0;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// crypto_aead_decrypt -The code for the cipher implementation (decryption part) goes here.\n//            * INPUT: ciphertext c,associated data ad,\n//\t\t\t\tpublic message number or nonce npub, and secret key k.\n//            * OUTPUT: plaintext m\n/////////////////////////////////////////////////////////////////////////////////////////////////\nint crypto_aead_decrypt(unsigned char *m, unsigned long long *mlen,\n        unsigned char *nsec, const unsigned char *c, unsigned long long clen,\n        const unsigned char *ad, unsigned long long adlen,\n        const unsigned char *npub, const unsigned char *k)\n{\n    int i;\n    int isValid = -1; //not valid message\n    Byte PCMACKey[kSIZE];\n    Chunk RMACKey;\n    Chunk prime;\n    Chunk PCMACTag; //tag of PCMAC\n    Chunk RMACTag; //tag of RMAC\n    Chunk tagFromCipher; // tag retrieved from the cipher\n    Byte nonce[kSIZE] =\n    { 0 };\n    for (i = 0; i < SIZE; i++)\n        tagFromCipher[i] = c[clen - SIZE + i];\n\n    clen -= SIZE; //actual clen without the tag\n\n    for (i = 0; i < kSIZE; i++)\n        PCMACKey[i] = k[i];\n\n    for (i = 0; i < SIZE; i++)\n    {\n        RMACKey[i] = k[i + kSIZE];\n        prime[i] = k[i + SIZE + kSIZE];\n    }\n\n    for (i = SIZE; i < CRYPTO_NPUBBYTES; i++)\n        nonce[i - SIZE] = npub[i];\n    isValid = PCMACDec(PCMACTag, m, mlen, c, clen, nonce, PCMACKey);\n\n    if (isValid != 0)\n        return isValid;\n\n    Sign(prime, RMACKey, ad, adlen, RMACTag);\n\n    ModularAddition(RMACTag, PCMACTag);\n\n    isValid = Verify(RMACTag, tagFromCipher);\n\n    return isValid;\n}\n\n} // namespace Aes256avalanchev1_raw\n"
        },
        {
            "file_name": "aes256cpfbv1_encrypt.cpp",
            "content": "/*\n *  CPFB version 1.0\n * @author Miguel Montes\n * @author Daniel Penazzi\n *\n * To the extent possible under law, the authors have waived all copyright\n * and related or neighboring rights to the source code in this file.\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n/* Notes about this version\n * This is the reference version, and it uses AES as provided by\n * the crypto_core library.\n */\n\n#include \"aes256cpfbv1_encrypt.h\"\n#include \"aes256cpfbv1_api.h\"\n// CHANGE include commented out, typedef created instead (cinttypes necessary to add)\n// #include \"crypto_uint32.h\"\n#include <cinttypes>\ntypedef uint32_t crypto_uint32;\n\n#define BLOCK_LENGTH 16\n\n#if CRYPTO_KEYBYTES == 16\n#define KEYBITS 128\n#define KEY_LENGTH 16\n// CHANGE crypto_code include changed to caesar common API\n// #include \"crypto_core_aes128encrypt.h\"\n#include \"../../common/api.h\"\n// CHANGE namespace added\n// #define AES_encrypt(in,out,key) crypto_core_aes128encrypt(out,in,key,0)\n#define AES_encrypt(in,out,key) CaesarCommon::crypto_core_aes128encrypt(out,in,key,0)\n#elif CRYPTO_KEYBYTES == 32\n#define KEYBITS 256\n#define KEY_LENGTH 32\n// CHANGE crypto_code include changed to caesar common API\n// #include \"crypto_core_aes256encrypt.h\"\n#include \"../../common/api.h\"\n// CHANGE namespace added\n// #define AES_encrypt(in,out,key) crypto_core_aes256encrypt(out,in,key,0)\n#define AES_encrypt(in,out,key) CaesarCommon::crypto_core_aes256encrypt(out,in,key,0)\n#else\n#error \"Unknown Key Length\"\n#endif\n\n#if CRYPTO_ABYTES <= 16\n#define TAG_LENGTH CRYPTO_ABYTES\n#else\n#error \"BAD TAG LENGTH\"\n#endif\n\n\n#if CRYPTO_NPUBBYTES >= 8 && CRYPTO_NPUBBYTES <= 15\n#define NONCE_LENGTH CRYPTO_NPUBBYTES\n#define NONCE_TYPE (CRYPTO_NPUBBYTES-8)\n#define NONCE_INCREMENT 8\n#else\n#error \"BAD NONCE LENGTH\"\n#endif\n\n// CHANGE namespace moved due to includes\nnamespace Aes256cpfbv1_raw {\nint numRounds = -1;\n\nstatic void store32(unsigned char *x, unsigned long long u)\n{\n    int i;\n    for (i = 3; i >= 0; --i) {\n    x[i] = (unsigned char)u;\n    u >>= 8;\n    }\n}\n\nstatic void store64(unsigned char *x, unsigned long long u)\n{\n    int i;\n    for (i = 7; i >= 0; --i) {\n    x[i] = (unsigned char)u;\n    u >>= 8;\n    }\n}\n\n\nstatic int verify_tag(const unsigned char* a, const unsigned char* b){\n  int i;\n  unsigned char res = 0;\n  for (i=0; i < TAG_LENGTH; i++)\n    res |= a[i] ^ b[i];\n  return res == 0 ? 0 : -1;\n}\n\n\n\nstatic void xor128(const unsigned char* a, const unsigned char* b, unsigned char* x){\n  int i;\n  for (i = 0; i < 16; i++)\n    x[i] = a[i] ^ b[i];\n}\n\n\n\nstatic void init_nonce(unsigned char* nonce, const unsigned char* npub){\n    int i;\n    for (i = 0; i < NONCE_LENGTH; ++i)\n    nonce[i] = npub[i];\n    for (i = NONCE_LENGTH; i < BLOCK_LENGTH -1; i++)\n      nonce[i] = 0;\n    nonce[BLOCK_LENGTH -1] = (unsigned char) NONCE_TYPE;\n}\n\nstatic void inc_nonce(unsigned char* nonce){\n  int i;\n  nonce[BLOCK_LENGTH -1] = (unsigned char)(nonce[BLOCK_LENGTH -1] + NONCE_INCREMENT);\n  if (nonce[BLOCK_LENGTH-1] != NONCE_TYPE) return;\n  for (i = BLOCK_LENGTH-2; i >= NONCE_LENGTH; i--)\n    if (++nonce[i]) return;\n}\n\n\nstatic void gen_kappa(const unsigned char* nonce, unsigned char* kappa, const unsigned char* key){\n    AES_encrypt(nonce,kappa,key);\n#if KEYBITS == 256\n    AES_encrypt(kappa,kappa+16,key);\n#endif\n}\n\n\nint crypto_aead_encrypt(unsigned char *c, unsigned long long *clen,\n            const unsigned char *m, unsigned long long mlen,\n            const unsigned char *ad, unsigned long long adlen,\n            const unsigned char *nsec,\n            const unsigned char *npub, const unsigned char *k)\n{\n    unsigned char kappa_0[KEY_LENGTH];\n    unsigned char kappa_m[KEY_LENGTH];\n    unsigned char nonce[BLOCK_LENGTH];\n    unsigned char X[BLOCK_LENGTH];\n    unsigned char P[BLOCK_LENGTH];\n    unsigned char stream[BLOCK_LENGTH];\n    unsigned long long i;\n    crypto_uint32 counter;\n    (void)nsec; /* avoid warning */\n\n    *clen = mlen + TAG_LENGTH;\n\n\n    /* Generation of the first kappa */\n    init_nonce(nonce,npub);\n    gen_kappa(nonce, kappa_0, k);\n\n    /* Block encoding alen and mlen\n     * In an online implementation, it would be done at the end, and X would be 0\n     */\n    store64(X, mlen);\n    store32(X + 8, adlen);\n    store32(X + 12, 0);\n    AES_encrypt(X, X, kappa_0);\n\n    /* AD processing */\n    counter = 0;\n    while (adlen > 0) {\n    unsigned long long blocklen = 12;\n    if (adlen < blocklen)\n        blocklen = adlen;\n    for (i = 0; i < blocklen; i++)\n        P[i] = ad[i];\n    for (i = blocklen; i < 12; i++)\n        P[i] = 0;\n    ++counter;\n    store32(P + 12, counter);\n    AES_encrypt(P, stream, kappa_0);\n    xor128(X, stream, X);\n    ad += blocklen;\n    adlen -= blocklen;\n    }\n\n    /* Plaintext processing */\n    if (mlen > 0) {\n    /* New kappa */\n        inc_nonce(nonce);\n    gen_kappa(nonce, kappa_m, k);\n\n    counter = 0;\n\n    /* P_0 processing */\n    for (i = 0; i < BLOCK_LENGTH; i++)\n        P[i] = kappa_0[i]; /* This is P[i] = 0 ^ kappa_0[i] */\n    AES_encrypt(P, stream, kappa_m);\n\n    while (mlen > 0) {\n        unsigned long long blocklen = 12;\n        if (mlen < blocklen)\n        blocklen = mlen;\n        for (i = 0; i < blocklen; ++i) {\n        P[i] = m[i];\n        c[i] = m[i] ^ stream[i];\n        }\n        for (i = blocklen; i < 12; i++)\n        P[i] = 0;\n        ++counter;\n        if(counter == 0){\n            /* If the counter is zero, we have processed 2**32 blocks\n         * We need to generate a new kappa */\n        inc_nonce(nonce);\n        gen_kappa(nonce, kappa_m, k);\n        }\n        store32(P + 12, counter);\n        xor128(P, kappa_0, P);\n        AES_encrypt(P, stream, kappa_m);\n        xor128(X, stream, X);\n        c += blocklen;\n        m += blocklen;\n        mlen -= blocklen;\n    }\n    }\n    AES_encrypt(X, X, kappa_0);\n    for (i = 0; i < TAG_LENGTH; i++)\n    c[i] = X[i];\n    return 0;\n}\n\n\nint crypto_aead_decrypt(unsigned char *m, unsigned long long *outputmlen,\n            unsigned char *nsec,\n            const unsigned char *c, unsigned long long clen,\n            const unsigned char *ad, unsigned long long adlen,\n            const unsigned char *npub, const unsigned char *k)\n{\n    unsigned char kappa_0[KEY_LENGTH];\n    unsigned char kappa_m[KEY_LENGTH];\n    unsigned char nonce[BLOCK_LENGTH];\n    unsigned char X[BLOCK_LENGTH];\n    unsigned char P[BLOCK_LENGTH];\n    unsigned char stream[BLOCK_LENGTH];\n    unsigned long long i;\n    crypto_uint32 counter;\n    unsigned long long mlen;\n\n    (void)nsec; /* avoid warning */\n\n    if (clen < TAG_LENGTH)\n    return -1;\n    *outputmlen = mlen = clen - TAG_LENGTH;\n\n\n    /* Generation of the first kappa */\n    init_nonce(nonce,npub);\n    gen_kappa(nonce, kappa_0, k);\n\n    /* Block encoding alen and mlen\n     * In an online implementation, it would be done at the end, and X would be 0\n     */\n    store64(X, mlen);\n    store32(X + 8, adlen);\n    store32(X + 12, 0);\n    AES_encrypt(X, X, kappa_0);\n\n    /* AD processing */\n    counter = 0;\n    while (adlen > 0) {\n    unsigned long long blocklen = 12;\n    if (adlen < blocklen)\n        blocklen = adlen;\n    for (i = 0; i < blocklen; i++)\n        P[i] = ad[i];\n    for (i = blocklen; i < 12; i++)\n        P[i] = 0;\n    ++counter;\n    store32(P + 12, counter);\n    AES_encrypt(P, stream, kappa_0);\n    xor128(X, stream, X);\n    ad += blocklen;\n    adlen -= blocklen;\n    }\n\n\n    /* Plaintext processing */\n    if (mlen > 0) {\n    /* New kappa */\n        inc_nonce(nonce);\n    gen_kappa(nonce, kappa_m, k);\n\n    counter = 0;\n\n    /* P_0 processing */\n    for (i = 0; i < BLOCK_LENGTH; i++)\n        P[i] = kappa_0[i];\n    AES_encrypt(P, stream, kappa_m);\n\n    while (mlen > 0) {\n        unsigned long long blocklen = 12;\n        if (mlen < blocklen)\n        blocklen = mlen;\n        for (i = 0; i < blocklen; ++i) {\n        m[i] = c[i] ^ stream[i];\n        P[i] = m[i];\n        }\n        for (i = blocklen; i < 12; i++)\n        P[i] = 0;\n        ++counter;\n        if(counter == 0){\n        /* We need to generate a new kappa */\n        inc_nonce(nonce);\n        gen_kappa(nonce, kappa_m, k);\n        }\n        store32(P + 12, counter);\n        xor128(P, kappa_0, P);\n        AES_encrypt(P, stream, kappa_m);\n        xor128(X, stream, X);\n        c += blocklen;\n        m += blocklen;\n        mlen -= blocklen;\n    }\n    }\n    AES_encrypt(X, X, kappa_0);\n    return verify_tag(c,X);\n}\n\n} // namespace Aes256cpfbv1_raw\n"
        },
        {
            "file_name": "aes256gcmv1_encrypt.cpp",
            "content": "#include \"aes256gcmv1_encrypt.h\"\n// CHANGE api included instead of crypto core headers\n#include \"../../common/api.h\"\n// #include \"crypto_verify_16.h\"\n// #include \"crypto_core_aes256encrypt.h\"\n// CHANGE namespace added\n#define AES(out,in,k) CaesarCommon::crypto_core_aes256encrypt(out,in,k,0)\n\n// CHANGE namespace moved due to includes\nnamespace Aes256gcmv1_raw {\nint numRounds = -1;\n\nstatic void store32(unsigned char *x,unsigned long long u)\n{\n  int i;\n  for (i = 3;i >= 0;--i) { x[i] = u; u >>= 8; }\n}\n\nstatic void store64(unsigned char *x,unsigned long long u)\n{\n  int i;\n  for (i = 7;i >= 0;--i) { x[i] = u; u >>= 8; }\n}\n\n/*\na = (a + x) * y in the finite field\n16 bytes in a\nxlen bytes in x; xlen <= 16; x is implicitly 0-padded\n16 bytes in y\n*/\nstatic void addmul(unsigned char *a,\n  const unsigned char *x,unsigned long long xlen,\n  const unsigned char *y)\n{\n  int i;\n  int j;\n  unsigned char abits[128];\n  unsigned char ybits[128];\n  unsigned char prodbits[256];\n  for (i = 0;i < xlen;++i) a[i] ^= x[i];\n  for (i = 0;i < 128;++i) abits[i] = (a[i / 8] >> (7 - (i % 8))) & 1;\n  for (i = 0;i < 128;++i) ybits[i] = (y[i / 8] >> (7 - (i % 8))) & 1;\n  for (i = 0;i < 256;++i) prodbits[i] = 0;\n  for (i = 0;i < 128;++i)\n    for (j = 0;j < 128;++j)\n      prodbits[i + j] ^= abits[i] & ybits[j];\n  for (i = 127;i >= 0;--i) {\n    prodbits[i] ^= prodbits[i + 128];\n    prodbits[i + 1] ^= prodbits[i + 128];\n    prodbits[i + 2] ^= prodbits[i + 128];\n    prodbits[i + 7] ^= prodbits[i + 128];\n    prodbits[i + 128] ^= prodbits[i + 128];\n  }\n  for (i = 0;i < 16;++i) a[i] = 0;\n  for (i = 0;i < 128;++i) a[i / 8] |= (prodbits[i] << (7 - (i % 8)));\n}\n\nstatic unsigned char zero[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n\nint crypto_aead_encrypt(\n  unsigned char *c,unsigned long long *clen,\n  const unsigned char *m,unsigned long long mlen,\n  const unsigned char *ad,unsigned long long adlen,\n  const unsigned char *nsec,\n  const unsigned char *npub,\n  const unsigned char *k\n)\n{\n  unsigned char kcopy[32];\n  unsigned char H[16];\n  unsigned char J[16];\n  unsigned char T[16];\n  unsigned char accum[16];\n  unsigned char stream[16];\n  unsigned char finalblock[16];\n  unsigned long long i;\n  unsigned long long index;\n\n  for (i = 0;i < 32;++i) kcopy[i] = k[i];\n\n  *clen = mlen + 16;\n  store64(finalblock,8 * adlen);\n  store64(finalblock + 8,8 * mlen);\n\n  AES(H,zero,kcopy);\n\n  for (i = 0;i < 12;++i) J[i] = npub[i];\n  index = 1;\n  store32(J + 12,index);\n  AES(T,J,kcopy);\n\n  for (i = 0;i < 16;++i) accum[i] = 0;\n\n  while (adlen > 0) {\n    unsigned long long blocklen = 16;\n    if (adlen < blocklen) blocklen = adlen;\n    addmul(accum,ad,blocklen,H);\n    ad += blocklen;\n    adlen -= blocklen;\n  }\n\n  while (mlen > 0) {\n    unsigned long long blocklen = 16;\n    if (mlen < blocklen) blocklen = mlen;\n    ++index;\n    store32(J + 12,index);\n    AES(stream,J,kcopy);\n    for (i = 0;i < blocklen;++i) c[i] = m[i] ^ stream[i];\n    addmul(accum,c,blocklen,H);\n    c += blocklen;\n    m += blocklen;\n    mlen -= blocklen;\n  }\n\n  addmul(accum,finalblock,16,H);\n  for (i = 0;i < 16;++i) c[i] = T[i] ^ accum[i];\n  return 0;\n}\n\nint crypto_aead_decrypt(\n  unsigned char *m,unsigned long long *outputmlen,\n  unsigned char *nsec,\n  const unsigned char *c,unsigned long long clen,\n  const unsigned char *ad,unsigned long long adlen,\n  const unsigned char *npub,\n  const unsigned char *k\n)\n{\n  unsigned char kcopy[32];\n  unsigned char H[16];\n  unsigned char J[16];\n  unsigned char T[16];\n  unsigned char accum[16];\n  unsigned char stream[16];\n  unsigned char finalblock[16];\n  unsigned long long mlen;\n  unsigned long long origmlen;\n  unsigned long long index;\n  unsigned long long i;\n  const unsigned char *origc;\n\n  for (i = 0;i < 32;++i) kcopy[i] = k[i];\n\n  if (clen < 16) return -1;\n  mlen = clen - 16;\n\n  store64(finalblock,8 * adlen);\n  store64(finalblock + 8,8 * mlen);\n\n  AES(H,zero,kcopy);\n\n  for (i = 0;i < 12;++i) J[i] = npub[i];\n  index = 1;\n  store32(J + 12,index);\n  AES(T,J,kcopy);\n\n  for (i = 0;i < 16;++i) accum[i] = 0;\n\n  while (adlen > 0) {\n    unsigned long long blocklen = 16;\n    if (adlen < blocklen) blocklen = adlen;\n    addmul(accum,ad,blocklen,H);\n    ad += blocklen;\n    adlen -= blocklen;\n  }\n\n  origc = c;\n  origmlen = mlen;\n  while (mlen > 0) {\n    unsigned long long blocklen = 16;\n    if (mlen < blocklen) blocklen = mlen;\n    addmul(accum,c,blocklen,H);\n    c += blocklen;\n    mlen -= blocklen;\n  }\n\n  addmul(accum,finalblock,16,H);\n  for (i = 0;i < 16;++i) accum[i] ^= T[i];\n  // CHANGE namespace added\n  if (CaesarCommon::crypto_verify_16(accum,c) != 0) return -1;\n\n  c = origc;\n  mlen = origmlen;\n  *outputmlen = mlen;\n\n  while (mlen > 0) {\n    unsigned long long blocklen = 16;\n    if (mlen < blocklen) blocklen = mlen;\n    ++index;\n    store32(J + 12,index);\n    AES(stream,J,kcopy);\n    for (i = 0;i < blocklen;++i) m[i] = c[i] ^ stream[i];\n    c += blocklen;\n    m += blocklen;\n    mlen -= blocklen;\n  }\n\n  return 0;\n}\n\n} // namespace Aes256gcmv1_raw\n"
        },
        {
            "file_name": "aes256otrsv1_OTR.cpp",
            "content": "/* Copyright (c) 2014, NEC Corporation. All rights reserved.\n*\n* LICENSE\n*\n* 1. NEC Corporation (\"NEC\") hereby grants users to use and reproduce\n*AES-OTR program (\"Software\") for testing and evaluation purpose for\n*CAESAR (Competition for Authenticated Encryption: Security, Applicability,\n*and Robustness). The users must not use the Software for any other purpose\n*or distribute it to any third party.\n*\n* 2. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n*OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n*FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL NEC\n*BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, OR CONSEQUENTIAL\n*DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n*ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OF THE\n*SOFTWARE.\n*\n* 3. In the event of an user's failure to comply with any term of this License\n*or wrongful act, NEC may terminate such user's use of the Software. Upon such\n*termination the user must cease all use of the Software and destroy all copies\n*of the Software.\n*\n* 4. The users shall comply with all applicable laws and regulations, including\n*export and import control laws, which govern the usage of the Software.\n*/\n#include <string.h>\n#include \"aes256otrsv1_t-aes_define.h\"\n#include \"aes256otrsv1_OTR.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Aes256otrsv1_raw {\n\n/* AES functions */\nextern int KeySchedule(int skeylen, int mode, const uint8 *skey);\nextern int Encryption(int skeylen, uint8 *plain, uint8 *cipher);\n\n/* basic internal functions */\nstatic void ozp(uint32 length, const uint8 *in, uint8 *out);\nstatic void mul2(const uint8 *in, uint8 *out);\n// CHANGE 'xor' renamed to 'xor2' (xor is an alternative token in C++ and cannot be redefined)\nstatic void xor2(const uint8 *x, const uint8 *y, uint8 *z);\nstatic void xorp(uint32 length, const uint8 *x, const uint8 *y, uint8 *z);\n\n/* internal variables */\nuint8\tQ[BLOCK]={0}, Q2[BLOCK]={0}, Qd[BLOCK]={0};\nuint8\tTE[BLOCK]={0}, TA[BLOCK]={0};\nuint8\tL[BLOCK]={0}, Ld[BLOCK]={0};\n\n/*\n Setup : AES (enc) key schedule and generate authentication masks\n*/\nint Setup(const uint8 *skey)\n{\n    uint8 cst[16] = {0};\n\n    KeySchedule(KeyLen, ENC, skey);\n    Encryption(KeyLen, cst, Q);\n    mul2(Q, Q2); /* Q2 = 2Q */\n    mul2(Q2, Qd); /* Qd = 4Q */\n    return SUCCESS;\n}\n/*\n nEnc : nonce encryption and mask generation (L, Ld)\n needs TA when ADP=s\n */\nint nEnc(const uint8 *nonce, uint32 nonce_len){\n    uint8 tmp[BLOCK]={0};\n\n    ozp(nonce_len, nonce, tmp);\n    Encryption(KeyLen, tmp, L);\t// L = E(N10*)\n    if(ADP==Seri){\n        xor2(L,TA,L); // L ^= TA\n    }\n    mul2(L, Ld);\n    mul2(Ld, Ld);\n    return SUCCESS;\n}\n\n/*\n EFunc : OTR Core Encryption Function\n*/\nint EFunc(\n          const uint8 *nonce,\n          uint32 nonce_len,\n          const uint8 *plaintext,\n          uint32 pl_len,\n          uint8 *ciphertext)\n{\n    uint32 i,j = 0;\n    uint32 ell=0; //number of 2BLOCK-byte chunks, excl. last one\n    uint32 last=0; //number of bytes in the last chunks\n\n    uint8 tmp[BLOCK], LdL[BLOCK], Llast[BLOCK], Z[BLOCK];\n    uint8 Sum[BLOCK]={0};\n\n    if(pl_len != 0){\n        last = pl_len % DBLOCK;\n        if(last == 0) last = DBLOCK;\n        ell = (pl_len-last) / DBLOCK; // plaintext length = 2BLOCK*ell + last (non-zero)\n    }\n//\telse{ ell=0; last=0;}\n\n    nEnc(nonce, nonce_len);\n\n    /* 2-round Feistel for the full chunks */\n    for(i = 0; i < ell; i++, j = j+DBLOCK){\n        xor2(Ld,plaintext+j,tmp);\n        Encryption(KeyLen, tmp, tmp);\n        xor2(tmp,plaintext+(j+BLOCK),ciphertext+j);\n        xor2(Ld,L,LdL);\n        xor2(LdL,ciphertext+j,tmp);\n        Encryption(KeyLen, tmp, tmp);\n        xor2(tmp,plaintext+j,ciphertext+(j+BLOCK));\n        xor2(Sum,plaintext+(j+BLOCK),Sum);\n        mul2(Ld,Ld); // Ld = 2Ld\n    }\n    /* Last chunk */\n    if(last <= BLOCK){ \t//odd block, including the case pl_len = 0 (no plaintext)\n        Encryption(KeyLen, Ld, Z);\n        xorp(last, Z,plaintext+j,ciphertext+j);\n        ozp(last,plaintext+j,tmp);\n        xor2(tmp,Sum,Sum);\n        memcpy(Llast,Ld,BLOCK); //Llast=Ld\n    }\n    else{//even blocks, last > BLOCK always holds. 2-round Feistel with last swap\n        xor2(Ld,plaintext+j,tmp);\n        Encryption(KeyLen,tmp,Z);\n        xorp(last-BLOCK,Z,plaintext+(j+BLOCK),ciphertext+(j+BLOCK));\n        xor2(Ld,L,Llast); // Llast = Ld xor L\n        ozp(last-BLOCK,ciphertext+(j+BLOCK),tmp);\n        xor2(Sum,tmp,Sum);\n        xor2(Sum,Z,Sum);\n        xor2(Llast,tmp,tmp);\n        Encryption(KeyLen,tmp,tmp);\n        xor2(tmp,plaintext+j,ciphertext+j);\n    }\n    /* TE generation */\n    mul2(Llast,tmp);\n    xor2(Llast,tmp,Llast); //Llast = 3Llast\n    xor2(Sum,Llast,Sum);\t//Sum = 3Llast xor Sum\n    if(last == BLOCK || last == DBLOCK){//last = 16 or 32\n        xor2(Sum,L,Sum);\n    }\n    Encryption(KeyLen,Sum,TE);\n    return SUCCESS;\n}\n\n/*\n DFunc : OTR Core Decryption Function\n */\nint DFunc(\n          const uint8 *nonce,\n          uint32 nonce_len,\n          const uint8 *ciphertext,\n          uint32 ci_len,\n          uint8 *plaintext)\n{\n    uint32 i,j = 0;\n    uint32 ell=0; //number of 2BLOCK-byte chunks, excl. last one\n    uint32 last=0; //number of bytes in the last chunks\n\n    uint8 tmp[BLOCK], LdL[BLOCK], Llast[BLOCK], Z[BLOCK];\n    uint8 Sum[BLOCK]={0};\n\n    if(ci_len != 0){\n        last = ci_len % DBLOCK;\n        if(last == 0) last = DBLOCK;\n        ell = (ci_len-last) / DBLOCK; // plaintext length = 2BLOCK*ell + last (non-zero)\n    }\n//\telse{ ell=0; last=0;}\n\n    nEnc(nonce, nonce_len);\n\n    /* 2-round Feistel for the full chunks */\n    for(i = 0; i < ell; i++, j=j+DBLOCK){\n        xor2(Ld,L,LdL);\n        xor2(LdL,ciphertext+j,tmp);\n        Encryption(KeyLen, tmp, tmp);\n        xor2(tmp,ciphertext+(j+BLOCK),plaintext+j);\n        xor2(Ld,plaintext+j,tmp);\n        Encryption(KeyLen, tmp, tmp);\n        xor2(tmp,ciphertext+j,plaintext+(j+BLOCK));\n        xor2(Sum,plaintext+(j+BLOCK),Sum);\n        mul2(Ld,Ld); // Ld = 2Ld\n    }\n    /* Last chunk */\n    if(last <= BLOCK){ \t//odd block, including the case pl_len = 0 (no plaintext)\n        Encryption(KeyLen, Ld, Z);\n        xorp(last, Z,ciphertext+j,plaintext+j);\n        ozp(last,plaintext+j,tmp);\n        xor2(tmp,Sum,Sum);\n        memcpy(Llast,Ld,BLOCK); //Llast = Ld\n    }\n    else{//even blocks, last > BLOCK always holds. 2-round Feistel with last swap\n        xor2(Ld,L,Llast); //Llast = Ld xor L\n        ozp(last-BLOCK,ciphertext+(j+BLOCK),tmp);\n        xor2(Sum,tmp,Sum);\n        xor2(Llast,tmp,tmp);\n        Encryption(KeyLen,tmp,tmp);\n        xor2(tmp,ciphertext+j,plaintext+j);\n        xor2(Ld,plaintext+j,tmp);\n        Encryption(KeyLen,tmp,Z);\n        xorp(last-BLOCK,Z,ciphertext+(j+BLOCK),plaintext+(j+BLOCK));\n        xor2(Sum,Z,Sum);\n    }\n    /* TE generation */\n    mul2(Llast,tmp);\n    xor2(Llast,tmp,Llast); //Llast = 3Llast\n    xor2(Sum,Llast,Sum);\t//Sum = 3Llast xor Sum\n    if(last == BLOCK || last == DBLOCK){//last = 16 or 32\n        xor2(Sum,L,Sum);\n    }\n    Encryption(KeyLen,Sum,TE);\n    return SUCCESS;\n}//end of DFunc\n/*\n AFunc : OTR Core Authentication Function (ADP=p)\n*/\nint AFunc(\n          const uint8 *header,\n          uint32 h_len)\n{\n    uint32 i,j = 0;\n    uint32 m, last;\n    uint8 ASum[BLOCK]={0}, tmp[BLOCK], mask[BLOCK];\n\n    last = h_len % BLOCK;\n    if(last == 0) last = BLOCK;\n    m = (h_len-last) / BLOCK; //header = m blocks + last bytes\n\n    memcpy(mask,Qd,BLOCK);\n    /* XE */\n    for(i = 0; i < m; i++, j=j+BLOCK){\n        xor2(mask,header+j,tmp);\n        Encryption(KeyLen,tmp,tmp);\n        xor2(ASum,tmp,ASum);\n        mul2(mask,mask);\n    }\n    /* last block */\n    ozp(last,header+j,tmp);\n    xor2(ASum,tmp,ASum);\n\n    if(last != BLOCK ){\n        xor2(mask,Q,mask);\n    }\n    else{\n        xor2(mask,Q2,mask);\n    }\n    xor2(ASum,mask,ASum);\n    Encryption(KeyLen,ASum,TA);\n    return SUCCESS;\n}\n/*\n AFuncS : OTR Core Authentication Function (ADP=s)\n*/\nint AFuncS(\n          const uint8 *header,\n          uint32 h_len)\n{\n    uint32 i,j = 0;\n    uint32 m, last;\n    uint8 tmp[BLOCK], chain[BLOCK]={0};\n\n    last = h_len % BLOCK;\n    if(last == 0) last = BLOCK;\n    m = (h_len-last) / BLOCK; //header = m blocks + last bytes\n\n    /* CBC */\n    for(i = 0; i < m; i++, j=j+BLOCK){\n        xor2(chain,header+j,chain);\n        Encryption(KeyLen,chain,chain);\n    }\n    /* last block */\n    ozp(last,header+j,tmp);\n    xor2(tmp,chain,chain);\n    if(last != BLOCK ){\n        xor2(chain,Q2,chain);\n    }\n    else{\n        xor2(chain,Qd,chain);\n    }\n    Encryption(KeyLen,chain,TA);\n    return SUCCESS;\n}\n/*\n AE_Encrypt : OTR Encryption\n*/\nint AE_Encrypt(\n          const uint8 *nonce,\n          uint32 nonce_len,\n          const uint8 *plaintext,\n          uint32 pl_len,\n          const uint8 *header,\n          uint32 h_len,\n          uint32 t_len,\n          uint8 *ciphertext,\n          uint8 *tag)\n{\n    if(ADP==Para)\n    {\n        if(h_len==0){\n            memset(TA,0,BLOCK);\n        }\n        else{\n            AFunc(header,h_len);\n        }\n        EFunc(nonce,nonce_len,plaintext,pl_len,ciphertext);\n        xorp(t_len,TE,TA,tag);\n    }\n    else if(ADP==Seri)\n    {\n        if(h_len==0){\n            memset(TA,0,BLOCK);\n        }\n        else{\n            AFuncS(header,h_len);\n        }\n            EFunc(nonce,nonce_len,plaintext,pl_len,ciphertext);\n            memcpy(tag,TE,t_len);\n    }\n    return SUCCESS;\n}\n/*\n AE_Decrypt : OTR Decryption\n*/\nint AE_Decrypt(\n          const uint8 *nonce,\n          uint32 nonce_len,\n          const uint8 *ciphertext,\n          uint32 ci_len,\n          const uint8 *header,\n          uint32 h_len,\n          uint32 t_len,\n          const uint8 *tag,\n          uint8 *plaintext)\n{\n    uint32 i;\n    uint8 loctag[BLOCK];\n\n    if(ADP==Para)\n    {\n        if(h_len==0){\n            memset(TA,0,BLOCK);\n        }\n        else{\n            AFunc(header,h_len);\n        }\n            DFunc(nonce,nonce_len,ciphertext,ci_len,plaintext);\n            xorp(t_len,TE,TA,loctag);\n    }\n    else if(ADP==Seri)\n    {\n        if(h_len==0){\n            memset(TA,0,BLOCK);\n        }\n        else{\n            AFuncS(header,h_len);\n        }\n            DFunc(nonce,nonce_len,ciphertext,ci_len,plaintext);\n            memcpy(loctag,TE,t_len);\n    }\n\n    if(memcmp(loctag,tag,t_len)!=0){//verfication failure\n        for(i=0; i<ci_len; i++)plaintext[i] = 0;// zeroing wrong plaintext\n        return TAG_UNMATCH;\n    }\n    return TAG_MATCH;\n}//end of AE_Decrypt\n\n/*\n ozp: 100...0 padding for length (<=16) bytes (when n = 16 nothing is done)\n*/\nstatic void ozp(uint32 length, const uint8 *in, uint8 *out){\n    memset(out,0,BLOCK);\n    memcpy(out,in,length);\n    if(length<BLOCK){\n        out[length] = 0x80;\n    }\n}\n\n /*\n mul2 : mutiply 2 over GF(2^n)\n*/\nstatic const uint8 cst_mul[2] = {0x00, 0x87};\n\nstatic void mul2(const uint8 *in, uint8 *out)\n{\n    int i, t = in[0] >> 7;\n    for(i = 0; i < 15; i++)\n        out[i] = (in[i] << 1) | (in[i + 1] >> 7);\n    out[15] = (in[15] << 1) ^ cst_mul[t];\n}\n\nstatic void xor2(const uint8 *x, const uint8 *y, uint8 *z)\n{\n    uint32 i;\n    for(i = 0; i < BLOCK; i++){\n        z[i] = x[i]^y[i];\n    }\n}\n\nstatic void xorp(uint32 length, const uint8 *x, const uint8 *y, uint8 *z){\n    uint32 i;\n    for(i = 0; i < length; i++){\n        z[i] = x[i]^y[i];\n    }\n}\n\n} // namespace Aes256otrsv1_raw\n"
        },
        {
            "file_name": "aescopav1_aes-core.cpp",
            "content": "/*\n * AES-128 implementation, adapted from https://code.google.com/p/aes128-byte-oriented/\n *\n * Authors:\n * - Filippo Sironi (filippo.sironi@gmail.com)\n * - Matteo Villa (villa.matteo@gmail.com)\n *\n * New BSD License\n */\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"aescopav1_aes-core.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Aescopav1_raw {\n\n#define sbox(x) (__sbox[x])\nstatic const uint8_t __sbox[] = {\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n};\n\n#define isbox(x) (__isbox[x])\nstatic const uint8_t __isbox[] = {\n    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d\n};\n\n#define rcon(x) (__rcon[x])\nstatic const uint8_t __rcon[] = {\n    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36\n};\n\n#define xtime2_sbox(x) (__xtime2_sbox[x])\nstatic const uint8_t __xtime2_sbox[] = {\n    0xc6, 0xf8, 0xee, 0xf6, 0xff, 0xd6, 0xde, 0x91, 0x60, 0x02, 0xce, 0x56, 0xe7, 0xb5, 0x4d, 0xec,\n    0x8f, 0x1f, 0x89, 0xfa, 0xef, 0xb2, 0x8e, 0xfb, 0x41, 0xb3, 0x5f, 0x45, 0x23, 0x53, 0xe4, 0x9b,\n    0x75, 0xe1, 0x3d, 0x4c, 0x6c, 0x7e, 0xf5, 0x83, 0x68, 0x51, 0xd1, 0xf9, 0xe2, 0xab, 0x62, 0x2a,\n    0x08, 0x95, 0x46, 0x9d, 0x30, 0x37, 0x0a, 0x2f, 0x0e, 0x24, 0x1b, 0xdf, 0xcd, 0x4e, 0x7f, 0xea,\n    0x12, 0x1d, 0x58, 0x34, 0x36, 0xdc, 0xb4, 0x5b, 0xa4, 0x76, 0xb7, 0x7d, 0x52, 0xdd, 0x5e, 0x13,\n    0xa6, 0xb9, 0x00, 0xc1, 0x40, 0xe3, 0x79, 0xb6, 0xd4, 0x8d, 0x67, 0x72, 0x94, 0x98, 0xb0, 0x85,\n    0xbb, 0xc5, 0x4f, 0xed, 0x86, 0x9a, 0x66, 0x11, 0x8a, 0xe9, 0x04, 0xfe, 0xa0, 0x78, 0x25, 0x4b,\n    0xa2, 0x5d, 0x80, 0x05, 0x3f, 0x21, 0x70, 0xf1, 0x63, 0x77, 0xaf, 0x42, 0x20, 0xe5, 0xfd, 0xbf,\n    0x81, 0x18, 0x26, 0xc3, 0xbe, 0x35, 0x88, 0x2e, 0x93, 0x55, 0xfc, 0x7a, 0xc8, 0xba, 0x32, 0xe6,\n    0xc0, 0x19, 0x9e, 0xa3, 0x44, 0x54, 0x3b, 0x0b, 0x8c, 0xc7, 0x6b, 0x28, 0xa7, 0xbc, 0x16, 0xad,\n    0xdb, 0x64, 0x74, 0x14, 0x92, 0x0c, 0x48, 0xb8, 0x9f, 0xbd, 0x43, 0xc4, 0x39, 0x31, 0xd3, 0xf2,\n    0xd5, 0x8b, 0x6e, 0xda, 0x01, 0xb1, 0x9c, 0x49, 0xd8, 0xac, 0xf3, 0xcf, 0xca, 0xf4, 0x47, 0x10,\n    0x6f, 0xf0, 0x4a, 0x5c, 0x38, 0x57, 0x73, 0x97, 0xcb, 0xa1, 0xe8, 0x3e, 0x96, 0x61, 0x0d, 0x0f,\n    0xe0, 0x7c, 0x71, 0xcc, 0x90, 0x06, 0xf7, 0x1c, 0xc2, 0x6a, 0xae, 0x69, 0x17, 0x99, 0x3a, 0x27,\n    0xd9, 0xeb, 0x2b, 0x22, 0xd2, 0xa9, 0x07, 0x33, 0x2d, 0x3c, 0x15, 0xc9, 0x87, 0xaa, 0x50, 0xa5,\n    0x03, 0x59, 0x09, 0x1a, 0x65, 0xd7, 0x84, 0xd0, 0x82, 0x29, 0x5a, 0x1e, 0x7b, 0xa8, 0x6d, 0x2c\n};\n\n#define xtime3_sbox(x) (__xtime3_sbox[x])\nconst static uint8_t __xtime3_sbox[] = {\n    0xa5, 0x84, 0x99, 0x8d, 0x0d, 0xbd, 0xb1, 0x54, 0x50, 0x03, 0xa9, 0x7d, 0x19, 0x62, 0xe6, 0x9a,\n    0x45, 0x9d, 0x40, 0x87, 0x15, 0xeb, 0xc9, 0x0b, 0xec, 0x67, 0xfd, 0xea, 0xbf, 0xf7, 0x96, 0x5b,\n    0xc2, 0x1c, 0xae, 0x6a, 0x5a, 0x41, 0x02, 0x4f, 0x5c, 0xf4, 0x34, 0x08, 0x93, 0x73, 0x53, 0x3f,\n    0x0c, 0x52, 0x65, 0x5e, 0x28, 0xa1, 0x0f, 0xb5, 0x09, 0x36, 0x9b, 0x3d, 0x26, 0x69, 0xcd, 0x9f,\n    0x1b, 0x9e, 0x74, 0x2e, 0x2d, 0xb2, 0xee, 0xfb, 0xf6, 0x4d, 0x61, 0xce, 0x7b, 0x3e, 0x71, 0x97,\n    0xf5, 0x68, 0x00, 0x2c, 0x60, 0x1f, 0xc8, 0xed, 0xbe, 0x46, 0xd9, 0x4b, 0xde, 0xd4, 0xe8, 0x4a,\n    0x6b, 0x2a, 0xe5, 0x16, 0xc5, 0xd7, 0x55, 0x94, 0xcf, 0x10, 0x06, 0x81, 0xf0, 0x44, 0xba, 0xe3,\n    0xf3, 0xfe, 0xc0, 0x8a, 0xad, 0xbc, 0x48, 0x04, 0xdf, 0xc1, 0x75, 0x63, 0x30, 0x1a, 0x0e, 0x6d,\n    0x4c, 0x14, 0x35, 0x2f, 0xe1, 0xa2, 0xcc, 0x39, 0x57, 0xf2, 0x82, 0x47, 0xac, 0xe7, 0x2b, 0x95,\n    0xa0, 0x98, 0xd1, 0x7f, 0x66, 0x7e, 0xab, 0x83, 0xca, 0x29, 0xd3, 0x3c, 0x79, 0xe2, 0x1d, 0x76,\n    0x3b, 0x56, 0x4e, 0x1e, 0xdb, 0x0a, 0x6c, 0xe4, 0x5d, 0x6e, 0xef, 0xa6, 0xa8, 0xa4, 0x37, 0x8b,\n    0x32, 0x43, 0x59, 0xb7, 0x8c, 0x64, 0xd2, 0xe0, 0xb4, 0xfa, 0x07, 0x25, 0xaf, 0x8e, 0xe9, 0x18,\n    0xd5, 0x88, 0x6f, 0x72, 0x24, 0xf1, 0xc7, 0x51, 0x23, 0x7c, 0x9c, 0x21, 0xdd, 0xdc, 0x86, 0x85,\n    0x90, 0x42, 0xc4, 0xaa, 0xd8, 0x05, 0x01, 0x12, 0xa3, 0x5f, 0xf9, 0xd0, 0x91, 0x58, 0x27, 0xb9,\n    0x38, 0x13, 0xb3, 0x33, 0xbb, 0x70, 0x89, 0xa7, 0xb6, 0x22, 0x92, 0x20, 0x49, 0xff, 0x78, 0x7a,\n    0x8f, 0xf8, 0x80, 0x17, 0xda, 0x31, 0xc6, 0xb8, 0xc3, 0xb0, 0x77, 0x11, 0xcb, 0xfc, 0xd6, 0x3a,\n};\n\n#define xtime9(x) (__xtime9[x])\nstatic const uint8_t __xtime9[] = {\n    0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,\n    0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,\n    0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,\n    0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,\n    0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,\n    0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,\n    0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,\n    0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,\n    0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,\n    0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,\n    0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,\n    0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,\n    0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,\n    0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,\n    0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,\n    0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46\n};\n\n#define xtimeb(x) (__xtimeb[x])\nstatic const uint8_t __xtimeb[] = {\n    0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,\n    0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,\n    0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,\n    0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,\n    0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,\n    0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,\n    0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,\n    0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,\n    0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,\n    0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,\n    0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,\n    0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,\n    0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,\n    0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,\n    0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,\n    0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3\n};\n\n#define xtimed(x) (__xtimed[x])\nstatic const uint8_t __xtimed[] = {\n    0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,\n    0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,\n    0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,\n    0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,\n    0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,\n    0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,\n    0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,\n    0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,\n    0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,\n    0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,\n    0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,\n    0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,\n    0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,\n    0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,\n    0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,\n    0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97\n};\n\n#define xtimee(x) (__xtimee[x])\nstatic const uint8_t __xtimee[] = {\n    0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,\n    0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,\n    0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,\n    0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,\n    0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,\n    0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,\n    0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,\n    0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,\n    0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,\n    0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,\n    0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,\n    0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,\n    0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,\n    0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,\n    0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,\n    0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d\n};\n\n#define block_copy(d, s) memcpy(d, s, 16 * sizeof(uint8_t))\n\nvoid aes_first_addroundkey(uint8_t state[], const uint8_t text[], const uint8_t round_key[]);\nvoid aes_addroundkey(uint8_t state[], const uint8_t round_key[]);\nvoid aes_last_addroundkey(uint8_t text[], const uint8_t state[], const uint8_t round_key[]);\n\nvoid aes_subbytes_shiftrows(uint8_t state[]);\nvoid aes_subbyte_shiftrows_mixcols(uint8_t state[]);\n\nvoid aes_isubbytes_ishiftrows(uint8_t state[]);\nvoid aes_isubbyte_ishiftrows_imixcols(uint8_t state[]);\n\nvoid aesc_keyexp(const uint8_t key[], uint8_t key_sched[])\n{\n    uint8_t key_sched_0, key_sched_1, key_sched_2, key_sched_3, tmp;\n\n    unsigned int i;\n\n    block_copy(key_sched, key);\n\n    for (i = 16; i < 176; i += 4) {\n        key_sched_0 = key_sched[i - 4];\n        key_sched_1 = key_sched[i - 3];\n        key_sched_2 = key_sched[i - 2];\n        key_sched_3 = key_sched[i - 1];\n\n        if (!(i & 0x0f)) {\n            tmp = key_sched_0;\n            key_sched_0 = sbox(key_sched_1) ^ rcon(i >> 4);\n            key_sched_1 = sbox(key_sched_2);\n            key_sched_2 = sbox(key_sched_3);\n            key_sched_3 = sbox(tmp);\n        }\n\n        key_sched[i] = key_sched[i - 16] ^ key_sched_0;\n        key_sched[i + 1] = key_sched[i - 15] ^ key_sched_1;\n        key_sched[i + 2] = key_sched[i - 14] ^ key_sched_2;\n        key_sched[i + 3] = key_sched[i - 13] ^ key_sched_3;\n    }\n}\n\nvoid aes_first_addroundkey(uint8_t state[], const uint8_t text[], const uint8_t round_key[])\n{\n    unsigned int i;\n\n    for (i = 0; i < 16; ++i)\n        state[i] = text[i] ^ round_key[i];\n}\n\nvoid aes_addroundkey(uint8_t state[], const uint8_t round_key[])\n{\n    unsigned int i;\n\n    for (i = 0; i < 16; ++i)\n        state[i] ^= round_key[i];\n}\n\nvoid aes_last_addroundkey(uint8_t text[], const uint8_t state[], const uint8_t round_key[])\n{\n    unsigned int i;\n\n    for (i = 0; i < 16; ++i)\n        text[i] = state[i] ^ round_key[i];\n}\n\nvoid aes_subbytes_shiftrows(uint8_t state[])\n{\n    uint8_t tmp;\n\n    state[0] = sbox(state[0]);\n    state[4] = sbox(state[4]);\n    state[8] = sbox(state[8]);\n    state[12] = sbox(state[12]);\n\n    tmp = state[1];\n    state[1] = sbox(state[5]);\n    state[5] = sbox(state[9]);\n    state[9] = sbox(state[13]);\n    state[13] = sbox(tmp);\n\n    tmp = state[2];\n    state[2] = sbox(state[10]);\n    state[10] = sbox(tmp);\n    tmp = state[6];\n    state[6] = sbox(state[14]);\n    state[14] = sbox(tmp);\n\n    tmp = state[3];\n    state[3] = sbox(state[15]);\n    state[15] = sbox(state[11]);\n    state[11] = sbox(state[7]);\n    state[7] = sbox(tmp);\n}\n\nvoid aes_subbyte_shiftrows_mixcols(uint8_t state[])\n{\n    uint8_t tmp[16];\n\n    block_copy(tmp, state);\n\n    state[0] = xtime2_sbox(tmp[0]) ^ xtime3_sbox(tmp[5]) ^ sbox(tmp[10]) ^ sbox(tmp[15]);\n    state[1] = sbox(tmp[0]) ^ xtime2_sbox(tmp[5]) ^ xtime3_sbox(tmp[10]) ^ sbox(tmp[15]);\n    state[2] = sbox(tmp[0]) ^ sbox(tmp[5]) ^ xtime2_sbox(tmp[10]) ^ xtime3_sbox(tmp[15]);\n    state[3] = xtime3_sbox(tmp[0]) ^ sbox(tmp[5]) ^ sbox(tmp[10]) ^ xtime2_sbox(tmp[15]);\n\n    state[4] = xtime2_sbox(tmp[4]) ^ xtime3_sbox(tmp[9]) ^ sbox(tmp[14]) ^ sbox(tmp[3]);\n    state[5] = sbox(tmp[4]) ^ xtime2_sbox(tmp[9]) ^ xtime3_sbox(tmp[14]) ^ sbox(tmp[3]);\n    state[6] = sbox(tmp[4]) ^ sbox(tmp[9]) ^ xtime2_sbox(tmp[14]) ^ xtime3_sbox(tmp[3]);\n    state[7] = xtime3_sbox(tmp[4]) ^ sbox(tmp[9]) ^ sbox(tmp[14]) ^ xtime2_sbox(tmp[3]);\n\n    state[8] = xtime2_sbox(tmp[8]) ^ xtime3_sbox(tmp[13]) ^ sbox(tmp[2]) ^ sbox(tmp[7]);\n    state[9] = sbox(tmp[8]) ^ xtime2_sbox(tmp[13]) ^ xtime3_sbox(tmp[2]) ^ sbox(tmp[7]);\n    state[10] = sbox(tmp[8]) ^ sbox(tmp[13]) ^ xtime2_sbox(tmp[2]) ^ xtime3_sbox(tmp[7]);\n    state[11] = xtime3_sbox(tmp[8]) ^ sbox(tmp[13]) ^ sbox(tmp[2]) ^ xtime2_sbox(tmp[7]);\n\n    state[12] = xtime2_sbox(tmp[12]) ^ xtime3_sbox(tmp[1]) ^ sbox(tmp[6]) ^ sbox(tmp[11]);\n    state[13] = sbox(tmp[12]) ^ xtime2_sbox(tmp[1]) ^ xtime3_sbox(tmp[6]) ^ sbox(tmp[11]);\n    state[14] = sbox(tmp[12]) ^ sbox(tmp[1]) ^ xtime2_sbox(tmp[6]) ^ xtime3_sbox(tmp[11]);\n    state[15] = xtime3_sbox(tmp[12]) ^ sbox(tmp[1]) ^ sbox(tmp[6]) ^ xtime2_sbox(tmp[11]);\n}\n\nvoid aesc_encrypt(const uint8_t plain_text[], uint8_t cipher_text[], const uint8_t key_sched[])\n{\n    uint8_t state[16];\n\n    unsigned int i;\n\n    aes_first_addroundkey(state, plain_text, key_sched);\n\n    for (i = 1; i < 10; ++i) {\n        aes_subbyte_shiftrows_mixcols(state);\n        aes_addroundkey(state, key_sched + i * 16);\n    }\n\n    aes_subbytes_shiftrows(state);\n    aes_last_addroundkey(cipher_text, state, key_sched + 10 * 16);\n}\n\nvoid aes_isubbytes_ishiftrows(uint8_t state[])\n{\n    uint8_t tmp;\n\n    state[0] = isbox(state[0]);\n    state[4] = isbox(state[4]);\n    state[8] = isbox(state[8]);\n    state[12] = isbox(state[12]);\n\n    tmp = state[13];\n    state[13] = isbox(state[9]);\n    state[9] = isbox(state[5]);\n    state[5] = isbox(state[1]);\n    state[1] = isbox(tmp);\n\n    tmp = state[2];\n    state[2] = isbox(state[10]);\n    state[10] = isbox(tmp);\n    tmp = state[6];\n    state[6] = isbox(state[14]);\n    state[14] = isbox(tmp);\n\n    tmp = state[3];\n    state[3] = isbox(state[7]);\n    state[7] = isbox(state[11]);\n    state[11] = isbox(state[15]);\n    state[15] = isbox(tmp);\n}\n\nvoid aes_isubbyte_ishiftrows_imixcols(uint8_t state[])\n{\n    uint8_t tmp[16];\n\n    block_copy(tmp, state);\n\n    state[0] = isbox(xtimee(tmp[0]) ^ xtimeb(tmp[1]) ^ xtimed(tmp[2]) ^ xtime9(tmp[3]));\n    state[5] = isbox(xtime9(tmp[0]) ^ xtimee(tmp[1]) ^ xtimeb(tmp[2]) ^ xtimed(tmp[3]));\n    state[10] = isbox(xtimed(tmp[0]) ^ xtime9(tmp[1]) ^ xtimee(tmp[2]) ^ xtimeb(tmp[3]));\n    state[15] = isbox(xtimeb(tmp[0]) ^ xtimed(tmp[1]) ^ xtime9(tmp[2]) ^ xtimee(tmp[3]));\n\n    state[4] = isbox(xtimee(tmp[4]) ^ xtimeb(tmp[5]) ^ xtimed(tmp[6]) ^ xtime9(tmp[7]));\n    state[9] = isbox(xtime9(tmp[4]) ^ xtimee(tmp[5]) ^ xtimeb(tmp[6]) ^ xtimed(tmp[7]));\n    state[14] = isbox(xtimed(tmp[4]) ^ xtime9(tmp[5]) ^ xtimee(tmp[6]) ^ xtimeb(tmp[7]));\n    state[3] = isbox(xtimeb(tmp[4]) ^ xtimed(tmp[5]) ^ xtime9(tmp[6]) ^ xtimee(tmp[7]));\n\n    state[8] = isbox(xtimee(tmp[8]) ^ xtimeb(tmp[9]) ^ xtimed(tmp[10]) ^ xtime9(tmp[11]));\n    state[13] = isbox(xtime9(tmp[8]) ^ xtimee(tmp[9]) ^ xtimeb(tmp[10]) ^ xtimed(tmp[11]));\n    state[2] = isbox(xtimed(tmp[8]) ^ xtime9(tmp[9]) ^ xtimee(tmp[10]) ^ xtimeb(tmp[11]));\n    state[7] = isbox(xtimeb(tmp[8]) ^ xtimed(tmp[9]) ^ xtime9(tmp[10]) ^ xtimee(tmp[11]));\n\n    state[12] = isbox(xtimee(tmp[12]) ^ xtimeb(tmp[13]) ^ xtimed(tmp[14]) ^ xtime9(tmp[15]));\n    state[1] = isbox(xtime9(tmp[12]) ^ xtimee(tmp[13]) ^ xtimeb(tmp[14]) ^ xtimed(tmp[15]));\n    state[6] = isbox(xtimed(tmp[12]) ^ xtime9(tmp[13]) ^ xtimee(tmp[14]) ^ xtimeb(tmp[15]));\n    state[11] = isbox(xtimeb(tmp[12]) ^ xtimed(tmp[13]) ^ xtime9(tmp[14]) ^ xtimee(tmp[15]));\n}\n\nvoid aesc_decrypt(const uint8_t cipher_text[], uint8_t plain_text[], const uint8_t key_sched[])\n{\n    uint8_t state[16];\n\n    unsigned int i;\n\n    aes_first_addroundkey(state, cipher_text, key_sched + 10 * 16);\n    aes_isubbytes_ishiftrows(state);\n\n    for (i = 9; i > 0; --i) {\n        aes_addroundkey(state, key_sched + i * 16);\n        aes_isubbyte_ishiftrows_imixcols(state);\n    }\n\n    aes_last_addroundkey(plain_text, state, key_sched);\n}\n\n} // namespace Aescopav1_raw\n"
        },
        {
            "file_name": "aesjambuv1_aes.cpp",
            "content": "#include <string.h>\n\n// CHANGE namespace moved due to includes\nnamespace Aesjambuv1_raw {\n\n#ifdef _MSC_VER\n#define inline __inline\n#endif\n\ntypedef unsigned int U32;\n\nunsigned int TE0[256] = {\n    0xa56363c6,  0x847c7cf8,  0x997777ee,  0x8d7b7bf6,\n    0xdf2f2ff,  0xbd6b6bd6,  0xb16f6fde,  0x54c5c591,\n    0x50303060,  0x3010102,  0xa96767ce,  0x7d2b2b56,\n    0x19fefee7,  0x62d7d7b5,  0xe6abab4d,  0x9a7676ec,\n    0x45caca8f,  0x9d82821f,  0x40c9c989,  0x877d7dfa,\n    0x15fafaef,  0xeb5959b2,  0xc947478e,  0xbf0f0fb,\n    0xecadad41,  0x67d4d4b3,  0xfda2a25f,  0xeaafaf45,\n    0xbf9c9c23,  0xf7a4a453,  0x967272e4,  0x5bc0c09b,\n    0xc2b7b775,  0x1cfdfde1,  0xae93933d,  0x6a26264c,\n    0x5a36366c,  0x413f3f7e,  0x2f7f7f5,  0x4fcccc83,\n    0x5c343468,  0xf4a5a551,  0x34e5e5d1,  0x8f1f1f9,\n    0x937171e2,  0x73d8d8ab,  0x53313162,  0x3f15152a,\n    0xc040408,  0x52c7c795,  0x65232346,  0x5ec3c39d,\n    0x28181830,  0xa1969637,  0xf05050a,  0xb59a9a2f,\n    0x907070e,  0x36121224,  0x9b80801b,  0x3de2e2df,\n    0x26ebebcd,  0x6927274e,  0xcdb2b27f,  0x9f7575ea,\n    0x1b090912,  0x9e83831d,  0x742c2c58,  0x2e1a1a34,\n    0x2d1b1b36,  0xb26e6edc,  0xee5a5ab4,  0xfba0a05b,\n    0xf65252a4,  0x4d3b3b76,  0x61d6d6b7,  0xceb3b37d,\n    0x7b292952,  0x3ee3e3dd,  0x712f2f5e,  0x97848413,\n    0xf55353a6,  0x68d1d1b9,  0x0,  0x2cededc1,\n    0x60202040,  0x1ffcfce3,  0xc8b1b179,  0xed5b5bb6,\n    0xbe6a6ad4,  0x46cbcb8d,  0xd9bebe67,  0x4b393972,\n    0xde4a4a94,  0xd44c4c98,  0xe85858b0,  0x4acfcf85,\n    0x6bd0d0bb,  0x2aefefc5,  0xe5aaaa4f,  0x16fbfbed,\n    0xc5434386,  0xd74d4d9a,  0x55333366,  0x94858511,\n    0xcf45458a,  0x10f9f9e9,  0x6020204,  0x817f7ffe,\n    0xf05050a0,  0x443c3c78,  0xba9f9f25,  0xe3a8a84b,\n    0xf35151a2,  0xfea3a35d,  0xc0404080,  0x8a8f8f05,\n    0xad92923f,  0xbc9d9d21,  0x48383870,  0x4f5f5f1,\n    0xdfbcbc63,  0xc1b6b677,  0x75dadaaf,  0x63212142,\n    0x30101020,  0x1affffe5,  0xef3f3fd,  0x6dd2d2bf,\n    0x4ccdcd81,  0x140c0c18,  0x35131326,  0x2fececc3,\n    0xe15f5fbe,  0xa2979735,  0xcc444488,  0x3917172e,\n    0x57c4c493,  0xf2a7a755,  0x827e7efc,  0x473d3d7a,\n    0xac6464c8,  0xe75d5dba,  0x2b191932,  0x957373e6,\n    0xa06060c0,  0x98818119,  0xd14f4f9e,  0x7fdcdca3,\n    0x66222244,  0x7e2a2a54,  0xab90903b,  0x8388880b,\n    0xca46468c,  0x29eeeec7,  0xd3b8b86b,  0x3c141428,\n    0x79dedea7,  0xe25e5ebc,  0x1d0b0b16,  0x76dbdbad,\n    0x3be0e0db,  0x56323264,  0x4e3a3a74,  0x1e0a0a14,\n    0xdb494992,  0xa06060c,  0x6c242448,  0xe45c5cb8,\n    0x5dc2c29f,  0x6ed3d3bd,  0xefacac43,  0xa66262c4,\n    0xa8919139,  0xa4959531,  0x37e4e4d3,  0x8b7979f2,\n    0x32e7e7d5,  0x43c8c88b,  0x5937376e,  0xb76d6dda,\n    0x8c8d8d01,  0x64d5d5b1,  0xd24e4e9c,  0xe0a9a949,\n    0xb46c6cd8,  0xfa5656ac,  0x7f4f4f3,  0x25eaeacf,\n    0xaf6565ca,  0x8e7a7af4,  0xe9aeae47,  0x18080810,\n    0xd5baba6f,  0x887878f0,  0x6f25254a,  0x722e2e5c,\n    0x241c1c38,  0xf1a6a657,  0xc7b4b473,  0x51c6c697,\n    0x23e8e8cb,  0x7cdddda1,  0x9c7474e8,  0x211f1f3e,\n    0xdd4b4b96,  0xdcbdbd61,  0x868b8b0d,  0x858a8a0f,\n    0x907070e0,  0x423e3e7c,  0xc4b5b571,  0xaa6666cc,\n    0xd8484890,  0x5030306,  0x1f6f6f7,  0x120e0e1c,\n    0xa36161c2,  0x5f35356a,  0xf95757ae,  0xd0b9b969,\n    0x91868617,  0x58c1c199,  0x271d1d3a,  0xb99e9e27,\n    0x38e1e1d9,  0x13f8f8eb,  0xb398982b,  0x33111122,\n    0xbb6969d2,  0x70d9d9a9,  0x898e8e07,  0xa7949433,\n    0xb69b9b2d,  0x221e1e3c,  0x92878715,  0x20e9e9c9,\n    0x49cece87,  0xff5555aa,  0x78282850,  0x7adfdfa5,\n    0x8f8c8c03,  0xf8a1a159,  0x80898909,  0x170d0d1a,\n    0xdabfbf65,  0x31e6e6d7,  0xc6424284,  0xb86868d0,\n    0xc3414182,  0xb0999929,  0x772d2d5a,  0x110f0f1e,\n    0xcbb0b07b,  0xfc5454a8,  0xd6bbbb6d,  0x3a16162c\n};\n\nunsigned int TE1[256] = {\n    0x6363c6a5,  0x7c7cf884,  0x7777ee99,  0x7b7bf68d,\n    0xf2f2ff0d,  0x6b6bd6bd,  0x6f6fdeb1,  0xc5c59154,\n    0x30306050,  0x1010203,  0x6767cea9,  0x2b2b567d,\n    0xfefee719,  0xd7d7b562,  0xabab4de6,  0x7676ec9a,\n    0xcaca8f45,  0x82821f9d,  0xc9c98940,  0x7d7dfa87,\n    0xfafaef15,  0x5959b2eb,  0x47478ec9,  0xf0f0fb0b,\n    0xadad41ec,  0xd4d4b367,  0xa2a25ffd,  0xafaf45ea,\n    0x9c9c23bf,  0xa4a453f7,  0x7272e496,  0xc0c09b5b,\n    0xb7b775c2,  0xfdfde11c,  0x93933dae,  0x26264c6a,\n    0x36366c5a,  0x3f3f7e41,  0xf7f7f502,  0xcccc834f,\n    0x3434685c,  0xa5a551f4,  0xe5e5d134,  0xf1f1f908,\n    0x7171e293,  0xd8d8ab73,  0x31316253,  0x15152a3f,\n    0x404080c,  0xc7c79552,  0x23234665,  0xc3c39d5e,\n    0x18183028,  0x969637a1,  0x5050a0f,  0x9a9a2fb5,\n    0x7070e09,  0x12122436,  0x80801b9b,  0xe2e2df3d,\n    0xebebcd26,  0x27274e69,  0xb2b27fcd,  0x7575ea9f,\n    0x909121b,  0x83831d9e,  0x2c2c5874,  0x1a1a342e,\n    0x1b1b362d,  0x6e6edcb2,  0x5a5ab4ee,  0xa0a05bfb,\n    0x5252a4f6,  0x3b3b764d,  0xd6d6b761,  0xb3b37dce,\n    0x2929527b,  0xe3e3dd3e,  0x2f2f5e71,  0x84841397,\n    0x5353a6f5,  0xd1d1b968,  0x0,  0xededc12c,\n    0x20204060,  0xfcfce31f,  0xb1b179c8,  0x5b5bb6ed,\n    0x6a6ad4be,  0xcbcb8d46,  0xbebe67d9,  0x3939724b,\n    0x4a4a94de,  0x4c4c98d4,  0x5858b0e8,  0xcfcf854a,\n    0xd0d0bb6b,  0xefefc52a,  0xaaaa4fe5,  0xfbfbed16,\n    0x434386c5,  0x4d4d9ad7,  0x33336655,  0x85851194,\n    0x45458acf,  0xf9f9e910,  0x2020406,  0x7f7ffe81,\n    0x5050a0f0,  0x3c3c7844,  0x9f9f25ba,  0xa8a84be3,\n    0x5151a2f3,  0xa3a35dfe,  0x404080c0,  0x8f8f058a,\n    0x92923fad,  0x9d9d21bc,  0x38387048,  0xf5f5f104,\n    0xbcbc63df,  0xb6b677c1,  0xdadaaf75,  0x21214263,\n    0x10102030,  0xffffe51a,  0xf3f3fd0e,  0xd2d2bf6d,\n    0xcdcd814c,  0xc0c1814,  0x13132635,  0xececc32f,\n    0x5f5fbee1,  0x979735a2,  0x444488cc,  0x17172e39,\n    0xc4c49357,  0xa7a755f2,  0x7e7efc82,  0x3d3d7a47,\n    0x6464c8ac,  0x5d5dbae7,  0x1919322b,  0x7373e695,\n    0x6060c0a0,  0x81811998,  0x4f4f9ed1,  0xdcdca37f,\n    0x22224466,  0x2a2a547e,  0x90903bab,  0x88880b83,\n    0x46468cca,  0xeeeec729,  0xb8b86bd3,  0x1414283c,\n    0xdedea779,  0x5e5ebce2,  0xb0b161d,  0xdbdbad76,\n    0xe0e0db3b,  0x32326456,  0x3a3a744e,  0xa0a141e,\n    0x494992db,  0x6060c0a,  0x2424486c,  0x5c5cb8e4,\n    0xc2c29f5d,  0xd3d3bd6e,  0xacac43ef,  0x6262c4a6,\n    0x919139a8,  0x959531a4,  0xe4e4d337,  0x7979f28b,\n    0xe7e7d532,  0xc8c88b43,  0x37376e59,  0x6d6ddab7,\n    0x8d8d018c,  0xd5d5b164,  0x4e4e9cd2,  0xa9a949e0,\n    0x6c6cd8b4,  0x5656acfa,  0xf4f4f307,  0xeaeacf25,\n    0x6565caaf,  0x7a7af48e,  0xaeae47e9,  0x8081018,\n    0xbaba6fd5,  0x7878f088,  0x25254a6f,  0x2e2e5c72,\n    0x1c1c3824,  0xa6a657f1,  0xb4b473c7,  0xc6c69751,\n    0xe8e8cb23,  0xdddda17c,  0x7474e89c,  0x1f1f3e21,\n    0x4b4b96dd,  0xbdbd61dc,  0x8b8b0d86,  0x8a8a0f85,\n    0x7070e090,  0x3e3e7c42,  0xb5b571c4,  0x6666ccaa,\n    0x484890d8,  0x3030605,  0xf6f6f701,  0xe0e1c12,\n    0x6161c2a3,  0x35356a5f,  0x5757aef9,  0xb9b969d0,\n    0x86861791,  0xc1c19958,  0x1d1d3a27,  0x9e9e27b9,\n    0xe1e1d938,  0xf8f8eb13,  0x98982bb3,  0x11112233,\n    0x6969d2bb,  0xd9d9a970,  0x8e8e0789,  0x949433a7,\n    0x9b9b2db6,  0x1e1e3c22,  0x87871592,  0xe9e9c920,\n    0xcece8749,  0x5555aaff,  0x28285078,  0xdfdfa57a,\n    0x8c8c038f,  0xa1a159f8,  0x89890980,  0xd0d1a17,\n    0xbfbf65da,  0xe6e6d731,  0x424284c6,  0x6868d0b8,\n    0x414182c3,  0x999929b0,  0x2d2d5a77,  0xf0f1e11,\n    0xb0b07bcb,  0x5454a8fc,  0xbbbb6dd6,  0x16162c3a\n};\n\nunsigned int TE2[256] = {\n    0x63c6a563,  0x7cf8847c,  0x77ee9977,  0x7bf68d7b,\n    0xf2ff0df2,  0x6bd6bd6b,  0x6fdeb16f,  0xc59154c5,\n    0x30605030,  0x1020301,  0x67cea967,  0x2b567d2b,\n    0xfee719fe,  0xd7b562d7,  0xab4de6ab,  0x76ec9a76,\n    0xca8f45ca,  0x821f9d82,  0xc98940c9,  0x7dfa877d,\n    0xfaef15fa,  0x59b2eb59,  0x478ec947,  0xf0fb0bf0,\n    0xad41ecad,  0xd4b367d4,  0xa25ffda2,  0xaf45eaaf,\n    0x9c23bf9c,  0xa453f7a4,  0x72e49672,  0xc09b5bc0,\n    0xb775c2b7,  0xfde11cfd,  0x933dae93,  0x264c6a26,\n    0x366c5a36,  0x3f7e413f,  0xf7f502f7,  0xcc834fcc,\n    0x34685c34,  0xa551f4a5,  0xe5d134e5,  0xf1f908f1,\n    0x71e29371,  0xd8ab73d8,  0x31625331,  0x152a3f15,\n    0x4080c04,  0xc79552c7,  0x23466523,  0xc39d5ec3,\n    0x18302818,  0x9637a196,  0x50a0f05,  0x9a2fb59a,\n    0x70e0907,  0x12243612,  0x801b9b80,  0xe2df3de2,\n    0xebcd26eb,  0x274e6927,  0xb27fcdb2,  0x75ea9f75,\n    0x9121b09,  0x831d9e83,  0x2c58742c,  0x1a342e1a,\n    0x1b362d1b,  0x6edcb26e,  0x5ab4ee5a,  0xa05bfba0,\n    0x52a4f652,  0x3b764d3b,  0xd6b761d6,  0xb37dceb3,\n    0x29527b29,  0xe3dd3ee3,  0x2f5e712f,  0x84139784,\n    0x53a6f553,  0xd1b968d1,  0x0,  0xedc12ced,\n    0x20406020,  0xfce31ffc,  0xb179c8b1,  0x5bb6ed5b,\n    0x6ad4be6a,  0xcb8d46cb,  0xbe67d9be,  0x39724b39,\n    0x4a94de4a,  0x4c98d44c,  0x58b0e858,  0xcf854acf,\n    0xd0bb6bd0,  0xefc52aef,  0xaa4fe5aa,  0xfbed16fb,\n    0x4386c543,  0x4d9ad74d,  0x33665533,  0x85119485,\n    0x458acf45,  0xf9e910f9,  0x2040602,  0x7ffe817f,\n    0x50a0f050,  0x3c78443c,  0x9f25ba9f,  0xa84be3a8,\n    0x51a2f351,  0xa35dfea3,  0x4080c040,  0x8f058a8f,\n    0x923fad92,  0x9d21bc9d,  0x38704838,  0xf5f104f5,\n    0xbc63dfbc,  0xb677c1b6,  0xdaaf75da,  0x21426321,\n    0x10203010,  0xffe51aff,  0xf3fd0ef3,  0xd2bf6dd2,\n    0xcd814ccd,  0xc18140c,  0x13263513,  0xecc32fec,\n    0x5fbee15f,  0x9735a297,  0x4488cc44,  0x172e3917,\n    0xc49357c4,  0xa755f2a7,  0x7efc827e,  0x3d7a473d,\n    0x64c8ac64,  0x5dbae75d,  0x19322b19,  0x73e69573,\n    0x60c0a060,  0x81199881,  0x4f9ed14f,  0xdca37fdc,\n    0x22446622,  0x2a547e2a,  0x903bab90,  0x880b8388,\n    0x468cca46,  0xeec729ee,  0xb86bd3b8,  0x14283c14,\n    0xdea779de,  0x5ebce25e,  0xb161d0b,  0xdbad76db,\n    0xe0db3be0,  0x32645632,  0x3a744e3a,  0xa141e0a,\n    0x4992db49,  0x60c0a06,  0x24486c24,  0x5cb8e45c,\n    0xc29f5dc2,  0xd3bd6ed3,  0xac43efac,  0x62c4a662,\n    0x9139a891,  0x9531a495,  0xe4d337e4,  0x79f28b79,\n    0xe7d532e7,  0xc88b43c8,  0x376e5937,  0x6ddab76d,\n    0x8d018c8d,  0xd5b164d5,  0x4e9cd24e,  0xa949e0a9,\n    0x6cd8b46c,  0x56acfa56,  0xf4f307f4,  0xeacf25ea,\n    0x65caaf65,  0x7af48e7a,  0xae47e9ae,  0x8101808,\n    0xba6fd5ba,  0x78f08878,  0x254a6f25,  0x2e5c722e,\n    0x1c38241c,  0xa657f1a6,  0xb473c7b4,  0xc69751c6,\n    0xe8cb23e8,  0xdda17cdd,  0x74e89c74,  0x1f3e211f,\n    0x4b96dd4b,  0xbd61dcbd,  0x8b0d868b,  0x8a0f858a,\n    0x70e09070,  0x3e7c423e,  0xb571c4b5,  0x66ccaa66,\n    0x4890d848,  0x3060503,  0xf6f701f6,  0xe1c120e,\n    0x61c2a361,  0x356a5f35,  0x57aef957,  0xb969d0b9,\n    0x86179186,  0xc19958c1,  0x1d3a271d,  0x9e27b99e,\n    0xe1d938e1,  0xf8eb13f8,  0x982bb398,  0x11223311,\n    0x69d2bb69,  0xd9a970d9,  0x8e07898e,  0x9433a794,\n    0x9b2db69b,  0x1e3c221e,  0x87159287,  0xe9c920e9,\n    0xce8749ce,  0x55aaff55,  0x28507828,  0xdfa57adf,\n    0x8c038f8c,  0xa159f8a1,  0x89098089,  0xd1a170d,\n    0xbf65dabf,  0xe6d731e6,  0x4284c642,  0x68d0b868,\n    0x4182c341,  0x9929b099,  0x2d5a772d,  0xf1e110f,\n    0xb07bcbb0,  0x54a8fc54,  0xbb6dd6bb,  0x162c3a16\n};\n\nunsigned int TE3[256] = {\n    0xc6a56363,  0xf8847c7c,  0xee997777,  0xf68d7b7b,\n    0xff0df2f2,  0xd6bd6b6b,  0xdeb16f6f,  0x9154c5c5,\n    0x60503030,  0x2030101,  0xcea96767,  0x567d2b2b,\n    0xe719fefe,  0xb562d7d7,  0x4de6abab,  0xec9a7676,\n    0x8f45caca,  0x1f9d8282,  0x8940c9c9,  0xfa877d7d,\n    0xef15fafa,  0xb2eb5959,  0x8ec94747,  0xfb0bf0f0,\n    0x41ecadad,  0xb367d4d4,  0x5ffda2a2,  0x45eaafaf,\n    0x23bf9c9c,  0x53f7a4a4,  0xe4967272,  0x9b5bc0c0,\n    0x75c2b7b7,  0xe11cfdfd,  0x3dae9393,  0x4c6a2626,\n    0x6c5a3636,  0x7e413f3f,  0xf502f7f7,  0x834fcccc,\n    0x685c3434,  0x51f4a5a5,  0xd134e5e5,  0xf908f1f1,\n    0xe2937171,  0xab73d8d8,  0x62533131,  0x2a3f1515,\n    0x80c0404,  0x9552c7c7,  0x46652323,  0x9d5ec3c3,\n    0x30281818,  0x37a19696,  0xa0f0505,  0x2fb59a9a,\n    0xe090707,  0x24361212,  0x1b9b8080,  0xdf3de2e2,\n    0xcd26ebeb,  0x4e692727,  0x7fcdb2b2,  0xea9f7575,\n    0x121b0909,  0x1d9e8383,  0x58742c2c,  0x342e1a1a,\n    0x362d1b1b,  0xdcb26e6e,  0xb4ee5a5a,  0x5bfba0a0,\n    0xa4f65252,  0x764d3b3b,  0xb761d6d6,  0x7dceb3b3,\n    0x527b2929,  0xdd3ee3e3,  0x5e712f2f,  0x13978484,\n    0xa6f55353,  0xb968d1d1,  0x0,  0xc12ceded,\n    0x40602020,  0xe31ffcfc,  0x79c8b1b1,  0xb6ed5b5b,\n    0xd4be6a6a,  0x8d46cbcb,  0x67d9bebe,  0x724b3939,\n    0x94de4a4a,  0x98d44c4c,  0xb0e85858,  0x854acfcf,\n    0xbb6bd0d0,  0xc52aefef,  0x4fe5aaaa,  0xed16fbfb,\n    0x86c54343,  0x9ad74d4d,  0x66553333,  0x11948585,\n    0x8acf4545,  0xe910f9f9,  0x4060202,  0xfe817f7f,\n    0xa0f05050,  0x78443c3c,  0x25ba9f9f,  0x4be3a8a8,\n    0xa2f35151,  0x5dfea3a3,  0x80c04040,  0x58a8f8f,\n    0x3fad9292,  0x21bc9d9d,  0x70483838,  0xf104f5f5,\n    0x63dfbcbc,  0x77c1b6b6,  0xaf75dada,  0x42632121,\n    0x20301010,  0xe51affff,  0xfd0ef3f3,  0xbf6dd2d2,\n    0x814ccdcd,  0x18140c0c,  0x26351313,  0xc32fecec,\n    0xbee15f5f,  0x35a29797,  0x88cc4444,  0x2e391717,\n    0x9357c4c4,  0x55f2a7a7,  0xfc827e7e,  0x7a473d3d,\n    0xc8ac6464,  0xbae75d5d,  0x322b1919,  0xe6957373,\n    0xc0a06060,  0x19988181,  0x9ed14f4f,  0xa37fdcdc,\n    0x44662222,  0x547e2a2a,  0x3bab9090,  0xb838888,\n    0x8cca4646,  0xc729eeee,  0x6bd3b8b8,  0x283c1414,\n    0xa779dede,  0xbce25e5e,  0x161d0b0b,  0xad76dbdb,\n    0xdb3be0e0,  0x64563232,  0x744e3a3a,  0x141e0a0a,\n    0x92db4949,  0xc0a0606,  0x486c2424,  0xb8e45c5c,\n    0x9f5dc2c2,  0xbd6ed3d3,  0x43efacac,  0xc4a66262,\n    0x39a89191,  0x31a49595,  0xd337e4e4,  0xf28b7979,\n    0xd532e7e7,  0x8b43c8c8,  0x6e593737,  0xdab76d6d,\n    0x18c8d8d,  0xb164d5d5,  0x9cd24e4e,  0x49e0a9a9,\n    0xd8b46c6c,  0xacfa5656,  0xf307f4f4,  0xcf25eaea,\n    0xcaaf6565,  0xf48e7a7a,  0x47e9aeae,  0x10180808,\n    0x6fd5baba,  0xf0887878,  0x4a6f2525,  0x5c722e2e,\n    0x38241c1c,  0x57f1a6a6,  0x73c7b4b4,  0x9751c6c6,\n    0xcb23e8e8,  0xa17cdddd,  0xe89c7474,  0x3e211f1f,\n    0x96dd4b4b,  0x61dcbdbd,  0xd868b8b,  0xf858a8a,\n    0xe0907070,  0x7c423e3e,  0x71c4b5b5,  0xccaa6666,\n    0x90d84848,  0x6050303,  0xf701f6f6,  0x1c120e0e,\n    0xc2a36161,  0x6a5f3535,  0xaef95757,  0x69d0b9b9,\n    0x17918686,  0x9958c1c1,  0x3a271d1d,  0x27b99e9e,\n    0xd938e1e1,  0xeb13f8f8,  0x2bb39898,  0x22331111,\n    0xd2bb6969,  0xa970d9d9,  0x7898e8e,  0x33a79494,\n    0x2db69b9b,  0x3c221e1e,  0x15928787,  0xc920e9e9,\n    0x8749cece,  0xaaff5555,  0x50782828,  0xa57adfdf,\n    0x38f8c8c,  0x59f8a1a1,  0x9808989,  0x1a170d0d,\n    0x65dabfbf,  0xd731e6e6,  0x84c64242,  0xd0b86868,\n    0x82c34141,  0x29b09999,  0x5a772d2d,  0x1e110f0f,\n    0x7bcbb0b0,  0xa8fc5454,  0x6dd6bbbb,  0x2c3a1616\n};\n\nunsigned int TE4[256] = {\n    0x63636363,  0x7c7c7c7c,  0x77777777,  0x7b7b7b7b,\n    0xf2f2f2f2,  0x6b6b6b6b,  0x6f6f6f6f,  0xc5c5c5c5,\n    0x30303030,  0x1010101,  0x67676767,  0x2b2b2b2b,\n    0xfefefefe,  0xd7d7d7d7,  0xabababab,  0x76767676,\n    0xcacacaca,  0x82828282,  0xc9c9c9c9,  0x7d7d7d7d,\n    0xfafafafa,  0x59595959,  0x47474747,  0xf0f0f0f0,\n    0xadadadad,  0xd4d4d4d4,  0xa2a2a2a2,  0xafafafaf,\n    0x9c9c9c9c,  0xa4a4a4a4,  0x72727272,  0xc0c0c0c0,\n    0xb7b7b7b7,  0xfdfdfdfd,  0x93939393,  0x26262626,\n    0x36363636,  0x3f3f3f3f,  0xf7f7f7f7,  0xcccccccc,\n    0x34343434,  0xa5a5a5a5,  0xe5e5e5e5,  0xf1f1f1f1,\n    0x71717171,  0xd8d8d8d8,  0x31313131,  0x15151515,\n    0x4040404,  0xc7c7c7c7,  0x23232323,  0xc3c3c3c3,\n    0x18181818,  0x96969696,  0x5050505,  0x9a9a9a9a,\n    0x7070707,  0x12121212,  0x80808080,  0xe2e2e2e2,\n    0xebebebeb,  0x27272727,  0xb2b2b2b2,  0x75757575,\n    0x9090909,  0x83838383,  0x2c2c2c2c,  0x1a1a1a1a,\n    0x1b1b1b1b,  0x6e6e6e6e,  0x5a5a5a5a,  0xa0a0a0a0,\n    0x52525252,  0x3b3b3b3b,  0xd6d6d6d6,  0xb3b3b3b3,\n    0x29292929,  0xe3e3e3e3,  0x2f2f2f2f,  0x84848484,\n    0x53535353,  0xd1d1d1d1,  0x0,  0xedededed,\n    0x20202020,  0xfcfcfcfc,  0xb1b1b1b1,  0x5b5b5b5b,\n    0x6a6a6a6a,  0xcbcbcbcb,  0xbebebebe,  0x39393939,\n    0x4a4a4a4a,  0x4c4c4c4c,  0x58585858,  0xcfcfcfcf,\n    0xd0d0d0d0,  0xefefefef,  0xaaaaaaaa,  0xfbfbfbfb,\n    0x43434343,  0x4d4d4d4d,  0x33333333,  0x85858585,\n    0x45454545,  0xf9f9f9f9,  0x2020202,  0x7f7f7f7f,\n    0x50505050,  0x3c3c3c3c,  0x9f9f9f9f,  0xa8a8a8a8,\n    0x51515151,  0xa3a3a3a3,  0x40404040,  0x8f8f8f8f,\n    0x92929292,  0x9d9d9d9d,  0x38383838,  0xf5f5f5f5,\n    0xbcbcbcbc,  0xb6b6b6b6,  0xdadadada,  0x21212121,\n    0x10101010,  0xffffffff,  0xf3f3f3f3,  0xd2d2d2d2,\n    0xcdcdcdcd,  0xc0c0c0c,  0x13131313,  0xecececec,\n    0x5f5f5f5f,  0x97979797,  0x44444444,  0x17171717,\n    0xc4c4c4c4,  0xa7a7a7a7,  0x7e7e7e7e,  0x3d3d3d3d,\n    0x64646464,  0x5d5d5d5d,  0x19191919,  0x73737373,\n    0x60606060,  0x81818181,  0x4f4f4f4f,  0xdcdcdcdc,\n    0x22222222,  0x2a2a2a2a,  0x90909090,  0x88888888,\n    0x46464646,  0xeeeeeeee,  0xb8b8b8b8,  0x14141414,\n    0xdededede,  0x5e5e5e5e,  0xb0b0b0b,  0xdbdbdbdb,\n    0xe0e0e0e0,  0x32323232,  0x3a3a3a3a,  0xa0a0a0a,\n    0x49494949,  0x6060606,  0x24242424,  0x5c5c5c5c,\n    0xc2c2c2c2,  0xd3d3d3d3,  0xacacacac,  0x62626262,\n    0x91919191,  0x95959595,  0xe4e4e4e4,  0x79797979,\n    0xe7e7e7e7,  0xc8c8c8c8,  0x37373737,  0x6d6d6d6d,\n    0x8d8d8d8d,  0xd5d5d5d5,  0x4e4e4e4e,  0xa9a9a9a9,\n    0x6c6c6c6c,  0x56565656,  0xf4f4f4f4,  0xeaeaeaea,\n    0x65656565,  0x7a7a7a7a,  0xaeaeaeae,  0x8080808,\n    0xbabababa,  0x78787878,  0x25252525,  0x2e2e2e2e,\n    0x1c1c1c1c,  0xa6a6a6a6,  0xb4b4b4b4,  0xc6c6c6c6,\n    0xe8e8e8e8,  0xdddddddd,  0x74747474,  0x1f1f1f1f,\n    0x4b4b4b4b,  0xbdbdbdbd,  0x8b8b8b8b,  0x8a8a8a8a,\n    0x70707070,  0x3e3e3e3e,  0xb5b5b5b5,  0x66666666,\n    0x48484848,  0x3030303,  0xf6f6f6f6,  0xe0e0e0e,\n    0x61616161,  0x35353535,  0x57575757,  0xb9b9b9b9,\n    0x86868686,  0xc1c1c1c1,  0x1d1d1d1d,  0x9e9e9e9e,\n    0xe1e1e1e1,  0xf8f8f8f8,  0x98989898,  0x11111111,\n    0x69696969,  0xd9d9d9d9,  0x8e8e8e8e,  0x94949494,\n    0x9b9b9b9b,  0x1e1e1e1e,  0x87878787,  0xe9e9e9e9,\n    0xcececece,  0x55555555,  0x28282828,  0xdfdfdfdf,\n    0x8c8c8c8c,  0xa1a1a1a1,  0x89898989,  0xd0d0d0d,\n    0xbfbfbfbf,  0xe6e6e6e6,  0x42424242,  0x68686868,\n    0x41414141,  0x99999999,  0x2d2d2d2d,  0xf0f0f0f,\n    0xb0b0b0b0,  0x54545454,  0xbbbbbbbb,  0x16161616\n};\n\n\nstatic const U32 rcon[] = {\n    0x01, 0x02, 0x04, 0x08,\n    0x10, 0x20, 0x40, 0x80,\n    0x1B, 0x36, /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */\n};\n\nvoid AESKeySteup(const unsigned char* rk, unsigned int* rkexp)\n{\n    // round key 0\n    memcpy(rkexp, rk, 16);\n\n    // round key 1\n    rkexp += 4;\n    rkexp[0] = ((unsigned int *)rk)[0] ^\n        (TE4[((rkexp-4)[3] >> 8) & 0xff] & 0x000000ff) ^\n        (TE4[((rkexp-4)[3] >> 16) & 0xff] & 0x0000ff00) ^\n        (TE4[(rkexp-4)[3] >> 24] & 0x00ff0000) ^\n        (TE4[(rkexp-4)[3] & 0xff] & 0xff000000) ^\n        rcon[0];\n    rkexp[1] = rkexp[0] ^ (rkexp-4)[1];\n    rkexp[2] = rkexp[1] ^ (rkexp-4)[2];\n    rkexp[3] = rkexp[2] ^ (rkexp-4)[3];\n\n    // round key 2\n    rkexp += 4;\n    rkexp[0] = (rkexp-4)[0] ^\n        (TE4[((rkexp-4)[3] >> 8) & 0xff] & 0x000000ff) ^\n        (TE4[((rkexp-4)[3] >> 16) & 0xff] & 0x0000ff00) ^\n        (TE4[(rkexp-4)[3] >> 24] & 0x00ff0000) ^\n        (TE4[(rkexp-4)[3] & 0xff] & 0xff000000) ^\n        rcon[1];\n    rkexp[1] = rkexp[0] ^ (rkexp-4)[1];\n    rkexp[2] = rkexp[1] ^ (rkexp-4)[2];\n    rkexp[3] = rkexp[2] ^ (rkexp-4)[3];\n\n    // round key 3\n    rkexp += 4;\n    rkexp[0] = (rkexp-4)[0] ^\n        (TE4[((rkexp-4)[3] >> 8) & 0xff] & 0x000000ff) ^\n        (TE4[((rkexp-4)[3] >> 16) & 0xff] & 0x0000ff00) ^\n        (TE4[(rkexp-4)[3] >> 24] & 0x00ff0000) ^\n        (TE4[(rkexp-4)[3] & 0xff] & 0xff000000) ^\n        rcon[2];\n    rkexp[1] = rkexp[0] ^ (rkexp-4)[1];\n    rkexp[2] = rkexp[1] ^ (rkexp-4)[2];\n    rkexp[3] = rkexp[2] ^ (rkexp-4)[3];\n\n    // round key 4\n    rkexp += 4;\n    rkexp[0] = (rkexp-4)[0] ^\n        (TE4[((rkexp-4)[3] >> 8) & 0xff] & 0x000000ff) ^\n        (TE4[((rkexp-4)[3] >> 16) & 0xff] & 0x0000ff00) ^\n        (TE4[(rkexp-4)[3] >> 24] & 0x00ff0000) ^\n        (TE4[(rkexp-4)[3] & 0xff] & 0xff000000) ^\n        rcon[3];\n    rkexp[1] = rkexp[0] ^ (rkexp-4)[1];\n    rkexp[2] = rkexp[1] ^ (rkexp-4)[2];\n    rkexp[3] = rkexp[2] ^ (rkexp-4)[3];\n\n    // round key 5\n    rkexp += 4;\n    rkexp[0] = (rkexp-4)[0] ^\n        (TE4[((rkexp-4)[3] >> 8) & 0xff] & 0x000000ff) ^\n        (TE4[((rkexp-4)[3] >> 16) & 0xff] & 0x0000ff00) ^\n        (TE4[(rkexp-4)[3] >> 24] & 0x00ff0000) ^\n        (TE4[(rkexp-4)[3] & 0xff] & 0xff000000) ^\n        rcon[4];\n    rkexp[1] = rkexp[0] ^ (rkexp-4)[1];\n    rkexp[2] = rkexp[1] ^ (rkexp-4)[2];\n    rkexp[3] = rkexp[2] ^ (rkexp-4)[3];\n\n    // round key 6\n    rkexp += 4;\n    rkexp[0] = (rkexp-4)[0] ^\n        (TE4[((rkexp-4)[3] >> 8) & 0xff] & 0x000000ff) ^\n        (TE4[((rkexp-4)[3] >> 16) & 0xff] & 0x0000ff00) ^\n        (TE4[(rkexp-4)[3] >> 24] & 0x00ff0000) ^\n        (TE4[(rkexp-4)[3] & 0xff] & 0xff000000) ^\n        rcon[5];\n    rkexp[1] = rkexp[0] ^ (rkexp-4)[1];\n    rkexp[2] = rkexp[1] ^ (rkexp-4)[2];\n    rkexp[3] = rkexp[2] ^ (rkexp-4)[3];\n\n    // round key 7\n    rkexp += 4;\n    rkexp[0] = (rkexp-4)[0] ^\n        (TE4[((rkexp-4)[3] >> 8) & 0xff] & 0x000000ff) ^\n        (TE4[((rkexp-4)[3] >> 16) & 0xff] & 0x0000ff00) ^\n        (TE4[(rkexp-4)[3] >> 24] & 0x00ff0000) ^\n        (TE4[(rkexp-4)[3] & 0xff] & 0xff000000) ^\n        rcon[6];\n    rkexp[1] = rkexp[0] ^ (rkexp-4)[1];\n    rkexp[2] = rkexp[1] ^ (rkexp-4)[2];\n    rkexp[3] = rkexp[2] ^ (rkexp-4)[3];\n\n    // round key 8\n    rkexp += 4;\n    rkexp[0] = (rkexp-4)[0] ^\n        (TE4[((rkexp-4)[3] >> 8) & 0xff] & 0x000000ff) ^\n        (TE4[((rkexp-4)[3] >> 16) & 0xff] & 0x0000ff00) ^\n        (TE4[(rkexp-4)[3] >> 24] & 0x00ff0000) ^\n        (TE4[(rkexp-4)[3] & 0xff] & 0xff000000) ^\n        rcon[7];\n    rkexp[1] = rkexp[0] ^ (rkexp-4)[1];\n    rkexp[2] = rkexp[1] ^ (rkexp-4)[2];\n    rkexp[3] = rkexp[2] ^ (rkexp-4)[3];\n\n    // round key 9\n    rkexp += 4;\n    rkexp[0] = (rkexp-4)[0] ^\n        (TE4[((rkexp-4)[3] >> 8) & 0xff] & 0x000000ff) ^\n        (TE4[((rkexp-4)[3] >> 16) & 0xff] & 0x0000ff00) ^\n        (TE4[(rkexp-4)[3] >> 24] & 0x00ff0000) ^\n        (TE4[(rkexp-4)[3] & 0xff] & 0xff000000) ^\n        rcon[8];\n    rkexp[1] = rkexp[0] ^ (rkexp-4)[1];\n    rkexp[2] = rkexp[1] ^ (rkexp-4)[2];\n    rkexp[3] = rkexp[2] ^ (rkexp-4)[3];\n\n    // round key 10\n    rkexp += 4;\n    rkexp[0] = (rkexp-4)[0] ^\n        (TE4[((rkexp-4)[3] >> 8) & 0xff] & 0x000000ff) ^\n        (TE4[((rkexp-4)[3] >> 16) & 0xff] & 0x0000ff00) ^\n        (TE4[(rkexp-4)[3] >> 24] & 0x00ff0000) ^\n        (TE4[(rkexp-4)[3] & 0xff] & 0xff000000) ^\n        rcon[9];\n    rkexp[1] = rkexp[0] ^ (rkexp-4)[1];\n    rkexp[2] = rkexp[1] ^ (rkexp-4)[2];\n    rkexp[3] = rkexp[2] ^ (rkexp-4)[3];\n}\n\nvoid inline AESRound(unsigned char *out, unsigned char *in, const unsigned int*rk)\n{\n      ((U32*)out)[0] = TE0[*(in+0)]  ^ TE1[*(in+5)]  ^ TE2[*(in+10)] ^ TE3[*(in+15)] ^ rk[0];\n      ((U32*)out)[1] = TE0[*(in+4)]  ^ TE1[*(in+9)]  ^ TE2[*(in+14)] ^ TE3[*(in+3)]  ^ rk[1];\n      ((U32*)out)[2] = TE0[*(in+8)]  ^ TE1[*(in+13)] ^ TE2[*(in+2)]  ^ TE3[*(in+7)]  ^ rk[2];\n      ((U32*)out)[3] = TE0[*(in+12)] ^ TE1[*(in+1)]  ^ TE2[*(in+6)]  ^ TE3[*(in+11)] ^ rk[3];\n}\n\nvoid inline AESRoundFinal(unsigned char *out, unsigned char *in, const unsigned int*rk)\n{\n    ((U32*)out)[0] = (TE4[*(in+0)] & 0x000000ff)  ^ (TE4[*(in+5)] & 0x0000ff00)   ^ (TE4[*(in+10)] & 0x00ff0000) ^ (TE4[*(in+15)] & 0xff000000) ^ rk[0];\n    ((U32*)out)[1] = (TE4[*(in+4)] & 0x000000ff)  ^ (TE4[*(in+9)] & 0x0000ff00)   ^ (TE4[*(in+14)] & 0x00ff0000) ^ (TE4[*(in+3)] & 0xff000000)   ^ rk[1];\n    ((U32*)out)[2] = (TE4[*(in+8)] & 0x000000ff)  ^ (TE4[*(in+13)] & 0x0000ff00) ^ (TE4[*(in+2)] & 0x00ff0000)   ^ (TE4[*(in+7)] & 0xff000000)   ^ rk[2];\n    ((U32*)out)[3] = (TE4[*(in+12)] & 0x000000ff)^ (TE4[*(in+1)] & 0x0000ff00)   ^ (TE4[*(in+6)] & 0x00ff0000)   ^ (TE4[*(in+11)] & 0xff000000) ^ rk[3];\n}\n\nvoid AESEncrypt(const unsigned int*rk, unsigned int *state)\n{\n    unsigned int s0, s1, s2, s3, t0, t1, t2, t3;\n\n    s0 = state[0] ^ rk[0];\n    s1 = state[1] ^ rk[1];\n    s2 = state[2] ^ rk[2];\n    s3 = state[3] ^ rk[3];\n\n    /* round 1: */\n    t0 = TE0[s0 & 0xff] ^ TE1[(s1 >>  8) & 0xff] ^ TE2[(s2 >>  16) & 0xff] ^ TE3[s3 >> 24] ^ rk[ 4];\n    t1 = TE0[s1 & 0xff] ^ TE1[(s2 >>  8) & 0xff] ^ TE2[(s3 >>  16) & 0xff] ^ TE3[s0 >> 24] ^ rk[ 5];\n    t2 = TE0[s2 & 0xff] ^ TE1[(s3 >>  8) & 0xff] ^ TE2[(s0 >>  16) & 0xff] ^ TE3[s1 >> 24] ^ rk[ 6];\n    t3 = TE0[s3 & 0xff] ^ TE1[(s0 >>  8) & 0xff] ^ TE2[(s1 >>  16) & 0xff] ^ TE3[s2 >> 24] ^ rk[ 7];\n    /* round 2: */\n    s0 = TE0[t0 & 0xff] ^ TE1[(t1 >>  8) & 0xff] ^ TE2[(t2 >>  16) & 0xff] ^ TE3[t3 >> 24] ^ rk[ 8];\n    s1 = TE0[t1 & 0xff] ^ TE1[(t2 >>  8) & 0xff] ^ TE2[(t3 >>  16) & 0xff] ^ TE3[t0 >> 24] ^ rk[ 9];\n    s2 = TE0[t2 & 0xff] ^ TE1[(t3 >>  8) & 0xff] ^ TE2[(t0 >>  16) & 0xff] ^ TE3[t1 >> 24] ^ rk[10];\n    s3 = TE0[t3 & 0xff] ^ TE1[(t0 >>  8) & 0xff] ^ TE2[(t1 >>  16) & 0xff] ^ TE3[t2 >> 24] ^ rk[11];\n    /* round 3: */\n    t0 = TE0[s0 & 0xff] ^ TE1[(s1 >>  8) & 0xff] ^ TE2[(s2 >>  16) & 0xff] ^ TE3[s3 >> 24] ^ rk[12];\n    t1 = TE0[s1 & 0xff] ^ TE1[(s2 >>  8) & 0xff] ^ TE2[(s3 >>  16) & 0xff] ^ TE3[s0 >> 24] ^ rk[13];\n    t2 = TE0[s2 & 0xff] ^ TE1[(s3 >>  8) & 0xff] ^ TE2[(s0 >>  16) & 0xff] ^ TE3[s1 >> 24] ^ rk[14];\n    t3 = TE0[s3 & 0xff] ^ TE1[(s0 >>  8) & 0xff] ^ TE2[(s1 >>  16) & 0xff] ^ TE3[s2 >> 24] ^ rk[15];\n    /* round 4: */\n    s0 = TE0[t0 & 0xff] ^ TE1[(t1 >>  8) & 0xff] ^ TE2[(t2 >>  16) & 0xff] ^ TE3[t3 >> 24] ^ rk[16];\n    s1 = TE0[t1 & 0xff] ^ TE1[(t2 >>  8) & 0xff] ^ TE2[(t3 >>  16) & 0xff] ^ TE3[t0 >> 24] ^ rk[17];\n    s2 = TE0[t2 & 0xff] ^ TE1[(t3 >>  8) & 0xff] ^ TE2[(t0 >>  16) & 0xff] ^ TE3[t1 >> 24] ^ rk[18];\n    s3 = TE0[t3 & 0xff] ^ TE1[(t0 >>  8) & 0xff] ^ TE2[(t1 >>  16) & 0xff] ^ TE3[t2 >> 24] ^ rk[19];\n    /* round 5: */\n    t0 = TE0[s0 & 0xff] ^ TE1[(s1 >>  8) & 0xff] ^ TE2[(s2 >>  16) & 0xff] ^ TE3[s3 >> 24] ^ rk[20];\n    t1 = TE0[s1 & 0xff] ^ TE1[(s2 >>  8) & 0xff] ^ TE2[(s3 >>  16) & 0xff] ^ TE3[s0 >> 24] ^ rk[21];\n    t2 = TE0[s2 & 0xff] ^ TE1[(s3 >>  8) & 0xff] ^ TE2[(s0 >>  16) & 0xff] ^ TE3[s1 >> 24] ^ rk[22];\n    t3 = TE0[s3 & 0xff] ^ TE1[(s0 >>  8) & 0xff] ^ TE2[(s1 >>  16) & 0xff] ^ TE3[s2 >> 24] ^ rk[23];\n    /* round 6: */\n    s0 = TE0[t0 & 0xff] ^ TE1[(t1 >>  8) & 0xff] ^ TE2[(t2 >>  16) & 0xff] ^ TE3[t3 >> 24] ^ rk[24];\n    s1 = TE0[t1 & 0xff] ^ TE1[(t2 >>  8) & 0xff] ^ TE2[(t3 >>  16) & 0xff] ^ TE3[t0 >> 24] ^ rk[25];\n    s2 = TE0[t2 & 0xff] ^ TE1[(t3 >>  8) & 0xff] ^ TE2[(t0 >>  16) & 0xff] ^ TE3[t1 >> 24] ^ rk[26];\n    s3 = TE0[t3 & 0xff] ^ TE1[(t0 >>  8) & 0xff] ^ TE2[(t1 >>  16) & 0xff] ^ TE3[t2 >> 24] ^ rk[27];\n    /* round 7: */\n    t0 = TE0[s0 & 0xff] ^ TE1[(s1 >>  8) & 0xff] ^ TE2[(s2 >>  16) & 0xff] ^ TE3[s3 >> 24] ^ rk[28];\n    t1 = TE0[s1 & 0xff] ^ TE1[(s2 >>  8) & 0xff] ^ TE2[(s3 >>  16) & 0xff] ^ TE3[s0 >> 24] ^ rk[29];\n    t2 = TE0[s2 & 0xff] ^ TE1[(s3 >>  8) & 0xff] ^ TE2[(s0 >>  16) & 0xff] ^ TE3[s1 >> 24] ^ rk[30];\n    t3 = TE0[s3 & 0xff] ^ TE1[(s0 >>  8) & 0xff] ^ TE2[(s1 >>  16) & 0xff] ^ TE3[s2 >> 24] ^ rk[31];\n    /* round 8: */\n    s0 = TE0[t0 & 0xff] ^ TE1[(t1 >>  8) & 0xff] ^ TE2[(t2 >>  16) & 0xff] ^ TE3[t3 >> 24] ^ rk[32];\n    s1 = TE0[t1 & 0xff] ^ TE1[(t2 >>  8) & 0xff] ^ TE2[(t3 >>  16) & 0xff] ^ TE3[t0 >> 24] ^ rk[33];\n    s2 = TE0[t2 & 0xff] ^ TE1[(t3 >>  8) & 0xff] ^ TE2[(t0 >>  16) & 0xff] ^ TE3[t1 >> 24] ^ rk[34];\n    s3 = TE0[t3 & 0xff] ^ TE1[(t0 >>  8) & 0xff] ^ TE2[(t1 >>  16) & 0xff] ^ TE3[t2 >> 24] ^ rk[35];\n    /* round 9: */\n    t0 = TE0[s0 & 0xff] ^ TE1[(s1 >>  8) & 0xff] ^ TE2[(s2 >>  16) & 0xff] ^ TE3[s3 >> 24] ^ rk[36];\n    t1 = TE0[s1 & 0xff] ^ TE1[(s2 >>  8) & 0xff] ^ TE2[(s3 >>  16) & 0xff] ^ TE3[s0 >> 24] ^ rk[37];\n    t2 = TE0[s2 & 0xff] ^ TE1[(s3 >>  8) & 0xff] ^ TE2[(s0 >>  16) & 0xff] ^ TE3[s1 >> 24] ^ rk[38];\n    t3 = TE0[s3 & 0xff] ^ TE1[(s0 >>  8) & 0xff] ^ TE2[(s1 >>  16) & 0xff] ^ TE3[s2 >> 24] ^ rk[39];\n    rk += 40;\n    /* round 10 */\n    state[0] = (TE4[t0 & 0xff] & 0x000000ff)  ^ (TE4[(t1 >> 8) & 0xff] & 0x0000ff00)   ^ (TE4[(t2 >> 16) & 0xff] & 0x00ff0000)   ^ (TE4[(t3 >> 24) & 0xff] & 0xff000000) ^ rk[0];\n    state[1] = (TE4[t1 & 0xff] & 0x000000ff)  ^ (TE4[(t2 >> 8) & 0xff] & 0x0000ff00)   ^ (TE4[(t3 >> 16) & 0xff] & 0x00ff0000)   ^ (TE4[(t0 >> 24) & 0xff] &  0xff000000) ^ rk[1];\n    state[2] = (TE4[t2 & 0xff] & 0x000000ff)  ^ (TE4[(t3 >> 8) & 0xff] & 0x0000ff00)   ^ (TE4[(t0 >> 16) & 0xff] & 0x00ff0000)   ^ (TE4[(t1 >> 24) & 0xff]  & 0xff000000) ^ rk[2];\n    state[3] = (TE4[t3 & 0xff] & 0x000000ff)  ^ (TE4[(t0 >> 8) & 0xff] & 0x0000ff00)   ^ (TE4[(t1 >> 16) & 0xff] & 0x00ff0000)   ^ (TE4[(t2 >> 24) & 0xff] & 0xff000000) ^ rk[3];\n\n}\n\n\n} // namespace Aesjambuv1_raw\n"
        },
        {
            "file_name": "aesjambuv1_encrypt.cpp",
            "content": "#include \"aesjambuv1_encrypt.h\"\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"aesjambuv1_aes.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Aesjambuv1_raw {\nint numRounds = -1;\n\n#ifdef _MSC_VER\n#define inline __inline\n#endif\n\nstatic inline void jambu_initialization(const unsigned int *rk, const uint8_t *iv, unsigned int *stateS, unsigned int *stateR)\n{\n\n    stateS[0] = ((unsigned int *)iv)[0]; stateS[1] = ((unsigned int *)iv)[1];\n    AESEncrypt(rk, stateS);\n    stateS[0] ^= 0x5;\n    stateR[0] = stateS[2];\n    stateR[1] = stateS[3];\n    return;\n\n}\n\nstatic inline void jambu_tag_generation(const unsigned int *rk, uint64_t msglen, uint8_t *c, unsigned int *stateS, unsigned int *stateR)\n{\n\n    AESEncrypt(rk, stateS);\n    stateS[0] ^= stateR[0] ^ 0x03;\n    stateS[1] ^= stateR[1];\n    stateR[0] ^= stateS[2];\n    stateR[1] ^= stateS[3];\n\n    AESEncrypt(rk, stateS);\n\n    ((unsigned int *)(c+msglen))[0] = stateS[0] ^ stateS[2] ^ stateR[0];\n    ((unsigned int *)(c+msglen))[1] = stateS[1] ^ stateS[3] ^ stateR[1];\n}\n\nstatic inline int jambu_tag_verification(const unsigned int *rk, uint64_t msglen, const uint8_t *c, unsigned int *stateS, unsigned int *stateR)\n{\n    uint8_t t[8];\n    int check = 0;\n    int i;\n\n    AESEncrypt(rk, stateS);\n    stateS[0] ^= stateR[0] ^ 0x03;\n    stateS[1] ^= stateR[1];\n\n    stateR[0] ^= stateS[2];\n    stateR[1] ^= stateS[3];\n\n    AESEncrypt(rk, stateS);\n\n    ((unsigned int *)t)[0] = stateS[0] ^ stateS[2] ^ stateR[0];\n    ((unsigned int *)t)[1] = stateS[1] ^ stateS[3] ^ stateR[1];\n    for (i = 0; i  < 8; i++) check |= (c[msglen+i] ^ t[i]);\n    if (0 == check) return 0; else return -1;\n}\n\nstatic inline void jambu_aut_ad_step(const unsigned int *rk, const uint8_t *adblock,\n                                     unsigned int *stateS, unsigned int *stateR)\n{\n    AESEncrypt(rk, stateS);\n    stateS[0] ^= stateR[0] ^ 0x01;\n    stateS[1] ^= stateR[1];\n    stateS[2] ^= ((unsigned int *)adblock)[0];\n    stateS[3] ^= ((unsigned int *)adblock)[1];\n\n    stateR[0] ^= stateS[2];\n    stateR[1] ^= stateS[3];\n\n    return;\n}\n\nstatic inline void jambu_aut_ad_partial(const unsigned int *rk, const uint8_t *adblock,\n                                        unsigned int *stateS, unsigned int *stateR, unsigned int len)\n{\n    uint8_t p[8];\n\n    memcpy(p, adblock, len);\n\n    p[len] = 0x80; // pad '1'\n    memset(p+len+1, 0, 7-len); // pad '0'\n\n    AESEncrypt(rk, stateS);\n    stateS[0] ^= stateR[0] ^ 0x01;\n    stateS[1] ^= stateR[1];\n    stateS[2] ^= ((unsigned int *)p)[0];\n    stateS[3] ^= ((unsigned int *)p)[1];\n\n    stateR[0] ^= stateS[2];\n    stateR[1] ^= stateS[3];\n\n    return;\n}\n\nstatic inline void jambu_aut_ad_full(const unsigned int *rk, unsigned int *stateS, unsigned int *stateR)\n{\n    AESEncrypt(rk, stateS);\n    stateS[0] ^= stateR[0] ^ 0x01;\n    stateS[1] ^= stateR[1];\n    stateS[2] ^= 0x80;\n\n    stateR[0] ^= stateS[2];\n    stateR[1] ^= stateS[3];\n    return;\n}\n\nstatic inline void jambu_enc_aut_msg_step(const unsigned int *rk, const uint8_t *plaintextblk,\n                                          uint8_t *ciphertextblk, unsigned int *stateS, unsigned int *stateR)\n{\n\n    AESEncrypt(rk, stateS);\n    stateS[0] ^= stateR[0];\n    stateS[1] ^= stateR[1];\n    stateS[2] ^= ((unsigned int *)plaintextblk)[0];\n    stateS[3] ^= ((unsigned int *)plaintextblk)[1];\n\n    stateR[0] ^= stateS[2];\n    stateR[1] ^= stateS[3];\n    ((unsigned int *)ciphertextblk)[0] = stateS[0] ^ ((unsigned int *)plaintextblk)[0];\n    ((unsigned int *)ciphertextblk)[1] = stateS[1] ^ ((unsigned int *)plaintextblk)[1];\n\n    return;\n}\n\n/* Deal with partial final block */\nstatic inline void jambu_enc_aut_msg_partial(const unsigned int *rk, const uint8_t *plaintextblk,\n                                             uint8_t *ciphertextblk, unsigned int *stateS, unsigned int *stateR, unsigned int len)\n{\n    uint8_t p[8];\n\n    memcpy(p, plaintextblk, len);\n\n    p[len] = 0x80; // pad '1'\n    memset(p+len+1, 0, 7-len);// pad '0'\n\n    AESEncrypt(rk, stateS);\n    stateS[0] ^= stateR[0];\n    stateS[1] ^= stateR[1];\n    stateS[2] ^= ((unsigned int *)p)[0];\n    stateS[3] ^= ((unsigned int *)p)[1];\n\n    stateR[0] ^= stateS[2];\n    stateR[1] ^= stateS[3];\n    ((unsigned int *)ciphertextblk)[0] = stateS[0] ^ ((unsigned int *)p)[0];\n    ((unsigned int *)ciphertextblk)[1] = stateS[1] ^ ((unsigned int *)p)[1];\n\n    return;\n}\n\nstatic inline void jambu_enc_aut_msg_full(const unsigned int *rk, unsigned int *stateS, unsigned int *stateR)\n{\n    AESEncrypt(rk, stateS);\n    stateS[0] ^= stateR[0];\n    stateS[1] ^= stateR[1];\n    stateS[2] ^= 0x80;\n\n    stateR[0] ^= stateS[2];\n    stateR[1] ^= stateS[3];\n\n    return;\n}\n\nstatic inline void jambu_dec_aut_msg_step(const unsigned int *rk, uint8_t *plaintextblk, const uint8_t *ciphertextblk, unsigned int *stateS, unsigned int *stateR)\n{\n    AESEncrypt(rk, stateS);\n    stateS[0] ^= stateR[0];\n    stateS[1] ^= stateR[1];\n    ((unsigned int *)plaintextblk)[0] = stateS[0] ^ ((unsigned int *)ciphertextblk)[0];\n    ((unsigned int *)plaintextblk)[1] = stateS[1] ^ ((unsigned int *)ciphertextblk)[1];\n\n    stateS[2] ^= ((unsigned int *)plaintextblk)[0];\n    stateS[3] ^= ((unsigned int *)plaintextblk)[1];\n\n    stateR[0] ^= stateS[2];\n    stateR[1] ^= stateS[3];\n\n}\n\nstatic inline void jambu_dec_aut_partial(const unsigned int *rk, uint8_t *plaintextblk, const uint8_t *ciphertextblk, unsigned int *stateS, unsigned int *stateR, unsigned int len)\n{\n    uint8_t p[8];\n    AESEncrypt(rk, stateS);\n    stateS[0] ^= stateR[0];\n    stateS[1] ^= stateR[1];\n    ((unsigned int *)p)[0] = stateS[0] ^ ((unsigned int *)ciphertextblk)[0];\n    ((unsigned int *)p)[1] = stateS[1] ^ ((unsigned int *)ciphertextblk)[1];\n    p[len] = 0x80;\n    memset(p+len+1, 0, 7-len);\n    memcpy(plaintextblk, p, len);\n\n    stateS[2] ^= ((unsigned int *)p)[0];\n    stateS[3] ^= ((unsigned int *)p)[1];\n\n    stateR[0] ^= stateS[2];\n    stateR[1] ^= stateS[3];\n\n}\n\nint crypto_aead_encrypt(\n    unsigned char *c,unsigned long long *clen,\n    const unsigned char *m,unsigned long long mlen,\n    const unsigned char *ad,unsigned long long adlen,\n    const unsigned char *nsec,\n    const unsigned char *npub,\n    const unsigned char *k\n    )\n{\n    unsigned int i;\n    unsigned int jambu_state[4];\n    unsigned int stateR[2];\n    unsigned int EK[44]; // Nr = 10, 4*(Nr+1) = 44 round keys\n\n    // key expansion\n    AESKeySteup(k, EK);\n\n    // Initialization\n    memset(jambu_state, 0, 16);\n    memset(stateR, 0, 8);\n    jambu_initialization(EK, npub, jambu_state, stateR);\n\n    //process the associated data\n    for (i = 0; (i+8) <= adlen; i += 8) {\n        jambu_aut_ad_step(EK, ad+i, jambu_state, stateR);\n    }\n    //deal with the partial block of associated data\n    //in this program, we assume that the message length is a multiple of bytes.\n    if (  (adlen & 0x7) != 0 )  {\n        jambu_aut_ad_partial(EK, ad+i, jambu_state, stateR, adlen & 0x7);\n    }\n    else\n    {\n        jambu_aut_ad_full(EK, jambu_state, stateR);\n    }\n\n    // encrypt the plaintext, we assume that the message length is multiple of bytes.\n    for (i = 0; (i+8) <= mlen; i += 8) {\n        jambu_enc_aut_msg_step(EK, m+i, c+i, jambu_state, stateR);\n    }\n\n    // deal with the final plaintext block\n    if ((mlen & 0x7) != 0) {\n        jambu_enc_aut_msg_partial(EK, m+i, c+i, jambu_state, stateR, mlen & 0x7);\n    }\n    else\n    {\n        jambu_enc_aut_msg_full(EK, jambu_state, stateR);\n    }\n\n    // finalization stage, we assume that the tag length is a multiple of bytes\n    jambu_tag_generation(EK, mlen, c, jambu_state, stateR);\n    *clen = mlen + 8;\n    return 0;\n}\n\nint crypto_aead_decrypt(\n    unsigned char *m,unsigned long long *mlen,\n    unsigned char *nsec,\n    const unsigned char *c,unsigned long long clen,\n    const unsigned char *ad,unsigned long long adlen,\n    const unsigned char *npub,\n    const unsigned char *k\n    )\n{\n    unsigned int i;\n    uint8_t check = 0;\n    unsigned int jambu_state[4];\n    unsigned int stateR[2];\n    unsigned int EK[44];\n\n    // key expansion\n    AESKeySteup(k, EK);\n\n    // Initialization\n    memset(jambu_state, 0, 16);\n    memset(stateR, 0, 8);\n    jambu_initialization(EK, npub, jambu_state, stateR);\n\n    //process the associated data\n    for (i = 0; (i+8) <= adlen; i += 8) {\n        jambu_aut_ad_step(EK, ad+i, jambu_state, stateR);\n    }\n    //deal with the partial block of associated data\n    //in this program, we assume that the message length is a multiple of bytes.\n    if (  (adlen & 0x7) != 0 )  {\n        jambu_aut_ad_partial(EK, ad+i, jambu_state, stateR, adlen & 0x7);\n    }\n    else\n    {\n        jambu_aut_ad_full(EK, jambu_state, stateR);\n    }\n\n    // decrypt the ciphertext\n    *mlen = clen - 8;\n    for (i = 0; (i+8)  <= *mlen; i = i+8) {\n        jambu_dec_aut_msg_step(EK, m+i, c+i, jambu_state, stateR);\n    }\n\n    // deal with the final block\n    if (((*mlen) & 0x7) != 0) {\n        jambu_dec_aut_partial(EK, m+i, c+i, jambu_state, stateR, *mlen & 0x7);\n    }\n    else\n    {\n        jambu_enc_aut_msg_full(EK, jambu_state, stateR);\n    }\n\n    // verification, we assume that the tag length is a multiple of bytes\n    return jambu_tag_verification(EK, *mlen, c, jambu_state, stateR);\n    return 0;\n}\n\n\n} // namespace Aesjambuv1_raw\n"
        },
        {
            "file_name": "aezv3_aez_ref.cpp",
            "content": "/*\n// AEZ v3 reference code. AEZ info: http://www.cs.ucdavis.edu/~rogaway/aez\n//\n// ** This version is slow and susceptible to side-channel attacks. **\n// ** Do not use for any purpose other than to understand AEZ.      **\n//\n// Written by Ted Krovetz (ted@krovetz.net). Last modified 25 September 2014.\n//\n// This is free and unencumbered software released into the public domain.\n//\n// Anyone is free to copy, modify, publish, use, compile, sell, or\n// distribute this software, either in source code form or as a compiled\n// binary, for any purpose, commercial or non-commercial, and by any\n// means.\n//\n// In jurisdictions that recognize copyright laws, the author or authors\n// of this software dedicate any and all copyright interest in the\n// software to the public domain. We make this dedication for the benefit\n// of the public at large and to the detriment of our heirs and\n// successors. We intend this dedication to be an overt act of\n// relinquishment in perpetuity of all present and future rights to this\n// software under copyright law.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n//\n// For more information, please refer to <http://unlicense.org/>\n*/\n#include <stdlib.h>\n#include <string.h>\n\ntypedef unsigned char byte;\n\n/* Use Rijmen, Bosselaers and Barreto's reference code.\n   INTERMEDIATE_VALUE_KAT must be defined in its header for AES4/AES10\n   functionality. Also, it defines the \"u32\" type used for AES internal keys.\n*/\n#include \"aezv3_rijndael-alg-fst.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Aezv3_raw {\nint numRounds = -1;\n\n/* ------------------------------------------------------------------------- */\n\nstatic void write32_big_endian(unsigned x, void *ptr) {\n    byte *p = (byte *)ptr;\n    p[0] = (byte)(x>>24); p[1] = (byte)(x>>16);\n    p[2] = (byte)(x>> 8); p[3] = (byte)(x>> 0);\n}\n\n/* ------------------------------------------------------------------------- */\n\n/* Adjust our constructed round keys to be compatible with rijndael-alg-fst  */\nstatic void correct_key(u32 *p, unsigned nbytes) {\n    unsigned i;\n    for (i=0; i<nbytes/4; i++) write32_big_endian(p[i], p+i);\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic void xor_bytes(byte *src1, byte *src2, unsigned n, byte *dst) {\n    while (n) { n--; dst[n] = src1[n] ^ src2[n]; }\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic void double_block(byte *p) {\n    byte i, tmp = p[0];\n    for (i=0; i<15; i++)\n        p[i] = (p[i] << 1) | (p[i+1] >> 7);\n    p[15] = (p[15] << 1) ^ ((tmp >> 7) * 135);\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic void mult_block(unsigned x, byte *src, byte *dst) {\n    byte t[16], r[16];\n    memcpy(t,src,16); memset(r,0,16);\n    for ( ; x; x>>=1) {\n        if (x&1) xor_bytes(r,t,16,r);\n        double_block(t);\n    }\n    memcpy(dst,r,16);\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic void Extract(byte *K, unsigned kbytes, byte extracted_key[3*16]) {\n    unsigned i,j,k,empty;\n    byte buf[16];\n    u32 aes4_key_z[4*5],aes4_key_c[4*5];\n\n    empty = (kbytes==0);\n    memset(extracted_key,0,48);\n    for (i=0;i<16;i++) ((byte *)aes4_key_z)[i]=(byte)i;\n    correct_key(aes4_key_z, 16);\n    for (i=1;i<5;i++) memcpy((byte*)aes4_key_z+16*i,aes4_key_z,16);\n\n    for (j=1; kbytes >= 16; K+=16, kbytes-=16, j++) {\n        for (i=1; i<=3; i++) {\n            /* aes4 ([i]_64 [j]_64) */\n            memset(aes4_key_c,0,12); ((byte *)aes4_key_c)[7]=(byte)i;\n            write32_big_endian(j, (byte *)aes4_key_c+12);\n            rijndaelEncryptRound(aes4_key_z, 10, (byte *)aes4_key_c, 4);\n            /* Set aes4 key to derived key, aes4 K_j, accumulate result */\n            correct_key(aes4_key_c, 16);\n            for (k=1; k<5; k++) memcpy((byte*)aes4_key_c+16*k, aes4_key_c, 16);\n            memcpy(buf, K, 16);\n            rijndaelEncryptRound(aes4_key_c, 10, buf, 4);\n            xor_bytes(extracted_key+(i-1)*16, buf, 16, extracted_key+(i-1)*16);\n        }\n    }\n    if (kbytes || empty) {  /* If key remains, or kbytes was initially zero */\n        for (i=1; i<=3; i++) {\n            /* aes4 ([i]_64 [0]_64) */\n            memset(aes4_key_c,0,16); ((byte *)aes4_key_c)[7]=(byte)i;\n            rijndaelEncryptRound(aes4_key_z, 10, (byte *)aes4_key_c, 4);\n            /* Set aes4 key to derived key, aes4 K_m10*, accumulate result */\n            correct_key(aes4_key_c, 16);\n            for (k=1; k<5; k++) memcpy((byte*)aes4_key_c+16*k, aes4_key_c, 16);\n            memset(buf,0,16); memcpy(buf,K,kbytes); buf[kbytes]=0x80;\n            rijndaelEncryptRound(aes4_key_c, 10, buf, 4);\n            xor_bytes(extracted_key+(i-1)*16, buf, 16, extracted_key+(i-1)*16);\n        }\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic void E(byte *K, unsigned kbytes, int i, unsigned j,\n                                                byte src[16], byte dst[16]) {\n    byte k, extracted_key[3*16], iJ[16], jJ[16], buf[16], I[16], J[16], L[16];\n\n    Extract(K, kbytes, extracted_key);\n    memcpy(I,extracted_key,16);\n    memcpy(J,extracted_key+16,16);\n    memcpy(L,extracted_key+32,16);\n\n    /* Encipher */\n    if (i < 0) {\n        u32 aes_key[4*11];\n        memset(aes_key,0,16);                                  /* 0        */\n        memcpy((byte*)aes_key+ 16, I, 16);                     /* I        */\n        memcpy((byte*)aes_key+ 32, L, 16);                     /* L        */\n        memcpy((byte*)aes_key+ 48, J, 16);                     /* J        */\n        correct_key(aes_key,4*16);\n        memcpy((byte*)aes_key+ 64, (byte*)aes_key+16, 48);     /* I L J    */\n        memcpy((byte*)aes_key+112, (byte*)aes_key+16, 48);     /* I L J    */\n        memcpy((byte*)aes_key+160, (byte*)aes_key+16, 16);     /* I        */\n        mult_block(j,J,jJ); xor_bytes(jJ,src,16,buf);\n        rijndaelEncryptRound(aes_key, 11, buf, 10); /* incl final MixColumns */\n    } else {\n        u32 aes4_key[4*5];\n        unsigned first = (i>=3?0:i);  /* Which key comes first in aes4_key */\n        /* Build AES4 key in use */\n        memset((byte *)aes4_key, 0, 16);\n        for (k=0; k<3; k++)\n            memcpy((byte*)aes4_key+16+k*16, extracted_key+(k+first)%3*16, 16);\n        if (i==2) memcpy((byte*)aes4_key+64, I, 16);\n        else      memset((byte*)aes4_key+64, 0, 16);\n        correct_key(aes4_key,5*16);\n        /* Build encryption buffer from src and various offsets used */\n        memcpy(buf, src, 16);\n        if (i == 0) {\n            mult_block(j,J,jJ); xor_bytes(buf,jJ,16,buf);\n        } else if (i==1 || i==2) {\n            mult_block(j%8,J,jJ); xor_bytes(buf,jJ,16,buf);\n            for ( ; j>8; j-=8) mult_block(2,L,L);  /* L = 2^((j-1)/8) L */\n            xor_bytes(buf, L, 16, buf);\n        } else /* i >= 3 */ {\n            mult_block((i-2)*8,J,iJ); xor_bytes(buf,iJ,16,buf);\n            if (j>0) {\n                mult_block(j%8,J,jJ); xor_bytes(buf,jJ,16,buf);\n                for ( ; j>8; j-=8) mult_block(2,L,L);  /* L = 2^((j-1)/8) L */\n                xor_bytes(buf, L, 16, buf);\n            }\n        }\n        rijndaelEncryptRound(aes4_key, 10, buf, 4);\n    }\n    memcpy(dst, buf, 16);\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic void AEZhash(byte *K, unsigned kbytes, byte *N, unsigned nbytes,\n    byte *A[], unsigned abytes[], unsigned veclen, unsigned tau, byte *result) {\n\n    byte buf[16], sum[16], *p;\n    unsigned i, j, bytes, empty;\n\n    /* Initialize sum with hash of tau */\n    memset(buf,0,12); write32_big_endian(tau, buf+12);\n    E(K,kbytes,3,1,buf,sum);\n\n    /* Hash nonce, accumulate into sum */\n    empty = (nbytes==0);\n    for (j=1; nbytes>=16; j++, nbytes-=16, N+=16) {\n        E(K,kbytes,4,j,N,buf); xor_bytes(sum, buf, 16, sum);\n    }\n    if (nbytes || empty) {\n        memset(buf,0,16); memcpy(buf,N,nbytes); buf[nbytes]=0x80;\n        E(K,kbytes,4,0,buf,buf);\n        xor_bytes(sum, buf, 16, sum);\n    }\n\n    /* Hash each vector element, accumulate into sum */\n    for (i=0; i<veclen; i++) {\n        p = A[i]; bytes = abytes[i]; empty = (bytes==0);\n        for (j=1; bytes>=16; j++, bytes-=16, p+=16) {\n            E(K,kbytes,5+i,j,p,buf); xor_bytes(sum, buf, 16, sum);\n        }\n        if (bytes || empty) {\n            memset(buf,0,16); memcpy(buf,p,bytes); buf[bytes]=0x80;\n            E(K,kbytes,5+i,0,buf,buf);\n            xor_bytes(sum, buf, 16, sum);\n        }\n    }\n    memcpy(result,sum,16);\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic void AEZprf(byte *K, unsigned kbytes, byte delta[16], unsigned bytes, byte *result) {\n\n    byte buf[16], ctr[16];\n    memset(ctr,0,16);\n    for ( ; bytes >= 16; bytes-=16, result+=16) {\n        unsigned i=15;\n        xor_bytes(delta, ctr, 16, buf);\n        E(K,kbytes,-1,3,buf,result);\n        do { ctr[i]++; i--; } while (ctr[i+1]==0);   /* ctr+=1 */\n    }\n    if (bytes) {\n        xor_bytes(delta, ctr, 16, buf);\n        E(K,kbytes,-1,3,buf,buf);\n        memcpy(result, buf, bytes);\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n\n/* Set d=0 for EncipherAEZcore and d=1 for DecipherAEZcore */\nstatic void AEZcore(byte *K, unsigned kbytes, byte delta[16],\n                        byte *in, unsigned inbytes, unsigned d, byte *out) {\n    byte tmp[16], X[16], Y[16], S[16];\n    byte *in_orig = in, *out_orig = out;\n    unsigned j, inbytes_orig = inbytes;\n\n    memset(X,0,16); memset(Y,0,16);\n\n    /* Pass 1 over in[0:-32], store intermediate values in out[0:-32] */\n    for (j=1; inbytes >= 64; j++, inbytes-=32, in+=32, out+=32) {\n        E(K, kbytes, 1, j, in+16, tmp); xor_bytes(in, tmp, 16, out);\n        E(K, kbytes, 0, 0, out, tmp); xor_bytes(in+16, tmp, 16, out+16);\n        xor_bytes(out+16, X, 16, X);\n    }\n\n    /* Finish X calculation */\n    inbytes -= 32;                /* inbytes now has fragment length 0..31 */\n    if (inbytes >= 16) {\n        E(K, kbytes, 0, 4, in, tmp); xor_bytes(X, tmp, 16, X);\n        inbytes -= 16; in += 16; out += 16;\n        memset(tmp,0,16); memcpy(tmp,in,inbytes); tmp[inbytes] = 0x80;\n        E(K, kbytes, 0, 5, tmp, tmp); xor_bytes(X, tmp, 16, X);\n    } else if (inbytes > 0) {\n        memset(tmp,0,16); memcpy(tmp,in,inbytes); tmp[inbytes] = 0x80;\n        E(K, kbytes, 0, 4, tmp, tmp); xor_bytes(X, tmp, 16, X);\n    }\n    in += inbytes; out += inbytes;\n\n    /* Calculate S */\n    E(K, kbytes, 0, 1+d, in+16, tmp);\n    xor_bytes(X, in, 16, out);\n    xor_bytes(delta, out, 16, out);\n    xor_bytes(tmp, out, 16, out);\n    E(K, kbytes, -1, 1+d, out, tmp);\n    xor_bytes(in+16, tmp, 16, out+16);\n    xor_bytes(out, out+16, 16, S);\n\n    /* Pass 2 over intermediate values in out[32..]. Final values written */\n    inbytes = inbytes_orig; out = out_orig; in = in_orig;\n    for (j=1; inbytes >= 64; j++, inbytes-=32, in+=32, out+=32) {\n        E(K, kbytes, 2, j, S, tmp);\n        xor_bytes(out, tmp, 16, out); xor_bytes(out+16, tmp, 16, out+16);\n        xor_bytes(out, Y, 16, Y);\n        E(K, kbytes, 0, 0, out+16, tmp); xor_bytes(out, tmp, 16, out);\n        E(K, kbytes, 1, j, out, tmp); xor_bytes(out+16, tmp, 16, out+16);\n        memcpy(tmp, out, 16); memcpy(out, out+16, 16); memcpy(out+16, tmp, 16);\n    }\n\n    /* Finish Y calculation and finish encryption of fragment bytes */\n    inbytes -= 32;                /* inbytes now has fragment length 0..31 */\n    if (inbytes >= 16) {\n        E(K, kbytes, -1, 4, S, tmp); xor_bytes(in, tmp, 16, out);\n        E(K, kbytes, 0, 4, out, tmp); xor_bytes(Y, tmp, 16, Y);\n        inbytes -= 16; in += 16; out += 16;\n        E(K, kbytes, -1, 5, S, tmp); xor_bytes(in, tmp, inbytes, tmp);\n        memcpy(out,tmp,inbytes);\n        memset(tmp+inbytes,0,16-inbytes); tmp[inbytes] = 0x80;\n        E(K, kbytes, 0, 5, tmp, tmp); xor_bytes(Y, tmp, 16, Y);\n    } else if (inbytes > 0) {\n        E(K, kbytes, -1, 4, S, tmp); xor_bytes(in, tmp, inbytes, tmp);\n        memcpy(out,tmp,inbytes);\n        memset(tmp+inbytes,0,16-inbytes); tmp[inbytes] = 0x80;\n        E(K, kbytes, 0, 4, tmp, tmp); xor_bytes(Y, tmp, 16, Y);\n    }\n    in += inbytes; out += inbytes;\n\n    /* Finish encryption of last two blocks */\n    E(K, kbytes, -1, 2-d, out+16, tmp);\n    xor_bytes(out, tmp, 16, out);\n    E(K, kbytes, 0, 2-d, out, tmp);\n    xor_bytes(tmp, out+16, 16, out+16);\n    xor_bytes(delta, out+16, 16, out+16);\n    xor_bytes(Y, out+16, 16, out+16);\n    memcpy(tmp, out, 16); memcpy(out, out+16, 16); memcpy(out+16, tmp, 16);\n}\n\n/* ------------------------------------------------------------------------- */\n\n/* Set d=0 for EncipherAEZtiny and d=1 for DecipherAEZtiny */\nstatic void AEZtiny(byte *K, unsigned kbytes, byte delta[16],\n                        byte *in, unsigned inbytes, unsigned d, byte *out) {\n    unsigned rounds,i,j=7,k;\n    int step;\n    byte mask=0x00, pad=0x80, L[16], R[16], buf[32];\n    if      (inbytes==1) rounds=24;\n    else if (inbytes==2) rounds=16;\n    else if (inbytes<16) rounds=10;\n    else {          j=6; rounds=8; }\n    /* Split (inbytes*8)/2 bits into L and R. Beware: May end in nibble. */\n    memcpy(L, in,           (inbytes+1)/2);\n    memcpy(R, in+inbytes/2, (inbytes+1)/2);\n    if (inbytes&1) {                     /* Must shift R left by half a byte */\n        for (i=0; i<inbytes/2; i++)\n            R[i] = (byte)((R[i] << 4) | (R[i+1] >> 4));\n        R[inbytes/2] = (byte)(R[inbytes/2] << 4);\n        pad = 0x08; mask = 0xf0;\n    }\n    if (d) {\n        if (inbytes < 16) {\n            memset(buf,0,16); memcpy(buf,in,inbytes); buf[0] |= 0x80;\n            xor_bytes(delta, buf, 16, buf);\n            E(K, kbytes,0,3,buf,buf);\n            L[0] ^= (buf[0] & 0x80);\n        }\n        i = rounds-1; step = -1;\n    } else {\n        i = 0; step = 1;\n    }\n    for (k=0; k<rounds/2; k++,i=(unsigned)((int)i+2*step)) {\n        memset(buf, 0, 16);\n        memcpy(buf,R,(inbytes+1)/2);\n        buf[inbytes/2] = (buf[inbytes/2] & mask) | pad;\n        xor_bytes(buf, delta, 16, buf);\n        buf[15] ^= (byte)i;\n        E(K, kbytes,0,j,buf,buf);\n        xor_bytes(L, buf, 16, L);\n\n        memset(buf, 0, 16);\n        memcpy(buf,L,(inbytes+1)/2);\n        buf[inbytes/2] = (buf[inbytes/2] & mask) | pad;\n        xor_bytes(buf, delta, 16, buf);\n        buf[15] ^= (byte)((int)i+step);\n        E(K, kbytes,0,j,buf,buf);\n        xor_bytes(R, buf, 16, R);\n    }\n    memcpy(buf,           R, inbytes/2);\n    memcpy(buf+inbytes/2, L, (inbytes+1)/2);\n    if (inbytes&1) {\n        for (i=inbytes-1; i>inbytes/2; i--)\n            buf[i] = (byte)((buf[i] >> 4) | (buf[i-1] << 4));\n        buf[inbytes/2] = (byte)((L[0] >> 4) | (R[inbytes/2] & 0xf0));\n    }\n    memcpy(out,buf,inbytes);\n    if ((inbytes < 16) && !d) {\n        memset(buf+inbytes,0,16-inbytes); buf[0] |= 0x80;\n        xor_bytes(delta, buf, 16, buf);\n        E(K, kbytes,0,3,buf,buf);\n        out[0] ^= (buf[0] & 0x80);\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic void Encipher(byte *K, unsigned kbytes, byte delta[16],\n                                    byte *in, unsigned inbytes, byte *out) {\n    if (inbytes == 0) return;\n    if (inbytes < 32) AEZtiny(K, kbytes, delta, in, inbytes, 0, out);\n    else              AEZcore(K, kbytes, delta, in, inbytes, 0, out);\n}\n\n/* ------------------------------------------------------------------------- */\n\nstatic void Decipher(byte *K, unsigned kbytes, byte delta[16],\n                                    byte *in, unsigned inbytes, byte *out) {\n    if (inbytes == 0) return;\n    if (inbytes < 32) AEZtiny(K, kbytes, delta, in, inbytes, 1, out);\n    else              AEZcore(K, kbytes, delta, in, inbytes, 1, out);\n}\n\n/* ------------------------------------------------------------------------- */\n\nint Decrypt(byte *K, unsigned kbytes,\n            byte *N, unsigned nbytes,\n            byte *AD[], unsigned adbytes[],\n            unsigned veclen, unsigned abytes,\n            byte *C, unsigned cbytes, byte *M) {\n    byte delta[16], *X, sum=0;\n    unsigned i;\n    if (cbytes < abytes) return -1;\n    AEZhash(K, kbytes, N, nbytes, AD, adbytes, veclen, abytes*8, delta);\n    X = (byte *)malloc(cbytes);\n    if (cbytes==abytes) {\n        AEZprf(K, kbytes, delta, abytes, X);\n        for (i=0; i<abytes; i++) sum |= (X[i] ^ C[i]);\n    } else {\n        Decipher(K, kbytes, delta, C, cbytes, X);\n        for (i=0; i<abytes; i++) sum |= X[cbytes-abytes+i];\n        if (sum==0) memcpy(M,X,cbytes-abytes);\n    }\n    free(X);\n    return (sum == 0 ? 0 : -1);  /* return 0 if valid, -1 if invalid */\n}\n\n/* ------------------------------------------------------------------------- */\n\nvoid Encrypt(byte *K, unsigned kbytes,\n             byte *N, unsigned nbytes,\n             byte *AD[], unsigned adbytes[],\n             unsigned veclen, unsigned abytes,\n             byte *M, unsigned mbytes, byte *C) {\n    byte delta[16], *X;\n    AEZhash(K, kbytes, N, nbytes, AD, adbytes, veclen, abytes*8, delta);\n    if (mbytes==0) {\n        AEZprf(K, kbytes, delta, abytes, C);\n    } else {\n        X = (byte *)malloc(mbytes+abytes);\n        memcpy(X, M, mbytes); memset(X+mbytes,0,abytes);\n        Encipher(K, kbytes, delta, X, mbytes+abytes, X);\n        memcpy(C, X, mbytes+abytes);\n        free(X);\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n/* aez mapping for CAESAR competition\n#define CRYPTO_KEYBYTES 16\n#define CRYPTO_NSECBYTES 0\n#define CRYPTO_NPUBBYTES 12\n#define CRYPTO_ABYTES 16\n*/\n\n#include \"aezv3_encrypt.h\"\n#include \"aezv3_api.h\"\n\nint crypto_aead_encrypt(\n    unsigned char *c,unsigned long long *clen,\n    const unsigned char *m,unsigned long long mlen,\n    const unsigned char *ad,unsigned long long adlen,\n    const unsigned char *nsec,\n    const unsigned char *npub,\n    const unsigned char *k\n)\n{\n    byte *AD[] = {(byte*)ad};\n    unsigned adbytes[] = {(unsigned)adlen};\n    (void)nsec;\n    if (clen) *clen = mlen+16;\n    Encrypt((byte*)k, CRYPTO_KEYBYTES, (byte*)npub, CRYPTO_NPUBBYTES,\n            AD, adbytes, 1, CRYPTO_ABYTES, (byte*)m, mlen, (byte*)c);\n    return 0;\n}\n\nint crypto_aead_decrypt(\n    unsigned char *m,unsigned long long *mlen,\n    unsigned char *nsec,\n    const unsigned char *c,unsigned long long clen,\n    const unsigned char *ad,unsigned long long adlen,\n    const unsigned char *npub,\n    const unsigned char *k\n)\n{\n    byte *AD[] = {(byte*)ad};\n    unsigned adbytes[] = {(unsigned)adlen};\n    (void)nsec;\n    if (mlen) *mlen = clen-16;\n    return Decrypt((byte*)k, CRYPTO_KEYBYTES, (byte*)npub, CRYPTO_NPUBBYTES,\n                    AD, adbytes, 1, CRYPTO_ABYTES, (byte*)c, clen, (byte*)m);\n}\n\n} // namespace Aezv3_raw\n"
        },
        {
            "file_name": "Anubis.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"Anubis_data.h\"\n\nconst DWORD T0[256] = {\n    0xa753a6f5U, 0xd3bb6bd0U, 0xe6d1bf6eU, 0x71e2d93bU,\n    0xd0bd67daU, 0xac458acfU, 0x4d9a29b3U, 0x79f2f90bU,\n    0x3a74e89cU, 0xc98f038cU, 0x913f7e41U, 0xfce5d732U,\n    0x1e3c7844U, 0x478e018fU, 0x54a84de5U, 0xbd67cea9U,\n    0x8c050a0fU, 0xa557aef9U, 0x7af4f501U, 0xfbebcb20U,\n    0x63c69157U, 0xb86ddab7U, 0xdda753f4U, 0xd4b577c2U,\n    0xe5d7b364U, 0xb37bf68dU, 0xc59733a4U, 0xbe61c2a3U,\n    0xa94f9ed1U, 0x880d1a17U, 0x0c183028U, 0xa259b2ebU,\n    0x3972e496U, 0xdfa35bf8U, 0x2952a4f6U, 0xdaa94fe6U,\n    0x2b56acfaU, 0xa84d9ad7U, 0xcb8b0b80U, 0x4c982db5U,\n    0x4b9631a7U, 0x224488ccU, 0xaa4992dbU, 0x244890d8U,\n    0x4182199bU, 0x70e0dd3dU, 0xa651a2f3U, 0xf9efc32cU,\n    0x5ab475c1U, 0xe2d9af76U, 0xb07dfa87U, 0x366cd8b4U,\n    0x7dfae913U, 0xe4d5b762U, 0x3366ccaaU, 0xffe3db38U,\n    0x60c09d5dU, 0x204080c0U, 0x08102030U, 0x8b0b161dU,\n    0x5ebc65d9U, 0xab4b96ddU, 0x7ffee11fU, 0x78f0fd0dU,\n    0x7cf8ed15U, 0x2c58b0e8U, 0x57ae41efU, 0xd2b96fd6U,\n    0xdca557f2U, 0x6ddaa973U, 0x7efce519U, 0x0d1a342eU,\n    0x53a651f7U, 0x94356a5fU, 0xc39b2bb0U, 0x2850a0f0U,\n    0x274e9cd2U, 0x060c1814U, 0x5fbe61dfU, 0xad478ec9U,\n    0x67ce814fU, 0x5cb86dd5U, 0x55aa49e3U, 0x48903dadU,\n    0x0e1c3824U, 0x52a455f1U, 0xeac98f46U, 0x42841591U,\n    0x5bb671c7U, 0x5dba69d3U, 0x3060c0a0U, 0x58b07dcdU,\n    0x51a259fbU, 0x59b279cbU, 0x3c78f088U, 0x4e9c25b9U,\n    0x3870e090U, 0x8a09121bU, 0x72e4d531U, 0x14285078U,\n    0xe7d3bb68U, 0xc6913faeU, 0xdea15ffeU, 0x50a05dfdU,\n    0x8e010203U, 0x9239724bU, 0xd1bf63dcU, 0x77eec12fU,\n    0x933b764dU, 0x458a0983U, 0x9a29527bU, 0xce811f9eU,\n    0x2d5ab4eeU, 0x03060c0aU, 0x62c49551U, 0xb671e293U,\n    0xb96fdeb1U, 0xbf63c6a5U, 0x96316253U, 0x6bd6b167U,\n    0x3f7efc82U, 0x070e1c12U, 0x1224486cU, 0xae4182c3U,\n    0x40801d9dU, 0x3468d0b8U, 0x468c0589U, 0x3e7cf884U,\n    0xdbab4be0U, 0xcf831b98U, 0xecc59752U, 0xcc851792U,\n    0xc19f23bcU, 0xa15fbee1U, 0xc09d27baU, 0xd6b17fceU,\n    0x1d3a744eU, 0xf4f5f702U, 0x61c2995bU, 0x3b76ec9aU,\n    0x10204060U, 0xd8ad47eaU, 0x68d0bd6dU, 0xa05dbae7U,\n    0xb17ffe81U, 0x0a14283cU, 0x69d2b96bU, 0x6cd8ad75U,\n    0x499239abU, 0xfae9cf26U, 0x76ecc529U, 0xc49537a2U,\n    0x9e214263U, 0x9b2b567dU, 0x6edca579U, 0x992f5e71U,\n    0xc2992fb6U, 0xb773e695U, 0x982d5a77U, 0xbc65caafU,\n    0x8f030605U, 0x85172e39U, 0x1f3e7c42U, 0xb475ea9fU,\n    0xf8edc72aU, 0x11224466U, 0x2e5cb8e4U, 0x00000000U,\n    0x254a94deU, 0x1c387048U, 0x2a54a8fcU, 0x3d7af48eU,\n    0x050a141eU, 0x4f9e21bfU, 0x7bf6f107U, 0xb279f28bU,\n    0x3264c8acU, 0x903d7a47U, 0xaf4386c5U, 0x19326456U,\n    0xa35bb6edU, 0xf7f3fb08U, 0x73e6d137U, 0x9d274e69U,\n    0x152a547eU, 0x74e8cd25U, 0xeec19f5eU, 0xca890f86U,\n    0x9f234665U, 0x0f1e3c22U, 0x1b366c5aU, 0x75eac923U,\n    0x86112233U, 0x84152a3fU, 0x9c254a6fU, 0x4a9435a1U,\n    0x97336655U, 0x1a34685cU, 0x65ca8943U, 0xf6f1ff0eU,\n    0xedc79354U, 0x09122436U, 0xbb6bd6bdU, 0x264c98d4U,\n    0x831b362dU, 0xebcb8b40U, 0x6fdea17fU, 0x811f3e21U,\n    0x04081018U, 0x6ad4b561U, 0x43861197U, 0x01020406U,\n    0x172e5c72U, 0xe1dfa37cU, 0x87132635U, 0xf5f7f304U,\n    0x8d070e09U, 0xe3dbab70U, 0x23468ccaU, 0x801d3a27U,\n    0x44880d85U, 0x162c5874U, 0x66cc8549U, 0x214284c6U,\n    0xfee1df3eU, 0xd5b773c4U, 0x3162c4a6U, 0xd9af43ecU,\n    0x356ad4beU, 0x18306050U, 0x0204080cU, 0x64c88d45U,\n    0xf2f9ef16U, 0xf1ffe31cU, 0x56ac45e9U, 0xcd871394U,\n    0x8219322bU, 0xc88d078aU, 0xba69d2bbU, 0xf0fde71aU,\n    0xefc39b58U, 0xe9cf834cU, 0xe8cd874aU, 0xfde7d334U,\n    0x890f1e11U, 0xd7b37bc8U, 0xc7933ba8U, 0xb577ee99U,\n    0xa455aaffU, 0x2f5ebce2U, 0x95376e59U, 0x13264c6aU,\n    0x0b162c3aU, 0xf3fbeb10U, 0xe0dda77aU, 0x376edcb2U,\n};\n\nconst DWORD T1[256] = {\n    0x53a7f5a6U, 0xbbd3d06bU, 0xd1e66ebfU, 0xe2713bd9U,\n    0xbdd0da67U, 0x45accf8aU, 0x9a4db329U, 0xf2790bf9U,\n    0x743a9ce8U, 0x8fc98c03U, 0x3f91417eU, 0xe5fc32d7U,\n    0x3c1e4478U, 0x8e478f01U, 0xa854e54dU, 0x67bda9ceU,\n    0x058c0f0aU, 0x57a5f9aeU, 0xf47a01f5U, 0xebfb20cbU,\n    0xc6635791U, 0x6db8b7daU, 0xa7ddf453U, 0xb5d4c277U,\n    0xd7e564b3U, 0x7bb38df6U, 0x97c5a433U, 0x61bea3c2U,\n    0x4fa9d19eU, 0x0d88171aU, 0x180c2830U, 0x59a2ebb2U,\n    0x723996e4U, 0xa3dff85bU, 0x5229f6a4U, 0xa9dae64fU,\n    0x562bfaacU, 0x4da8d79aU, 0x8bcb800bU, 0x984cb52dU,\n    0x964ba731U, 0x4422cc88U, 0x49aadb92U, 0x4824d890U,\n    0x82419b19U, 0xe0703dddU, 0x51a6f3a2U, 0xeff92cc3U,\n    0xb45ac175U, 0xd9e276afU, 0x7db087faU, 0x6c36b4d8U,\n    0xfa7d13e9U, 0xd5e462b7U, 0x6633aaccU, 0xe3ff38dbU,\n    0xc0605d9dU, 0x4020c080U, 0x10083020U, 0x0b8b1d16U,\n    0xbc5ed965U, 0x4babdd96U, 0xfe7f1fe1U, 0xf0780dfdU,\n    0xf87c15edU, 0x582ce8b0U, 0xae57ef41U, 0xb9d2d66fU,\n    0xa5dcf257U, 0xda6d73a9U, 0xfc7e19e5U, 0x1a0d2e34U,\n    0xa653f751U, 0x35945f6aU, 0x9bc3b02bU, 0x5028f0a0U,\n    0x4e27d29cU, 0x0c061418U, 0xbe5fdf61U, 0x47adc98eU,\n    0xce674f81U, 0xb85cd56dU, 0xaa55e349U, 0x9048ad3dU,\n    0x1c0e2438U, 0xa452f155U, 0xc9ea468fU, 0x84429115U,\n    0xb65bc771U, 0xba5dd369U, 0x6030a0c0U, 0xb058cd7dU,\n    0xa251fb59U, 0xb259cb79U, 0x783c88f0U, 0x9c4eb925U,\n    0x703890e0U, 0x098a1b12U, 0xe47231d5U, 0x28147850U,\n    0xd3e768bbU, 0x91c6ae3fU, 0xa1defe5fU, 0xa050fd5dU,\n    0x018e0302U, 0x39924b72U, 0xbfd1dc63U, 0xee772fc1U,\n    0x3b934d76U, 0x8a458309U, 0x299a7b52U, 0x81ce9e1fU,\n    0x5a2deeb4U, 0x06030a0cU, 0xc4625195U, 0x71b693e2U,\n    0x6fb9b1deU, 0x63bfa5c6U, 0x31965362U, 0xd66b67b1U,\n    0x7e3f82fcU, 0x0e07121cU, 0x24126c48U, 0x41aec382U,\n    0x80409d1dU, 0x6834b8d0U, 0x8c468905U, 0x7c3e84f8U,\n    0xabdbe04bU, 0x83cf981bU, 0xc5ec5297U, 0x85cc9217U,\n    0x9fc1bc23U, 0x5fa1e1beU, 0x9dc0ba27U, 0xb1d6ce7fU,\n    0x3a1d4e74U, 0xf5f402f7U, 0xc2615b99U, 0x763b9aecU,\n    0x20106040U, 0xadd8ea47U, 0xd0686dbdU, 0x5da0e7baU,\n    0x7fb181feU, 0x140a3c28U, 0xd2696bb9U, 0xd86c75adU,\n    0x9249ab39U, 0xe9fa26cfU, 0xec7629c5U, 0x95c4a237U,\n    0x219e6342U, 0x2b9b7d56U, 0xdc6e79a5U, 0x2f99715eU,\n    0x99c2b62fU, 0x73b795e6U, 0x2d98775aU, 0x65bcafcaU,\n    0x038f0506U, 0x1785392eU, 0x3e1f427cU, 0x75b49feaU,\n    0xedf82ac7U, 0x22116644U, 0x5c2ee4b8U, 0x00000000U,\n    0x4a25de94U, 0x381c4870U, 0x542afca8U, 0x7a3d8ef4U,\n    0x0a051e14U, 0x9e4fbf21U, 0xf67b07f1U, 0x79b28bf2U,\n    0x6432acc8U, 0x3d90477aU, 0x43afc586U, 0x32195664U,\n    0x5ba3edb6U, 0xf3f708fbU, 0xe67337d1U, 0x279d694eU,\n    0x2a157e54U, 0xe87425cdU, 0xc1ee5e9fU, 0x89ca860fU,\n    0x239f6546U, 0x1e0f223cU, 0x361b5a6cU, 0xea7523c9U,\n    0x11863322U, 0x15843f2aU, 0x259c6f4aU, 0x944aa135U,\n    0x33975566U, 0x341a5c68U, 0xca654389U, 0xf1f60effU,\n    0xc7ed5493U, 0x12093624U, 0x6bbbbdd6U, 0x4c26d498U,\n    0x1b832d36U, 0xcbeb408bU, 0xde6f7fa1U, 0x1f81213eU,\n    0x08041810U, 0xd46a61b5U, 0x86439711U, 0x02010604U,\n    0x2e17725cU, 0xdfe17ca3U, 0x13873526U, 0xf7f504f3U,\n    0x078d090eU, 0xdbe370abU, 0x4623ca8cU, 0x1d80273aU,\n    0x8844850dU, 0x2c167458U, 0xcc664985U, 0x4221c684U,\n    0xe1fe3edfU, 0xb7d5c473U, 0x6231a6c4U, 0xafd9ec43U,\n    0x6a35bed4U, 0x30185060U, 0x04020c08U, 0xc864458dU,\n    0xf9f216efU, 0xfff11ce3U, 0xac56e945U, 0x87cd9413U,\n    0x19822b32U, 0x8dc88a07U, 0x69babbd2U, 0xfdf01ae7U,\n    0xc3ef589bU, 0xcfe94c83U, 0xcde84a87U, 0xe7fd34d3U,\n    0x0f89111eU, 0xb3d7c87bU, 0x93c7a83bU, 0x77b599eeU,\n    0x55a4ffaaU, 0x5e2fe2bcU, 0x3795596eU, 0x26136a4cU,\n    0x160b3a2cU, 0xfbf310ebU, 0xdde07aa7U, 0x6e37b2dcU,\n};\n\nconst DWORD T2[256] = {\n    0xa6f5a753U, 0x6bd0d3bbU, 0xbf6ee6d1U, 0xd93b71e2U,\n    0x67dad0bdU, 0x8acfac45U, 0x29b34d9aU, 0xf90b79f2U,\n    0xe89c3a74U, 0x038cc98fU, 0x7e41913fU, 0xd732fce5U,\n    0x78441e3cU, 0x018f478eU, 0x4de554a8U, 0xcea9bd67U,\n    0x0a0f8c05U, 0xaef9a557U, 0xf5017af4U, 0xcb20fbebU,\n    0x915763c6U, 0xdab7b86dU, 0x53f4dda7U, 0x77c2d4b5U,\n    0xb364e5d7U, 0xf68db37bU, 0x33a4c597U, 0xc2a3be61U,\n    0x9ed1a94fU, 0x1a17880dU, 0x30280c18U, 0xb2eba259U,\n    0xe4963972U, 0x5bf8dfa3U, 0xa4f62952U, 0x4fe6daa9U,\n    0xacfa2b56U, 0x9ad7a84dU, 0x0b80cb8bU, 0x2db54c98U,\n    0x31a74b96U, 0x88cc2244U, 0x92dbaa49U, 0x90d82448U,\n    0x199b4182U, 0xdd3d70e0U, 0xa2f3a651U, 0xc32cf9efU,\n    0x75c15ab4U, 0xaf76e2d9U, 0xfa87b07dU, 0xd8b4366cU,\n    0xe9137dfaU, 0xb762e4d5U, 0xccaa3366U, 0xdb38ffe3U,\n    0x9d5d60c0U, 0x80c02040U, 0x20300810U, 0x161d8b0bU,\n    0x65d95ebcU, 0x96ddab4bU, 0xe11f7ffeU, 0xfd0d78f0U,\n    0xed157cf8U, 0xb0e82c58U, 0x41ef57aeU, 0x6fd6d2b9U,\n    0x57f2dca5U, 0xa9736ddaU, 0xe5197efcU, 0x342e0d1aU,\n    0x51f753a6U, 0x6a5f9435U, 0x2bb0c39bU, 0xa0f02850U,\n    0x9cd2274eU, 0x1814060cU, 0x61df5fbeU, 0x8ec9ad47U,\n    0x814f67ceU, 0x6dd55cb8U, 0x49e355aaU, 0x3dad4890U,\n    0x38240e1cU, 0x55f152a4U, 0x8f46eac9U, 0x15914284U,\n    0x71c75bb6U, 0x69d35dbaU, 0xc0a03060U, 0x7dcd58b0U,\n    0x59fb51a2U, 0x79cb59b2U, 0xf0883c78U, 0x25b94e9cU,\n    0xe0903870U, 0x121b8a09U, 0xd53172e4U, 0x50781428U,\n    0xbb68e7d3U, 0x3faec691U, 0x5ffedea1U, 0x5dfd50a0U,\n    0x02038e01U, 0x724b9239U, 0x63dcd1bfU, 0xc12f77eeU,\n    0x764d933bU, 0x0983458aU, 0x527b9a29U, 0x1f9ece81U,\n    0xb4ee2d5aU, 0x0c0a0306U, 0x955162c4U, 0xe293b671U,\n    0xdeb1b96fU, 0xc6a5bf63U, 0x62539631U, 0xb1676bd6U,\n    0xfc823f7eU, 0x1c12070eU, 0x486c1224U, 0x82c3ae41U,\n    0x1d9d4080U, 0xd0b83468U, 0x0589468cU, 0xf8843e7cU,\n    0x4be0dbabU, 0x1b98cf83U, 0x9752ecc5U, 0x1792cc85U,\n    0x23bcc19fU, 0xbee1a15fU, 0x27bac09dU, 0x7fced6b1U,\n    0x744e1d3aU, 0xf702f4f5U, 0x995b61c2U, 0xec9a3b76U,\n    0x40601020U, 0x47ead8adU, 0xbd6d68d0U, 0xbae7a05dU,\n    0xfe81b17fU, 0x283c0a14U, 0xb96b69d2U, 0xad756cd8U,\n    0x39ab4992U, 0xcf26fae9U, 0xc52976ecU, 0x37a2c495U,\n    0x42639e21U, 0x567d9b2bU, 0xa5796edcU, 0x5e71992fU,\n    0x2fb6c299U, 0xe695b773U, 0x5a77982dU, 0xcaafbc65U,\n    0x06058f03U, 0x2e398517U, 0x7c421f3eU, 0xea9fb475U,\n    0xc72af8edU, 0x44661122U, 0xb8e42e5cU, 0x00000000U,\n    0x94de254aU, 0x70481c38U, 0xa8fc2a54U, 0xf48e3d7aU,\n    0x141e050aU, 0x21bf4f9eU, 0xf1077bf6U, 0xf28bb279U,\n    0xc8ac3264U, 0x7a47903dU, 0x86c5af43U, 0x64561932U,\n    0xb6eda35bU, 0xfb08f7f3U, 0xd13773e6U, 0x4e699d27U,\n    0x547e152aU, 0xcd2574e8U, 0x9f5eeec1U, 0x0f86ca89U,\n    0x46659f23U, 0x3c220f1eU, 0x6c5a1b36U, 0xc92375eaU,\n    0x22338611U, 0x2a3f8415U, 0x4a6f9c25U, 0x35a14a94U,\n    0x66559733U, 0x685c1a34U, 0x894365caU, 0xff0ef6f1U,\n    0x9354edc7U, 0x24360912U, 0xd6bdbb6bU, 0x98d4264cU,\n    0x362d831bU, 0x8b40ebcbU, 0xa17f6fdeU, 0x3e21811fU,\n    0x10180408U, 0xb5616ad4U, 0x11974386U, 0x04060102U,\n    0x5c72172eU, 0xa37ce1dfU, 0x26358713U, 0xf304f5f7U,\n    0x0e098d07U, 0xab70e3dbU, 0x8cca2346U, 0x3a27801dU,\n    0x0d854488U, 0x5874162cU, 0x854966ccU, 0x84c62142U,\n    0xdf3efee1U, 0x73c4d5b7U, 0xc4a63162U, 0x43ecd9afU,\n    0xd4be356aU, 0x60501830U, 0x080c0204U, 0x8d4564c8U,\n    0xef16f2f9U, 0xe31cf1ffU, 0x45e956acU, 0x1394cd87U,\n    0x322b8219U, 0x078ac88dU, 0xd2bbba69U, 0xe71af0fdU,\n    0x9b58efc3U, 0x834ce9cfU, 0x874ae8cdU, 0xd334fde7U,\n    0x1e11890fU, 0x7bc8d7b3U, 0x3ba8c793U, 0xee99b577U,\n    0xaaffa455U, 0xbce22f5eU, 0x6e599537U, 0x4c6a1326U,\n    0x2c3a0b16U, 0xeb10f3fbU, 0xa77ae0ddU, 0xdcb2376eU,\n};\n\nconst DWORD T3[256] = {\n    0xf5a653a7U, 0xd06bbbd3U, 0x6ebfd1e6U, 0x3bd9e271U,\n    0xda67bdd0U, 0xcf8a45acU, 0xb3299a4dU, 0x0bf9f279U,\n    0x9ce8743aU, 0x8c038fc9U, 0x417e3f91U, 0x32d7e5fcU,\n    0x44783c1eU, 0x8f018e47U, 0xe54da854U, 0xa9ce67bdU,\n    0x0f0a058cU, 0xf9ae57a5U, 0x01f5f47aU, 0x20cbebfbU,\n    0x5791c663U, 0xb7da6db8U, 0xf453a7ddU, 0xc277b5d4U,\n    0x64b3d7e5U, 0x8df67bb3U, 0xa43397c5U, 0xa3c261beU,\n    0xd19e4fa9U, 0x171a0d88U, 0x2830180cU, 0xebb259a2U,\n    0x96e47239U, 0xf85ba3dfU, 0xf6a45229U, 0xe64fa9daU,\n    0xfaac562bU, 0xd79a4da8U, 0x800b8bcbU, 0xb52d984cU,\n    0xa731964bU, 0xcc884422U, 0xdb9249aaU, 0xd8904824U,\n    0x9b198241U, 0x3ddde070U, 0xf3a251a6U, 0x2cc3eff9U,\n    0xc175b45aU, 0x76afd9e2U, 0x87fa7db0U, 0xb4d86c36U,\n    0x13e9fa7dU, 0x62b7d5e4U, 0xaacc6633U, 0x38dbe3ffU,\n    0x5d9dc060U, 0xc0804020U, 0x30201008U, 0x1d160b8bU,\n    0xd965bc5eU, 0xdd964babU, 0x1fe1fe7fU, 0x0dfdf078U,\n    0x15edf87cU, 0xe8b0582cU, 0xef41ae57U, 0xd66fb9d2U,\n    0xf257a5dcU, 0x73a9da6dU, 0x19e5fc7eU, 0x2e341a0dU,\n    0xf751a653U, 0x5f6a3594U, 0xb02b9bc3U, 0xf0a05028U,\n    0xd29c4e27U, 0x14180c06U, 0xdf61be5fU, 0xc98e47adU,\n    0x4f81ce67U, 0xd56db85cU, 0xe349aa55U, 0xad3d9048U,\n    0x24381c0eU, 0xf155a452U, 0x468fc9eaU, 0x91158442U,\n    0xc771b65bU, 0xd369ba5dU, 0xa0c06030U, 0xcd7db058U,\n    0xfb59a251U, 0xcb79b259U, 0x88f0783cU, 0xb9259c4eU,\n    0x90e07038U, 0x1b12098aU, 0x31d5e472U, 0x78502814U,\n    0x68bbd3e7U, 0xae3f91c6U, 0xfe5fa1deU, 0xfd5da050U,\n    0x0302018eU, 0x4b723992U, 0xdc63bfd1U, 0x2fc1ee77U,\n    0x4d763b93U, 0x83098a45U, 0x7b52299aU, 0x9e1f81ceU,\n    0xeeb45a2dU, 0x0a0c0603U, 0x5195c462U, 0x93e271b6U,\n    0xb1de6fb9U, 0xa5c663bfU, 0x53623196U, 0x67b1d66bU,\n    0x82fc7e3fU, 0x121c0e07U, 0x6c482412U, 0xc38241aeU,\n    0x9d1d8040U, 0xb8d06834U, 0x89058c46U, 0x84f87c3eU,\n    0xe04babdbU, 0x981b83cfU, 0x5297c5ecU, 0x921785ccU,\n    0xbc239fc1U, 0xe1be5fa1U, 0xba279dc0U, 0xce7fb1d6U,\n    0x4e743a1dU, 0x02f7f5f4U, 0x5b99c261U, 0x9aec763bU,\n    0x60402010U, 0xea47add8U, 0x6dbdd068U, 0xe7ba5da0U,\n    0x81fe7fb1U, 0x3c28140aU, 0x6bb9d269U, 0x75add86cU,\n    0xab399249U, 0x26cfe9faU, 0x29c5ec76U, 0xa23795c4U,\n    0x6342219eU, 0x7d562b9bU, 0x79a5dc6eU, 0x715e2f99U,\n    0xb62f99c2U, 0x95e673b7U, 0x775a2d98U, 0xafca65bcU,\n    0x0506038fU, 0x392e1785U, 0x427c3e1fU, 0x9fea75b4U,\n    0x2ac7edf8U, 0x66442211U, 0xe4b85c2eU, 0x00000000U,\n    0xde944a25U, 0x4870381cU, 0xfca8542aU, 0x8ef47a3dU,\n    0x1e140a05U, 0xbf219e4fU, 0x07f1f67bU, 0x8bf279b2U,\n    0xacc86432U, 0x477a3d90U, 0xc58643afU, 0x56643219U,\n    0xedb65ba3U, 0x08fbf3f7U, 0x37d1e673U, 0x694e279dU,\n    0x7e542a15U, 0x25cde874U, 0x5e9fc1eeU, 0x860f89caU,\n    0x6546239fU, 0x223c1e0fU, 0x5a6c361bU, 0x23c9ea75U,\n    0x33221186U, 0x3f2a1584U, 0x6f4a259cU, 0xa135944aU,\n    0x55663397U, 0x5c68341aU, 0x4389ca65U, 0x0efff1f6U,\n    0x5493c7edU, 0x36241209U, 0xbdd66bbbU, 0xd4984c26U,\n    0x2d361b83U, 0x408bcbebU, 0x7fa1de6fU, 0x213e1f81U,\n    0x18100804U, 0x61b5d46aU, 0x97118643U, 0x06040201U,\n    0x725c2e17U, 0x7ca3dfe1U, 0x35261387U, 0x04f3f7f5U,\n    0x090e078dU, 0x70abdbe3U, 0xca8c4623U, 0x273a1d80U,\n    0x850d8844U, 0x74582c16U, 0x4985cc66U, 0xc6844221U,\n    0x3edfe1feU, 0xc473b7d5U, 0xa6c46231U, 0xec43afd9U,\n    0xbed46a35U, 0x50603018U, 0x0c080402U, 0x458dc864U,\n    0x16eff9f2U, 0x1ce3fff1U, 0xe945ac56U, 0x941387cdU,\n    0x2b321982U, 0x8a078dc8U, 0xbbd269baU, 0x1ae7fdf0U,\n    0x589bc3efU, 0x4c83cfe9U, 0x4a87cde8U, 0x34d3e7fdU,\n    0x111e0f89U, 0xc87bb3d7U, 0xa83b93c7U, 0x99ee77b5U,\n    0xffaa55a4U, 0xe2bc5e2fU, 0x596e3795U, 0x6a4c2613U,\n    0x3a2c160bU, 0x10ebfbf3U, 0x7aa7dde0U, 0xb2dc6e37U,\n};\n\nconst DWORD T4[256] = {\n    0xa7a7a7a7U, 0xd3d3d3d3U, 0xe6e6e6e6U, 0x71717171U,\n    0xd0d0d0d0U, 0xacacacacU, 0x4d4d4d4dU, 0x79797979U,\n    0x3a3a3a3aU, 0xc9c9c9c9U, 0x91919191U, 0xfcfcfcfcU,\n    0x1e1e1e1eU, 0x47474747U, 0x54545454U, 0xbdbdbdbdU,\n    0x8c8c8c8cU, 0xa5a5a5a5U, 0x7a7a7a7aU, 0xfbfbfbfbU,\n    0x63636363U, 0xb8b8b8b8U, 0xddddddddU, 0xd4d4d4d4U,\n    0xe5e5e5e5U, 0xb3b3b3b3U, 0xc5c5c5c5U, 0xbebebebeU,\n    0xa9a9a9a9U, 0x88888888U, 0x0c0c0c0cU, 0xa2a2a2a2U,\n    0x39393939U, 0xdfdfdfdfU, 0x29292929U, 0xdadadadaU,\n    0x2b2b2b2bU, 0xa8a8a8a8U, 0xcbcbcbcbU, 0x4c4c4c4cU,\n    0x4b4b4b4bU, 0x22222222U, 0xaaaaaaaaU, 0x24242424U,\n    0x41414141U, 0x70707070U, 0xa6a6a6a6U, 0xf9f9f9f9U,\n    0x5a5a5a5aU, 0xe2e2e2e2U, 0xb0b0b0b0U, 0x36363636U,\n    0x7d7d7d7dU, 0xe4e4e4e4U, 0x33333333U, 0xffffffffU,\n    0x60606060U, 0x20202020U, 0x08080808U, 0x8b8b8b8bU,\n    0x5e5e5e5eU, 0xababababU, 0x7f7f7f7fU, 0x78787878U,\n    0x7c7c7c7cU, 0x2c2c2c2cU, 0x57575757U, 0xd2d2d2d2U,\n    0xdcdcdcdcU, 0x6d6d6d6dU, 0x7e7e7e7eU, 0x0d0d0d0dU,\n    0x53535353U, 0x94949494U, 0xc3c3c3c3U, 0x28282828U,\n    0x27272727U, 0x06060606U, 0x5f5f5f5fU, 0xadadadadU,\n    0x67676767U, 0x5c5c5c5cU, 0x55555555U, 0x48484848U,\n    0x0e0e0e0eU, 0x52525252U, 0xeaeaeaeaU, 0x42424242U,\n    0x5b5b5b5bU, 0x5d5d5d5dU, 0x30303030U, 0x58585858U,\n    0x51515151U, 0x59595959U, 0x3c3c3c3cU, 0x4e4e4e4eU,\n    0x38383838U, 0x8a8a8a8aU, 0x72727272U, 0x14141414U,\n    0xe7e7e7e7U, 0xc6c6c6c6U, 0xdedededeU, 0x50505050U,\n    0x8e8e8e8eU, 0x92929292U, 0xd1d1d1d1U, 0x77777777U,\n    0x93939393U, 0x45454545U, 0x9a9a9a9aU, 0xcecececeU,\n    0x2d2d2d2dU, 0x03030303U, 0x62626262U, 0xb6b6b6b6U,\n    0xb9b9b9b9U, 0xbfbfbfbfU, 0x96969696U, 0x6b6b6b6bU,\n    0x3f3f3f3fU, 0x07070707U, 0x12121212U, 0xaeaeaeaeU,\n    0x40404040U, 0x34343434U, 0x46464646U, 0x3e3e3e3eU,\n    0xdbdbdbdbU, 0xcfcfcfcfU, 0xececececU, 0xccccccccU,\n    0xc1c1c1c1U, 0xa1a1a1a1U, 0xc0c0c0c0U, 0xd6d6d6d6U,\n    0x1d1d1d1dU, 0xf4f4f4f4U, 0x61616161U, 0x3b3b3b3bU,\n    0x10101010U, 0xd8d8d8d8U, 0x68686868U, 0xa0a0a0a0U,\n    0xb1b1b1b1U, 0x0a0a0a0aU, 0x69696969U, 0x6c6c6c6cU,\n    0x49494949U, 0xfafafafaU, 0x76767676U, 0xc4c4c4c4U,\n    0x9e9e9e9eU, 0x9b9b9b9bU, 0x6e6e6e6eU, 0x99999999U,\n    0xc2c2c2c2U, 0xb7b7b7b7U, 0x98989898U, 0xbcbcbcbcU,\n    0x8f8f8f8fU, 0x85858585U, 0x1f1f1f1fU, 0xb4b4b4b4U,\n    0xf8f8f8f8U, 0x11111111U, 0x2e2e2e2eU, 0x00000000U,\n    0x25252525U, 0x1c1c1c1cU, 0x2a2a2a2aU, 0x3d3d3d3dU,\n    0x05050505U, 0x4f4f4f4fU, 0x7b7b7b7bU, 0xb2b2b2b2U,\n    0x32323232U, 0x90909090U, 0xafafafafU, 0x19191919U,\n    0xa3a3a3a3U, 0xf7f7f7f7U, 0x73737373U, 0x9d9d9d9dU,\n    0x15151515U, 0x74747474U, 0xeeeeeeeeU, 0xcacacacaU,\n    0x9f9f9f9fU, 0x0f0f0f0fU, 0x1b1b1b1bU, 0x75757575U,\n    0x86868686U, 0x84848484U, 0x9c9c9c9cU, 0x4a4a4a4aU,\n    0x97979797U, 0x1a1a1a1aU, 0x65656565U, 0xf6f6f6f6U,\n    0xededededU, 0x09090909U, 0xbbbbbbbbU, 0x26262626U,\n    0x83838383U, 0xebebebebU, 0x6f6f6f6fU, 0x81818181U,\n    0x04040404U, 0x6a6a6a6aU, 0x43434343U, 0x01010101U,\n    0x17171717U, 0xe1e1e1e1U, 0x87878787U, 0xf5f5f5f5U,\n    0x8d8d8d8dU, 0xe3e3e3e3U, 0x23232323U, 0x80808080U,\n    0x44444444U, 0x16161616U, 0x66666666U, 0x21212121U,\n    0xfefefefeU, 0xd5d5d5d5U, 0x31313131U, 0xd9d9d9d9U,\n    0x35353535U, 0x18181818U, 0x02020202U, 0x64646464U,\n    0xf2f2f2f2U, 0xf1f1f1f1U, 0x56565656U, 0xcdcdcdcdU,\n    0x82828282U, 0xc8c8c8c8U, 0xbabababaU, 0xf0f0f0f0U,\n    0xefefefefU, 0xe9e9e9e9U, 0xe8e8e8e8U, 0xfdfdfdfdU,\n    0x89898989U, 0xd7d7d7d7U, 0xc7c7c7c7U, 0xb5b5b5b5U,\n    0xa4a4a4a4U, 0x2f2f2f2fU, 0x95959595U, 0x13131313U,\n    0x0b0b0b0bU, 0xf3f3f3f3U, 0xe0e0e0e0U, 0x37373737U,\n};\n\nconst DWORD T5[256] = {\n    0x00000000U, 0x01020608U, 0x02040c10U, 0x03060a18U,\n    0x04081820U, 0x050a1e28U, 0x060c1430U, 0x070e1238U,\n    0x08103040U, 0x09123648U, 0x0a143c50U, 0x0b163a58U,\n    0x0c182860U, 0x0d1a2e68U, 0x0e1c2470U, 0x0f1e2278U,\n    0x10206080U, 0x11226688U, 0x12246c90U, 0x13266a98U,\n    0x142878a0U, 0x152a7ea8U, 0x162c74b0U, 0x172e72b8U,\n    0x183050c0U, 0x193256c8U, 0x1a345cd0U, 0x1b365ad8U,\n    0x1c3848e0U, 0x1d3a4ee8U, 0x1e3c44f0U, 0x1f3e42f8U,\n    0x2040c01dU, 0x2142c615U, 0x2244cc0dU, 0x2346ca05U,\n    0x2448d83dU, 0x254ade35U, 0x264cd42dU, 0x274ed225U,\n    0x2850f05dU, 0x2952f655U, 0x2a54fc4dU, 0x2b56fa45U,\n    0x2c58e87dU, 0x2d5aee75U, 0x2e5ce46dU, 0x2f5ee265U,\n    0x3060a09dU, 0x3162a695U, 0x3264ac8dU, 0x3366aa85U,\n    0x3468b8bdU, 0x356abeb5U, 0x366cb4adU, 0x376eb2a5U,\n    0x387090ddU, 0x397296d5U, 0x3a749ccdU, 0x3b769ac5U,\n    0x3c7888fdU, 0x3d7a8ef5U, 0x3e7c84edU, 0x3f7e82e5U,\n    0x40809d3aU, 0x41829b32U, 0x4284912aU, 0x43869722U,\n    0x4488851aU, 0x458a8312U, 0x468c890aU, 0x478e8f02U,\n    0x4890ad7aU, 0x4992ab72U, 0x4a94a16aU, 0x4b96a762U,\n    0x4c98b55aU, 0x4d9ab352U, 0x4e9cb94aU, 0x4f9ebf42U,\n    0x50a0fdbaU, 0x51a2fbb2U, 0x52a4f1aaU, 0x53a6f7a2U,\n    0x54a8e59aU, 0x55aae392U, 0x56ace98aU, 0x57aeef82U,\n    0x58b0cdfaU, 0x59b2cbf2U, 0x5ab4c1eaU, 0x5bb6c7e2U,\n    0x5cb8d5daU, 0x5dbad3d2U, 0x5ebcd9caU, 0x5fbedfc2U,\n    0x60c05d27U, 0x61c25b2fU, 0x62c45137U, 0x63c6573fU,\n    0x64c84507U, 0x65ca430fU, 0x66cc4917U, 0x67ce4f1fU,\n    0x68d06d67U, 0x69d26b6fU, 0x6ad46177U, 0x6bd6677fU,\n    0x6cd87547U, 0x6dda734fU, 0x6edc7957U, 0x6fde7f5fU,\n    0x70e03da7U, 0x71e23bafU, 0x72e431b7U, 0x73e637bfU,\n    0x74e82587U, 0x75ea238fU, 0x76ec2997U, 0x77ee2f9fU,\n    0x78f00de7U, 0x79f20befU, 0x7af401f7U, 0x7bf607ffU,\n    0x7cf815c7U, 0x7dfa13cfU, 0x7efc19d7U, 0x7ffe1fdfU,\n    0x801d2774U, 0x811f217cU, 0x82192b64U, 0x831b2d6cU,\n    0x84153f54U, 0x8517395cU, 0x86113344U, 0x8713354cU,\n    0x880d1734U, 0x890f113cU, 0x8a091b24U, 0x8b0b1d2cU,\n    0x8c050f14U, 0x8d07091cU, 0x8e010304U, 0x8f03050cU,\n    0x903d47f4U, 0x913f41fcU, 0x92394be4U, 0x933b4decU,\n    0x94355fd4U, 0x953759dcU, 0x963153c4U, 0x973355ccU,\n    0x982d77b4U, 0x992f71bcU, 0x9a297ba4U, 0x9b2b7dacU,\n    0x9c256f94U, 0x9d27699cU, 0x9e216384U, 0x9f23658cU,\n    0xa05de769U, 0xa15fe161U, 0xa259eb79U, 0xa35bed71U,\n    0xa455ff49U, 0xa557f941U, 0xa651f359U, 0xa753f551U,\n    0xa84dd729U, 0xa94fd121U, 0xaa49db39U, 0xab4bdd31U,\n    0xac45cf09U, 0xad47c901U, 0xae41c319U, 0xaf43c511U,\n    0xb07d87e9U, 0xb17f81e1U, 0xb2798bf9U, 0xb37b8df1U,\n    0xb4759fc9U, 0xb57799c1U, 0xb67193d9U, 0xb77395d1U,\n    0xb86db7a9U, 0xb96fb1a1U, 0xba69bbb9U, 0xbb6bbdb1U,\n    0xbc65af89U, 0xbd67a981U, 0xbe61a399U, 0xbf63a591U,\n    0xc09dba4eU, 0xc19fbc46U, 0xc299b65eU, 0xc39bb056U,\n    0xc495a26eU, 0xc597a466U, 0xc691ae7eU, 0xc793a876U,\n    0xc88d8a0eU, 0xc98f8c06U, 0xca89861eU, 0xcb8b8016U,\n    0xcc85922eU, 0xcd879426U, 0xce819e3eU, 0xcf839836U,\n    0xd0bddaceU, 0xd1bfdcc6U, 0xd2b9d6deU, 0xd3bbd0d6U,\n    0xd4b5c2eeU, 0xd5b7c4e6U, 0xd6b1cefeU, 0xd7b3c8f6U,\n    0xd8adea8eU, 0xd9afec86U, 0xdaa9e69eU, 0xdbabe096U,\n    0xdca5f2aeU, 0xdda7f4a6U, 0xdea1febeU, 0xdfa3f8b6U,\n    0xe0dd7a53U, 0xe1df7c5bU, 0xe2d97643U, 0xe3db704bU,\n    0xe4d56273U, 0xe5d7647bU, 0xe6d16e63U, 0xe7d3686bU,\n    0xe8cd4a13U, 0xe9cf4c1bU, 0xeac94603U, 0xebcb400bU,\n    0xecc55233U, 0xedc7543bU, 0xeec15e23U, 0xefc3582bU,\n    0xf0fd1ad3U, 0xf1ff1cdbU, 0xf2f916c3U, 0xf3fb10cbU,\n    0xf4f502f3U, 0xf5f704fbU, 0xf6f10ee3U, 0xf7f308ebU,\n    0xf8ed2a93U, 0xf9ef2c9bU, 0xfae92683U, 0xfbeb208bU,\n    0xfce532b3U, 0xfde734bbU, 0xfee13ea3U, 0xffe338abU,\n};\n\n/**\n * The round constants.\n */\nconst DWORD rc[] = {\n    0xa7d3e671U, 0xd0ac4d79U, 0x3ac991fcU, 0x1e4754bdU,\n\t0x8ca57afbU, 0x63b8ddd4U, 0xe5b3c5beU, 0xa9880ca2U,\n\t0x39df29daU, 0x2ba8cb4cU, 0x4b22aa24U, 0x4170a6f9U,\n\t0x5ae2b036U, 0x7de433ffU, 0x6020088bU, 0x5eab7f78U,\n\t0x7c2c57d2U, 0xdc6d7e0dU, 0x5394c328U,\n};\n\n\n/**\n * Create the Anubis key schedule for a given cipher key.\n * Both encryption and decryption key schedules are generated.\n * \n * @param key\t\t\tThe 32N-bit cipher key.\n * @param structpointer\tPointer to the structure that will hold the expanded key.\n */\nvoid Anubis_set_key(ANUBIS_DATA *pAd,const BYTE *key)\n{\n\tint N, R, i, pos, r;\n\tDWORD kappa[MAX_N];\n\tDWORD inter[MAX_N];\n\n\tpAd->keyBits = KEYSIZEB*8;\n\n\t/*\n\t * determine the N length parameter:\n\t * (N.B. it is assumed that the key length is valid!)\n\t */\n\tN = pAd->keyBits >> 5;\n\n\t/*\n\t * determine number of rounds from key size:\n\t */\n\tpAd->R = R = 8 + N;\n\n    /*\n\t * map cipher key to initial key state (mu):\n\t */\n    for (i = 0, pos = 0; i < N; i++, pos += 4) {\n\t\tkappa[i] =\n\t\t\t(key[pos    ] << 24) ^\n\t\t\t(key[pos + 1] << 16) ^\n\t\t\t(key[pos + 2] <<  8) ^\n\t\t\t(key[pos + 3]      );\n    }\n\n\t/*\n\t * generate R + 1 round keys:\n\t */\n\tfor (r = 0; r <= R; r++) {\n\t\tDWORD K0, K1, K2, K3;\n\t\t/*\n\t\t * generate r-th round key K^r:\n\t\t */\n\t\tK0 = T4[(kappa[N - 1] >> 24)       ];\n\t\tK1 = T4[(kappa[N - 1] >> 16) & 0xff];\n\t\tK2 = T4[(kappa[N - 1] >>  8) & 0xff];\n\t\tK3 = T4[(kappa[N - 1]      ) & 0xff];\n\t\tfor (i = N - 2; i >= 0; i--) {\n\t\t\tK0 = T4[(kappa[i] >> 24)       ] ^\n\t\t\t\t(T5[(K0 >> 24)       ] & 0xff000000U) ^\n\t\t\t\t(T5[(K0 >> 16) & 0xff] & 0x00ff0000U) ^\n\t\t\t\t(T5[(K0 >>  8) & 0xff] & 0x0000ff00U) ^\n\t\t\t\t(T5[(K0      ) & 0xff] & 0x000000ffU);\n\t\t\tK1 = T4[(kappa[i] >> 16) & 0xff] ^\n\t\t\t\t(T5[(K1 >> 24)       ] & 0xff000000U) ^\n\t\t\t\t(T5[(K1 >> 16) & 0xff] & 0x00ff0000U) ^\n\t\t\t\t(T5[(K1 >>  8) & 0xff] & 0x0000ff00U) ^\n\t\t\t\t(T5[(K1      ) & 0xff] & 0x000000ffU);\n\t\t\tK2 = T4[(kappa[i] >>  8) & 0xff] ^\n\t\t\t\t(T5[(K2 >> 24)       ] & 0xff000000U) ^\n\t\t\t\t(T5[(K2 >> 16) & 0xff] & 0x00ff0000U) ^\n\t\t\t\t(T5[(K2 >>  8) & 0xff] & 0x0000ff00U) ^\n\t\t\t\t(T5[(K2      ) & 0xff] & 0x000000ffU);\n\t\t\tK3 = T4[(kappa[i]      ) & 0xff] ^\n\t\t\t\t(T5[(K3 >> 24)       ] & 0xff000000U) ^\n\t\t\t\t(T5[(K3 >> 16) & 0xff] & 0x00ff0000U) ^\n\t\t\t\t(T5[(K3 >>  8) & 0xff] & 0x0000ff00U) ^\n\t\t\t\t(T5[(K3      ) & 0xff] & 0x000000ffU);\n\t\t}\n\t\t/*\n\t\t-- this is the code to use with the large U tables:\n\t\tK0 = K1 = K2 = K3 = 0;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tK0 ^= U[i][(kappa[i] >> 24)       ];\n\t\t\tK1 ^= U[i][(kappa[i] >> 16) & 0xff];\n\t\t\tK2 ^= U[i][(kappa[i] >>  8) & 0xff];\n\t\t\tK3 ^= U[i][(kappa[i]      ) & 0xff];\n\t\t}\n\t\t*/\n\t\tpAd->roundKeyEnc[r][0] = K0;\n\t\tpAd->roundKeyEnc[r][1] = K1;\n\t\tpAd->roundKeyEnc[r][2] = K2;\n\t\tpAd->roundKeyEnc[r][3] = K3;\n\n\t\t/*\n\t\t * compute kappa^{r+1} from kappa^r:\n\t\t */\n\t\tif (r == R) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tint j = i;\n\t\t\tinter[i]  = T0[(kappa[j--] >> 24)       ]; if (j < 0) j = N - 1;\n\t\t\tinter[i] ^= T1[(kappa[j--] >> 16) & 0xff]; if (j < 0) j = N - 1;\n\t\t\tinter[i] ^= T2[(kappa[j--] >>  8) & 0xff]; if (j < 0) j = N - 1;\n\t\t\tinter[i] ^= T3[(kappa[j  ]      ) & 0xff];\n\t\t}\n\t\tkappa[0] = inter[0] ^ rc[r];\n\t\tfor (i = 1; i < N; i++) {\n\t\t\tkappa[i] = inter[i];\n\t\t}\n\t}\n\n\t/*\n\t * generate inverse key schedule: K'^0 = K^R, K'^R = K^0, K'^r = theta(K^{R-r}):\n\t */\n\tfor (i = 0; i < 4; i++) {\n\t\tpAd->roundKeyDec[0][i] = pAd->roundKeyEnc[R][i];\n\t\tpAd->roundKeyDec[R][i] = pAd->roundKeyEnc[0][i];\n\t}\n\tfor (r = 1; r < R; r++) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tDWORD v = pAd->roundKeyEnc[R - r][i];\n\t\t\tpAd->roundKeyDec[r][i] =\n\t\t\t\tT0[T4[(v >> 24)       ] & 0xff] ^\n\t\t\t\tT1[T4[(v >> 16) & 0xff] & 0xff] ^\n\t\t\t\tT2[T4[(v >>  8) & 0xff] & 0xff] ^\n\t\t\t\tT3[T4[(v      ) & 0xff] & 0xff];\n\t\t}\n\t}\n}\n\n/**\n * Either encrypt or decrypt a data block, according to the key schedule.\n * \n * @param\tblock\t\tthe data block to be encrypted/decrypted.\n * @param\troundKey\tthe key schedule to be used.\n * @param\tR\t\t\tnumber of rounds.\n */\nvoid aux_crypt(const BYTE *plaintext, BYTE *ciphertext, const DWORD roundKey[MAX_ROUNDS + 1][4], int R)\n{\n\tint i, pos, r;\n\tDWORD state[4];\n\tDWORD inter[4];\n\n    /*\n\t * map plaintext block to cipher state (mu)\n\t * and add initial round key (sigma[K^0]):\n\t */\n    for (i = 0, pos = 0; i < 4; i++, pos += 4) {\n\t\tstate[i] =\n\t\t\t(plaintext[pos    ] << 24) ^\n\t\t\t(plaintext[pos + 1] << 16) ^\n\t\t\t(plaintext[pos + 2] <<  8) ^\n\t\t\t(plaintext[pos + 3]      ) ^\n\t\t\troundKey[0][i];\n    }\n\n    /*\n     * R - 1 full rounds:\n     */\n    for (r = 1; r < R; r++) {\n\t\tinter[0] =\n\t\t\tT0[(state[0] >> 24)       ] ^\n\t\t\tT1[(state[1] >> 24)       ] ^\n\t\t\tT2[(state[2] >> 24)       ] ^\n\t\t\tT3[(state[3] >> 24)       ] ^\n\t\t\troundKey[r][0];\n\t\tinter[1] =\n\t\t\tT0[(state[0] >> 16) & 0xff] ^\n\t\t\tT1[(state[1] >> 16) & 0xff] ^\n\t\t\tT2[(state[2] >> 16) & 0xff] ^\n\t\t\tT3[(state[3] >> 16) & 0xff] ^\n\t\t\troundKey[r][1];\n\t\tinter[2] =\n\t\t\tT0[(state[0] >>  8) & 0xff] ^\n\t\t\tT1[(state[1] >>  8) & 0xff] ^\n\t\t\tT2[(state[2] >>  8) & 0xff] ^\n\t\t\tT3[(state[3] >>  8) & 0xff] ^\n\t\t\troundKey[r][2];\n\t\tinter[3] =\n\t\t\tT0[(state[0]      ) & 0xff] ^\n\t\t\tT1[(state[1]      ) & 0xff] ^\n\t\t\tT2[(state[2]      ) & 0xff] ^\n\t\t\tT3[(state[3]      ) & 0xff] ^\n\t\t\troundKey[r][3];\n\t\tstate[0] = inter[0];\n\t\tstate[1] = inter[1];\n\t\tstate[2] = inter[2];\n\t\tstate[3] = inter[3];\n    }\n\n    /*\n\t * last round:\n\t */\n\tinter[0] =\n\t\t(T0[(state[0] >> 24)       ] & 0xff000000U) ^\n\t\t(T1[(state[1] >> 24)       ] & 0x00ff0000U) ^\n\t\t(T2[(state[2] >> 24)       ] & 0x0000ff00U) ^\n\t\t(T3[(state[3] >> 24)       ] & 0x000000ffU) ^\n\t\troundKey[R][0];\n\tinter[1] =\n\t\t(T0[(state[0] >> 16) & 0xff] & 0xff000000U) ^\n\t\t(T1[(state[1] >> 16) & 0xff] & 0x00ff0000U) ^\n\t\t(T2[(state[2] >> 16) & 0xff] & 0x0000ff00U) ^\n\t\t(T3[(state[3] >> 16) & 0xff] & 0x000000ffU) ^\n\t\troundKey[R][1];\n\tinter[2] =\n\t\t(T0[(state[0] >>  8) & 0xff] & 0xff000000U) ^\n\t\t(T1[(state[1] >>  8) & 0xff] & 0x00ff0000U) ^\n\t\t(T2[(state[2] >>  8) & 0xff] & 0x0000ff00U) ^\n\t\t(T3[(state[3] >>  8) & 0xff] & 0x000000ffU) ^\n\t\troundKey[R][2];\n\tinter[3] =\n\t\t(T0[(state[0]      ) & 0xff] & 0xff000000U) ^\n\t\t(T1[(state[1]      ) & 0xff] & 0x00ff0000U) ^\n\t\t(T2[(state[2]      ) & 0xff] & 0x0000ff00U) ^\n\t\t(T3[(state[3]      ) & 0xff] & 0x000000ffU) ^\n\t\troundKey[R][3];\n\n\t/*\n\t * map cipher state to ciphertext block (mu^{-1}):\n\t */\n    for (i = 0, pos = 0; i < 4; i++, pos += 4) {\n        DWORD w = inter[i];\n        ciphertext[pos    ] = (BYTE)(w >> 24);\n        ciphertext[pos + 1] = (BYTE)(w >> 16);\n        ciphertext[pos + 2] = (BYTE)(w >>  8);\n        ciphertext[pos + 3] = (BYTE)(w      );\n    }\n}\n\n/**\n * Encrypt a data block.\n * \n * @param\tstructpointer\tthe expanded key.\n * @param\tplaintext\t\tthe data block to be encrypted.\n * @param\tciphertext\t\tthe encrypted data block.\n */\nvoid Anubis_encrypt(const ANUBIS_DATA *pAd,const BYTE *plaintext,BYTE *ciphertext)\n{\n\taux_crypt(plaintext, ciphertext, pAd->roundKeyEnc, pAd->R);\n}\n\n/**\n * Decrypt a data block.\n * \n * @param\tstructpointer\tthe expanded key.\n * @param\tciphertext\t\tthe data block to be decrypted.\n * @param\tplaintext\t\tthe decrypted data block.\n */\nvoid Anubis_decrypt(const ANUBIS_DATA *pAd,const BYTE *ciphertext,BYTE *plaintext)\n{\n\taux_crypt(ciphertext, plaintext, pAd->roundKeyDec, pAd->R);\n}\n"
        },
        {
            "file_name": "argon-ref.cpp",
            "content": "#include \"stdio.h\"\n\n#include \"wmmintrin.h\"\n#include <immintrin.h> \n#include <intrin.h> \n#include <time.h> \n\n#include <string>\nusing namespace std;\n\n#define MAX_THREADS 32\n#define MAX_OUTLEN 32\n#define MIN_MEMORY 1\n#define MAX_MEMORY (1<<26)\n#define MIN_TIME 1\n#define LENGTH_SIZE 4\n#define MIN_PASSWORD 0\n#define MAX_PASSWORD 256\n#define MAX_SALT  32\n#define MAX_SECRET 16\n#define INPUT_SIZE (INPUT_BLOCKS*12)\n#define INPUT_BLOCKS 32\n#define CACHE_SIZE 128\n#define BATCH_SIZE 16   //should be not larger than 32\n#define GROUP_SIZE 32\n\n#define AES_ROUNDS 5\n\n#define u32 unsigned __int32\n#define u64 unsigned long long int\n\n#define KAT\n#define _MEASURE\n//#define KATINT\n\nunsigned char subkeys[11][16]={\n\t{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, },\n{0xd6, 0xaa, 0x74, 0xfd, 0xd2, 0xaf, 0x72, 0xfa, 0xda, 0xa6, 0x78, 0xf1, 0xd6, 0xab, 0x76, 0xfe, },\n{0xb6, 0x92, 0xcf, 0x0b, 0x64, 0x3d, 0xbd, 0xf1, 0xbe, 0x9b, 0xc5, 0x00, 0x68, 0x30, 0xb3, 0xfe, },\n{0xb6, 0xff, 0x74, 0x4e, 0xd2, 0xc2, 0xc9, 0xbf, 0x6c, 0x59, 0x0c, 0xbf, 0x04, 0x69, 0xbf, 0x41, },\n{0x47, 0xf7, 0xf7, 0xbc, 0x95, 0x35, 0x3e, 0x03, 0xf9, 0x6c, 0x32, 0xbc, 0xfd, 0x05, 0x8d, 0xfd, },\n{0x3c, 0xaa, 0xa3, 0xe8, 0xa9, 0x9f, 0x9d, 0xeb, 0x50, 0xf3, 0xaf, 0x57, 0xad, 0xf6, 0x22, 0xaa, },\n{0x5e, 0x39, 0x0f, 0x7d, 0xf7, 0xa6, 0x92, 0x96, 0xa7, 0x55, 0x3d, 0xc1, 0x0a, 0xa3, 0x1f, 0x6b, },\n{0x14, 0xf9, 0x70, 0x1a, 0xe3, 0x5f, 0xe2, 0x8c, 0x44, 0x0a, 0xdf, 0x4d, 0x4e, 0xa9, 0xc0, 0x26, },\n{0x47, 0x43, 0x87, 0x35, 0xa4, 0x1c, 0x65, 0xb9, 0xe0, 0x16, 0xba, 0xf4, 0xae, 0xbf, 0x7a, 0xd2, },\n{0x54, 0x99, 0x32, 0xd1, 0xf0, 0x85, 0x57, 0x68, 0x10, 0x93, 0xed, 0x9c, 0xbe, 0x2c, 0x97, 0x4e, },\n\t{0x13, 0x11, 0x1d, 0x7f, 0xe3, 0x94, 0x4a, 0x17, 0xf3, 0x07, 0xa7, 0x8b, 0x4d, 0x2b, 0x30, 0xc5, }};\n\nu64 subkeys64[11][2]=\n\t{{0x0706050403020100, 0x0f0e0d0c0b0a0908},\n{0xfa72afd2fd74aad6, 0xfe76abd6f178a6da},\n{0xf1bd3d640bcf92b6, 0xfeb3306800c59bbe},\n{0xbfc9c2d24e74ffb6, 0x41bf6904bf0c596c},\n{0x033e3595bcf7f747, 0xfd8d05fdbc326cf9},\n{0xeb9d9fa9e8a3aa3c, 0xaa22f6ad57aff350},\n{0x9692a6f77d0f395e, 0x6b1fa30ac13d55a7},\n{0x8ce25fe31a70f914, 0x26c0a94e4ddf0a44},\n{0xb9651ca435874347, 0xd27abfaef4ba16e0},\n{0x685785f0d1329954, 0x4e972cbe9ced9310},\n{0x174a94e37f1d1113, 0xc5302b4d8ba707f3}};\n\nstruct int128{\n\tu64 i0,i1;\n\tint128(u64 y0=0, u64 y1=0){i0 = y0; i1 = y1;};\n\tint128& operator^=(const int128 &r){ i0 ^= r.i0; i1 ^=r.i1; return *this;}\n\tint128& operator=(const int128 &r){ i0 = r.i0; i1 =r.i1; return *this;}\n\tunsigned char operator[](unsigned i)\n\t{\n\t\tif(i<8)\n\t\t\treturn (i0>>(8*i))&0xff;\n\t\telse if(i<16)\n\t\t\treturn (i1>>(8*(i-8)))&0xff;\n\t\treturn 0;\n\t}\n\tint128 operator^(const int128 &r){ return int128(i0 ^ r.i0,i1^r.i1); }\n};\n\n\n\n//AES S-box\nconst static unsigned char sbox[256] =   {\n\t\t//0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F\n\t\t0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0\n\t\t0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1\n\t\t0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2\n\t\t0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3\n\t\t0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4\n\t\t0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5\n\t\t0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6\n\t\t0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7\n\t\t0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8\n\t\t0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9\n\t\t0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A\n\t\t0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B\n\t\t0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C\n\t\t0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D\n\t\t0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E\n\t\t0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };\n\nunsigned char mul[256][256]; //GF(256) multiplication table, initialized in Init().\n\nvoid AES_Round(unsigned char* state, unsigned char* subkey)  //SubBytes-ShiftRows-MixColumns-AddRoundKey\n{\n\tunsigned char tmp[4][4];\n\n\tfor(unsigned i=0; i<4; ++i)\n\t{\n\t\tfor(unsigned j=0; j<4; ++j)\n\t\t\ttmp[j][i] = state[4*i+j];//AES state conversion\n\t}\n\tfor(unsigned i=0; i<4; ++i)//Columnwise loop\n\t {\n\t \tstate[4*i] = mul[sbox[tmp[0][i]]][2] ^ mul[sbox[tmp[3][(i+3)%4]]][1] ^\n\t\t\t\t\t\tmul[sbox[tmp[2][(i+2)%4]]][1] ^ mul[sbox[tmp[1][(i+1)%4]]][3];\n\t\tstate[4*i+1] = mul[sbox[tmp[1][(i+1)%4]]][2] ^ mul[sbox[tmp[0][i]]][1] ^\n\t\t\t\t\tmul[sbox[tmp[3][(i+3)%4]]][1] ^ mul[sbox[tmp[2][(i+2)%4]]][3];\n\t\tstate[4*i+2] = mul[sbox[tmp[2][(i+2)%4]]][2] ^ mul[sbox[tmp[1][(i+1)%4]]][1] ^\n\t\t\t\t\tmul[sbox[tmp[0][i]]][1] ^ mul[sbox[tmp[3][(i+3)%4]]][3];\n\t\tstate[4*i+3] = mul[sbox[tmp[3][(i+3)%4]]][2] ^ mul[sbox[tmp[2][(i+2)%4]]][1] ^\n\t\t\t\t\tmul[sbox[tmp[1][(i+1)%4]]][1] ^ mul[sbox[tmp[0][i]]][3];\n\t }\n\tfor(unsigned i=0; i<16; ++i)\n\t\tstate[i] ^= subkey[i];\n\n}\n\n//GF(256) multiplication\n\nunsigned char gmul_o(unsigned char a, unsigned char b) {\n\tunsigned char p = 0;\n\tunsigned char counter;\n\tunsigned char hi_bit_set;\n\tfor(counter = 0; counter < 8; counter++) {\n\t\tif((b & 1) == 1) \n\t\t\tp ^= a;\n\t\thi_bit_set = (a & 0x80);\n\t\ta <<= 1;\n\t\tif(hi_bit_set == 0x80) \n\t\t\ta ^= 0x1b;\t\t\n\t\tb >>= 1;\n\t}\n\treturn p;\n}\n\nvoid Init()\n{\n\tfor(unsigned i=0; i<256; ++i)\n\t\t{\n\t\t\tfor(unsigned j=0; j<256; ++j)\n\t\t\t\tmul[i][j] = gmul_o(i,j);\n\t\t}\n}\n\n\nvoid AES_reduced(int128 &input)\n{\n\tunsigned char state[16];\n\t/*unsigned char subkeys[AES_ROUNDS+1][16];\n\tmemset(subkeys,0,(AES_ROUNDS+1)*16);\n\tfor(unsigned i=0; i<16; i+=4)\n\t\tfor(unsigned j=0; j<AES_ROUNDS+1; ++j)\n\t\t\tsubkeys[j][i]=j+1;*/\n\tfor(unsigned i=0; i<8; ++i)\n\t\t\tstate[i] = (input.i0>>(i*8))&0xff ^ subkeys[0][i];//AES state conversion\n\tfor(unsigned i=0; i<8; ++i)\n\t\tstate[i+8] = (input.i1>>(i*8))&0xff ^ subkeys[0][i+8];\n\t\n\tfor(unsigned i=0; i<AES_ROUNDS;++i)\n\t\tAES_Round(state,subkeys[i+1]);\n\tinput.i0 = *((u64*)state);\n\tinput.i1 = *((u64*)(state+8));\n\n}\n\n\nvoid SubGroups(int128* state, unsigned width)\n{\n\tfor(unsigned i=0; i<width; i+= 32)\n\t{\n\t\t//Computing X_i:\n\t\tint128 X[16];\n\t\tX[ 0] =  state[i+ 3]^ state[i+ 7]^ state[i+11]^ state[i+15]^ state[i+19]^ state[i+23]^ state[i+27]^ state[i+31];\n\t\tX[ 1] =  state[i+ 1]^ state[i+ 3]^ state[i+ 9]^ state[i+11]^ state[i+17]^ state[i+19]^ state[i+25]^ state[i+27];\n\t\tX[ 2] =  state[i+ 0]^ state[i+ 2]^ state[i+ 4]^ state[i+ 6]^ state[i+16]^ state[i+18]^ state[i+20]^ state[i+22];\n\t\tX[ 3] =  state[i+ 1]^ state[i+ 3]^ state[i+ 5]^ state[i+ 7]^ state[i+ 9]^ state[i+11]^ state[i+13]^ state[i+15];\n\t\tX[ 4] =  state[i+ 6]^ state[i+ 7]^ state[i+14]^ state[i+15]^ state[i+22]^ state[i+23]^ state[i+30]^ state[i+31];\n\t\tX[ 5] =  state[i+10]^ state[i+11]^ state[i+14]^ state[i+15]^ state[i+26]^ state[i+27]^ state[i+30]^ state[i+31];\n\t\tX[ 6] =  state[i+16]^ state[i+17]^ state[i+20]^ state[i+21]^ state[i+24]^ state[i+25]^ state[i+28]^ state[i+29];\n\t\tX[ 7] =  state[i+12]^ state[i+13]^ state[i+14]^ state[i+15]^ state[i+28]^ state[i+29]^ state[i+30]^ state[i+31];\n\t\tX[ 8] =  state[i+ 4]^ state[i+ 5]^ state[i+ 6]^ state[i+ 7]^ state[i+12]^ state[i+13]^ state[i+14]^ state[i+15];\n\t\tX[ 9] =  state[i+16]^ state[i+17]^ state[i+18]^ state[i+19]^ state[i+20]^ state[i+21]^ state[i+22]^ state[i+23];\n\t\tX[10] =  state[i+ 1]^ state[i+ 5]^ state[i+ 9]^ state[i+13]^ state[i+17]^ state[i+21]^ state[i+25]^ state[i+29];\n\t\tX[11] =  state[i+ 2]^ state[i+ 6]^ state[i+10]^ state[i+14]^ state[i+18]^ state[i+22]^ state[i+26]^ state[i+30];\n\t\tX[12] =  state[i+ 4]^ state[i+ 5]^ state[i+ 6]^ state[i+ 7]^ state[i+20]^ state[i+21]^ state[i+22]^ state[i+23];\n\t\tX[13] =  state[i+ 8]^ state[i+ 9]^ state[i+10]^ state[i+11]^ state[i+24]^ state[i+25]^ state[i+26]^ state[i+27];\n\t\tX[14] =  state[i+ 0]^ state[i+ 1]^ state[i+ 2]^ state[i+ 3]^ state[i+ 8]^ state[i+ 9]^ state[i+10]^ state[i+11];\n\t\tX[15] =  state[i+ 0]^ state[i+ 4]^ state[i+ 8]^ state[i+12]^ state[i+16]^ state[i+20]^ state[i+24]^ state[i+28];\n\t\t\n\t\t\n\n\t\tfor(unsigned j=0; j<16;++j)\n\t\t{\n\t\t\tAES_reduced(X[j]);//Computing F's\n\t\t\tstate[i+2*j] ^= X[j]; //XORs\n\t\t\tstate[i+2*j+1] ^= X[j];\n\t\t\tAES_reduced(state[i+2*j]);\n\t\t\tAES_reduced(state[i+2*j+1]);\n\t\t}\n\t}\n}\n\nvoid ShuffleSlices(int128* state, unsigned width)\n{\n\tfor(unsigned s=0; s<32; ++s) //Loop on slices\n\t{\n\t\tunsigned j=0;\n\t\tfor(unsigned i=0; i<width/32; ++i)\n\t\t{\n\t\t\t//j <- j+ S[i]\n\t\t\t//Swap(S[i],S[j])\n\t\t\tunsigned index1 = i*32 + s; \n\t\t\tint128 v1 = state[index1];\n\t\t\tj = (j+ (v1.i0&0xffffffff))%(width/32);\n\t\t\tunsigned index2 = j*32+s;\n\t\t\tswap(state[index1],state[index2]);\n\t\t}\n\t}\n}\n\nint ArgonRef(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, const void *secret, size_t secretlen, unsigned int t_cost, unsigned int m_cost)\n{\n\tInit();  //Initializing Galois field multiplication table.\n\tint128* state;  //Array A of blocks\n\n\t//0. Restricting parameters\n\t//maximum outlen=32\n\tif(outlen>MAX_OUTLEN)\n\t\toutlen=MAX_OUTLEN;\n\n\t//minumum m_cost =1\n\tif(m_cost<MIN_MEMORY)\n\t\tm_cost = MIN_MEMORY;\n\tif(m_cost>MAX_MEMORY)\n\t\tm_cost = MAX_MEMORY;\n\t\n\t//minimum t_cost =3\n\tif(t_cost<MIN_TIME)\n\t\tt_cost = MIN_TIME;\n\n\tif(inlen> MAX_PASSWORD)\n\t\tinlen = MAX_PASSWORD;\n\tif(saltlen> MAX_SALT)\n\t\tsaltlen = MAX_SALT;\n#ifdef KAT\n\tFILE* fp=fopen(\"kat.log\",\"a+\");\n\tfprintf(fp,\"=======================================\\n\");\n\tfprintf(fp,\"Iterations: %d, Memory: %d KBytes, Tag length: %d bytes\\n\", t_cost, m_cost,outlen);\n\tfprintf(fp,\"Password: \");\n\tfor(unsigned i=0; i<inlen; ++i)\n\t\tfprintf(fp,\"%2.2x \",((unsigned char*)in)[i]);\n\tfprintf(fp,\"\\n\");\n\tfprintf(fp,\"Salt: \");\n\tfor(unsigned i=0; i<saltlen; ++i)\n\t\tfprintf(fp,\"%2.2x \",((unsigned char*)salt)[i]);\n\tfprintf(fp,\"\\n\");\n\t\t\n#endif\n\n\n\n\t//1. Preparing input string I \n\tunsigned char Input[INPUT_SIZE];\n\tmemset(Input,0,INPUT_SIZE);\n\t//1.1 Password length\n\tfor(unsigned i=0; i<LENGTH_SIZE; ++i)\n\t{\n\t\tInput[i] = (inlen>>(8*i))&0xff;  //Little endian password length encoding\n\t}\n\t//1.2 Salt length\n\tfor(unsigned i=0; i<LENGTH_SIZE; ++i)\n\t{\n\t\tInput[i+LENGTH_SIZE] = (saltlen>>(8*i))&0xff;  //Little endian salt length encoding\n\t}\n\t//1.3 Secret length  -- equal to 0 in the default function\n\tfor(unsigned i=0; i<LENGTH_SIZE; ++i)\n\t{\n\t\tInput[i+2*LENGTH_SIZE] =(secretlen>>(8*i))&0xff;\n\t}\n\t//1.4 Iteration number\n\tfor(unsigned i=0; i<LENGTH_SIZE; ++i)\n\t{\n\t\tInput[i+3*LENGTH_SIZE] =(t_cost>>(8*i))&0xff;\n\t}\n\t//1.5 Memory parameter\n\tfor(unsigned i=0; i<LENGTH_SIZE; ++i)\n\t{\n\t\tInput[i+4*LENGTH_SIZE] =(m_cost>>(8*i))&0xff;\n\t}\n\t//1.6 Tag length\n\tfor(unsigned i=0; i<LENGTH_SIZE; ++i)\n\t{\n\t\tInput[i+5*LENGTH_SIZE] =(outlen>>(8*i))&0xff;\n\t}\n\t//1.7 Password\n\tfor(unsigned i=0; i<inlen; ++i)\n\t{\n\t\tInput[i+6*LENGTH_SIZE] =((unsigned char*)in)[i];\n\t}\n\t//1.8 Salt\n\tfor(unsigned i=0; i<saltlen; ++i)\n\t{\n\t\tInput[i+6*LENGTH_SIZE+inlen] =((unsigned char*)salt)[i];\n\t}\n\t//1.9 Secret\n\tfor(unsigned i=0; i<secretlen; ++i)\n\t{\n\t\tInput[i+6*LENGTH_SIZE+inlen+saltlen+i] =((unsigned char*)secret)[i];\n\t}\n\t//1.10 Padding\n\tfor(unsigned i=6*LENGTH_SIZE+inlen+saltlen+secretlen; i<INPUT_SIZE; ++i)\n\t\tInput[i] = 0;\n#ifdef KATINT\n\tfprintf(fp,\"Input string:\\n\");\n\tfor(unsigned i=0; i<INPUT_SIZE; ++i)\n\t{\n\t\tfprintf(fp,\"%2.2x \",Input[i]);\n\t\tif(i%30==29)\n\t\t\tfprintf(fp,\"\\n\");\n\t}\n\tfprintf(fp,\"\\n\");\n\t\t\n#endif\n\n\n\t//2. Filling blocks\n\tunsigned state_size = m_cost*64;\n\tstate = new int128[state_size];\n\tif(state==NULL)\n\t\treturn 1;\n\tprintf(\"Memory allocated: %d KBytes\\n\",state_size*sizeof(int128)/(1<<10));\n\n\tfor(unsigned i=0; i<state_size; ++i)\n\t{\n\t\t//Input part\n\t\tunsigned input_block_index = 12*(i%INPUT_BLOCKS); //Position where we take the input block\n\t\tstate[i].i0=0;\n\t\tfor(unsigned j=0; j<8; ++j)\n\t\t\tstate[i].i0 ^= ((u64)Input[input_block_index+j])<<(8*j);\n\t\tstate[i].i1=0;\n\t\tfor(unsigned j=0; j<4; ++j)\n\t\t\tstate[i].i1 ^= ((u64)Input[input_block_index+8+j])<<(8*j);\n\t\t//Counter\n\t\tstate[i].i1 ^= ((u64)i)<<(32);\n\t}\n\tmemset(Input,0,INPUT_SIZE);\n#ifdef KATINT\n\tfprintf(fp,\"Blocks:\\n\");\n\tfor(unsigned i=0; i<state_size; ++i)\n\t{\n\t\tfprintf(fp,\"Block %3.3d: H: %.16llx L: %.16llx\",i,state[i].i1,state[i].i0);\n\t\tfprintf(fp,\"\\n\");\n\t}\n\tfprintf(fp,\"\\n\");\n\t\t\n#endif\n\n\t//3. Initial transformation\n\tfor(unsigned i=0; i<state_size; ++i)\n\t{\n\t\tAES_reduced(state[i]);\n\t}\n\n\t#ifdef KATINT\n\tfprintf(fp,\"Initial transformation:\\nBlocks:\\n\");\n\tfor(unsigned i=0; i<state_size; ++i)\n\t{\n\t\tfprintf(fp,\"Block %3.3d: H: %.16llx L: %.16llx\",i,state[i].i1,state[i].i0);\n\t\tfprintf(fp,\"\\n\");\n\t}\n\tfprintf(fp,\"\\n\");\n\t\t\n#endif\n\n\t//4. Rounds: \n\tfor(unsigned l=0; l <t_cost; ++l)\n\t{\n\t\tSubGroups(state,state_size);\n#ifdef KATINT\n\tfprintf(fp,\"Round %d SubGroups:\\nBlocks:\\n\",l+1);\n\tfor(unsigned i=0; i<state_size; ++i)\n\t{\n\t\tfprintf(fp,\"Block %3.3d: H: %.16llx L: %.16llx\",i,state[i].i1,state[i].i0);\n\t\tfprintf(fp,\"\\n\");\n\t}\n\tfprintf(fp,\"\\n\");\n\t\t\n#endif\n\t\tShuffleSlices(state,state_size);\n\t\t\t#ifdef KATINT\n\tfprintf(fp,\"ShuffleSlices:\\nBlocks:\\n\");\n\tfor(unsigned i=0; i<state_size; ++i)\n\t{\n\t\tfprintf(fp,\"Block %3.3d: H: %.16llx L: %.16llx\",i,state[i].i1,state[i].i0);\n\t\tfprintf(fp,\"\\n\");\n\t}\n\tfprintf(fp,\"\\n\");\n\t\t\n#endif\n\t}\n\n\t//5.Finalization\n\tSubGroups(state,state_size);\n#ifdef KATINT\n\tfprintf(fp,\"Last round: SubGroups:\\nBlocks:\\n\");\n\tfor(unsigned i=0; i<state_size; ++i)\n\t{\n\t\tfprintf(fp,\"Block %3.3d: H: %.16llx L: %.16llx\",i,state[i].i1,state[i].i0);\n\t\tfprintf(fp,\"\\n\");\n\t}\n\tfprintf(fp,\"\\n\");\n\t\t\n#endif\n\n\n\tint128 a1(0,0);\n\tint128 a2(0,0);\n\tfor(unsigned i=0; i< state_size/2; ++i)\n\t{\n\t\ta1 ^= state[i];\n\t\ta2 ^= state[i+state_size/2];\n\t\tstate[i] = int128(0,0);\n\t\tstate[i+state_size/2] = int128(0,0);\n\t}\n\tif(outlen<=16)\n\t{\n\t\tint128 tag=a1^a2;\n\t\tAES_reduced(tag);\n\t\tAES_reduced(tag);\n\t\tAES_reduced(tag);\n\t\tAES_reduced(tag);\n\t\ttag ^= a1^a2;\n\t\tfor(unsigned i=0; i<outlen; ++i)\n\t\t\t((unsigned char*)out)[i] = tag[i];\n\t}\n\telse\n\t{\n\t\tint128 tag1=a1;\n\t\tAES_reduced(tag1);\n\t\tAES_reduced(tag1);\n\t\tAES_reduced(tag1);\n\t\tAES_reduced(tag1);\n\t\ttag1 ^= a1;\n\t\tfor(unsigned i=0; i<16; ++i)\n\t\t\t((unsigned char*)out)[i] = tag1[i];\n\t\tint128 tag2=a2;\n\t\tAES_reduced(tag2);\n\t\tAES_reduced(tag2);\n\t\tAES_reduced(tag2);\n\t\tAES_reduced(tag2);\n\t\ttag2 ^= a2;\n\t\tfor(unsigned i=16; i<outlen; ++i)\n\t\t\t((unsigned char*)out)[i] = tag2[i-16];\n\t}\n#ifdef KAT\n\tfprintf(fp,\"Tag: \");\n\tfor(unsigned i=0; i<outlen; ++i)\n\t\tfprintf(fp,\"%2.2x \",((unsigned char*)out)[i]);\n\tfprintf(fp,\"\\n\");\n\tfclose(fp);\n#endif KAT\n\t\n\n\tdelete state;\n\treturn 0;\n}\n\n\n\n\n\n\nint PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, \n\tunsigned int t_cost, unsigned int m_cost)\n//The major difference is that the slices are stored sequentially\n{\n\treturn ArgonRef(out, outlen, in, inlen, salt, saltlen, NULL, 0, t_cost, m_cost);\n}\n\n\nvoid GenKat(unsigned outlen)\n{\n\tunsigned char out[32];\n\tunsigned char zero_array[256];\n\tmemset(zero_array,0,256);\n\tunsigned t_cost = 3;\n\tunsigned m_cost = 2;\n#ifdef KAT\n\tremove(\"kat.log\");\n#endif\n\tfor(unsigned p_len=0; p_len<=256; p_len+=32)\n\t{\n\t\tfor(unsigned s_len=8; s_len<=32; s_len+=8)\n\t\t{\n#ifdef _MEASURE\n\t\t\tunsigned __int64 i1,i2,i3,d1,d2;\n\t\t\tunsigned int ui1,ui2,ui3;\n#endif\n\t\n\n\t\t\toutlen = s_len;\n#ifdef _MEASURE\n\t\t\tclock_t start = clock();\n\t\t\ti2 = __rdtscp(&ui2);\n#endif\n\t\t\t\n\t\t\tPHS(out,outlen,sbox,p_len,subkeys[5],s_len,t_cost,m_cost);\n\t\t\t\n#ifdef _MEASURE\n\t\t\ti3 = __rdtscp(&ui3);\n\t\t\tclock_t finish = clock();\n\n\t\t\td2 = (i3-i2)/(m_cost);\n\t\t\tfloat mcycles = (float)(i3-i2)/(1<<20);\n\t\t\tprintf(\"Argon Reference:  %d iterations %2.2f cpb %2.2f Mcycles\\n\", t_cost, (float)d2/1000,mcycles);\n\n\n\t\t\t\n\t\t\tfloat run_time = ((float)finish-start)/(CLOCKS_PER_SEC);\n\t\t\tprintf(\"%2.4f seconds\\n\", run_time);\n\t\t\t#endif\n\t\t}\n\t}\n}\n\nint main(int argc, char* argv[])\n{\n\tGenKat(32);\n}"
        },
        {
            "file_name": "artemia256v1_jhae_padding.cpp",
            "content": "#include \"artemia256v1_jhae.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\n// CHANGE namespace moved due to includes\nnamespace Artemia256v1_raw {\n\nunsigned char* padding_message(const unsigned char *block,\n                               int length,\n                               unsigned long long mlen,\n                               const unsigned char *nonce,\n                               const unsigned char *ad,\n                               unsigned long long adlen,\n                               int *paddedLen)\n{\n    int i;\n    int len = length * 8 + 98; //In Artemia-256, 98 bit should be append to message\n    if(len % BLOCK_BIT_SIZE != 0)\n        len += BLOCK_BIT_SIZE - (len % BLOCK_BIT_SIZE);\n\n    unsigned char* padded = (unsigned char*)calloc(len / 8, sizeof(unsigned char));\n    if(padded == 0x0){\n        *paddedLen = -1;\n        return NULL; // Could not allocate required memory\n    }\n\n    // compute length of nonce\n    int nonceLen;\n    if(nonce == NULL)\n        nonceLen = 0;\n    else {\n        nonceLen = BLOCK_BYTE_SIZE * 8;\n        for(i=BLOCK_BYTE_SIZE*8-1 ; i>=0 ; i--){\n            if((nonce[i/8] & (0x1 << (i%8))) != 0)\n                break;\n            nonceLen--;\n        }\n        if(nonceLen == 0)\n            nonceLen = 1; //  If data of nonce was zero then length of it will be one.\n    }\n    // compute length of assiciated data\n    int associatedDataLen;\n    if(ad == NULL)\n        associatedDataLen = 0;\n    else{\n        associatedDataLen = adlen * 8;\n        for(i=adlen*8-1 ; i>=0 ; i--){\n            if((ad[i/8] & (0x1 << (i%8))) != 0)\n                break;\n            associatedDataLen--;\n        }\n        if(associatedDataLen == 0)\n            associatedDataLen = 1; // If associated data was entirly zero then length will be one\n    }\n    // compute length of message\n    unsigned long long messageLen;\n    if(block == NULL)\n        messageLen = 0;\n    else\n        messageLen = mlen * 8;\n\n    // Order of filling padded message\n    static const int order[64] =\n    {\n        31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0,\n        63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32\n    };\n\n    // First: original data\n    for(i=0 ; i<length ; i++)\n        padded[order[i]] = block[length-1 - i];   // original data\n\n    // Padding 9 bit of value of the nonce length\n    padded[order[i++]] = (unsigned char)((nonceLen >> 1) & 0xFF); // most significat eight bits\n    unsigned long long temp;\n    temp = (associatedDataLen >> 1) | ((nonceLen & 0x1) << 23); // concate 9th bit of value of nonce length to the value of associated data length\n\n    // Padding 24 bit of value of length of assiciated data\n    padded[order[i++]] = (unsigned char)((temp >> 16) & 0xFF);\n    padded[order[i++]] = (unsigned char)((temp >> 8) & 0xFF);\n    padded[order[i++]] = (unsigned char)(temp & 0xFF);\n    temp = (messageLen >> 1) | ((unsigned long long)(associatedDataLen & 0x1) << 63); // concate 24th bit of the value of associated data length to the value of message length\n\n    // Padding 64 bit of value of the message length\n    padded[order[i++]] = (unsigned char)((temp >> 56) & 0xFF);\n    padded[order[i++]] = (unsigned char)((temp >> 48) & 0xFF);\n    padded[order[i++]] = (unsigned char)((temp >> 40) & 0xFF);\n    padded[order[i++]] = (unsigned char)((temp >> 32) & 0xFF);\n    padded[order[i++]] = (unsigned char)((temp >> 24) & 0xFF);\n    padded[order[i++]] = (unsigned char)((temp >> 16) & 0xFF);\n    padded[order[i++]] = (unsigned char)((temp >> 8) & 0xFF);\n    padded[order[i++]] = (unsigned char)(temp & 0xFF);\n\n    padded[order[i]] = (unsigned char)((messageLen & 0x1) << 7); // concate 64th bit of value of length of message\n    padded[order[i]] |= 0x40; // a bit '1' and a sequence of '0'\n\n    *paddedLen = len / 8;\n    return padded;\n}\n\nunsigned char* padding_associated_data(const unsigned char *adBlock,\n                                       int length,\n                                       int *paddedLen)\n{\n    int i;\n    int len = length * 8 + 1; //In the Artemia, one bit (with value '1') should be append to message\n    if(len % BLOCK_BIT_SIZE != 0)\n        len += BLOCK_BIT_SIZE - (len % BLOCK_BIT_SIZE);\n\n    unsigned char* padded = (unsigned char*)calloc(len / 8, sizeof(unsigned char));\n    if(padded == 0x0){\n        *paddedLen = -1;\n        return NULL; // Could not allocate required memory\n    }\n\n    int lack = len/8 - length;\n    for(i=0 ; i<length ; i++)\n        padded[lack + i] = adBlock[i]; // original data\n    // Padding one bit '1'\n    padded[lack - 1] = 0x80;\n\n    *paddedLen = len / 8;\n    return padded;\n}\n\nunsigned char* unpadding_message(unsigned char* message,\n                                 unsigned long long msglen,\n                                 unsigned long long* unpaddedLen)\n{\n    /*\n     * In Artemia-256, 98 bit is appended to message and a sequence of 0s is appended\n     * in orther to complete blocks. To unpad message, all zero byte in the end of message\n     * and 13 byte before zero bytes will be removed. It is because of that added 98 bits\n     * fill 13 bytes.\n     */\n    int i;\n    unsigned long extraBytesCount = 0;\n    // Check last block to count zero bytes\n    unsigned char* lastBlock = message + msglen - BLOCK_BYTE_SIZE;\n    for(i=0 ; i<BLOCK_BYTE_SIZE ; i++){\n        if(lastBlock[i] != 0)\n            break;\n        extraBytesCount++; // Count zero bytes that was padded to message\n    }\n    extraBytesCount += 13; // Count padded bytes\n    unsigned long long originLen = msglen - extraBytesCount;\n\n    unsigned char* unpaddedMessage = (unsigned char*) malloc(originLen * sizeof(unsigned char));\n    if(unpaddedMessage == NULL){\n        *unpaddedLen = -1;\n        return NULL;\n    }\n    int remain = originLen % BLOCK_BYTE_SIZE;\n    int extra = BLOCK_BYTE_SIZE - remain;\n    // Copy original data exept last block of it\n    for(i=0 ; i<originLen - remain ; i++)\n        unpaddedMessage[i] = message[i];\n    // Last block should be copied from the left side of block\n    for( ; i<originLen ; i++)\n        unpaddedMessage[i] = message[i + extra];\n\n    *unpaddedLen = originLen;\n    return unpaddedMessage;\n}\n\nunsigned long long unpadding_message_inplace(unsigned char* message,\n                                             unsigned long long msglen)\n{\n    /*\n     * In Artemia-256, 98 bit is appended to message and a sequence of 0s is appended\n     * in orther to complete blocks. To unpad message, all zero byte in the end of message\n     * and 13 byte before zero bytes will be removed. It is because of that added 98 bits\n     * fill 13 bytes.\n     */\n    int i;\n    unsigned long extraBytesCount = 0;\n    // Check last block to count zero bytes\n    unsigned char* lastBlock = message + msglen - BLOCK_BYTE_SIZE;\n    for(i=0 ; i<BLOCK_BYTE_SIZE ; i++){\n        if(lastBlock[i] != 0)\n            break;\n        extraBytesCount++; // Count zero bytes that was padded to message\n    }\n    extraBytesCount += 13; // Count padded bytes\n    unsigned long long originLen = msglen - extraBytesCount;\n\n    int remain = originLen % BLOCK_BYTE_SIZE;\n    int extra = BLOCK_BYTE_SIZE - remain;\n    // Shift original data of last block in order to remove padded data\n    for(i = originLen - remain ; i<originLen ; i++)\n        message[i] = message[i + extra];\n    // Clear other data\n    for( ; i<msglen ; i++)\n        message[i] = 0;\n\n    return originLen;\n}\n\n} // namespace Artemia256v1_raw\n"
        },
        {
            "file_name": "artemia256v1_jhae_permutation.cpp",
            "content": "#include \"artemia256v1_jhae.h\"\n#include <string.h>\n\n// CHANGE namespace moved due to includes\nnamespace Artemia256v1_raw {\n\n// AES SBOX\nconst unsigned char AES_SBOX[] = {\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n};\n\n// The constants of Artemia \u00e2\u02c6\u2019 512 in the hexadecimal\n// Nonzero bytes indeces: 0-3\nconst unsigned char C0[64] = {0x3b, 0x2d, 0x1e, 0x0f, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n// Nonzero bytes indeces: 16-19\nconst unsigned char C1[64] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x78, 0x69, 0x5a, 0x4b, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n// Nonzero bytes indeces: 32-35\nconst unsigned char C2[64] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0xb4, 0xa5, 0x96, 0x87, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n// Nonzero bytes indeces: 48-51\nconst unsigned char C3[64] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0xf0, 0xe1, 0xd2, 0xc3, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n// Nonzero bytes indeces: 4-7\nconst unsigned char C4[64] = {0x00, 0x00, 0x00, 0x00, 0x5a, 0x4b, 0x3c, 0x2d,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n// Nonzero bytes indeces: 36-40\nconst unsigned char C5[64] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x96, 0x87, 0x78, 0x69,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\nconst unsigned char *C[6] = {C0, C1, C2, C3, C4, C5};\n\nvoid transformation_D1(unsigned char *x0, unsigned char *x1, unsigned char *x2, unsigned char *x3);\nvoid transformation_D2(unsigned char *x0, unsigned char *x1, unsigned char *x2, unsigned char *x3);\nvoid transformation_D3(unsigned char *x0, unsigned char *x1, unsigned char *x2, unsigned char *x3);\n\n// Artemia-permutation-512\nvoid artemia_permutation(unsigned char *X,\n                         unsigned char *Y)\n{\n    int round, i;\n    // Copy X into Y\n    memcpy(Y, X, 2 * BLOCK_BYTE_SIZE * sizeof(unsigned char));\n\n    for(round = 0 ; round < 6 ; round++){\n        // XOR(X,C)\n        for(i=0 ; i < 2*BLOCK_BYTE_SIZE ; i++)\n            Y[i] ^= C[round][i];\n\n        // D1\n        transformation_D1(Y, Y+16, Y+32, Y+48);\n\n        // S1\n        for(i=0 ; i < 2*BLOCK_BYTE_SIZE ; i++)\n            Y[i] = AES_SBOX[Y[i]];\n\n        // D2\n        transformation_D2(Y, Y+4, Y+8, Y+12);\n        transformation_D2(Y+16, Y+20, Y+24, Y+28);\n        transformation_D2(Y+32, Y+36, Y+40, Y+44);\n        transformation_D2(Y+48, Y+52, Y+56, Y+60);\n\n        // S2\n        for(i=0 ; i < 2*BLOCK_BYTE_SIZE ; i++)\n            Y[i] = AES_SBOX[Y[i]];\n\n        // D3\n        for(i=0 ; i<2*BLOCK_BYTE_SIZE ; i+=4)\n            transformation_D3(Y+i, Y+i+1, Y+i+2, Y+i+3);\n\n        // S3\n        for(i=0 ; i < 2*BLOCK_BYTE_SIZE ; i++)\n            Y[i] = AES_SBOX[Y[i]];\n    }\n}\n\nvoid transformation_D1(unsigned char *x0,\n                       unsigned char *x1,\n                       unsigned char *x2,\n                       unsigned char *x3)\n{\n    // Y0 = X0 ^ X2 ^ X3 ^ L(X1 ^ X3)\n    // Y1 = X1 ^ X3 ^ Y0 ^ L(X2 ^ Y0)\n    // Y2 = X2 ^ Y0 ^ Y1 ^ L(X3 ^ Y1)\n    // Y3 = X3 ^ Y1 ^ Y2 ^ L(Y0 ^ Y2)\n    //\n    // L(X) = (X<<1) ^ (X>>3)\n\n    const int LEN = 128;\n    unsigned char temp[LEN/8];\n    int i;\n    unsigned char extL = 0, extR = 0, L = 0;\n\n    // Compute Y0\n    for(i=0 ; i<LEN/8 ; i++)    // temp = x1 ^ x3\n        temp[i] = x1[i] ^ x3[i];\n\n    for(i=0 ; i<LEN/8 ; i++){\n        extL = i == 0 ? temp[0] << 1 : (temp[i] << 1) | (temp[i-1] >> 7);\n        extR = i == LEN/8-1 ? temp[i] >> 3 : (temp[i] >> 3) | (temp[i+1] << 5);\n        L = extL ^ extR;\n        x0[i] = x0[i] ^ x2[i] ^ x3[i] ^ L; // save resulted value of Y0 in x0\n    }\n\n    // Compute Y1\n    for(i=0 ; i<LEN/8 ; i++)    // temp = x2 ^ x0\n        temp[i] = x2[i] ^ x0[i];\n\n    for(i=0 ; i<LEN/8 ; i++){\n        extL = i == 0 ? temp[0] << 1 : (temp[i] << 1) | (temp[i-1] >> 7);\n        extR = i == LEN/8-1 ? temp[i] >> 3 : (temp[i] >> 3) | (temp[i+1] << 5);\n        L = extL ^ extR;\n        x1[i] = x1[i] ^ x3[i] ^ x0[i] ^ L; // save resulted value of Y1 in x1\n    }\n\n    // Compute Y2\n    for(i=0 ; i<LEN/8 ; i++)    // temp = x3 ^ x1\n        temp[i] = x3[i] ^ x1[i];\n\n    for(i=0 ; i<LEN/8 ; i++){\n        extL = i == 0 ? temp[0] << 1 : (temp[i] << 1) | (temp[i-1] >> 7);\n        extR = i == LEN/8-1 ? temp[i] >> 3 : (temp[i] >> 3) | (temp[i+1] << 5);\n        L = extL ^ extR;\n        x2[i] = x2[i] ^ x0[i] ^ x1[i] ^ L; // save resulted value of Y2 in x2\n    }\n\n    // Compute Y3\n    for(i=0 ; i<LEN/8 ; i++)    // temp = x2 ^ x0\n        temp[i] = x0[i] ^ x2[i];\n\n    for(i=0 ; i<LEN/8 ; i++){\n        extL = i == 0 ? temp[0] << 1 : (temp[i] << 1) | (temp[i-1] >> 7);\n        extR = i == LEN/8-1 ? temp[i] >> 3 : (temp[i] >> 3) | (temp[i+1] << 5);\n        L = extL ^ extR;\n        x3[i] = x3[i] ^ x1[i] ^ x2[i] ^ L; // save resulted value of Y3 in x3\n    }\n\n}\n\nvoid transformation_D2(unsigned char *x0,\n                       unsigned char *x1,\n                       unsigned char *x2,\n                       unsigned char *x3)\n{\n    // Y0 = X0 ^ X2 ^ X3 ^ L(X1 ^ X3)\n    // Y1 = X1 ^ X3 ^ Y0 ^ L(X2 ^ Y0)\n    // Y2 = X2 ^ Y0 ^ Y1 ^ L(X3 ^ Y1)\n    // Y3 = X3 ^ Y1 ^ Y2 ^ L(Y0 ^ Y2)\n    //\n    // L(X) = (X<<1) ^ (X>>3)\n\n    const int LEN = 32;\n    unsigned char temp[LEN/8];\n    int i;\n    unsigned char extL = 0, extR = 0, L = 0;\n\n    // Compute Y0\n    for(i=0 ; i<LEN/8 ; i++)    // temp = x1 ^ x3\n        temp[i] = x1[i] ^ x3[i];\n\n    for(i=0 ; i<LEN/8 ; i++){\n        extL = i == 0 ? temp[0] << 1 : (temp[i] << 1) | (temp[i-1] >> 7);\n        extR = i == LEN/8-1 ? temp[i] >> 3 : (temp[i] >> 3) | (temp[i+1] << 5);\n        L = extL ^ extR;\n        x0[i] = x0[i] ^ x2[i] ^ x3[i] ^ L; // save resulted value of Y0 in x0\n    }\n\n    // Compute Y1\n    for(i=0 ; i<LEN/8 ; i++)    // temp = x2 ^ x0\n        temp[i] = x2[i] ^ x0[i];\n\n    for(i=0 ; i<LEN/8 ; i++){\n        extL = i == 0 ? temp[0] << 1 : (temp[i] << 1) | (temp[i-1] >> 7);\n        extR = i == LEN/8-1 ? temp[i] >> 3 : (temp[i] >> 3) | (temp[i+1] << 5);\n        L = extL ^ extR;\n        x1[i] = x1[i] ^ x3[i] ^ x0[i] ^ L; // save resulted value of Y1 in x1\n    }\n\n    // Compute Y2\n    for(i=0 ; i<LEN/8 ; i++)    // temp = x3 ^ x1\n        temp[i] = x3[i] ^ x1[i];\n\n    for(i=0 ; i<LEN/8 ; i++){\n        extL = i == 0 ? temp[0] << 1 : (temp[i] << 1) | (temp[i-1] >> 7);\n        extR = i == LEN/8-1 ? temp[i] >> 3 : (temp[i] >> 3) | (temp[i+1] << 5);\n        L = extL ^ extR;\n        x2[i] = x2[i] ^ x0[i] ^ x1[i] ^ L; // save resulted value of Y2 in x2\n    }\n\n    // Compute Y3\n    for(i=0 ; i<LEN/8 ; i++)    // temp = x2 ^ x0\n        temp[i] = x0[i] ^ x2[i];\n\n    for(i=0 ; i<LEN/8 ; i++){\n        extL = i == 0 ? temp[0] << 1 : (temp[i] << 1) | (temp[i-1] >> 7);\n        extR = i == LEN/8-1 ? temp[i] >> 3 : (temp[i] >> 3) | (temp[i+1] << 5);\n        L = extL ^ extR;\n        x3[i] = x3[i] ^ x1[i] ^ x2[i] ^ L; // save resulted value of Y3 in x3\n    }\n\n}\n\nvoid transformation_D3(unsigned char *x0,\n                       unsigned char *x1,\n                       unsigned char *x2,\n                       unsigned char *x3)\n{\n    // Y0 = X0 ^ X2 ^ X3 ^ L(X1 ^ X3)\n    // Y1 = X1 ^ X3 ^ Y0 ^ L(X2 ^ Y0)\n    // Y2 = X2 ^ Y0 ^ Y1 ^ L(X3 ^ Y1)\n    // Y3 = X3 ^ Y1 ^ Y2 ^ L(Y0 ^ Y2)\n    //\n    // L(X) = (X^(X<<1)) <<< 1\n\n    unsigned char temp, L = 0;\n\n    // Compute Y0\n    temp = (*x1) ^ (*x3);\n    L = temp ^ (temp << 1);\n    L = (L << 1) | (L >> 7); // Left-Rotate L\n    x0[0] = x0[0] ^ x2[0] ^ x3[0] ^ L; // save resulted value of Y0 in x0\n\n    // Compute Y1\n    temp = (*x2) ^ (*x0);\n    L = temp ^ (temp << 1);\n    L = (L << 1) | (L >> 7); // Left-Rotate L\n    x1[0] = x1[0] ^ x3[0] ^ x0[0] ^ L; // save resulted value of Y1 in x1\n\n    // Compute Y2\n    temp = (*x3) ^ (*x1);\n    L = temp ^ (temp << 1);\n    L = (L << 1) | (L >> 7); // Left-Rotate L\n    x2[0] = x2[0] ^ x0[0] ^ x1[0] ^ L; // save resulted value of Y2 in x2\n\n    // Compute Y3\n    temp = (*x0) ^ (*x2);\n    L = temp ^ (temp << 1);\n    L = (L << 1) | (L >> 7); // Left-Rotate L\n    x3[0] = x3[0] ^ x1[0] ^ x2[0] ^ L; // save resulted value of Y3 in x3\n\n}\n\n} // namespace Artemia256v1_raw\n"
        },
        {
            "file_name": "battcrypt.cpp",
            "content": "// Copyright (c) 2014 Steve Thomas <steve AT tobtu DOT com>\n\n#include <assert.h>\n#include <string.h>\n#include \"battcrypt.h\"\n#include \"sha512.h\"\n#include \"blowfish.h\"\n\n#define DATA_SIZE      512   // 2 KiB\n#define DATA_BF_BLOCKS (DATA_SIZE / 2)\n#define HASH_LENGTH    Sha512::HASH_LENGTH\n\n// My assumptions for this code:\n// HASH_LENGTH % sizeof(uint64_t)               == 0\n// (sizeof(uint32_t) * DATA_SIZE) % HASH_LENGTH == 0\n// DATA_SIZE % 2                                == 0\n//  defined(ARC_32) && sizeof(size_t) == sizeof(uint32_t)\n// !defined(ARC_32) && sizeof(size_t) == sizeof(uint64_t)\n\nint PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost)\n{\n\tSha512    sha512;\n\tuint32_t  data[DATA_SIZE];\n\tBlowfish  blowfish;\n\tuint64_t  key[HASH_LENGTH / sizeof(uint64_t)];\n\tuint64_t  upgradeLoops = 1;\n\tuint64_t  loops;\n\tsize_t    memSize      = ((size_t) 4) <<  m_cost;\n\tsize_t    memMask      = memSize - 1;\n\tuint32_t *mem;\n\tuint32_t *p;\n\tuint32_t *q;\n\n\tassert(HASH_LENGTH % sizeof(uint64_t) == 0);\n\tassert((sizeof(uint32_t) * DATA_SIZE) % HASH_LENGTH == 0);\n\tassert(DATA_SIZE % 2 == 0);\n#ifdef ARC_32\n\tassert(sizeof(memSize) >= sizeof(uint32_t));\n\tif (m_cost > 18 || (t_cost & 0xffff) > 62 || (t_cost >> 16) > 63 || outlen > HASH_LENGTH)\n\t{\n\t\treturn 1;\n\t}\n#else\n\tassert(sizeof(memSize) >= sizeof(uint64_t));\n\tif (m_cost > 50 || (t_cost & 0xffff) > 62 || (t_cost >> 16) > 63 || outlen > HASH_LENGTH)\n\t{\n\t\treturn 1;\n\t}\n#endif\n\n\t// upgradeLoops = 1, 2, 3, 4, 6, 8, 12, 16, ...\n\tunsigned int tmp = t_cost >> 16;\n\tif (tmp != 0)\n\t{\n\t\tupgradeLoops = (uint64_t) (3 - (tmp & 1)) << ((tmp - 1) >> 1);\n\t}\n\t// loops = 2, 3, 4, 6, 8, 12, 16, ...\n\ttmp = t_cost & 0xffff;\n\tloops = (uint64_t) ((tmp & 1) + 2) << (tmp >> 1);\n\n\t// key = SHA512(SHA512(salt) || in)\n\tSha512::hash(salt, saltlen, key);\n\tsha512.init();\n\tsha512.update(key, HASH_LENGTH);\n\tsha512.update(in,  inlen);\n\tsha512.finish(key);\n\n\tmem = new uint32_t[DATA_SIZE * memSize];\n\tfor (uint64_t u = 0; u < upgradeLoops; u++)\n\t{\n\t\t// Init blowfish 448 bit\n\t\tblowfish.initKey448(key);\n\n\t\t// Fill data\n\t\t// data = SHA512(BIG_ENDIAN_64( 0) || key) ||\n\t\t//        SHA512(BIG_ENDIAN_64( 1) || key) ||\n\t\t//        ...\n\t\t//        SHA512(BIG_ENDIAN_64(31) || key)\n\t\tfor (size_t i = 0; i < sizeof(data) / HASH_LENGTH; i++)\n\t\t{\n\t\t\tuint64_t tmp64 = WRITE_BIG_ENDIAN_64(i);\n\t\t\tsha512.init();\n\t\t\tsha512.update(&tmp64, sizeof(uint64_t));\n\t\t\tsha512.update(key,    HASH_LENGTH);\n\t\t\tsha512.finish(data + HASH_LENGTH / sizeof(uint32_t) * i);\n\t\t}\n\n\t\t// Init memory\n\t\tfor (size_t i = 0; i < memSize; i++)\n\t\t{\n\t\t\t// data = blowfish_encrypt_cbc(data)\n\t\t\t// mem = mem || data\n\t\t\tblowfish.cbcEncrypt(data, data, DATA_BF_BLOCKS);\n\t\t\tmemcpy(mem + DATA_SIZE * i, data, sizeof(data));\n\t\t}\n\t\t// data = blowfish_encrypt_cbc(data)\n\t\tblowfish.cbcEncrypt(data, data, DATA_BF_BLOCKS);\n\n\t\t// Work\n\t\tfor (uint64_t i = 0; i < loops; i++)\n\t\t{\n\t\t\tfor (size_t j = 0; j < memSize; j++)\n\t\t\t{\n\t\t\t\t// mem[j] = blowfish_encrypt_cbc(data ^ mem[j] ^ mem[last64Bits(data) & memMask])\n\t\t\t\tp = mem + DATA_SIZE * j;\n\t\t\t\tq = mem + DATA_SIZE * (READ_BIG_ENDIAN_64(((uint64_t*) data)[DATA_SIZE / 2 - 1]) & memMask);\n\t\t\t\tfor (int k = 0; k < DATA_SIZE; k++)\n\t\t\t\t{\n\t\t\t\t\tp[k] ^= data[k] ^ q[k];\n\t\t\t\t}\n\t\t\t\tp = mem + DATA_SIZE * j;\n\t\t\t\tblowfish.cbcEncrypt(p, p, DATA_BF_BLOCKS);\n\t\t\t\t// data ^= mem[j]\n\t\t\t\tfor (int k = 0; k < DATA_SIZE; k++)\n\t\t\t\t{\n\t\t\t\t\tdata[k] ^= p[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Finish\n\t\t// key = truncate(SHA512(SHA512(data || key)), outlen) || zeros(HASH_LENGTH - outlen)\n\t\tsha512.init();\n\t\tsha512.update(data, sizeof(data));\n\t\tsha512.update(key,  HASH_LENGTH);\n\t\tsha512.finish(key);\n\t\tSha512::hash(key, HASH_LENGTH, key, outlen);\n\t\tmemset(((uint8_t*) key) + outlen, 0, HASH_LENGTH - outlen);\n\t}\n\n\t// Finish\n\t// out = key\n\tmemcpy(out, key, outlen);\n\n\t// Clean up\n\t// TODO: find a secure wipe function\n\tmemset(data, 0, sizeof(data));\n\tmemset(key,  0, sizeof(key));\n\tmemset(mem,  0, sizeof(uint32_t) * DATA_SIZE * memSize);\n\tdelete [] mem;\n\tp = NULL;\n\tq = NULL;\n\treturn 0;\n}\n\nint battcryptKdf(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost)\n{\n\tSha512    sha512;\n\tuint32_t  data[DATA_SIZE];\n\tBlowfish  blowfish;\n\tuint64_t  key[HASH_LENGTH / sizeof(uint64_t)];\n\t// loops = 2, 3, 4, 6, 8, 12, 16, ...\n\tuint64_t  loops   = (uint64_t) ((t_cost & 1) + 2) << (t_cost >> 1);\n\tsize_t    memSize = ((size_t) 4) << m_cost;\n\tsize_t    memMask = memSize - 1;\n\tuint32_t *mem;\n\tuint32_t *p;\n\tuint32_t *q;\n\n\tassert(HASH_LENGTH % sizeof(uint64_t) == 0);\n\tassert((sizeof(uint32_t) * DATA_SIZE) % HASH_LENGTH == 0);\n\tassert(DATA_SIZE % 2 == 0);\n#ifdef ARC_32\n\tassert(sizeof(memSize) >= sizeof(uint32_t));\n\tif (m_cost > 18 || (t_cost & 0xffff) > 62 || (t_cost >> 16) > 63 || outlen > HASH_LENGTH)\n\t{\n\t\treturn 1;\n\t}\n#else\n\tassert(sizeof(memSize) >= sizeof(uint64_t));\n\tif (m_cost > 50 || (t_cost & 0xffff) > 62 || (t_cost >> 16) > 63 || outlen > HASH_LENGTH)\n\t{\n\t\treturn 1;\n\t}\n#endif\n\n\t// key = SHA512(SHA512(salt) || in)\n\tSha512::hash(salt, saltlen, key);\n\tsha512.init();\n\tsha512.update(key, HASH_LENGTH);\n\tsha512.update(in,  inlen);\n\tsha512.finish(key);\n\n\tmem = new uint32_t[DATA_SIZE * memSize];\n\n\t// Init blowfish 448 bit\n\tblowfish.initKey448(key);\n\n\t// Fill data\n\t// data = SHA512(BIG_ENDIAN_64( 0) || key) ||\n\t//        SHA512(BIG_ENDIAN_64( 1) || key) ||\n\t//        ...\n\t//        SHA512(BIG_ENDIAN_64(31) || key)\n\tfor (size_t i = 0; i < sizeof(data) / HASH_LENGTH; i++)\n\t{\n\t\tuint64_t tmp = WRITE_BIG_ENDIAN_64(i);\n\t\tsha512.init();\n\t\tsha512.update(&tmp, sizeof(uint64_t));\n\t\tsha512.update(key,  HASH_LENGTH);\n\t\tsha512.finish(data + HASH_LENGTH / sizeof(uint32_t) * i);\n\t}\n\n\t// Init memory\n\tfor (size_t i = 0; i < memSize; i++)\n\t{\n\t\t// data = blowfish_encrypt_cbc(data)\n\t\t// mem = mem || data\n\t\tblowfish.cbcEncrypt(data, data, DATA_BF_BLOCKS);\n\t\tmemcpy(mem + DATA_SIZE * i, data, sizeof(data));\n\t}\n\t// data = blowfish_encrypt_cbc(data)\n\tblowfish.cbcEncrypt(data, data, DATA_BF_BLOCKS);\n\n\t// Work\n\tfor (uint64_t i = 0; i < loops; i++)\n\t{\n\t\tfor (size_t j = 0; j < memSize; j++)\n\t\t{\n\t\t\t// mem[j] = blowfish_encrypt_cbc(data ^ mem[j] ^ mem[last64Bits(data) & memMask])\n\t\t\tp = mem + DATA_SIZE * j;\n\t\t\tq = mem + DATA_SIZE * (READ_BIG_ENDIAN_64(((uint64_t*) data)[DATA_SIZE / 2 - 1]) & memMask);\n\t\t\tfor (int k = 0; k < DATA_SIZE; k++)\n\t\t\t{\n\t\t\t\tp[k] ^= data[k] ^ q[k];\n\t\t\t}\n\t\t\tp = mem + DATA_SIZE * j;\n\t\t\tblowfish.cbcEncrypt(p, p, DATA_BF_BLOCKS);\n\t\t\t// data ^= mem[j]\n\t\t\tfor (int k = 0; k < DATA_SIZE; k++)\n\t\t\t{\n\t\t\t\tdata[k] ^= p[k];\n\t\t\t}\n\t\t}\n\t}\n\n\t// Finish\n\t// work = SHA512(data || key)\n\t// while length(out) < outlen\n\t//     out = out || SHA512(READ_BIG_ENDIAN_64(i) || work || in)\n\t//     i = i + 1\n\tuint64_t work[HASH_LENGTH / sizeof(uint64_t)];\n\tsha512.init();\n\tsha512.update(data, sizeof(data));\n\tsha512.update(key,  HASH_LENGTH);\n\tsha512.finish(work);\n\tfor (int i = 0, left = (int) outlen; left > 0; i++, left -= HASH_LENGTH)\n\t{\n\t\tuint64_t tmp = WRITE_BIG_ENDIAN_64(i);\n\t\tsha512.init();\n\t\tsha512.update(&tmp, sizeof(tmp));\n\t\tsha512.update(work, HASH_LENGTH);\n\t\tsha512.update(in,   inlen);\n\t\tsha512.finish(out,  left);\n\t\tout = ((uint8_t*) out) + HASH_LENGTH;\n\t}\n\n\t// Clean up\n\t// TODO: find a secure wipe function\n\tmemset(data, 0, sizeof(data));\n\tmemset(work, 0, sizeof(work));\n\tmemset(key,  0, sizeof(key));\n\tmemset(mem,  0, sizeof(uint32_t) * DATA_SIZE * memSize);\n\tdelete [] mem;\n\tp = NULL;\n\tq = NULL;\n\treturn 0;\n}\n"
        },
        {
            "file_name": "blake2b-ref.c",
            "content": "/*\n   BLAKE2 reference source code package - reference C implementations\n\n   Written in 2012 by Samuel Neves <sneves@dei.uc.pt>\n\n   To the extent possible under law, the author(s) have dedicated all copyright\n   and related and neighboring rights to this software to the public domain\n   worldwide. This software is distributed without any warranty.\n\n   You should have received a copy of the CC0 Public Domain Dedication along with\n   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n\n#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"blake2.h\"\n#include \"blake2-impl.h\"\n\nstatic const uint64_t blake2b_IV[8] =\n{\n  0x6a09e667f3bcc908ULL, 0xbb67ae8584caa73bULL,\n  0x3c6ef372fe94f82bULL, 0xa54ff53a5f1d36f1ULL,\n  0x510e527fade682d1ULL, 0x9b05688c2b3e6c1fULL,\n  0x1f83d9abfb41bd6bULL, 0x5be0cd19137e2179ULL\n};\n\nstatic const uint8_t blake2b_sigma[12][16] =\n{\n  {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,\n  { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 } ,\n  { 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 } ,\n  {  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 } ,\n  {  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 } ,\n  {  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 } ,\n  { 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 } ,\n  { 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 } ,\n  {  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 } ,\n  { 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0 } ,\n  {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,\n  { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 }\n};\n\n\nstatic inline int blake2b_set_lastnode( blake2b_state *S )\n{\n  S->f[1] = ~0ULL;\n  return 0;\n}\n\nstatic inline int blake2b_clear_lastnode( blake2b_state *S )\n{\n  S->f[1] = 0ULL;\n  return 0;\n}\n\n/* Some helper functions, not necessarily useful */\nstatic inline int blake2b_set_lastblock( blake2b_state *S )\n{\n  if( S->last_node ) blake2b_set_lastnode( S );\n\n  S->f[0] = ~0ULL;\n  return 0;\n}\n\nstatic inline int blake2b_clear_lastblock( blake2b_state *S )\n{\n  if( S->last_node ) blake2b_clear_lastnode( S );\n\n  S->f[0] = 0ULL;\n  return 0;\n}\n\nstatic inline int blake2b_increment_counter( blake2b_state *S, const uint64_t inc )\n{\n  S->t[0] += inc;\n  S->t[1] += ( S->t[0] < inc );\n  return 0;\n}\n\n\n\n// Parameter-related functions\nstatic inline int blake2b_param_set_digest_length( blake2b_param *P, const uint8_t digest_length )\n{\n  P->digest_length = digest_length;\n  return 0;\n}\n\nstatic inline int blake2b_param_set_fanout( blake2b_param *P, const uint8_t fanout )\n{\n  P->fanout = fanout;\n  return 0;\n}\n\nstatic inline int blake2b_param_set_max_depth( blake2b_param *P, const uint8_t depth )\n{\n  P->depth = depth;\n  return 0;\n}\n\nstatic inline int blake2b_param_set_leaf_length( blake2b_param *P, const uint32_t leaf_length )\n{\n  store32( &P->leaf_length, leaf_length );\n  return 0;\n}\n\nstatic inline int blake2b_param_set_node_offset( blake2b_param *P, const uint64_t node_offset )\n{\n  store64( &P->node_offset, node_offset );\n  return 0;\n}\n\nstatic inline int blake2b_param_set_node_depth( blake2b_param *P, const uint8_t node_depth )\n{\n  P->node_depth = node_depth;\n  return 0;\n}\n\nstatic inline int blake2b_param_set_inner_length( blake2b_param *P, const uint8_t inner_length )\n{\n  P->inner_length = inner_length;\n  return 0;\n}\n\nstatic inline int blake2b_param_set_salt( blake2b_param *P, const uint8_t salt[BLAKE2B_SALTBYTES] )\n{\n  memcpy( P->salt, salt, BLAKE2B_SALTBYTES );\n  return 0;\n}\n\nstatic inline int blake2b_param_set_personal( blake2b_param *P, const uint8_t personal[BLAKE2B_PERSONALBYTES] )\n{\n  memcpy( P->personal, personal, BLAKE2B_PERSONALBYTES );\n  return 0;\n}\n\nstatic inline int blake2b_init0( blake2b_state *S )\n{\n  memset( S, 0, sizeof( blake2b_state ) );\n\n  for( int i = 0; i < 8; ++i ) S->h[i] = blake2b_IV[i];\n\n  return 0;\n}\n\n/* init xors IV with input parameter block */\nint blake2b_init_param( blake2b_state *S, const blake2b_param *P )\n{\n  blake2b_init0( S );\n  uint8_t *p = ( uint8_t * )( P );\n\n  /* IV XOR ParamBlock */\n  for( size_t i = 0; i < 8; ++i )\n    S->h[i] ^= load64( p + sizeof( S->h[i] ) * i );\n\n  return 0;\n}\n\n\n\nint blake2b_init( blake2b_state *S, const uint8_t outlen )\n{\n  blake2b_param P[1];\n\n  if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;\n\n  P->digest_length = outlen;\n  P->key_length    = 0;\n  P->fanout        = 1;\n  P->depth         = 1;\n  store32( &P->leaf_length, 0 );\n  store64( &P->node_offset, 0 );\n  P->node_depth    = 0;\n  P->inner_length  = 0;\n  memset( P->reserved, 0, sizeof( P->reserved ) );\n  memset( P->salt,     0, sizeof( P->salt ) );\n  memset( P->personal, 0, sizeof( P->personal ) );\n  return blake2b_init_param( S, P );\n}\n\n\nint blake2b_init_key( blake2b_state *S, const uint8_t outlen, const void *key, const uint8_t keylen )\n{\n  blake2b_param P[1];\n\n  if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;\n\n  if ( !key || !keylen || keylen > BLAKE2B_KEYBYTES ) return -1;\n\n  P->digest_length = outlen;\n  P->key_length    = keylen;\n  P->fanout        = 1;\n  P->depth         = 1;\n  store32( &P->leaf_length, 0 );\n  store64( &P->node_offset, 0 );\n  P->node_depth    = 0;\n  P->inner_length  = 0;\n  memset( P->reserved, 0, sizeof( P->reserved ) );\n  memset( P->salt,     0, sizeof( P->salt ) );\n  memset( P->personal, 0, sizeof( P->personal ) );\n\n  if( blake2b_init_param( S, P ) < 0 ) return -1;\n\n  {\n    uint8_t block[BLAKE2B_BLOCKBYTES];\n    memset( block, 0, BLAKE2B_BLOCKBYTES );\n    memcpy( block, key, keylen );\n    blake2b_update( S, block, BLAKE2B_BLOCKBYTES );\n    secure_zero_memory( block, BLAKE2B_BLOCKBYTES ); /* Burn the key from stack */\n  }\n  return 0;\n}\n\nstatic int blake2b_compress( blake2b_state *S, const uint8_t block[BLAKE2B_BLOCKBYTES] )\n{\n  uint64_t m[16];\n  uint64_t v[16];\n  int i;\n\n  for( i = 0; i < 16; ++i )\n    m[i] = load64( block + i * sizeof( m[i] ) );\n\n  for( i = 0; i < 8; ++i )\n    v[i] = S->h[i];\n\n  v[ 8] = blake2b_IV[0];\n  v[ 9] = blake2b_IV[1];\n  v[10] = blake2b_IV[2];\n  v[11] = blake2b_IV[3];\n  v[12] = S->t[0] ^ blake2b_IV[4];\n  v[13] = S->t[1] ^ blake2b_IV[5];\n  v[14] = S->f[0] ^ blake2b_IV[6];\n  v[15] = S->f[1] ^ blake2b_IV[7];\n#define G(r,i,a,b,c,d) \\\n  do { \\\n    a = a + b + m[blake2b_sigma[r][2*i+0]]; \\\n    d = rotr64(d ^ a, 32); \\\n    c = c + d; \\\n    b = rotr64(b ^ c, 24); \\\n    a = a + b + m[blake2b_sigma[r][2*i+1]]; \\\n    d = rotr64(d ^ a, 16); \\\n    c = c + d; \\\n    b = rotr64(b ^ c, 63); \\\n  } while(0)\n#define ROUND(r)  \\\n  do { \\\n    G(r,0,v[ 0],v[ 4],v[ 8],v[12]); \\\n    G(r,1,v[ 1],v[ 5],v[ 9],v[13]); \\\n    G(r,2,v[ 2],v[ 6],v[10],v[14]); \\\n    G(r,3,v[ 3],v[ 7],v[11],v[15]); \\\n    G(r,4,v[ 0],v[ 5],v[10],v[15]); \\\n    G(r,5,v[ 1],v[ 6],v[11],v[12]); \\\n    G(r,6,v[ 2],v[ 7],v[ 8],v[13]); \\\n    G(r,7,v[ 3],v[ 4],v[ 9],v[14]); \\\n  } while(0)\n  ROUND( 0 );\n  ROUND( 1 );\n  ROUND( 2 );\n  ROUND( 3 );\n  ROUND( 4 );\n  ROUND( 5 );\n  ROUND( 6 );\n  ROUND( 7 );\n  ROUND( 8 );\n  ROUND( 9 );\n  ROUND( 10 );\n  ROUND( 11 );\n\n  for( i = 0; i < 8; ++i )\n    S->h[i] = S->h[i] ^ v[i] ^ v[i + 8];\n\n#undef G\n#undef ROUND\n  return 0;\n}\n\n/* inlen now in bytes */\nint blake2b_update( blake2b_state *S, const uint8_t *in, uint64_t inlen )\n{\n  while( inlen > 0 )\n  {\n    size_t left = S->buflen;\n    size_t fill = 2 * BLAKE2B_BLOCKBYTES - left;\n\n    if( inlen > fill )\n    {\n      memcpy( S->buf + left, in, fill ); // Fill buffer\n      S->buflen += fill;\n      blake2b_increment_counter( S, BLAKE2B_BLOCKBYTES );\n      blake2b_compress( S, S->buf ); // Compress\n      memcpy( S->buf, S->buf + BLAKE2B_BLOCKBYTES, BLAKE2B_BLOCKBYTES ); // Shift buffer left\n      S->buflen -= BLAKE2B_BLOCKBYTES;\n      in += fill;\n      inlen -= fill;\n    }\n    else // inlen <= fill\n    {\n      memcpy( S->buf + left, in, inlen );\n      S->buflen += inlen; // Be lazy, do not compress\n      in += inlen;\n      inlen -= inlen;\n    }\n  }\n\n  return 0;\n}\n\n/* Is this correct? */\nint blake2b_final( blake2b_state *S, uint8_t *out, uint8_t outlen )\n{\n  uint8_t buffer[BLAKE2B_OUTBYTES];\n\n  if( S->buflen > BLAKE2B_BLOCKBYTES )\n  {\n    blake2b_increment_counter( S, BLAKE2B_BLOCKBYTES );\n    blake2b_compress( S, S->buf );\n    S->buflen -= BLAKE2B_BLOCKBYTES;\n    memcpy( S->buf, S->buf + BLAKE2B_BLOCKBYTES, S->buflen );\n  }\n\n  blake2b_increment_counter( S, S->buflen );\n  blake2b_set_lastblock( S );\n  memset( S->buf + S->buflen, 0, 2 * BLAKE2B_BLOCKBYTES - S->buflen ); /* Padding */\n  blake2b_compress( S, S->buf );\n\n  for( int i = 0; i < 8; ++i ) /* Output full hash to temp buffer */\n    store64( buffer + sizeof( S->h[i] ) * i, S->h[i] );\n\n  memcpy( out, buffer, outlen );\n  return 0;\n}\n\n/* inlen, at least, should be uint64_t. Others can be size_t. */\nint blake2b( uint8_t *out, const void *in, const void *key, const uint8_t outlen, const uint64_t inlen, uint8_t keylen )\n{\n  blake2b_state S[1];\n\n  /* Verify parameters */\n  if ( NULL == in ) return -1;\n\n  if ( NULL == out ) return -1;\n\n  if( NULL == key ) keylen = 0;\n\n  if( keylen > 0 )\n  {\n    if( blake2b_init_key( S, outlen, key, keylen ) < 0 ) return -1;\n  }\n  else\n  {\n    if( blake2b_init( S, outlen ) < 0 ) return -1;\n  }\n\n  blake2b_update( S, ( uint8_t * )in, inlen );\n  blake2b_final( S, out, outlen );\n  return 0;\n}\n\n#if defined(BLAKE2B_SELFTEST)\n#include <string.h>\n#include \"blake2-kat.h\"\nint main( int argc, char **argv )\n{\n  uint8_t key[BLAKE2B_KEYBYTES];\n  uint8_t buf[KAT_LENGTH];\n\n  for( size_t i = 0; i < BLAKE2B_KEYBYTES; ++i )\n    key[i] = ( uint8_t )i;\n\n  for( size_t i = 0; i < KAT_LENGTH; ++i )\n    buf[i] = ( uint8_t )i;\n\n  for( size_t i = 0; i < KAT_LENGTH; ++i )\n  {\n    uint8_t hash[BLAKE2B_OUTBYTES];\n    blake2b( hash, buf, key, BLAKE2B_OUTBYTES, i, BLAKE2B_KEYBYTES );\n\n    if( 0 != memcmp( hash, blake2b_keyed_kat[i], BLAKE2B_OUTBYTES ) )\n    {\n      puts( \"error\" );\n      return -1;\n    }\n  }\n\n  puts( \"ok\" );\n  return 0;\n}\n#endif\n\n"
        },
        {
            "file_name": "blake2b.c",
            "content": "/*\n   BLAKE2 reference source code package - optimized C implementations\n\n   Written in 2012 by Samuel Neves <sneves@dei.uc.pt>\n\n   To the extent possible under law, the author(s) have dedicated all copyright\n   and related and neighboring rights to this software to the public domain\n   worldwide. This software is distributed without any warranty.\n\n   You should have received a copy of the CC0 Public Domain Dedication along with\n   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n\n#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"blake2.h\"\n#include \"blake2-impl.h\"\n\n#include \"blake2-config.h\"\n\n\n#include <emmintrin.h>\n#if defined(HAVE_SSSE3)\n#include <tmmintrin.h>\n#endif\n#if defined(HAVE_SSE41)\n#include <smmintrin.h>\n#endif\n#if defined(HAVE_AVX)\n#include <immintrin.h>\n#endif\n#if defined(HAVE_XOP)\n#include <x86intrin.h>\n#endif\n\n#include \"blake2b-round.h\"\n\nALIGN( 64 ) static const uint64_t blake2b_IV[8] =\n{\n  0x6a09e667f3bcc908ULL, 0xbb67ae8584caa73bULL,\n  0x3c6ef372fe94f82bULL, 0xa54ff53a5f1d36f1ULL,\n  0x510e527fade682d1ULL, 0x9b05688c2b3e6c1fULL,\n  0x1f83d9abfb41bd6bULL, 0x5be0cd19137e2179ULL\n};\n\nstatic const uint8_t blake2b_sigma[12][16] =\n{\n  {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,\n  { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 } ,\n  { 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 } ,\n  {  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 } ,\n  {  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 } ,\n  {  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 } ,\n  { 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 } ,\n  { 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 } ,\n  {  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 } ,\n  { 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0 } ,\n  {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,\n  { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 }\n};\n\n\n/* Some helper functions, not necessarily useful */\nstatic inline int blake2b_set_lastnode( blake2b_state *S )\n{\n  S->f[1] = ~0ULL;\n  return 0;\n}\n\nstatic inline int blake2b_clear_lastnode( blake2b_state *S )\n{\n  S->f[1] = 0ULL;\n  return 0;\n}\n\nstatic inline int blake2b_set_lastblock( blake2b_state *S )\n{\n  if( S->last_node ) blake2b_set_lastnode( S );\n\n  S->f[0] = ~0ULL;\n  return 0;\n}\n\nstatic inline int blake2b_clear_lastblock( blake2b_state *S )\n{\n  if( S->last_node ) blake2b_clear_lastnode( S );\n\n  S->f[0] = 0ULL;\n  return 0;\n}\n\n\nstatic inline int blake2b_increment_counter( blake2b_state *S, const uint64_t inc )\n{\n#if __x86_64__\n  // ADD/ADC chain\n  __uint128_t t = ( ( __uint128_t )S->t[1] << 64 ) | S->t[0];\n  t += inc;\n  S->t[0] = ( uint64_t )( t >>  0 );\n  S->t[1] = ( uint64_t )( t >> 64 );\n#else\n  S->t[0] += inc;\n  S->t[1] += ( S->t[0] < inc );\n#endif\n  return 0;\n}\n\n\n// Parameter-related functions\nstatic inline int blake2b_param_set_digest_length( blake2b_param *P, const uint8_t digest_length )\n{\n  P->digest_length = digest_length;\n  return 0;\n}\n\nstatic inline int blake2b_param_set_fanout( blake2b_param *P, const uint8_t fanout )\n{\n  P->fanout = fanout;\n  return 0;\n}\n\nstatic inline int blake2b_param_set_max_depth( blake2b_param *P, const uint8_t depth )\n{\n  P->depth = depth;\n  return 0;\n}\n\nstatic inline int blake2b_param_set_leaf_length( blake2b_param *P, const uint32_t leaf_length )\n{\n  P->leaf_length = leaf_length;\n  return 0;\n}\n\nstatic inline int blake2b_param_set_node_offset( blake2b_param *P, const uint64_t node_offset )\n{\n  P->node_offset = node_offset;\n  return 0;\n}\n\nstatic inline int blake2b_param_set_node_depth( blake2b_param *P, const uint8_t node_depth )\n{\n  P->node_depth = node_depth;\n  return 0;\n}\n\nstatic inline int blake2b_param_set_inner_length( blake2b_param *P, const uint8_t inner_length )\n{\n  P->inner_length = inner_length;\n  return 0;\n}\n\nstatic inline int blake2b_param_set_salt( blake2b_param *P, const uint8_t salt[BLAKE2B_SALTBYTES] )\n{\n  memcpy( P->salt, salt, BLAKE2B_SALTBYTES );\n  return 0;\n}\n\nstatic inline int blake2b_param_set_personal( blake2b_param *P, const uint8_t personal[BLAKE2B_PERSONALBYTES] )\n{\n  memcpy( P->personal, personal, BLAKE2B_PERSONALBYTES );\n  return 0;\n}\n\nstatic inline int blake2b_init0( blake2b_state *S )\n{\n  memset( S, 0, sizeof( blake2b_state ) );\n\n  for( int i = 0; i < 8; ++i ) S->h[i] = blake2b_IV[i];\n\n  return 0;\n}\n\n/* init xors IV with input parameter block */\nint blake2b_init_param( blake2b_state *S, const blake2b_param *P )\n{\n  uint8_t *p, *h, *v;\n  //blake2b_init0( S );\n  v = ( uint8_t * )( blake2b_IV );\n  h = ( uint8_t * )( S->h );\n  p = ( uint8_t * )( P );\n  /* IV XOR ParamBlock */\n  memset( S, 0, sizeof( blake2b_state ) );\n\n  for( int i = 0; i < BLAKE2B_OUTBYTES; ++i ) h[i] = v[i] ^ p[i];\n\n  return 0;\n}\n\n\n/* Some sort of default parameter block initialization, for sequential blake2b */\nint blake2b_init( blake2b_state *S, const uint8_t outlen )\n{\n  if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;\n\n  const blake2b_param P =\n  {\n    outlen,\n    0,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    {0},\n    {0},\n    {0}\n  };\n  return blake2b_init_param( S, &P );\n}\n\nint blake2b_init_key( blake2b_state *S, const uint8_t outlen, const void *key, const uint8_t keylen )\n{\n  if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;\n\n  if ( ( !keylen ) || keylen > BLAKE2B_KEYBYTES ) return -1;\n\n  const blake2b_param P =\n  {\n    outlen,\n    keylen,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    {0},\n    {0},\n    {0}\n  };\n\n  if( blake2b_init_param( S, &P ) < 0 )\n    return 0;\n\n  {\n    uint8_t block[BLAKE2B_BLOCKBYTES];\n    memset( block, 0, BLAKE2B_BLOCKBYTES );\n    memcpy( block, key, keylen );\n    blake2b_update( S, block, BLAKE2B_BLOCKBYTES );\n    secure_zero_memory( block, BLAKE2B_BLOCKBYTES ); /* Burn the key from stack */\n  }\n  return 0;\n}\n\nstatic inline int blake2b_compress( blake2b_state *S, const uint8_t block[BLAKE2B_BLOCKBYTES] )\n{\n  __m128i row1l, row1h;\n  __m128i row2l, row2h;\n  __m128i row3l, row3h;\n  __m128i row4l, row4h;\n  __m128i b0, b1;\n  __m128i t0, t1;\n#if defined(HAVE_SSSE3) && !defined(HAVE_XOP)\n  const __m128i r16 = _mm_setr_epi8( 2, 3, 4, 5, 6, 7, 0, 1, 10, 11, 12, 13, 14, 15, 8, 9 );\n  const __m128i r24 = _mm_setr_epi8( 3, 4, 5, 6, 7, 0, 1, 2, 11, 12, 13, 14, 15, 8, 9, 10 );\n#endif\n#if defined(HAVE_SSE41)\n  const __m128i m0 = LOADU( block + 00 );\n  const __m128i m1 = LOADU( block + 16 );\n  const __m128i m2 = LOADU( block + 32 );\n  const __m128i m3 = LOADU( block + 48 );\n  const __m128i m4 = LOADU( block + 64 );\n  const __m128i m5 = LOADU( block + 80 );\n  const __m128i m6 = LOADU( block + 96 );\n  const __m128i m7 = LOADU( block + 112 );\n#else\n  const uint64_t  m0 = ( ( uint64_t * )block )[ 0];\n  const uint64_t  m1 = ( ( uint64_t * )block )[ 1];\n  const uint64_t  m2 = ( ( uint64_t * )block )[ 2];\n  const uint64_t  m3 = ( ( uint64_t * )block )[ 3];\n  const uint64_t  m4 = ( ( uint64_t * )block )[ 4];\n  const uint64_t  m5 = ( ( uint64_t * )block )[ 5];\n  const uint64_t  m6 = ( ( uint64_t * )block )[ 6];\n  const uint64_t  m7 = ( ( uint64_t * )block )[ 7];\n  const uint64_t  m8 = ( ( uint64_t * )block )[ 8];\n  const uint64_t  m9 = ( ( uint64_t * )block )[ 9];\n  const uint64_t m10 = ( ( uint64_t * )block )[10];\n  const uint64_t m11 = ( ( uint64_t * )block )[11];\n  const uint64_t m12 = ( ( uint64_t * )block )[12];\n  const uint64_t m13 = ( ( uint64_t * )block )[13];\n  const uint64_t m14 = ( ( uint64_t * )block )[14];\n  const uint64_t m15 = ( ( uint64_t * )block )[15];\n#endif\n  row1l = LOAD( &S->h[0] );\n  row1h = LOAD( &S->h[2] );\n  row2l = LOAD( &S->h[4] );\n  row2h = LOAD( &S->h[6] );\n  row3l = LOAD( &blake2b_IV[0] );\n  row3h = LOAD( &blake2b_IV[2] );\n  row4l = _mm_xor_si128( LOAD( &blake2b_IV[4] ), LOAD( &S->t[0] ) );\n  row4h = _mm_xor_si128( LOAD( &blake2b_IV[6] ), LOAD( &S->f[0] ) );\n  ROUND( 0 );\n  ROUND( 1 );\n  ROUND( 2 );\n  ROUND( 3 );\n  ROUND( 4 );\n  ROUND( 5 );\n  ROUND( 6 );\n  ROUND( 7 );\n  ROUND( 8 );\n  ROUND( 9 );\n  ROUND( 10 );\n  ROUND( 11 );\n  row1l = _mm_xor_si128( row3l, row1l );\n  row1h = _mm_xor_si128( row3h, row1h );\n  STORE( &S->h[0], _mm_xor_si128( LOAD( &S->h[0] ), row1l ) );\n  STORE( &S->h[2], _mm_xor_si128( LOAD( &S->h[2] ), row1h ) );\n  row2l = _mm_xor_si128( row4l, row2l );\n  row2h = _mm_xor_si128( row4h, row2h );\n  STORE( &S->h[4], _mm_xor_si128( LOAD( &S->h[4] ), row2l ) );\n  STORE( &S->h[6], _mm_xor_si128( LOAD( &S->h[6] ), row2h ) );\n  return 0;\n}\n\n\nint blake2b_update( blake2b_state *S, const uint8_t *in, uint64_t inlen )\n{\n  while( inlen > 0 )\n  {\n    size_t left = S->buflen;\n    size_t fill = 2 * BLAKE2B_BLOCKBYTES - left;\n\n    if( inlen > fill )\n    {\n      memcpy( S->buf + left, in, fill ); // Fill buffer\n      S->buflen += fill;\n      blake2b_increment_counter( S, BLAKE2B_BLOCKBYTES );\n      blake2b_compress( S, S->buf ); // Compress\n      memcpy( S->buf, S->buf + BLAKE2B_BLOCKBYTES, BLAKE2B_BLOCKBYTES ); // Shift buffer left\n      S->buflen -= BLAKE2B_BLOCKBYTES;\n      in += fill;\n      inlen -= fill;\n    }\n    else // inlen <= fill\n    {\n      memcpy( S->buf + left, in, inlen );\n      S->buflen += inlen; // Be lazy, do not compress\n      in += inlen;\n      inlen -= inlen;\n    }\n  }\n\n  return 0;\n}\n\n\nint blake2b_final( blake2b_state *S, uint8_t *out, uint8_t outlen )\n{\n  if( S->buflen > BLAKE2B_BLOCKBYTES )\n  {\n    blake2b_increment_counter( S, BLAKE2B_BLOCKBYTES );\n    blake2b_compress( S, S->buf );\n    S->buflen -= BLAKE2B_BLOCKBYTES;\n    memcpy( S->buf, S->buf + BLAKE2B_BLOCKBYTES, S->buflen );\n  }\n\n  blake2b_increment_counter( S, S->buflen );\n  blake2b_set_lastblock( S );\n  memset( S->buf + S->buflen, 0, 2 * BLAKE2B_BLOCKBYTES - S->buflen ); /* Padding */\n  blake2b_compress( S, S->buf );\n  memcpy( out, &S->h[0], outlen );\n  return 0;\n}\n\n\nint blake2b( uint8_t *out, const void *in, const void *key, const uint8_t outlen, const uint64_t inlen, uint8_t keylen )\n{\n  blake2b_state S[1];\n\n  /* Verify parameters */\n  if ( NULL == in ) return -1;\n\n  if ( NULL == out ) return -1;\n\n  if( NULL == key ) keylen = 0;\n\n  if( keylen )\n  {\n    if( blake2b_init_key( S, outlen, key, keylen ) < 0 ) return -1;\n  }\n  else\n  {\n    if( blake2b_init( S, outlen ) < 0 ) return -1;\n  }\n\n  blake2b_update( S, ( uint8_t * )in, inlen );\n  blake2b_final( S, out, outlen );\n  return 0;\n}\n\n#if defined(SUPERCOP)\nint crypto_hash( unsigned char *out, unsigned char *in, unsigned long long inlen )\n{\n  return blake2b( out, in, NULL, BLAKE2B_OUTBYTES, inlen, 0 );\n}\n#endif\n\n#if defined(BLAKE2B_SELFTEST)\n#include <string.h>\n#include \"blake2-kat.h\"\nint main( int argc, char **argv )\n{\n  uint8_t key[BLAKE2B_KEYBYTES];\n  uint8_t buf[KAT_LENGTH];\n\n  for( size_t i = 0; i < BLAKE2B_KEYBYTES; ++i )\n    key[i] = ( uint8_t )i;\n\n  for( size_t i = 0; i < KAT_LENGTH; ++i )\n    buf[i] = ( uint8_t )i;\n\n  for( size_t i = 0; i < KAT_LENGTH; ++i )\n  {\n    uint8_t hash[BLAKE2B_OUTBYTES];\n    blake2b( hash, buf, key, BLAKE2B_OUTBYTES, i, BLAKE2B_KEYBYTES );\n\n    if( 0 != memcmp( hash, blake2b_keyed_kat[i], BLAKE2B_OUTBYTES ) )\n    {\n      puts( \"error\" );\n      return -1;\n    }\n  }\n\n  puts( \"ok\" );\n  return 0;\n}\n#endif\n\n"
        },
        {
            "file_name": "blake2bp.c",
            "content": "/*\n   BLAKE2 reference source code package - optimized C implementations\n\n   Written in 2012 by Samuel Neves <sneves@dei.uc.pt>\n\n   To the extent possible under law, the author(s) have dedicated all copyright\n   and related and neighboring rights to this software to the public domain\n   worldwide. This software is distributed without any warranty.\n\n   You should have received a copy of the CC0 Public Domain Dedication along with\n   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n#if defined(_OPENMP)\n#include <omp.h>\n#endif\n\n#include \"blake2.h\"\n#include \"blake2-impl.h\"\n\n#define PARALLELISM_DEGREE 4\n\nstatic inline int blake2bp_init_leaf( blake2b_state *S, uint8_t outlen, uint8_t keylen, uint64_t offset )\n{\n  blake2b_param P[1];\n  P->digest_length = outlen;\n  P->key_length = keylen;\n  P->fanout = PARALLELISM_DEGREE;\n  P->depth = 2;\n  P->leaf_length = 0;\n  P->node_offset = offset;\n  P->node_depth = 0;\n  P->inner_length = outlen;\n  memset( P->reserved, 0, sizeof( P->reserved ) );\n  memset( P->salt, 0, sizeof( P->salt ) );\n  memset( P->personal, 0, sizeof( P->personal ) );\n  return blake2b_init_param( S, P );\n}\n\nstatic inline int blake2bp_init_root( blake2b_state *S, uint8_t outlen, uint8_t keylen )\n{\n  blake2b_param P[1];\n  P->digest_length = outlen;\n  P->key_length = keylen;\n  P->fanout = PARALLELISM_DEGREE;\n  P->depth = 2;\n  P->leaf_length = 0;\n  P->node_offset = 0;\n  P->node_depth = 1;\n  P->inner_length = outlen;\n  memset( P->reserved, 0, sizeof( P->reserved ) );\n  memset( P->salt, 0, sizeof( P->salt ) );\n  memset( P->personal, 0, sizeof( P->personal ) );\n  return blake2b_init_param( S, P );\n}\n\n\nint blake2bp_init( blake2bp_state *S, const uint8_t outlen )\n{\n  if( !outlen || outlen > BLAKE2B_OUTBYTES ) return -1;\n\n  memset( S->buf, 0, sizeof( S->buf ) );\n  S->buflen = 0;\n\n  if( blake2bp_init_root( S->R, outlen, 0 ) < 0 )\n    return -1;\n\n  for( size_t i = 0; i < PARALLELISM_DEGREE; ++i )\n    if( blake2bp_init_leaf( S->S[i], outlen, 0, i ) < 0 ) return -1;\n\n  S->R->last_node = 1;\n  S->S[PARALLELISM_DEGREE - 1]->last_node = 1;\n  return 0;\n}\n\nint blake2bp_init_key( blake2bp_state *S, const uint8_t outlen, const void *key, const uint8_t keylen )\n{\n  if( !outlen || outlen > BLAKE2B_OUTBYTES ) return -1;\n\n  if( !key || !keylen || keylen > BLAKE2B_KEYBYTES ) return -1;\n\n  memset( S->buf, 0, sizeof( S->buf ) );\n  S->buflen = 0;\n\n  if( blake2bp_init_root( S->R, outlen, keylen ) < 0 )\n    return -1;\n\n  for( size_t i = 0; i < PARALLELISM_DEGREE; ++i )\n    if( blake2bp_init_leaf( S->S[i], outlen, keylen, i ) < 0 ) return -1;\n\n  S->R->last_node = 1;\n  S->S[PARALLELISM_DEGREE - 1]->last_node = 1;\n  {\n    uint8_t block[BLAKE2B_BLOCKBYTES];\n    memset( block, 0, BLAKE2B_BLOCKBYTES );\n    memcpy( block, key, keylen );\n\n    for( size_t i = 0; i < PARALLELISM_DEGREE; ++i )\n      blake2b_update( S->S[i], block, BLAKE2B_BLOCKBYTES );\n\n    secure_zero_memory( block, BLAKE2B_BLOCKBYTES ); /* Burn the key from stack */\n  }\n  return 0;\n}\n\n\nint blake2bp_update( blake2bp_state *S, const uint8_t *in, uint64_t inlen )\n{\n  size_t left = S->buflen;\n  size_t fill = sizeof( S->buf ) - left;\n\n  if( left && inlen >= fill )\n  {\n    memcpy( S->buf + left, in, fill );\n\n    for( size_t i = 0; i < PARALLELISM_DEGREE; ++i )\n      blake2b_update( S->S[i], S->buf + i * BLAKE2B_BLOCKBYTES, BLAKE2B_BLOCKBYTES );\n\n    in += fill;\n    inlen -= fill;\n    left = 0;\n  }\n\n#if defined(_OPENMP)\n  #pragma omp parallel shared(S), num_threads(PARALLELISM_DEGREE)\n#else\n\n  for( size_t id__ = 0; id__ < PARALLELISM_DEGREE; ++id__ )\n#endif\n  {\n#if defined(_OPENMP)\n    size_t      id__ = omp_get_thread_num();\n#endif\n    uint64_t inlen__ = inlen;\n    const uint8_t *in__ = ( const uint8_t * )in;\n    in__ += id__ * BLAKE2B_BLOCKBYTES;\n\n    while( inlen__ >= PARALLELISM_DEGREE * BLAKE2B_BLOCKBYTES )\n    {\n      blake2b_update( S->S[id__], in__, BLAKE2B_BLOCKBYTES );\n      in__ += PARALLELISM_DEGREE * BLAKE2B_BLOCKBYTES;\n      inlen__ -= PARALLELISM_DEGREE * BLAKE2B_BLOCKBYTES;\n    }\n  }\n\n  in += inlen - inlen % ( PARALLELISM_DEGREE * BLAKE2B_BLOCKBYTES );\n  inlen %= PARALLELISM_DEGREE * BLAKE2B_BLOCKBYTES;\n\n  if( inlen > 0 )\n    memcpy( S->buf + left, in, inlen );\n\n  S->buflen = left + inlen;\n  return 0;\n}\n\n\n\nint blake2bp_final( blake2bp_state *S, uint8_t *out, const uint8_t outlen )\n{\n  uint8_t hash[PARALLELISM_DEGREE][BLAKE2B_OUTBYTES];\n\n  for( size_t i = 0; i < PARALLELISM_DEGREE; ++i )\n  {\n    if( S->buflen > i * BLAKE2B_BLOCKBYTES )\n    {\n      size_t left = S->buflen - i * BLAKE2B_BLOCKBYTES;\n\n      if( left > BLAKE2B_BLOCKBYTES ) left = BLAKE2B_BLOCKBYTES;\n\n      blake2b_update( S->S[i], S->buf + i * BLAKE2B_BLOCKBYTES, left );\n    }\n\n    blake2b_final( S->S[i], hash[i], BLAKE2B_OUTBYTES );\n  }\n\n  for( size_t i = 0; i < PARALLELISM_DEGREE; ++i )\n    blake2b_update( S->R, hash[i], BLAKE2B_OUTBYTES );\n\n  blake2b_final( S->R, out, outlen );\n  return 0;\n}\n\nint blake2bp( uint8_t *out, const void *in, const void *key, uint8_t outlen, uint64_t inlen, uint8_t keylen )\n{\n  uint8_t hash[PARALLELISM_DEGREE][BLAKE2B_OUTBYTES];\n  blake2b_state S[PARALLELISM_DEGREE][1];\n  blake2b_state FS[1];\n\n  /* Verify parameters */\n  if ( NULL == in ) return -1;\n\n  if ( NULL == out ) return -1;\n\n  if ( NULL == key ) keylen = 0;\n\n  for( size_t i = 0; i < PARALLELISM_DEGREE; ++i )\n    if( blake2bp_init_leaf( S[i], outlen, keylen, i ) < 0 ) return -1;\n\n  S[PARALLELISM_DEGREE - 1]->last_node = 1; // mark last node\n\n  if( keylen > 0 )\n  {\n    uint8_t block[BLAKE2B_BLOCKBYTES];\n    memset( block, 0, BLAKE2B_BLOCKBYTES );\n    memcpy( block, key, keylen );\n\n    for( size_t i = 0; i < PARALLELISM_DEGREE; ++i )\n      blake2b_update( S[i], block, BLAKE2B_BLOCKBYTES );\n\n    secure_zero_memory( block, BLAKE2B_BLOCKBYTES ); /* Burn the key from stack */\n  }\n\n#if defined(_OPENMP)\n  #pragma omp parallel shared(S,hash), num_threads(PARALLELISM_DEGREE)\n#else\n\n  for( size_t id__ = 0; id__ < PARALLELISM_DEGREE; ++id__ )\n#endif\n  {\n#if defined(_OPENMP)\n    size_t      id__ = omp_get_thread_num();\n#endif\n    uint64_t inlen__ = inlen;\n    const uint8_t *in__ = ( const uint8_t * )in;\n    in__ += id__ * BLAKE2B_BLOCKBYTES;\n\n    while( inlen__ >= PARALLELISM_DEGREE * BLAKE2B_BLOCKBYTES )\n    {\n      blake2b_update( S[id__], in__, BLAKE2B_BLOCKBYTES );\n      in__ += PARALLELISM_DEGREE * BLAKE2B_BLOCKBYTES;\n      inlen__ -= PARALLELISM_DEGREE * BLAKE2B_BLOCKBYTES;\n    }\n\n    if( inlen__ > id__ * BLAKE2B_BLOCKBYTES )\n    {\n      const size_t left = inlen__ - id__ * BLAKE2B_BLOCKBYTES;\n      const size_t len = left <= BLAKE2B_BLOCKBYTES ? left : BLAKE2B_BLOCKBYTES;\n      blake2b_update( S[id__], in__, len );\n    }\n\n    blake2b_final( S[id__], hash[id__], BLAKE2B_OUTBYTES );\n  }\n\n  if( blake2bp_init_root( FS, outlen, keylen ) < 0 )\n    return -1;\n\n  FS->last_node = 1; // Mark as last node\n\n  for( size_t i = 0; i < PARALLELISM_DEGREE; ++i )\n    blake2b_update( FS, hash[i], BLAKE2B_OUTBYTES );\n\n  blake2b_final( FS, out, outlen );\n  return 0;\n}\n\n\n#if defined(BLAKE2BP_SELFTEST)\n#include <string.h>\n#include \"blake2-kat.h\"\nint main( int argc, char **argv )\n{\n  uint8_t key[BLAKE2B_KEYBYTES];\n  uint8_t buf[KAT_LENGTH];\n\n  for( size_t i = 0; i < BLAKE2B_KEYBYTES; ++i )\n    key[i] = ( uint8_t )i;\n\n  for( size_t i = 0; i < KAT_LENGTH; ++i )\n    buf[i] = ( uint8_t )i;\n\n  for( size_t i = 0; i < KAT_LENGTH; ++i )\n  {\n    uint8_t hash[BLAKE2B_OUTBYTES];\n    //blake2bp( hash, buf, key, BLAKE2B_OUTBYTES, i, BLAKE2B_KEYBYTES );\n    blake2bp_state S[1];\n    blake2bp_init_key( S, BLAKE2B_OUTBYTES, key, BLAKE2B_KEYBYTES );\n    blake2bp_update( S, buf, i );\n    blake2bp_final( S, hash, BLAKE2B_OUTBYTES );\n\n    if( 0 != memcmp( hash, blake2bp_keyed_kat[i], BLAKE2B_OUTBYTES ) )\n    {\n      puts( \"error\" );\n      return -1;\n    }\n  }\n\n  puts( \"ok\" );\n  return 0;\n}\n#endif\n\n"
        },
        {
            "file_name": "blowfish.cpp",
            "content": "// Copyright (c) 2014 Steve Thomas <steve AT tobtu DOT com>\n\n#include <string.h>\n#include \"blowfish.h\"\n\nconst uint32_t BF_P[16 + 2] = {\n\t0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,\n\t0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,\n\t0x9216d5d9, 0x8979fb1b};\nconst uint32_t BF_SBOXES[4 * 256] = {\n\t0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e, 0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013, 0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,\n\t0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440, 0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a, 0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677, 0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193, 0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,\n\t0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239, 0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0, 0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98, 0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,\n\t0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d, 0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7, 0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463, 0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,\n\t0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb, 0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8, 0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82, 0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,\n\t0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b, 0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8, 0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4, 0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0, 0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,\n\t0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1, 0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9, 0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf, 0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,\n\t0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5, 0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915, 0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915, 0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a,\n\t0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266, 0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e, 0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1, 0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,\n\t0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8, 0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff, 0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd, 0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7, 0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,\n\t0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af, 0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87, 0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c, 0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,\n\t0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509, 0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a, 0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,\n\t0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28, 0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84, 0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf, 0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,\n\t0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7, 0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281, 0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696, 0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,\n\t0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0, 0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105, 0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250, 0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285, 0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,\n\t0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e, 0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc, 0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340, 0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7,\n\t0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068, 0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840, 0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504, 0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a, 0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,\n\t0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6, 0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b, 0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb, 0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,\n\t0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c, 0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc, 0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564, 0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,\n\t0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728, 0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0, 0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e, 0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d, 0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,\n\t0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb, 0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c, 0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9, 0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,\n\t0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc, 0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61, 0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9, 0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,\n\t0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633, 0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169, 0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027, 0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,\n\t0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634, 0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76, 0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc, 0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c, 0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0,\n\t0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe, 0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b, 0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4, 0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6, 0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,\n\t0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6, 0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59, 0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51, 0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,\n\t0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28, 0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd, 0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319, 0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,\n\t0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32, 0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166, 0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb, 0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,\n\t0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370, 0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048, 0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd, 0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,\n\t0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f, 0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525, 0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442, 0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,\n\t0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d, 0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299, 0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc, 0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,\n\t0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b, 0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060, 0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9, 0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f, 0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6};\n\n#define F(sboxes, x) \\\n\t(((sboxes[( x >> 24        )      ]  + \\\n\t   sboxes[((x >> 16) & 0xff) + 256]) ^ \\\n\t   sboxes[((x >>  8) & 0xff) + 512]) + \\\n\t   sboxes[( x        & 0xff) + 768])\n\n#define BF_ROUND(sboxes, p, l, r, i) \\\n\tl ^= p[i]; \\\n\tr ^= F(sboxes, l)\n\n#define BF_BLOCK(sboxes, p, l, r, tmp) \\\n\tBF_ROUND(sboxes, p, l, r,  0); \\\n\tBF_ROUND(sboxes, p, r, l,  1); \\\n\tBF_ROUND(sboxes, p, l, r,  2); \\\n\tBF_ROUND(sboxes, p, r, l,  3); \\\n\tBF_ROUND(sboxes, p, l, r,  4); \\\n\tBF_ROUND(sboxes, p, r, l,  5); \\\n\tBF_ROUND(sboxes, p, l, r,  6); \\\n\tBF_ROUND(sboxes, p, r, l,  7); \\\n\tBF_ROUND(sboxes, p, l, r,  8); \\\n\tBF_ROUND(sboxes, p, r, l,  9); \\\n\tBF_ROUND(sboxes, p, l, r, 10); \\\n\tBF_ROUND(sboxes, p, r, l, 11); \\\n\tBF_ROUND(sboxes, p, l, r, 12); \\\n\tBF_ROUND(sboxes, p, r, l, 13); \\\n\tBF_ROUND(sboxes, p, l, r, 14); \\\n\tBF_ROUND(sboxes, p, r, l, 15); \\\n\tl ^= p[16]; \\\n\tr ^= p[17]; \\\n\ttmp = l; \\\n\tl   = r; \\\n\tr   = tmp\n\nBlowfish::Blowfish()\n{\n}\n\nBlowfish::~Blowfish()\n{\n\tm_l = 0;\n\tm_r = 0;\n\tmemset(m_p,      0, sizeof(m_p));\n\tmemset(m_sboxes, 0, sizeof(m_sboxes));\n}\n\nvoid Blowfish::initKey448(const void *key448)\n{\n\tuint32_t l = 0;\n\tuint32_t r = 0;\n\tuint32_t tmp;\n\n\tm_l = 0;\n\tm_r = 0;\n\tmemcpy(m_p,      BF_P,      sizeof(m_p));\n\tmemcpy(m_sboxes, BF_SBOXES, sizeof(m_sboxes));\n\tfor (int i = 0; i < 18; i++)\n\t{\n\t\tm_p[i] ^= READ_BIG_ENDIAN_32(((uint32_t*) key448)[i % 14]);\n\t}\n\tfor (int i = 0; i < 16 + 2; i += 2) \n\t{ \n\t\tBF_BLOCK(m_sboxes, m_p, l, r, tmp);\n\t\tm_p[i    ] = l;\n\t\tm_p[i + 1] = r;\n\t}\n\tfor (int i = 0; i < 4 * 256; i += 2)\n\t{\n\t\tBF_BLOCK(m_sboxes, m_p, l, r, tmp);\n\t\tm_sboxes[i    ] = l;\n\t\tm_sboxes[i + 1] = r;\n\t}\n}\n\nvoid Blowfish::cbcEncrypt(const void *in, const void *out, uint32_t blocks)\n{\n\tuint32_t l = m_l;\n\tuint32_t r = m_r;\n\tuint32_t tmp;\n\n\tblocks *= 2;\n\tfor (uint32_t i = 0; i < blocks; i += 2)\n\t{\n\t\tl ^= READ_BIG_ENDIAN_32(((uint32_t*) in)[i    ]);\n\t\tr ^= READ_BIG_ENDIAN_32(((uint32_t*) in)[i + 1]);\n\t\tBF_BLOCK(m_sboxes, m_p, l, r, tmp);\n\t\t((uint32_t*) out)[i    ] = WRITE_BIG_ENDIAN_32(l);\n\t\t((uint32_t*) out)[i + 1] = WRITE_BIG_ENDIAN_32(r);\n\t}\n\tm_l = l;\n\tm_r = r;\n}\n"
        },
        {
            "file_name": "calicov8_calico.cpp",
            "content": "namespace Calicov8_raw {\n\n// Use Calico v8 construction.  Remove to use Calico v9 construction\n#ifndef CALICO_V9\n# define CALICO_V8\n#endif\n\n\n//// Basic types ////\n\n#if defined(_MSC_VER)\n\ntypedef unsigned __int8  u8;\ntypedef signed __int8\t s8;\ntypedef unsigned __int16 u16;\ntypedef signed __int16   s16;\ntypedef unsigned __int32 u32;\ntypedef signed __int32   s32;\ntypedef unsigned __int64 u64;\ntypedef signed __int64   s64;\n\n#else\n\n#include <stdint.h>\n\n    typedef uint8_t  u8;\n    typedef int8_t   s8;\n    typedef uint16_t u16;\n    typedef int16_t  s16;\n    typedef uint32_t u32;\n    typedef int32_t  s32;\n    typedef uint64_t u64;\n    typedef int64_t  s64;\n\n#endif\n\n\n//// Rotation ////\n\n#define CAT_ROL8(n, r)  ( (u8)((u8)(n) << (r)) | (u8)((u8)(n) >> ( 8 - (r))) ) /* only works for u8 */\n#define CAT_ROR8(n, r)  ( (u8)((u8)(n) >> (r)) | (u8)((u8)(n) << ( 8 - (r))) ) /* only works for u8 */\n#define CAT_ROL16(n, r) ( (u16)((u16)(n) << (r)) | (u16)((u16)(n) >> (16 - (r))) ) /* only works for u16 */\n#define CAT_ROR16(n, r) ( (u16)((u16)(n) >> (r)) | (u16)((u16)(n) << (16 - (r))) ) /* only works for u16 */\n#define CAT_ROL32(n, r) ( (u32)((u32)(n) << (r)) | (u32)((u32)(n) >> (32 - (r))) ) /* only works for u32 */\n#define CAT_ROR32(n, r) ( (u32)((u32)(n) >> (r)) | (u32)((u32)(n) << (32 - (r))) ) /* only works for u32 */\n#define CAT_ROL64(n, r) ( (u64)((u64)(n) << (r)) | (u64)((u64)(n) >> (64 - (r))) ) /* only works for u64 */\n#define CAT_ROR64(n, r) ( (u64)((u64)(n) >> (r)) | (u64)((u64)(n) << (64 - (r))) ) /* only works for u64 */\n\n\n//// Byte-order swapping ////\n\n#define CAT_BOSWAP16(n) CAT_ROL16(n, 8)\n#define CAT_BOSWAP32(n) ( (CAT_ROL32(n, 8) & 0x00ff00ff) | (CAT_ROL32(n, 24) & 0xff00ff00) )\n#define CAT_BOSWAP64(n) ( ((u64)CAT_BOSWAP32((u32)n) << 32) | CAT_BOSWAP32((u32)(n >> 32)) )\n\n\n//// Endian neutral ////\n\nstatic void write32(void *p, const u32 x) {\n    u8 *b = reinterpret_cast<u8 *>( p );\n\n    b[0] = (u8)x;\n    b[1] = (u8)(x >> 8);\n    b[2] = (u8)(x >> 16);\n    b[3] = (u8)(x >> 24);\n}\n\nstatic void write64(void *p, const u64 x) {\n    u8 *b = reinterpret_cast<u8 *>( p );\n\n    write32(b, (u32)x);\n    write32(b + 4, (u32)(x >> 32));\n}\n\nstatic u32 read32(const void *p) {\n    const u8 *b = reinterpret_cast<const u8 *>( p );\n\n    return (((u32)b[0] |\n            ((u32)(b[1]) <<  8) |\n            ((u32)(b[2]) << 16) |\n            ((u32)(b[3]) << 24)));\n}\n\nstatic u64 read64(const void *p) {\n    const u8 *b = reinterpret_cast<const u8 *>( p );\n\n    return ((u64)read32(b + 4) << 32) | read32(b);\n}\n\n\n//// SipHash-2-4 ////\n\n#define SIP_HALF_ROUND(a, b, c, d, s, t) \\\n    a += b; \\\n    c += d; \\\n    b = CAT_ROL64(b, s) ^ a; \\\n    d = CAT_ROL64(d, t) ^ c; \\\n    a = CAT_ROL64(a, 32);\n\n#define SIP_DOUBLE_ROUND(v0, v1, v2, v3) \\\n    SIP_HALF_ROUND(v0, v1, v2, v3, 13, 16); \\\n    SIP_HALF_ROUND(v2, v1, v0, v3, 17, 21); \\\n    SIP_HALF_ROUND(v0, v1, v2, v3, 13, 16); \\\n    SIP_HALF_ROUND(v2, v1, v0, v3, 17, 21);\n\n// SipHash finalization constants\nstatic const u64 MSG_XOR_CONST = 0xff;\n#ifdef CALICO_V8\nstatic const u64 AD_XOR_CONST = 0xff;\n#else\n// Calico v9 uses a different XOR constant for the additional data from the message\nstatic const u64 AD_XOR_CONST = 0xee;\n#endif\n\nstatic void siphash24_mix(u64 &v0, u64 &v1, u64 &v2, u64 &v3, const void *input, const u64 input_len, u64 xor_val) {\n    // Perform SIP rounds on 8 bytes of input at a time\n    const u64 *m64 = (const u64 *)input;\n    u64 words = input_len >> 3;\n    while (words > 0) {\n        u64 mi = read64(m64++);\n\n        v3 ^= mi;\n        SIP_DOUBLE_ROUND(v0, v1, v2, v3);\n        v0 ^= mi;\n\n        --words;\n    }\n\n    // Mix the last 1..7 bytes with the length\n    const u8 *m = reinterpret_cast<const u8 *>( m64 );\n    u64 last7 = input_len << 56;\n    switch (input_len & 7) {\n    case 7: last7 |= (u64)m[6] << 48;\n    case 6: last7 |= (u64)m[5] << 40;\n    case 5: last7 |= (u64)m[4] << 32;\n    case 4: last7 |= read32(m); // low -> low\n        break;\n    case 3: last7 |= (u64)m[2] << 16;\n    case 2: last7 |= (u64)m[1] << 8;\n    case 1: last7 |= (u64)m[0];\n        break;\n    };\n\n    // Final mix\n    v3 ^= last7;\n    SIP_DOUBLE_ROUND(v0, v1, v2, v3);\n    v0 ^= last7;\n\n    v2 ^= xor_val;\n    SIP_DOUBLE_ROUND(v0, v1, v2, v3);\n    SIP_DOUBLE_ROUND(v0, v1, v2, v3);\n}\n\nextern \"C\"\nvoid siphash24_mac(void *tag_p /* 8 bytes */,\n                   const unsigned char *key /* 32 bytes */,\n                   const void *public_msg_num_p /* 8 bytes */,\n                   const void *msg, const unsigned long long msg_len,\n                   const void *ad, const unsigned long long ad_len)\n{\n    const u64 public_msg_num = read64(public_msg_num_p);\n\n    // Convert key into two 64-bit integers\n#ifdef CALICO_V8\n    // Broken key mix for Calico v8\n    u64 k0 = read64(key) ^ public_msg_num;\n#else\n    u64 k0 = read64(key);\n#endif\n    u64 k1 = read64(key + 8);\n\n    // Mix the key across initial state\n    u64 v0 = k0 ^ 0x736f6d6570736575ULL;\n    u64 v1 = k1 ^ 0x646f72616e646f6dULL;\n    u64 v2 = k0 ^ 0x6c7967656e657261ULL;\n    u64 v3 = k1 ^ 0x7465646279746573ULL;\n\n#ifndef CALICO_V8\n    // New key mix for Calico v9\n    v3 ^= public_msg_num;\n    SIP_DOUBLE_ROUND(v0, v1, v2, v3);\n    v0 ^= public_msg_num;\n#endif\n\n    // Hash the message\n    siphash24_mix(v0, v1, v2, v3, msg, msg_len, MSG_XOR_CONST);\n\n    // Hash the additional data\n    siphash24_mix(v0, v1, v2, v3, ad, ad_len, AD_XOR_CONST);\n\n    const u64 tag = (v0 ^ v1) ^ (v2 ^ v3);\n\n    write64(tag_p, tag);\n}\n\n\n//// ChaCha14 ////\n\nstatic const int CHACHA_ROUNDS = 14; // Multiple of 2\n\n#define QUARTERROUND(A, B, C, D)\t\t\t\t\t\t\\\n    x[A] += x[B]; x[D] = CAT_ROL32(x[D] ^ x[A], 16);\t\\\n    x[C] += x[D]; x[B] = CAT_ROL32(x[B] ^ x[C], 12);\t\\\n    x[A] += x[B]; x[D] = CAT_ROL32(x[D] ^ x[A], 8);\t\t\\\n    x[C] += x[D]; x[B] = CAT_ROL32(x[B] ^ x[C], 7);\n\nstatic const u32 CHACHA_CONST[4] = {\n    0x61707865, 0x3320646e, 0x79622d32, 0x6b206574\n};\n\nstatic void chacha_gen(const u8 *key, const u64 block_counter, const u64 public_msg_num, u32 x[16]) {\n    x[0] = CHACHA_CONST[0];\n    x[1] = CHACHA_CONST[1];\n    x[2] = CHACHA_CONST[2];\n    x[3] = CHACHA_CONST[3];\n\n    for (int word = 0; word < 8; ++word) {\n        x[word + 4] = read32(key + (4 * word));\n    }\n\n    x[12] = (u32)block_counter;\n    x[13] = (u32)(block_counter >> 32);\n    x[14] = (u32)public_msg_num;\n    x[15] = (u32)(public_msg_num >> 32);\n\n    for (int round = CHACHA_ROUNDS; round > 0; round -= 2) {\n        QUARTERROUND(0, 4, 8,  12)\n        QUARTERROUND(1, 5, 9,  13)\n        QUARTERROUND(2, 6, 10, 14)\n        QUARTERROUND(3, 7, 11, 15)\n        QUARTERROUND(0, 5, 10, 15)\n        QUARTERROUND(1, 6, 11, 12)\n        QUARTERROUND(2, 7, 8,  13)\n        QUARTERROUND(3, 4, 9,  14)\n    }\n\n    x[0] += CHACHA_CONST[0];\n    x[1] += CHACHA_CONST[1];\n    x[2] += CHACHA_CONST[2];\n    x[3] += CHACHA_CONST[3];\n\n    for (int word = 0; word < 8; ++word) {\n        x[word + 4] += read32(key + (4 * word));\n    }\n\n    x[12] += (u32)block_counter;\n    x[13] += (u32)(block_counter >> 32);\n    x[14] += (u32)public_msg_num;\n    x[15] += (u32)(public_msg_num >> 32);\n}\n\nextern \"C\"\nvoid chacha(const unsigned char *key /* 32 bytes */,\n            const unsigned char *public_msg_num_p /* 8 bytes */,\n            const unsigned char *input,\n            unsigned long long len,\n            unsigned char *output)\n{\n    const u64 public_msg_num = read64(public_msg_num_p);\n    u64 block_counter = 0;\n    u32 keystream[16];\n\n    while (len >= 64) {\n        chacha_gen(key, block_counter, public_msg_num, keystream);\n\n        for (int word = 0; word < 16; ++word, input += 4, output += 4) {\n            write32(output, read32(input) ^ keystream[word]);\n        }\n\n        ++block_counter;\n        len -= 64;\n    }\n\n    if (len > 0) {\n        chacha_gen(key, block_counter, public_msg_num, keystream);\n\n        u64 words = len / 4;\n        for (u64 word = 0; word < words; ++word, input += 4, output += 4) {\n            write32(output, read32(input) ^ keystream[word]);\n        }\n\n        const u32 keystream_final = keystream[words];\n\n        switch (len % 4) {\n        case 3:\toutput[2] = input[2] ^ (u8)(keystream_final >> 16);\n        case 2:\toutput[1] = input[1] ^ (u8)(keystream_final >> 8);\n        case 1:\toutput[0] = input[0] ^ (u8)keystream_final;\n        }\n    }\n}\n\n} // namespace Calicov8_raw\n"
        },
        {
            "file_name": "Camellia.cpp",
            "content": "#include \"stdafx.h\"\n\nconst BYTE SIGMA[48] = {\n0xa0,0x9e,0x66,0x7f,0x3b,0xcc,0x90,0x8b,\n0xb6,0x7a,0xe8,0x58,0x4c,0xaa,0x73,0xb2,\n0xc6,0xef,0x37,0x2f,0xe9,0x4f,0x82,0xbe,\n0x54,0xff,0x53,0xa5,0xf1,0xd3,0x6f,0x1c,\n0x10,0xe5,0x27,0xfa,0xde,0x68,0x2d,0x1d,\n0xb0,0x56,0x88,0xc2,0xb3,0xe6,0xc1,0xfd};\n\nconst int KSFT1[26] = {\n0,64,0,64,15,79,15,79,30,94,45,109,45,124,60,124,77,13,\n94,30,94,30,111,47,111,47 };\nconst int KIDX1[26] = {\n0,0,4,4,0,0,4,4,4,4,0,0,4,0,4,4,0,0,0,0,4,4,0,0,4,4 };\nconst int KSFT2[34] = {\n0,64,0,64,15,79,15,79,30,94,30,94,45,109,45,109,60,124,\n60,124,60,124,77,13,77,13,94,30,94,30,111,47,111,47 };\nconst int KIDX2[34] = {\n0,0,12,12,8,8,4,4,8,8,12,12,0,0,4,4,0,0,8,8,12,12,\n0,0,4,4,8,8,4,4,0,0,12,12 };\n\nconst BYTE SBOX[256] = {\n112,130, 44,236,179, 39,192,229,228,133, 87, 53,234, 12,174, 65,\n 35,239,107,147, 69, 25,165, 33,237, 14, 79, 78, 29,101,146,189,\n134,184,175,143,124,235, 31,206, 62, 48,220, 95, 94,197, 11, 26,\n166,225, 57,202,213, 71, 93, 61,217,  1, 90,214, 81, 86,108, 77,\n139, 13,154,102,251,204,176, 45,116, 18, 43, 32,240,177,132,153,\n223, 76,203,194, 52,126,118,  5,109,183,169, 49,209, 23,  4,215,\n 20, 88, 58, 97,222, 27, 17, 28, 50, 15,156, 22, 83, 24,242, 34,\n254, 68,207,178,195,181,122,145, 36,  8,232,168, 96,252,105, 80,\n170,208,160,125,161,137, 98,151, 84, 91, 30,149,224,255,100,210,\n 16,196,  0, 72,163,247,117,219,138,  3,230,218,  9, 63,221,148,\n135, 92,131,  2,205, 74,144, 51,115,103,246,243,157,127,191,226,\n 82,155,216, 38,200, 55,198, 59,129,150,111, 75, 19,190, 99, 46,\n233,121,167,140,159,110,188,142, 41,245,249,182, 47,253,180, 89,\n120,152,  6,106,231, 70,113,186,212, 37,171, 66,136,162,141,250,\n114,  7,185, 85,248,238,172, 10, 54, 73, 42,104, 60, 56,241,164,\n 64, 40,211,123,187,201, 67,193, 21,227,173,244,119,199,128,158};\n\n#define SBOX1(n) SBOX[(n)]\n#define SBOX2(n) (BYTE)((SBOX[(n)]>>7^SBOX[(n)]<<1)&0xff)\n#define SBOX3(n) (BYTE)((SBOX[(n)]>>1^SBOX[(n)]<<7)&0xff)\n#define SBOX4(n) SBOX[((n)<<1^(n)>>7)&0xff]\n\nvoid ByteWord( const BYTE *x, DWORD *y )\n{\n\tint i;\n\tfor( i=0; i<4; i++ ){\n\t\ty[i] = ((DWORD)x[(i<<2)+0]<<24) + ((DWORD)x[(i<<2)+1]<<16)\n\t\t     + ((DWORD)x[(i<<2)+2]<<8 ) + ((DWORD)x[(i<<2)+3]<<0 );\n\t}\n}\n\nvoid WordByte( const DWORD *x, BYTE *y )\n{\n\tint i;\n\tfor( i=0; i<4; i++ ){\n\t\ty[(i<<2)+0] = (BYTE)(x[i]>>24&0xff);\n\t\ty[(i<<2)+1] = (BYTE)(x[i]>>16&0xff);\n\t\ty[(i<<2)+2] = (BYTE)(x[i]>> 8&0xff);\n\t\ty[(i<<2)+3] = (BYTE)(x[i]>> 0&0xff);\n\t}\n}\n\nvoid RotBlock( const DWORD *x, const int n, DWORD *y )\n{\n\tint r;\n\tif( r = (n & 31) ){\n\t\ty[0] = x[((n>>5)+0)&3]<<r^x[((n>>5)+1)&3]>>(32-r);\n\t\ty[1] = x[((n>>5)+1)&3]<<r^x[((n>>5)+2)&3]>>(32-r);\n\t}\n\telse{\n\t\ty[0] = x[((n>>5)+0)&3];\n\t\ty[1] = x[((n>>5)+1)&3];\n\t}\n}\n\nvoid SwapHalf( BYTE *x )\n{\n\tBYTE t;\n\tint  i;\n\tfor( i=0; i<8; i++ ){\n\t\tt = x[i];\n\t\tx[i] = x[8+i];\n\t\tx[8+i] = t;\n\t}\n}\n\nvoid XorBlock( const BYTE *x, const BYTE *y, BYTE *z )\n{\n\tint i;\n\tfor( i=0; i<16; i++ ) z[i] = x[i] ^ y[i];\n}\n\nvoid Camellia_Feistel( const BYTE *x, const BYTE *k, BYTE *y )\n{\n\tBYTE t[8];\n\n\tt[0] = SBOX1(x[0]^k[0]);\n\tt[1] = SBOX2(x[1]^k[1]);\n\tt[2] = SBOX3(x[2]^k[2]);\n\tt[3] = SBOX4(x[3]^k[3]);\n\tt[4] = SBOX2(x[4]^k[4]);\n\tt[5] = SBOX3(x[5]^k[5]);\n\tt[6] = SBOX4(x[6]^k[6]);\n\tt[7] = SBOX1(x[7]^k[7]);\n\n\ty[0] ^= t[0]^t[2]^t[3]^t[5]^t[6]^t[7];\n\ty[1] ^= t[0]^t[1]^t[3]^t[4]^t[6]^t[7];\n\ty[2] ^= t[0]^t[1]^t[2]^t[4]^t[5]^t[7];\n\ty[3] ^= t[1]^t[2]^t[3]^t[4]^t[5]^t[6];\n\ty[4] ^= t[0]^t[1]^t[5]^t[6]^t[7];\n\ty[5] ^= t[1]^t[2]^t[4]^t[6]^t[7];\n\ty[6] ^= t[2]^t[3]^t[4]^t[5]^t[7];\n\ty[7] ^= t[0]^t[3]^t[4]^t[5]^t[6];\n}\n\nvoid Camellia_FLlayer( BYTE *x, const BYTE *kl, const BYTE *kr )\n{\n\tDWORD t[4],u[4],v[4];\n\n\tByteWord( x, t );\n\tByteWord( kl, u );\n\tByteWord( kr, v );\n\n\tt[1] ^= (t[0]&u[0])<<1^(t[0]&u[0])>>31;\n\tt[0] ^= t[1]|u[1];\n\tt[2] ^= t[3]|v[1];\n\tt[3] ^= (t[2]&v[0])<<1^(t[2]&v[0])>>31;\n\n\tWordByte( t, x );\n}\n\nvoid Camellia_set_key( BYTE *e, const int n, const BYTE *k )\n{\n\tBYTE t[64];\n\tDWORD u[20];\n\tint  i;\n\n\tif( n == 128 ){\n\t\tfor( i=0 ; i<16; i++ ) t[i] = k[i];\n\t\tfor( i=16; i<32; i++ ) t[i] = 0;\n\t}\n\telse if( n == 192 ){\n\t\tfor( i=0 ; i<24; i++ ) t[i] = k[i];\n\t\tfor( i=24; i<32; i++ ) t[i] = k[i-8]^0xff;\n\t}\n\telse if( n == 256 ){\n\t\tfor( i=0 ; i<32; i++ ) t[i] = k[i];\n\t}\n\n\tXorBlock( t+0, t+16, t+32 );\n\n\tCamellia_Feistel( t+32, SIGMA+0, t+40 );\n\tCamellia_Feistel( t+40, SIGMA+8, t+32 );\n\n\tXorBlock( t+32, t+0, t+32 );\n\n\tCamellia_Feistel( t+32, SIGMA+16, t+40 );\n\tCamellia_Feistel( t+40, SIGMA+24, t+32 );\n\n\tByteWord( t+0,  u+0 );\n\tByteWord( t+32, u+4 );\n\n\tif( n == 128 ){\n\t\tfor( i=0; i<26; i+=2 ){\n\t\t\tRotBlock( u+KIDX1[i+0], KSFT1[i+0], u+16 );\n\t\t\tRotBlock( u+KIDX1[i+1], KSFT1[i+1], u+18 );\n\t\t\tWordByte( u+16, e+i*8 );\n\t\t}\n\t}\n\telse{\n\t\tXorBlock( t+32, t+16, t+48 );\n\n\t\tCamellia_Feistel( t+48, SIGMA+32, t+56 );\n\t\tCamellia_Feistel( t+56, SIGMA+40, t+48 );\n\n\t\tByteWord( t+16, u+8  );\n\t\tByteWord( t+48, u+12 );\n\n\t\tfor( i=0; i<34; i+=2 ){\n\t\t\tRotBlock( u+KIDX2[i+0], KSFT2[i+0], u+16 );\n\t\t\tRotBlock( u+KIDX2[i+1], KSFT2[i+1], u+18 );\n\t\t\tWordByte( u+16, e+(i<<3) );\n\t\t}\n\t}\n}\n\nvoid Camellia_encrypt( const BYTE *e, const int n, const BYTE *p, BYTE *c )\n{\n\tint i;\n\n\tXorBlock( p, e+0, c );\n\n\tfor( i=0; i<3; i++ ){\n\t\tCamellia_Feistel( c+0, e+16+(i<<4), c+8 );\n\t\tCamellia_Feistel( c+8, e+24+(i<<4), c+0 );\n\t}\n\n\tCamellia_FLlayer( c, e+64, e+72 );\n\n\tfor( i=0; i<3; i++ ){\n\t\tCamellia_Feistel( c+0, e+80+(i<<4), c+8 );\n\t\tCamellia_Feistel( c+8, e+88+(i<<4), c+0 );\n\t}\n\n\tCamellia_FLlayer( c, e+128, e+136 );\n\n\tfor( i=0; i<3; i++ ){\n\t\tCamellia_Feistel( c+0, e+144+(i<<4), c+8 );\n\t\tCamellia_Feistel( c+8, e+152+(i<<4), c+0 );\n\t}\n\n\tif( n == 128 ){\n\t\tSwapHalf( c );\n\t\tXorBlock( c, e+192, c );\n\t}\n\telse{\n\t\tCamellia_FLlayer( c, e+192, e+200 );\n\n\t\tfor( i=0; i<3; i++ ){\n\t\t\tCamellia_Feistel( c+0, e+208+(i<<4), c+8 );\n\t\t\tCamellia_Feistel( c+8, e+216+(i<<4), c+0 );\n\t\t}\n\n\t\tSwapHalf( c );\n\t\tXorBlock( c, e+256, c );\n\t}\n}\n\nvoid Camellia_decrypt( const BYTE *e, const int n, const BYTE *c, BYTE *p )\n{\n\tint i;\n\n\tif( n == 128 ){\n\t\tXorBlock( c, e+192, p );\n\t}\n\telse{\n\t\tXorBlock( c, e+256, p );\n\n\t\tfor( i=2; i>=0; i-- ){\n\t\t\tCamellia_Feistel( p+0, e+216+(i<<4), p+8 );\n\t\t\tCamellia_Feistel( p+8, e+208+(i<<4), p+0 );\n\t\t}\n\n\t\tCamellia_FLlayer( p, e+200, e+192 );\n\t}\n\n\tfor( i=2; i>=0; i-- ){\n\t\tCamellia_Feistel( p+0, e+152+(i<<4), p+8 );\n\t\tCamellia_Feistel( p+8, e+144+(i<<4), p+0 );\n\t}\n\n\tCamellia_FLlayer( p, e+136, e+128 );\n\n\tfor( i=2; i>=0; i-- ){\n\t\tCamellia_Feistel( p+0, e+88+(i<<4), p+8 );\n\t\tCamellia_Feistel( p+8, e+80+(i<<4), p+0 );\n\t}\n\n\tCamellia_FLlayer( p, e+72, e+64 );\n\n\tfor( i=2; i>=0; i-- ){\n\t\tCamellia_Feistel( p+0, e+24+(i<<4), p+8 );\n\t\tCamellia_Feistel( p+8, e+16+(i<<4), p+0 );\n\t}\n\n\tSwapHalf( p );\n\tXorBlock( p, e+0, p );\n}\n"
        },
        {
            "file_name": "Cast256.cpp",
            "content": "#include \"stdafx.h\"\n\n#pragma intrinsic(_lrotr,_lrotl)\n\n#define rotr(x,n) _lrotr(x,n)\n#define rotl(x,n) _lrotl(x,n)\n\n#define bswap(x)    (rotl(x, 8) & 0x00ff00ff | rotr(x, 8) & 0xff00ff00)\n\n#define byte(x,n)   ((BYTE)((x) >> (8 * n)))\n\n// ??\n#define BYTE_SWAP\n\n#ifdef  BLOCK_SWAP\n#define BYTE_SWAP\n#define WORD_SWAP\n#endif\n\n#ifdef  BYTE_SWAP\n#define io_swap(x)  bswap(x)\n#else\n#define io_swap(x)  (x)\n#endif\n\n#ifdef  WORD_SWAP\n\n#define get_block(x)                            \\\n    ((DWORD *)(x))[0] = io_swap(in_blk[3]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_blk[2]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_blk[1]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_blk[0])\n\n#define put_block(x)                            \\\n    out_blk[3] = io_swap(((DWORD *)(x))[0]);    \\\n    out_blk[2] = io_swap(((DWORD *)(x))[1]);    \\\n    out_blk[1] = io_swap(((DWORD *)(x))[2]);    \\\n    out_blk[0] = io_swap(((DWORD *)(x))[3])\n\n#define get_key(x,len)                          \\\n    ((DWORD *)(x))[4] = ((DWORD *)(x))[5] =     \\\n    ((DWORD *)(x))[6] = ((DWORD *)(x))[7] = 0;  \\\n    switch((((len) + 63) / 64)) {               \\\n    case 2:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[0]);     \\\n    break;                                      \\\n    case 3:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[5]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[0]);     \\\n    break;                                      \\\n    case 4:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[7]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[6]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[5]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[6] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[7] = io_swap(in_key[0]);     \\\n    }\n\n#else\n\n#define get_block(x)                            \\\n    ((DWORD *)(x))[0] = io_swap(in_blk[0]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_blk[1]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_blk[2]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_blk[3])\n\n#define put_block(x)                            \\\n    out_blk[0] = io_swap(((DWORD *)(x))[0]);    \\\n    out_blk[1] = io_swap(((DWORD *)(x))[1]);    \\\n    out_blk[2] = io_swap(((DWORD *)(x))[2]);    \\\n    out_blk[3] = io_swap(((DWORD *)(x))[3])\n\n#define get_key(x,len)                          \\\n    ((DWORD *)(x))[4] = ((DWORD *)(x))[5] =     \\\n    ((DWORD *)(x))[6] = ((DWORD *)(x))[7] = 0;  \\\n    switch((((len) + 63) / 64)) {               \\\n    case 4:                                     \\\n    ((DWORD *)(x))[6] = io_swap(in_key[6]);     \\\n    ((DWORD *)(x))[7] = io_swap(in_key[7]);     \\\n    case 3:                                     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[5]);     \\\n    case 2:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[0]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[3]);     \\\n    }\n\n#endif\n\nconst DWORD s_box[4][256] = \n{ {\n    0x30fb40d4, 0x9fa0ff0b, 0x6beccd2f, 0x3f258c7a, 0x1e213f2f, 0x9C004dd3, \n    0x6003e540, 0xcf9fc949, 0xbfd4af27, 0x88bbbdb5, 0xe2034090, 0x98d09675,\n    0x6e63a0e0, 0x15c361d2, 0xc2e7661d, 0x22d4ff8e, 0x28683b6f, 0xc07fd059, \n    0xff2379c8, 0x775f50e2, 0x43c340d3, 0xdf2f8656, 0x887ca41a, 0xa2d2bd2d,\n    0xa1c9e0d6, 0x346c4819, 0x61b76d87, 0x22540f2f, 0x2abe32e1, 0xaa54166b, \n    0x22568e3a, 0xa2d341d0, 0x66db40c8, 0xa784392f, 0x004dff2f, 0x2db9d2de, \n    0x97943fac, 0x4a97c1d8, 0x527644b7, 0xb5f437a7, 0xb82cbaef, 0xd751d159, \n    0x6ff7f0ed, 0x5a097a1f, 0x827b68d0, 0x90ecf52e, 0x22b0c054, 0xbc8e5935,\n    0x4b6d2f7f, 0x50bb64a2, 0xd2664910, 0xbee5812d, 0xb7332290, 0xe93b159f,\n    0xb48ee411, 0x4bff345d, 0xfd45c240, 0xad31973f, 0xc4f6d02e, 0x55fc8165,\n    0xd5b1caad, 0xa1ac2dae, 0xa2d4b76d, 0xc19b0C50, 0x882240f2, 0x0c6e4f38, \n    0xa4e4bfd7, 0x4f5ba272, 0x564c1d2f, 0xc59c5319, 0xb949e354, 0xb04669fe,\n    0xb1b6ab8a, 0xc71358dd, 0x6385c545, 0x110f935d, 0x57538ad5, 0x6a390493, \n    0xe63d37e0, 0x2a54f6b3, 0x3a787d5f, 0x6276a0b5, 0x19a6fcdf, 0x7a42206a, \n    0x29f9d4d5, 0xf61b1891, 0xbb72275e, 0xaa508167, 0x38901091, 0xc6b505eb, \n    0x84c7cb8c, 0x2ad75a0f, 0x874a1427, 0xa2d1936b, 0x2ad286af, 0xaa56d291,\n    0xd7894360, 0x425c750d, 0x93b39e26, 0x187184c9, 0x6c00b32d, 0x73e2bb14, \n    0xa0bebc3c, 0x54623779, 0x64459eab, 0x3f328b82, 0x7718cf82, 0x59a2cea6,\n    0x04ee002e, 0x89fe78e6, 0x3fab0950, 0x325ff6C2, 0x81383f05, 0x6963c5c8,\n    0x76cb5ad6, 0xd49974c9, 0xca180dcf, 0x380782d5, 0xc7fa5cf6, 0x8ac31511,\n    0x35e79e13, 0x47da91d0, 0xf40f9086, 0xa7e2419e, 0x31366241, 0x051ef495, \n    0xaa573b04, 0x4a805d8d, 0x548300d0, 0x00322a3c, 0xbf64cddf, 0xba57a68e,\n    0x75c6372b, 0x50afd341, 0xa7c13275, 0x915a0bf5, 0x6b54bfab, 0x2b0b1426, \n    0xab4cc9d7, 0x449ccd82, 0xf7fbf265, 0xab85c5f3, 0x1b55db94, 0xaad4e324, \n    0xcfa4bd3f, 0x2deaa3e2, 0x9e204d02, 0xc8bd25ac, 0xeadf55b3, 0xd5bd9e98, \n    0xe31231b2, 0x2ad5ad6c, 0x954329de, 0xadbe4528, 0xd8710f69, 0xaa51c90f,\n    0xaa786bf6, 0x22513f1e, 0xaa51a79b, 0x2ad344cc, 0x7b5a41f0, 0xd37cfbad, \n    0x1b069505, 0x41ece491, 0xb4c332e6, 0x032268d4, 0xc9600acc, 0xce387e6d, \n    0xbf6bb16c, 0x6a70fb78, 0x0d03d9c9, 0xd4df39de, 0xe01063da, 0x4736f464, \n    0x5ad328d8, 0xb347cc96, 0x75bb0fc3, 0x98511bfb, 0x4ffbcc35, 0xb58bcf6a,\n    0xe11f0abc, 0xbfc5fe4a, 0xa70aec10, 0xac39570a, 0x3f04442f, 0x6188b153, \n    0xe0397a2e, 0x5727cb79, 0x9ceb418f, 0x1cacd68d, 0x2ad37c96, 0x0175cb9d, \n    0xc69dff09, 0xc75b65f0, 0xd9db40d8, 0xec0e7779, 0x4744ead4, 0xb11c3274, \n    0xdd24cb9e, 0x7e1c54bd, 0xf01144f9, 0xd2240eb1, 0x9675b3fd, 0xa3ac3755,\n    0xd47c27af, 0x51c85f4d, 0x56907596, 0xa5bb15e6, 0x580304f0, 0xca042cf1, \n    0x011a37ea, 0x8dbfaadb, 0x35ba3e4a, 0x3526ffa0, 0xc37b4d09, 0xbc306ed9,\n    0x98a52666, 0x5648f725, 0xff5e569d, 0x0ced63d0, 0x7c63b2cf, 0x700b45e1, \n    0xd5ea50f1, 0x85a92872, 0xaf1fbda7, 0xd4234870, 0xa7870bf3, 0x2d3b4d79,\n    0x42e04198, 0x0cd0ede7, 0x26470db8, 0xf881814C, 0x474d6ad7, 0x7c0c5e5c, \n    0xd1231959, 0x381b7298, 0xf5d2f4db, 0xab838653, 0x6e2f1e23, 0x83719c9e,\n    0xbd91e046, 0x9a56456e, 0xdc39200c, 0x20c8c571, 0x962bda1c, 0xe1e696ff, \n    0xb141ab08, 0x7cca89b9, 0x1a69e783, 0x02cc4843, 0xa2f7c579, 0x429ef47d, \n    0x427b169c, 0x5ac9f049, 0xdd8f0f00, 0x5c8165bf\n  },\n  {\n    0x1f201094, 0xef0ba75b, 0x69e3cf7e, 0x393f4380, 0xfe61cf7a, 0xeec5207a,\n    0x55889c94, 0x72fc0651, 0xada7ef79, 0x4e1d7235, 0xd55a63ce, 0xde0436ba, \n    0x99c430ef, 0x5f0c0794, 0x18dcdb7d, 0xa1d6eff3, 0xa0b52f7b, 0x59e83605, \n    0xee15b094, 0xe9ffd909, 0xdc440086, 0xef944459, 0xba83ccb3, 0xe0c3cdfb,\n    0xd1da4181, 0x3b092ab1, 0xf997f1c1, 0xa5e6cf7b, 0x01420ddb, 0xe4e7ef5b, \n    0x25a1ff41, 0xe180f806, 0x1fc41080, 0x179bee7a, 0xd37ac6a9, 0xfe5830a4, \n    0x98de8b7f, 0x77e83f4e, 0x79929269, 0x24fa9f7b, 0xe113c85b, 0xacc40083, \n    0xd7503525, 0xf7ea615f, 0x62143154, 0x0d554b63, 0x5d681121, 0xc866c359,\n    0x3d63cf73, 0xcee234c0, 0xd4d87e87, 0x5c672b21, 0x071f6181, 0x39f7627f, \n    0x361e3084, 0xe4eb573b, 0x602f64a4, 0xd63acd9c, 0x1bbc4635, 0x9e81032d, \n    0x2701f50c, 0x99847ab4, 0xa0e3df79, 0xba6cf38c, 0x10843094, 0x2537a95e, \n    0xf46f6ffe, 0xa1ff3b1f, 0x208cfb6a, 0x8f458c74, 0xd9e0a227, 0x4ec73a34,\n    0xfc884f69, 0x3e4de8df, 0xef0e0088, 0x3559648d, 0x8a45388c, 0x1d804366, \n    0x721d9bfd, 0xa58684bb, 0xe8256333, 0x844e8212, 0x128d8098, 0xfed33fb4, \n    0xce280ae1, 0x27e19ba5, 0xd5a6c252, 0xe49754bd, 0xc5d655dd, 0xeb667064, \n    0x77840b4d, 0xa1b6a801, 0x84db26a9, 0xe0b56714, 0x21f043b7, 0xe5d05860,\n    0x54f03084, 0x066ff472, 0xa31aa153, 0xdadc4755, 0xb5625dbf, 0x68561be6, \n    0x83ca6b94, 0x2d6ed23b, 0xeccf01db, 0xa6d3d0ba, 0xb6803d5c, 0xaf77a709, \n    0x33b4a34c, 0x397bc8d6, 0x5ee22b95, 0x5f0e5304, 0x81ed6f61, 0x20e74364, \n    0xb45e1378, 0xde18639b, 0x881ca122, 0xb96726d1, 0x8049a7e8, 0x22b7da7b,\n    0x5e552d25, 0x5272d237, 0x79d2951c, 0xc60d894c, 0x488cb402, 0x1ba4fe5b, \n    0xa4b09f6b, 0x1ca815cf, 0xa20c3005, 0x8871df63, 0xb9de2fcb, 0x0cc6c9e9, \n    0x0beeff53, 0xe3214517, 0xb4542835, 0x9f63293c, 0xee41e729, 0x6e1d2d7c, \n    0x50045286, 0x1e6685f3, 0xf33401c6, 0x30a22c95, 0x31a70850, 0x60930f13,\n    0x73f98417, 0xa1269859, 0xec645c44, 0x52c877a9, 0xcdff33a6, 0xa02b1741, \n    0x7cbad9a2, 0x2180036f, 0x50d99c08, 0xcb3f4861, 0xc26bd765, 0x64a3f6ab, \n    0x80342676, 0x25a75e7b, 0xe4e6d1fc, 0x20c710e6, 0xcdf0b680, 0x17844d3b, \n    0x31eef84d, 0x7e0824e4, 0x2ccb49eb, 0x846a3bae, 0x8ff77888, 0xee5d60f6,\n    0x7af75673, 0x2fdd5cdb, 0xa11631c1, 0x30f66f43, 0xb3faec54, 0x157fd7fa, \n    0xef8579cc, 0xd152de58, 0xdb2ffd5e, 0x8f32ce19, 0x306af97a, 0x02f03ef8, \n    0x99319ad5, 0xc242fa0f, 0xa7e3ebb0, 0xc68e4906, 0xb8da230c, 0x80823028, \n    0xdcdef3c8, 0xd35fb171, 0x088a1bc8, 0xbec0c560, 0x61a3c9e8, 0xbca8f54d,\n    0xc72feffa, 0x22822e99, 0x82c570b4, 0xd8d94e89, 0x8b1c34bc, 0x301e16e6,\n    0x273be979, 0xb0ffeaa6, 0x61d9b8c6, 0x00b24869, 0xb7ffce3f, 0x08dc283b, \n    0x43daf65a, 0xf7e19798, 0x7619b72f, 0x8f1c9ba4, 0xdc8637a0, 0x16a7d3b1, \n    0x9fc393b7, 0xa7136eeb, 0xc6bcc63e, 0x1a513742, 0xef6828bc, 0x520365d6,\n    0x2d6a77ab, 0x3527ed4b, 0x821fd216, 0x095c6e2e, 0xdb92f2fb, 0x5eea29cb, \n    0x145892f5, 0x91584f7f, 0x5483697b, 0x2667a8cc, 0x85196048, 0x8c4bacea, \n    0x833860d4, 0x0d23e0f9, 0x6c387e8a, 0x0ae6d249, 0xb284600c, 0xd835731d, \n    0xdcb1c647, 0xac4c56ea, 0x3ebd81b3, 0x230eabb0, 0x6438bc87, 0xf0b5b1fa,\n    0x8f5ea2b3, 0xfc184642, 0x0a036b7a, 0x4fb089bd, 0x649da589, 0xa345415e, \n    0x5c038323, 0x3e5d3bb9, 0x43d79572, 0x7e6dd07c, 0x06dfdf1e, 0x6c6cc4ef, \n    0x7160a539, 0x73bfbe70, 0x83877605, 0x4523ecf1\n  },\n  {\n    0x8defc240, 0x25fa5d9f, 0xeb903dbf, 0xe810c907, 0x47607fff, 0x369fe44b,\n    0x8c1fc644, 0xaececa90, 0xbeb1f9bf, 0xeefbcaea, 0xe8cf1950, 0x51df07ae, \n    0x920e8806, 0xf0ad0548, 0xe13c8d83, 0x927010d5, 0x11107d9f, 0x07647db9,\n    0xb2e3e4d4, 0x3d4f285e, 0xb9afa820, 0xfade82e0, 0xa067268b, 0x8272792e,\n    0x553fb2c0, 0x489ae22b, 0xd4ef9794, 0x125e3fbc, 0x21fffcee, 0x825b1bfd,\n    0x9255c5ed, 0x1257a240, 0x4e1a8302, 0xbae07fff, 0x528246e7, 0x8e57140e,\n    0x3373f7bf, 0x8c9f8188, 0xa6fc4ee8, 0xc982b5a5, 0xa8c01db7, 0x579fc264,\n    0x67094f31, 0xf2bd3f5f, 0x40fff7c1, 0x1fb78dfc, 0x8e6bd2c1, 0x437be59b,\n    0x99b03dbf, 0xb5dbc64b, 0x638dc0e6, 0x55819d99, 0xa197c81c, 0x4a012d6e, \n    0xc5884a28, 0xccc36f71, 0xb843c213, 0x6c0743f1, 0x8309893c, 0x0feddd5f, \n    0x2f7fe850, 0xd7c07f7e, 0x02507fbf, 0x5afb9a04, 0xa747d2d0, 0x1651192e, \n    0xaf70bf3e, 0x58c31380, 0x5f98302e, 0x727cc3c4, 0x0a0fb402, 0x0f7fef82,\n    0x8c96fdad, 0x5d2c2aae, 0x8ee99a49, 0x50da88b8, 0x8427f4a0, 0x1eac5790, \n    0x796fb449, 0x8252dc15, 0xefbd7d9b, 0xa672597d, 0xada840d8, 0x45f54504, \n    0xfa5d7403, 0xe83ec305, 0x4f91751a, 0x925669c2, 0x23efe941, 0xa903f12e, \n    0x60270df2, 0x0276e4b6, 0x94fd6574, 0x927985b2, 0x8276dbcb, 0x02778176,\n    0xf8af918d, 0x4e48f79e, 0x8f616ddf, 0xe29d840e, 0x842f7d83, 0x340ce5c8, \n    0x96bbb682, 0x93b4b148, 0xef303cab, 0x984faf28, 0x779faf9b, 0x92dc560d, \n    0x224d1e20, 0x8437aa88, 0x7d29dc96, 0x2756d3dc, 0x8b907cee, 0xb51fd240, \n    0xe7c07ce3, 0xe566b4a1, 0xc3e9615e, 0x3cf8209d, 0x6094d1e3, 0xcd9ca341,\n    0x5c76460e, 0x00ea983b, 0xd4d67881, 0xfd47572c, 0xf76cedd9, 0xbda8229c, \n    0x127dadaa, 0x438a074e, 0x1f97c090, 0x081bdb8a, 0x93a07ebe, 0xb938ca15,\n    0x97b03cff, 0x3dc2c0f8, 0x8d1ab2ec, 0x64380e51, 0x68cc7bfb, 0xd90f2788, \n    0x12490181, 0x5de5ffd4, 0xdd7ef86a, 0x76a2e214, 0xb9a40368, 0x925d958f,\n    0x4b39fffa, 0xba39aee9, 0xa4ffd30b, 0xfaf7933b, 0x6d498623, 0x193cbcfa, \n    0x27627545, 0x825cf47a, 0x61bd8ba0, 0xd11e42d1, 0xcead04f4, 0x127ea392, \n    0x10428db7, 0x8272a972, 0x9270c4a8, 0x127de50b, 0x285ba1c8, 0x3c62f44f, \n    0x35c0eaa5, 0xe805d231, 0x428929fb, 0xb4fcdf82, 0x4fb66a53, 0x0e7dc15b,\n    0x1f081fab, 0x108618ae, 0xfcfd086d, 0xf9ff2889, 0x694bcc11, 0x236a5cae, \n    0x12deca4d, 0x2c3f8cc5, 0xd2d02dfe, 0xf8ef5896, 0xe4cf52da, 0x95155b67, \n    0x494a488c, 0xb9b6a80c, 0x5c8f82bc, 0x89d36b45, 0x3a609437, 0xec00c9a9, \n    0x44715253, 0x0a874b49, 0xd773bc40, 0x7c34671c, 0x02717ef6, 0x4feb5536,\n    0xa2d02fff, 0xd2bf60c4, 0xd43f03c0, 0x50b4ef6d, 0x07478cd1, 0x006e1888, \n    0xa2e53f55, 0xb9e6d4bc, 0xa2048016, 0x97573833, 0xd7207d67, 0xde0f8f3d, \n    0x72f87b33, 0xabcc4f33, 0x7688c55d, 0x7b00a6b0, 0x947b0001, 0x570075d2, \n    0xf9bb88f8, 0x8942019e, 0x4264a5ff, 0x856302e0, 0x72dbd92b, 0xee971b69,\n    0x6ea22fde, 0x5f08ae2b, 0xaf7a616d, 0xe5c98767, 0xcf1febd2, 0x61efc8c2, \n    0xf1ac2571, 0xcc8239c2, 0x67214cb8, 0xb1e583d1, 0xb7dc3e62, 0x7f10bdce, \n    0xf90a5c38, 0x0ff0443d, 0x606e6dc6, 0x60543a49, 0x5727c148, 0x2be98a1d, \n    0x8ab41738, 0x20e1be24, 0xaf96da0f, 0x68458425, 0x99833be5, 0x600d457d,\n    0x282f9350, 0x8334b362, 0xd91d1120, 0x2b6d8da0, 0x642b1e31, 0x9c305a00, \n    0x52bce688, 0x1b03588a, 0xf7baefd5, 0x4142ed9c, 0xa4315c11, 0x83323ec5, \n    0xdfef4636, 0xa133c501, 0xe9d3531c, 0xee353783\n  },\n  { \n    0x9db30420, 0x1fb6e9de, 0xa7be7bef, 0xd273a298, 0x4a4f7bdb, 0x64ad8c57, \n    0x85510443, 0xfa020ed1, 0x7e287aff, 0xe60fb663, 0x095f35a1, 0x79ebf120, \n    0xfd059d43, 0x6497b7b1, 0xf3641f63, 0x241e4adf, 0x28147f5f, 0x4fa2b8cd, \n    0xc9430040, 0x0cc32220, 0xfdd30b30, 0xc0a5374f, 0x1d2d00d9, 0x24147b15,\n    0xee4d111a, 0x0fca5167, 0x71ff904c, 0x2d195ffe, 0x1a05645f, 0x0c13fefe, \n    0x081b08ca, 0x05170121, 0x80530100, 0xe83e5efe, 0xac9af4f8, 0x7fe72701, \n    0xd2b8ee5f, 0x06df4261, 0xbb9e9b8a, 0x7293ea25, 0xce84ffdf, 0xf5718801, \n    0x3dd64b04, 0xa26f263b, 0x7ed48400, 0x547eebe6, 0x446d4ca0, 0x6cf3d6f5,\n    0x2649abdf, 0xaea0c7f5, 0x36338cc1, 0x503f7e93, 0xd3772061, 0x11b638e1, \n    0x72500e03, 0xf80eb2bb, 0xabe0502e, 0xec8d77de, 0x57971e81, 0xe14f6746,\n    0xc9335400, 0x6920318f, 0x081dbb99, 0xffc304a5, 0x4d351805, 0x7f3d5ce3, \n    0xa6c866c6, 0x5d5bcca9, 0xdaec6fea, 0x9f926f91, 0x9f46222f, 0x3991467d,\n    0xa5bf6d8e, 0x1143c44f, 0x43958302, 0xd0214eeb, 0x022083b8, 0x3fb6180c,\n    0x18f8931e, 0x281658e6, 0x26486e3e, 0x8bd78a70, 0x7477e4c1, 0xb506e07c,\n    0xf32d0a25, 0x79098b02, 0xe4eabb81, 0x28123b23, 0x69dead38, 0x1574ca16, \n    0xdf871b62, 0x211c40b7, 0xa51a9ef9, 0x0014377b, 0x041e8ac8, 0x09114003,\n    0xbd59e4d2, 0xe3d156d5, 0x4fe876d5, 0x2f91a340, 0x557be8de, 0x00eae4a7,\n    0x0ce5c2ec, 0x4db4bba6, 0xe756bdff, 0xdd3369ac, 0xec17b035, 0x06572327, \n    0x99afc8b0, 0x56c8c391, 0x6b65811c, 0x5e146119, 0x6e85cb75, 0xbe07c002, \n    0xc2325577, 0x893ff4ec, 0x5bbfc92d, 0xd0ec3b25, 0xb7801ab7, 0x8d6d3b24,\n    0x20c763ef, 0xc366a5fc, 0x9c382880, 0x0ace3205, 0xaac9548a, 0xeca1d7c7, \n    0x041afa32, 0x1d16625a, 0x6701902c, 0x9b757a54, 0x31d477f7, 0x9126b031, \n    0x36cc6fdb, 0xc70b8b46, 0xd9e66a48, 0x56e55a79, 0x026a4ceb, 0x52437eff, \n    0x2f8f76b4, 0x0df980a5, 0x8674cde3, 0xedda04eb, 0x17a9be04, 0x2c18f4df,\n    0xb7747f9d, 0xab2af7b4, 0xefc34d20, 0x2e096b7c, 0x1741a254, 0xe5b6a035, \n    0x213d42f6, 0x2c1c7c26, 0x61c2f50f, 0x6552daf9, 0xd2c231f8, 0x25130f69, \n    0xd8167fa2, 0x0418f2c8, 0x001a96a6, 0x0d1526ab, 0x63315c21, 0x5e0a72ec, \n    0x49bafefd, 0x187908d9, 0x8d0dbd86, 0x311170a7, 0x3e9b640c, 0xcc3e10d7,\n    0xd5cad3b6, 0x0caec388, 0xf73001e1, 0x6c728aff, 0x71eae2a1, 0x1f9af36e, \n    0xcfcbd12f, 0xc1de8417, 0xac07be6b, 0xcb44a1d8, 0x8b9b0f56, 0x013988c3, \n    0xb1c52fca, 0xb4be31cd, 0xd8782806, 0x12a3a4e2, 0x6f7de532, 0x58fd7eb6,\n    0xd01ee900, 0x24adffc2, 0xf4990fc5, 0x9711aac5, 0x001d7b95, 0x82e5e7d2,\n    0x109873f6, 0x00613096, 0xc32d9521, 0xada121ff, 0x29908415, 0x7fbb977f, \n    0xaf9eb3db, 0x29c9ed2a, 0x5ce2a465, 0xa730f32c, 0xd0aa3fe8, 0x8a5cc091, \n    0xd49e2ce7, 0x0ce454a9, 0xd60acd86, 0x015f1919, 0x77079103, 0xdea03af6, \n    0x78a8565e, 0xdee356df, 0x21f05cbe, 0x8b75e387, 0xb3c50651, 0xb8a5c3ef,\n    0xd8eeb6d2, 0xe523be77, 0xc2154529, 0x2f69efdf, 0xafe67afb, 0xf470c4b2,\n    0xf3e0eb5b, 0xd6cc9876, 0x39e4460c, 0x1fda8538, 0x1987832f, 0xca007367, \n    0xa99144f8, 0x296b299e, 0x492fc295, 0x9266beab, 0xb5676e69, 0x9bd3ddda,\n    0xdf7e052f, 0xdb25701c, 0x1b5e51ee, 0xf65324e6, 0x6afce36c, 0x0316cc04,\n    0x8644213e, 0xb7dc59d0, 0x7965291f, 0xccd6fd43, 0x41823979, 0x932bcdf6,\n    0xb657c34d, 0x4edfd282, 0x7ae5290c, 0x3cb9536b, 0x851e20fe, 0x9833557e,\n    0x13ecf0b0, 0xd3ffb372, 0x3f85c5c1, 0x0aef7ed2\n  }\n};\n\n#define f1(y,x,kr,km)           \\\n    t  = rotl(km + x, kr);      \\\n    u  = s_box[0][byte(t,3)];   \\\n    u ^= s_box[1][byte(t,2)];   \\\n    u -= s_box[2][byte(t,1)];   \\\n    u += s_box[3][byte(t,0)];   \\\n    y ^= u\n\n#define f2(y,x,kr,km)           \\\n    t  = rotl(km ^ x, kr);      \\\n    u  = s_box[0][byte(t,3)];   \\\n    u -= s_box[1][byte(t,2)];   \\\n    u += s_box[2][byte(t,1)];   \\\n    u ^= s_box[3][byte(t,0)];   \\\n    y ^= u\n\n#define f3(y,x,kr,km)           \\\n    t  = rotl(km - x, kr);      \\\n    u  = s_box[0][byte(t,3)];   \\\n    u += s_box[1][byte(t,2)];   \\\n    u ^= s_box[2][byte(t,1)];   \\\n    u -= s_box[3][byte(t,0)];   \\\n    y ^= u\n\n#define f_rnd(x,n)                              \\\n    f1(x[2],x[3],l_key[n],    l_key[n + 4]);    \\\n    f2(x[1],x[2],l_key[n + 1],l_key[n + 5]);    \\\n    f3(x[0],x[1],l_key[n + 2],l_key[n + 6]);    \\\n    f1(x[3],x[0],l_key[n + 3],l_key[n + 7])\n\n#define i_rnd(x, n)                             \\\n    f1(x[3],x[0],l_key[n + 3],l_key[n + 7]);    \\\n    f3(x[0],x[1],l_key[n + 2],l_key[n + 6]);    \\\n    f2(x[1],x[2],l_key[n + 1],l_key[n + 5]);    \\\n    f1(x[2],x[3],l_key[n],    l_key[n + 4])\n\n#define k_rnd(k,tr,tm)          \\\n    f1(k[6],k[7],tr[0],tm[0]);  \\\n    f2(k[5],k[6],tr[1],tm[1]);  \\\n    f3(k[4],k[5],tr[2],tm[2]);  \\\n    f1(k[3],k[4],tr[3],tm[3]);  \\\n    f2(k[2],k[3],tr[4],tm[4]);  \\\n    f3(k[1],k[2],tr[5],tm[5]);  \\\n    f1(k[0],k[1],tr[6],tm[6]);  \\\n    f2(k[7],k[0],tr[7],tm[7])\n\n/* initialise the key schedule from the user supplied key   */\nvoid Cast256_set_key(DWORD *l_key,const DWORD *in_key, const DWORD key_len)\n{\n\tDWORD  i, j, t, u, cm, cr, lk[8], tm[8], tr[8];\n\n    for(i = 0; i < key_len / 32; ++i)\n\n        lk[i] = io_swap(in_key[i]);\n\n    for(; i < 8; ++i)\n\n        lk[i] = 0;\n\n    cm = 0x5a827999; cr = 19;\n\n    for(i = 0; i < 96; i += 8)\n    {\n        for(j = 0; j < 8; ++j)\n        {\n            tm[j] = cm; cm += 0x6ed9eba1;\n            tr[j] = cr; cr += 17;\n        }\n\n        k_rnd(lk, tr, tm);\n        \n        for(j = 0; j < 8; ++j)\n        {\n            tm[j] = cm; cm += 0x6ed9eba1;\n            tr[j] = cr; cr += 17;\n        }\n\n        k_rnd(lk, tr, tm);\n\n        l_key[i + 0] = lk[0]; l_key[i + 1] = lk[2];\n        l_key[i + 2] = lk[4]; l_key[i + 3] = lk[6];\n        l_key[i + 4] = lk[7]; l_key[i + 5] = lk[5];\n        l_key[i + 6] = lk[3]; l_key[i + 7] = lk[1];\n    }\n}\n\nvoid Cast256_encrypt(const DWORD *l_key,const DWORD *in_blk, DWORD *out_blk)\n{\n\tDWORD  t, u, blk[4];\n\n    blk[0] = io_swap(in_blk[0]);\n\tblk[1] = io_swap(in_blk[1]);\n    blk[2] = io_swap(in_blk[2]);\n\tblk[3] = io_swap(in_blk[3]);\n\n    f_rnd(blk,  0);\n\tf_rnd(blk,  8);\n    f_rnd(blk, 16);\n\tf_rnd(blk, 24);\n    f_rnd(blk, 32);\n\tf_rnd(blk, 40);\n    i_rnd(blk, 48);\n\ti_rnd(blk, 56);\n    i_rnd(blk, 64);\n\ti_rnd(blk, 72);\n    i_rnd(blk, 80);\n\ti_rnd(blk, 88);\n\n    out_blk[0] = io_swap(blk[0]);\n\tout_blk[1] = io_swap(blk[1]);\n    out_blk[2] = io_swap(blk[2]);\n\tout_blk[3] = io_swap(blk[3]);\n}\n\nvoid Cast256_decrypt(const DWORD *l_key,const DWORD *in_blk, DWORD *out_blk)\n{\n\tDWORD  t, u, blk[4];\n\n    blk[0] = io_swap(in_blk[0]);\n\tblk[1] = io_swap(in_blk[1]);\n    blk[2] = io_swap(in_blk[2]);\n\tblk[3] = io_swap(in_blk[3]);\n\n    f_rnd(blk, 88);\n\tf_rnd(blk, 80);\n    f_rnd(blk, 72);\n\tf_rnd(blk, 64);\n    f_rnd(blk, 56);\n\tf_rnd(blk, 48);\n    i_rnd(blk, 40);\n\ti_rnd(blk, 32);\n    i_rnd(blk, 24);\n\ti_rnd(blk, 16);\n    i_rnd(blk,  8);\n\ti_rnd(blk,  0);\n\n    out_blk[0] = io_swap(blk[0]);\n\tout_blk[1] = io_swap(blk[1]);\n    out_blk[2] = io_swap(blk[2]);\n\tout_blk[3] = io_swap(blk[3]);\n}\n"
        },
        {
            "file_name": "catena-blake2b.c",
            "content": "#include \"catena.h\"\n#include \"blake2.h\"\n#include \"hash.h\"\n\n\ninline void __Hash1(const uint8_t *input, const uint32_t inputlen,\n\t\t      uint8_t hash[H_LEN])\n{\n  blake2b_state ctx;\n  blake2b_init(&ctx,H_LEN);\n  blake2b_update(&ctx, input, inputlen);\n  blake2b_final(&ctx, hash, H_LEN);\n}\n\n\n/***************************************************/\n\ninline void __Hash2(const uint8_t *i1, const uint8_t i1len,\n\t\t    const uint8_t *i2, const uint8_t i2len,\n\t\t    uint8_t hash[H_LEN])\n{\n  blake2b_state ctx;\n  blake2b_init(&ctx,H_LEN);\n  blake2b_update(&ctx, i1, i1len);\n  blake2b_update(&ctx, i2, i2len);\n  blake2b_final(&ctx, hash, H_LEN);\n}\n\n\n\n/***************************************************/\n\ninline void __Hash3(const uint8_t *i1, const uint8_t i1len,\n\t\t    const uint8_t *i2, const uint8_t i2len,\n\t\t    const uint8_t *i3, const uint8_t i3len,\n\t\t    uint8_t hash[H_LEN])\n{\n  blake2b_state ctx;\n  blake2b_init(&ctx,H_LEN);\n  blake2b_update(&ctx, i1, i1len);\n  blake2b_update(&ctx, i2, i2len);\n  blake2b_update(&ctx, i3, i3len);\n  blake2b_final(&ctx, hash, H_LEN);\n}\n\n/***************************************************/\n\ninline void __Hash4(const uint8_t *i1, const uint8_t i1len,\n\t\t    const uint8_t *i2, const uint8_t i2len,\n\t\t    const uint8_t *i3, const uint8_t i3len,\n\t\t     const uint8_t *i4, const uint8_t i4len,\n\t\t    uint8_t hash[H_LEN])\n{\n  blake2b_state ctx;\n  blake2b_init(&ctx,H_LEN);\n  blake2b_update(&ctx, i1, i1len);\n  blake2b_update(&ctx, i2, i2len);\n  blake2b_update(&ctx, i3, i3len);\n  blake2b_update(&ctx, i4, i4len);\n  blake2b_final(&ctx, hash, H_LEN);\n}\n\n\n/***************************************************/\n\ninline void __Hash5(const uint8_t *i1, const uint8_t i1len,\n\t\t    const uint8_t *i2, const uint8_t i2len,\n\t\t    const uint8_t *i3, const uint8_t i3len,\n\t\t    const uint8_t *i4, const uint8_t i4len,\n\t\t    const uint8_t *i5, const uint8_t i5len,\n\t\t    uint8_t hash[H_LEN])\n{\n  blake2b_state ctx;\n  blake2b_init(&ctx,H_LEN);\n  blake2b_update(&ctx, i1, i1len);\n  blake2b_update(&ctx, i2, i2len);\n  blake2b_update(&ctx, i3, i3len);\n  blake2b_update(&ctx, i4, i4len);\n  blake2b_update(&ctx, i5, i5len);\n  blake2b_final(&ctx, hash, H_LEN);\n}\n"
        },
        {
            "file_name": "catena-sha512.c",
            "content": "#include <openssl/sha.h>\n\n#include \"catena.h\"\n#include \"hash.h\"\n\n/***************************************************/\n\ninline void __Hash1(const uint8_t *input, const uint32_t inputlen,\n\t\t      uint8_t hash[H_LEN])\n{\n  SHA512_CTX ctx;\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, input, inputlen);\n  SHA512_Final(hash, &ctx);\n}\n\n/***************************************************/\n\ninline void __Hash2(const uint8_t *i1, const uint8_t i1len,\n\t\t    const uint8_t *i2, const uint8_t i2len,\n\t\t    uint8_t hash[H_LEN])\n{\n  SHA512_CTX ctx;\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, i1, i1len);\n  SHA512_Update(&ctx, i2, i2len);\n  SHA512_Final(hash, &ctx);\n}\n\n\n\n/***************************************************/\n\ninline void __Hash3(const uint8_t *i1, const uint8_t i1len,\n\t\t    const uint8_t *i2, const uint8_t i2len,\n\t\t    const uint8_t *i3, const uint8_t i3len,\n\t\t    uint8_t hash[H_LEN])\n{\n\n  SHA512_CTX ctx;\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, i1, i1len);\n  SHA512_Update(&ctx, i2, i2len);\n  SHA512_Update(&ctx, i3, i3len);\n  SHA512_Final(hash, &ctx);\n}\n\n/***************************************************/\n\ninline void __Hash4(const uint8_t *i1, const uint8_t i1len,\n\t\t    const uint8_t *i2, const uint8_t i2len,\n\t\t    const uint8_t *i3, const uint8_t i3len,\n\t\t     const uint8_t *i4, const uint8_t i4len,\n\t\t    uint8_t hash[H_LEN])\n{\n  SHA512_CTX ctx;\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, i1, i1len);\n  SHA512_Update(&ctx, i2, i2len);\n  SHA512_Update(&ctx, i3, i3len);\n  SHA512_Update(&ctx, i4, i4len);\n  SHA512_Final(hash, &ctx);\n}\n\n\n/***************************************************/\n\ninline void __Hash5(const uint8_t *i1, const uint8_t i1len,\n\t\t    const uint8_t *i2, const uint8_t i2len,\n\t\t    const uint8_t *i3, const uint8_t i3len,\n\t\t    const uint8_t *i4, const uint8_t i4len,\n\t\t    const uint8_t *i5, const uint8_t i5len,\n\t\t    uint8_t hash[H_LEN])\n{\n  SHA512_CTX ctx;\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, i1, i1len);\n  SHA512_Update(&ctx, i2, i2len);\n  SHA512_Update(&ctx, i3, i3len);\n  SHA512_Update(&ctx, i4, i4len);\n  SHA512_Update(&ctx, i5, i5len);\n  SHA512_Final(hash, &ctx);\n}\n\n\n/***************************************************/\n"
        },
        {
            "file_name": "catena.c",
            "content": "#include <string.h>\n#include <stdio.h>\n#include <byteswap.h>\n#include <stdlib.h>\n#include <sys/param.h>\n#define __STDC_CONSTANT_MACROS\n#include <stdint.h>\n\n\n#include \"catena.h\"\n#include \"hash.h\"\n\n\n#ifdef ARC_BIG_ENDIAN\n  #define TO_LITTLE_ENDIAN_64(n) bswap_64(n)\n  #define TO_LITTLE_ENDIAN_32(n) bswap_32(n)\n#else\n  #define TO_LITTLE_ENDIAN_64(n) (n)\n  #define TO_LITTLE_ENDIAN_32(n) (n)\n#endif\n\nuint64_t reverse(uint64_t x, const uint8_t n)\n{\n  x = bswap_64(x);\n  x = ((x & UINT64_C(0x0f0f0f0f0f0f0f0f)) << 4) |\n    ((x & UINT64_C(0xf0f0f0f0f0f0f0f0)) >> 4);\n  x = ((x & UINT64_C(0x3333333333333333)) << 2) |\n    ((x & UINT64_C(0xcccccccccccccccc)) >> 2);\n  x = ((x & UINT64_C(0x5555555555555555)) << 1) |\n    ((x & UINT64_C(0xaaaaaaaaaaaaaaaa)) >> 1);\n  return x >> (64 - n);\n}\n\n\nvoid LBRH(const uint8_t x[H_LEN], const uint8_t lambda,\n\t  const uint8_t garlic,   uint8_t h[H_LEN])\n{\n  const uint64_t c = UINT64_C(1) << garlic;\n  uint8_t *r = malloc(c*H_LEN);\n  uint64_t i = 0;\n  uint32_t k;\n\n  __Hash1(x, H_LEN, r);\n\n  /* Top row */\n  for (i = 1; i < c; i++) {\n    __Hash1(r + (i-1)*H_LEN, H_LEN, r + i*H_LEN);\n  }\n\n  /* Mid rows */\n  for (k = 0; k < lambda; k++) {\n    __Hash2(r + (c-1)*H_LEN, H_LEN, r, H_LEN, r);\n\n    /* Replace r[reverse(i, garlic)] with new value */\n    uint8_t *previousR = r, *p;\n    for (i = 1; i < c; i++) {\n      p = r + reverse(i, garlic) * H_LEN;\n      __Hash2(previousR, H_LEN, p, H_LEN, p);\n      previousR = p;\n    }\n    k++;\n    if (k >= lambda) {\n      break;\n    }\n    /* This is now sequential because (reverse(reverse(i, garlic), garlic) == i) */\n    __Hash2(r + (c-1)*H_LEN, H_LEN, r, H_LEN, r);\n    p = r + H_LEN;\n    for (i = 1; i < c; i++, p += H_LEN) {\n      __Hash1(p - H_LEN, 2 * H_LEN, p);\n    }\n  }\n\n  /* reverse(c - 1, garlic) == c - 1 */\n  memcpy(h, r + (c - 1) * H_LEN, H_LEN);\n  free(r);\n}\n\n\n\n/***************************************************/\n\n\nint __Catena(const uint8_t *pwd,   const uint32_t pwdlen,\n\t     const uint8_t *salt,  const uint8_t  saltlen,\n\t     const uint8_t *data,  const uint32_t datalen,\n\t     const uint8_t lambda, const uint8_t  min_garlic,\n\t     const uint8_t garlic, const uint8_t  hashlen,\n\t     const uint8_t client, const uint8_t  tweak_id, uint8_t *hash)\n{\n uint8_t x[H_LEN];\n uint8_t t[5];\n uint8_t c;\n\n if ((hashlen > H_LEN) || (garlic > 63) || (min_garlic > garlic)) return -1;\n\n  /* Compute Tweak */\n  t[0] = 0xFF;\n  t[1] = tweak_id;\n  t[2] = lambda;\n  t[3] = hashlen;\n  t[4] = saltlen;\n\n  /* Compute H(AD) */\n  __Hash1((uint8_t *) data, datalen,x);\n\n  /* Compute the initial value to hash  */\n  __Hash4(t,5, x, H_LEN, (uint8_t *) pwd,  pwdlen, salt, saltlen, x);\n\n  memset(x+hashlen, 0, H_LEN-hashlen);\n\n  for(c=min_garlic; c <= garlic; c++)\n    {\n      LBRH(x, lambda, c, x);\n      if( (c==garlic) && (client == CLIENT))\n\t{\n\t  memcpy(hash, x, H_LEN);\n\t  return 0;\n\t}\n      __Hash2(&c,1, x,H_LEN, x);\n      memset(x+hashlen, 0, H_LEN-hashlen);\n    }\n  memcpy(hash, x, hashlen);\n\n  return 0;\n}\n\n\n/***************************************************/\n\nint Catena(const uint8_t *pwd,   const uint32_t pwdlen,\n\t   const uint8_t *salt,  const uint8_t  saltlen,\n\t   const uint8_t *data,  const uint32_t datalen,\n\t   const uint8_t lambda, const uint8_t  min_garlic,\n\t   const uint8_t garlic, const uint8_t  hashlen,  uint8_t *hash)\n{\n  return __Catena(pwd, pwdlen, salt, saltlen, data, datalen,\n\t\t  lambda, min_garlic, garlic,\n\t\t  hashlen,  REGULAR, PASSWORD_HASHING_MODE, hash);\n\n}\n\n\n/***************************************************/\n\n\nint Naive_Catena(const char *pwd,  const char *salt, const char *data,\n\t\t  uint8_t hash[H_LEN])\n{\n  return __Catena( (uint8_t  *) pwd, strlen(pwd),\n\t\t   (uint8_t  *) salt, strlen(salt),\n\t\t   (uint8_t  *) data, strlen(data),\n\t\t   LAMBDA, MIN_GARLIC, GARLIC,\n\t\t   H_LEN, REGULAR, PASSWORD_HASHING_MODE, hash);\n}\n\n/***************************************************/\n\n\nint Simple_Catena(const uint8_t *pwd,   const uint32_t pwdlen,\n\t\t  const uint8_t *salt,  const uint8_t  saltlen,\n\t\t  const uint8_t *data,  const uint32_t datalen,\n\t\t  uint8_t hash[H_LEN])\n{\n  return __Catena(pwd, pwdlen, salt, saltlen, data, datalen,\n\t\t  LAMBDA, MIN_GARLIC, GARLIC, H_LEN,\n\t\t  REGULAR, PASSWORD_HASHING_MODE, hash);\n}\n\n\n/***************************************************/\n\nint Catena_Client(const uint8_t  *pwd,   const uint32_t pwdlen,\n\t\t  const uint8_t  *salt,  const uint8_t  saltlen,\n\t\t  const uint8_t  *data,  const uint32_t datalen,\n\t\t  const uint8_t lambda, const uint8_t  min_garlic,\n\t\t  const uint8_t  garlic, const uint8_t  hashlen,\n\t\t  uint8_t x[H_LEN])\n{\n  return __Catena(pwd, pwdlen, (uint8_t *) salt, saltlen, data, datalen,\n\t\t  lambda, min_garlic, garlic, hashlen,\n\t\t  CLIENT, PASSWORD_HASHING_MODE, x);\n}\n\n/***************************************************/\n\nint Catena_Server(const uint8_t garlic,  const uint8_t x[H_LEN],\n\t\t  const uint8_t hashlen, uint8_t *hash)\n{\n  uint8_t z[H_LEN];\n\n  if (hashlen > H_LEN) return -1;\n  __Hash2(&garlic,1,x, H_LEN, z);\n    memcpy(hash, z, hashlen);\n\n  return 0;\n}\n\n/***************************************************/\n\nvoid CI_Update(const uint8_t *old_hash,  const uint8_t lambda,\n\t       const uint8_t old_garlic, const uint8_t new_garlic,\n\t       const uint8_t hashlen, uint8_t *new_hash)\n{\n  uint8_t c;\n  uint8_t x[H_LEN];\n\n  memcpy(x, old_hash, hashlen);\n  memset(x+hashlen, 0, H_LEN-hashlen);\n\n  for(c=old_garlic+1; c <= new_garlic; c++)\n    {\n      LBRH(x, lambda, c, x);\n      __Hash2(&c,1,x, H_LEN, x);\n      memset(x+hashlen, 0, H_LEN-hashlen);\n    }\n  memcpy(new_hash,x,hashlen);\n}\n\n\n/***************************************************/\n\nvoid Catena_KG(const uint8_t *pwd,   const uint32_t pwdlen,\n\t       const uint8_t *salt,  const uint8_t saltlen,\n\t       const uint8_t *data,  const uint32_t datalen,\n\t       const uint8_t lambda, const uint8_t  min_garlic,\n\t       const uint8_t garlic, uint32_t keylen,\n\t       const uint8_t key_id, uint8_t *key)\n{\n  uint8_t hash[H_LEN];\n  const uint8_t zero = 0;\n  const uint32_t len = keylen/H_LEN;\n  const uint32_t rest = keylen%H_LEN;\n  uint64_t i;\n  keylen = TO_LITTLE_ENDIAN_32(keylen);\n\n  __Catena(pwd, pwdlen, salt, saltlen, data, datalen,\n\t   lambda, min_garlic, garlic, H_LEN, REGULAR, KEY_DERIVATION_MODE,\n\t   hash);\n\n  for(i=0; i < len; i++) {\n    uint64_t tmp = TO_LITTLE_ENDIAN_64(i);\n    __Hash5(&zero, 1, (uint8_t *) &tmp, 8, &key_id, 1,(uint8_t *) &keylen,4,\n\t      hash, H_LEN, &key[i*H_LEN]);\n  }\n\n  if(rest)\n    {\n      uint64_t tmp = TO_LITTLE_ENDIAN_64(i);\n      __Hash5(&zero, 1, (uint8_t *) &tmp, 8, &key_id, 1,(uint8_t *) &keylen,4,\n\t\thash, H_LEN, hash);\n      memcpy(&key[len*H_LEN], hash,rest);\n    }\n}\n\n\n/***************************************************/\n\nvoid Catena_Keyed_Hashing(const uint8_t *pwd,   const uint32_t pwdlen,\n\t\t\t  const uint8_t *salt,  const uint8_t saltlen,\n\t\t\t  const uint8_t *data,  const uint32_t datalen,\n\t\t\t  const uint8_t lambda, const uint8_t  min_garlic,\n\t\t\t  const uint8_t garlic, const uint8_t  hashlen,\n\t\t\t  const uint8_t *key,   const uint64_t uuid,\n\t\t\t  uint8_t *chash)\n{\n  uint8_t keystream[H_LEN];\n  uint64_t tmp = TO_LITTLE_ENDIAN_64(uuid);\n  int i;\n\n   __Catena(pwd, pwdlen, salt, saltlen, data, datalen,\n\t    lambda, min_garlic, garlic, hashlen,\n\t    REGULAR, PASSWORD_HASHING_MODE, chash);\n\n   __Hash3(key, KEY_LEN,  (uint8_t*) &tmp, 8, key, KEY_LEN, keystream);\n\n   for(i=0; i<hashlen; i++) chash[i] ^= keystream[i];\n}\n\n/***************************************************/\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\nint PHS(void *out, size_t outlen,  const void *in, size_t inlen,\n\tconst void *salt, size_t saltlen, unsigned int t_cost,\n\tunsigned int m_cost) {\n\n  return __Catena((const uint8_t *) in, inlen, salt, saltlen, (const uint8_t *)\n\t\t  \"\", 0, t_cost, MIN_GARLIC, m_cost, outlen, REGULAR,\n\t\t  PASSWORD_HASHING_MODE, out);\n}\n\n#pragma GCC diagnostic warning \"-Wunused-parameter\"\n"
        },
        {
            "file_name": "cba10_encrypt.cpp",
            "content": "#include <string.h>\n#include <openssl/aes.h>\n#include \"cba10_api.h\"\n#include \"cba10_encrypt.h\"\n#define NONCEBYTES CRYPTO_NPUBBYTES\n\n// CHANGE namespace moved due to includes\nnamespace Cba10_raw {\nint numRounds = -1;\n\n// CBA parameters\n//================\n#define tau_par\t\t(const int)96\n#define b_par\t\t(const int)48\n#define KEYBYTES   CRYPTO_KEYBYTES\n//================\n\n#define min(a, b)\t((a) < (b) ? (a):(b))\n#define TAGBYTES\ttau_par/8\n#define n_par\t\t(const int)128\n#define l_par\t\tmin(n_par - 2*b_par - 32, tau_par)\n\ntypedef unsigned char block[16];\ntypedef unsigned char half_block[8];\n\n/*----------------------------\n Rotates char *a to right by rot_amount\n ----------------------------*/\nstatic void rotate(unsigned char *a, int rot_amount, long long abytes) {\n    int rot_bytes = rot_amount / 8;\n    int rot_bits = rot_amount - (rot_bytes * 8);\n    int i;\n\t// EACirc: VLA not supported in MSVC (allocation)\n\t//unsigned char temp[abytes];\n\tunsigned char* temp = new unsigned char[abytes];\n    memcpy(temp, a, abytes);\n    for (i = 0; i < abytes; i++) {\n        a[(i + rot_bytes) % abytes] = temp[i];\n    }\n    memcpy(temp, a, abytes);\n    for (i = 1; i < abytes; i++) {\n        a[i] = (temp[i - 1] << (8 - rot_bits)) | (temp[i] >> rot_bits);\n    }\n    a[0] = (temp[abytes - 1] << (8 - rot_bits)) | (temp[0] >> rot_bits);\n\t// EACirc: VLA not supported in MSVC (deallocation)\n\tdelete[] temp;\n}\n\nstatic void xor_half_block(half_block out, half_block s1, half_block s2) {\n    unsigned i;\n    for (i = 0; i < 8; i++)\n        out[i] = s1[i] ^ s2[i];\n}\n\nstatic void xor_block(block out, const block s1, const block s2) {\n    unsigned i;\n    for (i = 0; i < 16; i++)\n        out[i] = s1[i] ^ s2[i];\n}\n\nstatic void pad_block(block out, const block in, int inbytes_to_pad) {\n    if (inbytes_to_pad == 16) {\n        memcpy(out, in, 16);\n        return;\n    } else {\n        memcpy(out, in, inbytes_to_pad);\n        memset(out + inbytes_to_pad, 128, 1);\n        int remaining_bytes = 16 - inbytes_to_pad - 1;\n        if (remaining_bytes)\n            memset(out + inbytes_to_pad + 1, 0, remaining_bytes);\n    }\n}\n\n/*----------------------------\n works on a half_block A and computes 2.A\n 2.A = (A<<1) xor (MSB(A).((0^59)11011))\n ----------------------------*/\nstatic void A2(half_block out, half_block A) {\n    int i;\n    int MSB = A[0] >> 7;\n    for (i = 0; i < 7; i++)\n        out[i] = (A[i] << 1) | (A[i + 1] >> 7);\n    out[7] = (A[7] << 1) ^ (MSB * 27);\n}\n\n/*----------------------------\n works on a half_block A and computes 3.A\n 3.A = (A) xor (2.A)\n ----------------------------*/\nstatic void A3(half_block out, half_block A) {\n    half_block temp;\n    memcpy(temp, A, 8);\n    A2(A, A);\n    xor_half_block(A, A, temp);\n    memcpy(out, A, 8);\n}\n\n/*----------------------------\n works on a half_block A and computes 4.A\n 4.A = 2.(2.A)\n ----------------------------*/\nstatic void A4(half_block out, half_block A) {\n    A2(A, A);\n    A2(A, A);\n    memcpy(out, A, 8);\n}\n\n/*----------------------------\n works on a half_block A and computes 5.A\n 5.A = 3.(3.A)\n ----------------------------*/static void A5(half_block out, half_block A) {\n    A3(A, A);\n    A3(A, A);\n    memcpy(out, A, 8);\n}\n\n/*----------------------------\n works on a half_block A and computes 6.A\n 6.A = 3.(2.A)\n ----------------------------*/\nstatic void A6(half_block out, half_block A) {\n    A2(A, A);\n    A3(A, A);\n    memcpy(out, A, 8);\n}\n\n/*----------------------------\n F(alpha, beta, in(0..127) = {0,1}^128) =\n alpha.in(0..63) || beta.in(64..127)\n ----------------------------*/\nstatic void F(block out, block in, int alpha, int beta) {\n    half_block in0, in1;\n    memcpy(in0, in, 8);\n    memcpy(in1, &in[8], 8);\n\n    switch (alpha) {\n    case 2:\n        A2(in0, in0);\n        break;\n    case 3:\n        A3(in0, in0);\n        break;\n    case 4:\n        A4(in0, in0);\n        break;\n    case 5:\n        A5(in0, in0);\n        break;\n    case 6:\n        A6(in0, in0);\n        break;\n    }\n\n    switch (beta) {\n    case 2:\n        A2(in1, in1);\n        break;\n    case 3:\n        A3(in1, in1);\n        break;\n    case 4:\n        A4(in1, in1);\n        break;\n    case 5:\n        A5(in1, in1);\n        break;\n    case 6:\n        A6(in1, in1);\n        break;\n    }\n    memcpy(out, in0, 8);\n    memcpy(&out[8], in1, 8);\n}\n\n/*----------------------------\n computes a tau-bit tag value for the associated data \"A\" using \"key\"\n this value will be used in the process of message encryption and authentication\n ----------------------------*/\nstatic void H(unsigned char *out, const unsigned char *key,\n        const unsigned char *in, long long abytes) {\n    AES_KEY aes_key;\n    block S, L, temp, delta;\n    AES_set_encrypt_key(key, KEYBYTES * 8, &aes_key);\n\n    memset(S, 0, 16);\n    unsigned char tau_char = tau_par & 0xFF;\n    unsigned char b_char = b_par & 0xFF;\n\n    temp[0] = tau_char;\n    temp[1] = b_char;\n    memset(temp + 2, 0, 14);\n\n    AES_encrypt(temp, L, &aes_key);\n\n    L[15] = L[15] | 0x03;\n    rotate(L, 1, 16);\n    F(delta, L, 2, 2);\n\n    long long i;\n    for (i = 1; i <= abytes / 16; i++, in = in + 16) {\n        F(delta, delta, 2, 2);\n        xor_block(temp, in, delta);\n        AES_encrypt(temp, temp, &aes_key);\n        xor_block(S, S, temp);\n    }\n\n    int last_block_bytes = abytes % 16;\n    if (last_block_bytes > 0) {\n        F(delta, delta, 3, 3);\n        pad_block(temp, in, last_block_bytes);\n        xor_block(temp, temp, delta);\n        AES_encrypt(temp, temp, &aes_key);\n        xor_block(S, S, temp);\n    }\n    memcpy(out, S, TAGBYTES);\n}\n\nstatic int enc(unsigned char *c, const unsigned char *key,\n        const unsigned char *nonce, const unsigned char *a, long long abytes,\n        const unsigned char *m, long long inbytes) {\n\n    const unsigned char* in = m;\n    unsigned char* out = c;\n    AES_KEY aes_key;\n    AES_set_encrypt_key(key, KEYBYTES * 8, &aes_key);\n    block temp1, temp2, R, delta, T_A, T, S;\n    H(T_A, key, a, abytes);\n\n    // R = E((0^(128 - nonce_bytes - 2)) || (tau) || (b) || (nonce))\n    unsigned char tau_char = tau_par & 0xFF;\n    unsigned char b_char = b_par & 0xFF;\n\n    if (16 - NONCEBYTES - 2 > 0)\n        memset(temp1, 0, 16 - NONCEBYTES - 2);\n    temp1[16 - NONCEBYTES - 2] = tau_char;\n    temp1[16 - NONCEBYTES - 1] = b_char;\n    memcpy(&temp1[16 - NONCEBYTES], nonce, NONCEBYTES);\n    AES_encrypt(temp1, R, &aes_key);\n    int bytes_1 = l_par / 8;\n    memcpy(temp2, R, 16);\n    if (bytes_1 > 0)\n        memset(temp2 + 16 - bytes_1, 255, bytes_1);\n    temp2[15 - bytes_1] |= 0x03;\n    rotate(temp2, (l_par / 2) + 1, 16);\n    F(delta, temp2, 2, 2);\n\n    if ((inbytes * 8) <= l_par) {\n\t\t// EACirc: VLA not supported in MSVC (allocation)\n\t\t//unsigned char C_0[inbytes];\n\t\tunsigned char* C_0 = new unsigned char[inbytes];\n        int i;\n        for (i = 0; i < inbytes; i++, out++, in++) {\n            C_0[i] = *in ^ R[16 - inbytes + i];\n            *out = C_0[i];\n        }\n\n        F(delta, delta, 3, 3);\n\n        pad_block(temp1, C_0, inbytes);\n\n        if (16 - TAGBYTES > 0)\n            memset(temp2, 0, 16 - TAGBYTES);\n        memcpy(&temp2[16 - TAGBYTES], T_A, TAGBYTES);\n\n        xor_block(temp1, temp1, temp2);\n        xor_block(temp1, temp1, delta);\n        AES_encrypt(temp1, temp1, &aes_key);\n        memcpy(out, temp1, TAGBYTES);\n        out = out + TAGBYTES;\n\t\t// EACirc: VLA not supported in MSVC (deallocation)\n\t\tdelete[] C_0;\n        return 0;\n    }\n\n    int l_bytes = l_par / 8;\n\t// EACirc: VLA not supported in MSVC (allocation)\n\t//unsigned char temp_l[(l_bytes)], C_0[(l_bytes)];\n\tunsigned char* temp_l = new unsigned char[(l_bytes)];\n\tunsigned char* C_0 = new unsigned char[(l_bytes)];\n    memcpy(temp_l, &R[16 - (l_bytes)], (l_bytes));\n\n    int i;\n    for (i = 0; i < l_bytes; i++, in++, out++) {\n        C_0[i] = *in ^ temp_l[i];\n        *out = C_0[i];\n    }\n\n    // T = T_A xor ((0^(tau-l))||C_0)\n    if ((tau_par - l_par) / 8 > 0)\n        memset(temp1, 0, (tau_par - l_par) / 8);\n    memcpy(&temp1[(tau_par - l_par) / 8], C_0, l_bytes);\n    for (i = 0; i < (TAGBYTES); i++)\n        T[i] = T_A[i] ^ temp1[i];\n    if (n_par / 8 > 0)\n        memset(S, 0, n_par / 8);\n\n\t// EACirc: VLA not supported in MSVC (deallocation)\n\tdelete[] temp_l;\n\tdelete[] C_0;\n\n    long long total_blocks = (inbytes - l_bytes) / 16;\n    int remaining_bytes = (inbytes - l_bytes) % 16;\n    if (remaining_bytes > 0)\n        total_blocks++;\n    else\n        remaining_bytes = 16;\n\n    for (i = 1; i <= total_blocks - 1; i++, in += 16, out += 16) {\n        xor_block(S, in, S);\n        F(delta, delta, 2, 2);\n        xor_block(temp1, in, delta);\n        AES_encrypt(temp1, temp1, &aes_key);\n        xor_block(out, temp1, delta);\n    }\n\n    if ((remaining_bytes <= (n_par - tau_par ) / 8) && (total_blocks >= 2)) {\n        out -= 16;\n        // C_{m-1} xor delta\n        xor_block(temp1, out, delta);\n\n        memcpy(temp2, in, remaining_bytes);\n        memcpy(&temp2[remaining_bytes], T, TAGBYTES);\n        xor_block(out, temp2, temp1);\n        int C_m_1_length = (TAGBYTES) + remaining_bytes;\n        out += C_m_1_length;\n\n        F(delta, delta, 3, 3);\n\n        pad_block(temp1, out - C_m_1_length, C_m_1_length);\n        xor_block(temp1, temp1, delta);\n        AES_encrypt(temp1, temp1, &aes_key);\n        xor_block(out, temp1, S);\n        out += 16;\n        return 0;\n    } else {\n        pad_block(temp1, in, remaining_bytes);\n\n        xor_block(S, S, temp1);\n        F(delta, delta, 2, 4);\n\n        if (16 - TAGBYTES > 0)\n            memset(temp1, 0, 16 - TAGBYTES);\n        memcpy(&temp1[16 - TAGBYTES], T, TAGBYTES);\n        xor_block(temp1, temp1, delta);\n        AES_encrypt(temp1, temp1, &aes_key);\n        int i;\n        for (i = 0; i < remaining_bytes; i++, in++, out++)\n            *out = *in ^ temp1[i];\n        if (remaining_bytes < 16)\n            F(delta, delta, 3, 5);\n        else\n            F(delta, delta, 5, 3);\n\n        if (16 - TAGBYTES > 0)\n            memset(temp1, 0, 16 - TAGBYTES);\n        memcpy(&temp1[16 - TAGBYTES], T, TAGBYTES);\n        xor_block(temp1, temp1, delta);\n        xor_block(temp1, temp1, S);\n        AES_encrypt(temp1, temp1, &aes_key);\n        memcpy(out, temp1, TAGBYTES);\n        out += TAGBYTES;\n        return 0;\n    }\n    return -1;\n}\n\nstatic int dec(unsigned char *m, const unsigned char *key,\n        const unsigned char *nonce, const unsigned char *a, long long abytes,\n        const unsigned char *c, long long inbytes) {\n\n    const unsigned char* in = c;\n    unsigned char* out = m;\n    AES_KEY aes_key, aes_decrypt_key;\n    AES_set_encrypt_key(key, KEYBYTES * 8, &aes_key);\n    AES_set_decrypt_key(key, KEYBYTES * 8, &aes_decrypt_key);\n    block temp1, temp2, R, delta, T_A, T, S, M_0, C_0;\n    if (inbytes * 8 < tau_par) {\n        return -1;\n    }\n    H(T_A, key, a, abytes);\n\n    // R = E((0^(128 - nonce_bytes - 2)) || (tau) || (b) || (nonce))\n    unsigned char tau_char = tau_par & 0xFF;\n    unsigned char b_char = b_par & 0xFF;\n    if (16 - NONCEBYTES - 2 > 0)\n        memset(temp1, 0, 16 - NONCEBYTES - 2);\n    temp1[16 - NONCEBYTES - 2] = tau_char;\n    temp1[16 - NONCEBYTES - 1] = b_char;\n    memcpy(&temp1[16 - NONCEBYTES], nonce, NONCEBYTES);\n    AES_encrypt(temp1, R, &aes_key);\n\n    int bytes_1 = l_par / 8;\n    memcpy(temp2, R, 16);\n    if (bytes_1 > 0)\n        memset(temp2 + 16 - bytes_1, 255, bytes_1);\n    temp2[15 - bytes_1] |= 0x03;\n    rotate(temp2, (l_par / 2) + 1, 16);\n    F(delta, temp2, 2, 2);\n\n    if (inbytes * 8 <= l_par + tau_par) {\n        int i, C_0_bytes = inbytes - (TAGBYTES);\n        for (i = 0; i < C_0_bytes; i++, in++) {\n            C_0[i] = *in;\n            M_0[i] = *in ^ R[16 - C_0_bytes + i];\n        }\n\n        F(delta, delta, 3, 3);\n        pad_block(temp1, C_0, C_0_bytes);\n\n        if (16 - TAGBYTES > 0)\n            memset(temp2, 0, 16 - TAGBYTES);\n        memcpy(&temp2[16 - TAGBYTES], T_A, TAGBYTES);\n\n        xor_block(temp1, temp1, temp2);\n        xor_block(temp1, temp1, delta);\n\n        AES_encrypt(temp1, temp1, &aes_key);\n        int validation_test = memcmp(temp1, in, TAGBYTES);\n\n        if (validation_test == 0) {\n            memcpy(out, M_0, C_0_bytes);\n            out += C_0_bytes;\n            return 0;\n        } else {\n            return -1;\n        }\n    }\n\n    int l_bytes = l_par / 8;\n\t// EACirc: VLA not supported in MSVC (allocation)\n\t//unsigned char temp_l[(l_bytes)];\n\tunsigned char* temp_l = new unsigned char[(l_bytes)];\n    memcpy(temp_l, &R[16 - (l_bytes)], (l_bytes));\n    int i;\n\n    for (i = 0; i < l_bytes; i++, in += 1, out += 1) {\n        C_0[i] = *in;\n        M_0[i] = *in ^ temp_l[i];\n        *out = M_0[i];\n    }\n\n\t// EACirc: VLA not supported in MSVC (deallocation)\n\tdelete[] temp_l;\n\n    // T = T_A xor ((0^(tau-l))||C_0)\n    if ((tau_par - l_par) / 8 > 0)\n        memset(temp1, 0, (tau_par - l_par) / 8);\n    memcpy(temp1 + (tau_par - l_par) / 8, C_0, l_bytes);\n\n    for (i = 0; i < (TAGBYTES); i++)\n        T[i] = T_A[i] ^ temp1[i];\n    memset(S, 0, 16);\n\n    long long total_blocks = (inbytes - l_bytes) / 16;\n    int remaining_bytes = (inbytes - l_bytes) % 16;\n    if (remaining_bytes > 0)\n        total_blocks++;\n    else\n        remaining_bytes = 16;\n\n    for (i = 1; i <= (total_blocks - 2); i++, in += 16, out += 16) {\n        F(delta, delta, 2, 2);\n        xor_block(temp1, in, delta);\n        AES_decrypt(temp1, temp1, &aes_decrypt_key);\n        xor_block(out, temp1, delta);\n        xor_block(S, S, out);\n    }\n    block C_m_1, C_m, M_m_1, delta_prime;\n    if ((remaining_bytes > (TAGBYTES)) && (total_blocks >= 2)) {\n        memcpy(C_m_1, in, remaining_bytes);\n        in += remaining_bytes;\n        memcpy(C_m, in, 16);\n        in += 16;\n        F(delta_prime, delta, 6, 6);\n\n        pad_block(temp1, C_m_1, remaining_bytes);\n        xor_block(temp1, temp1, delta_prime);\n        AES_encrypt(temp1, temp1, &aes_key);\n        xor_block(temp1, temp1, S);\n        xor_block(M_m_1, C_m, temp1);\n        memcpy(out, M_m_1, 16);\n        out += 16;\n\n        F(delta, delta, 2, 2);\n        xor_block(temp1, M_m_1, delta);\n        AES_encrypt(temp1, temp1, &aes_key);\n        xor_block(temp1, C_m_1, temp1);\n\n        block T_prime;\n        memcpy(out, temp1, remaining_bytes - (TAGBYTES));\n        out += remaining_bytes - (TAGBYTES);\n        memcpy(T_prime, temp1 + remaining_bytes - (TAGBYTES), TAGBYTES);\n        int validation_test = memcmp(T, T_prime, (TAGBYTES));\n        if (validation_test == 0)\n            return 0;\n        else\n            return -1;\n    } else {\n        int C_m_1_length;\n        if (total_blocks == 1) {\n            C_m_1_length = remaining_bytes - (TAGBYTES);\n            memcpy(C_m_1, in, C_m_1_length);\n            in += C_m_1_length;\n            memcpy(C_m, in, (TAGBYTES));\n            in += (TAGBYTES);\n        } else {\n            C_m_1_length = 16 + remaining_bytes - (TAGBYTES);\n            memcpy(C_m_1, in, C_m_1_length);\n            in += C_m_1_length;\n            memcpy(C_m, in, (TAGBYTES));\n            in += (TAGBYTES);\n        }\n\n        F(delta, delta, 2, 4);\n        if (16 - TAGBYTES > 0)\n            memset(temp1, 0, 16 - TAGBYTES);\n        memcpy(&temp1[16 - TAGBYTES], T, TAGBYTES);\n        xor_block(temp1, temp1, delta);\n        AES_encrypt(temp1, temp1, &aes_key);\n        xor_block(temp1, C_m_1, temp1);\n        memcpy(out, temp1, C_m_1_length);\n\n        out += C_m_1_length;\n        pad_block(temp1, temp1, C_m_1_length);\n        xor_block(S, S, temp1);\n        if (C_m_1_length < 16)\n            F(delta, delta, 3, 5);\n        else\n            F(delta, delta, 5, 3);\n        if (16 - TAGBYTES > 0)\n            memset(temp1, 0, 16 - TAGBYTES);\n        memcpy(&temp1[16 - TAGBYTES], T, TAGBYTES);\n        xor_block(temp1, temp1, delta);\n        xor_block(temp1, temp1, S);\n        AES_encrypt(temp1, temp1, &aes_key);\n\n        int validation_test = memcmp(C_m, temp1, TAGBYTES);\n        if (validation_test == 0)\n            return 0;\n        else\n            return -1;\n    }\n\n}\n\nint crypto_aead_encrypt(unsigned char *c, unsigned long long *clen,\n        const unsigned char *m, unsigned long long mlen,\n        const unsigned char *ad, unsigned long long adlen,\n        const unsigned char *nsec, const unsigned char *npub,\n        const unsigned char *k) {\n\n    int res = enc(c, k, npub, ad, adlen, m, mlen);\n    *clen = mlen + (long long)TAGBYTES;\n    return res;\n}\n\nint crypto_aead_decrypt(unsigned char *m, unsigned long long *mlen,\n        unsigned char *nsec, const unsigned char *c, unsigned long long clen,\n        const unsigned char *ad, unsigned long long adlen,\n        const unsigned char *npub, const unsigned char *k) {\n\n    int res = dec(m, k, npub, ad, adlen, c, clen);\n    *mlen = clen - (long long)TAGBYTES;\n    return res;\n}\n\n} // namespace Cba10_raw\n"
        },
        {
            "file_name": "cbc_v2.cc",
            "content": "/*\nCopyright (c) 2019 Stuart Steven Calder\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and\nthe following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n#include <cstdio>\n\n#include <ssc/general/print.hh>\n#include <ssc/general/symbols.hh>\n#include <ssc/memory/os_memory_locking.hh>\n\n#include \"cbc_v2.hh\"\n#include \"input_abstraction.hh\"\n\n#ifdef __OpenBSD__\n#\tinclude <unistd.h> // Include so we may use unveil() and pledge().\n#endif\n\nnamespace threecrypt::cbc_v2 {\n\n\tstatic size_t\n\tcalculate_encrypted_size\t(size_t const pre_encryption_size) {\n\t\t/* CBC_V2 encrypted files */\n\t\tconstexpr auto const File_Metadata_Size = CBC_V2_Header_t::Total_Size + MAC_Bytes;\n\t\tauto s = pre_encryption_size;\n\t\tif ( s < Block_Bytes )\n\t\t\ts = Block_Bytes;\n\t\telse\n\t\t\ts += (Block_Bytes - (s % Block_Bytes));\n\t\treturn s + File_Metadata_Size;\n\t}\n\n\tvoid\n\tencrypt\t(Input_Abstraction const & input_abstr) {\n\t\tusing namespace std;\n\n\t\tssc::OS_Map input_map, output_map;\n\n/* OpenBSD-specific security enhancing systemcalls */\n#ifdef __OpenBSD__\n\t\t// Allow reading and executing everything under /usr.\n\t\tif (unveil( \"/usr\", \"rx\" ) != 0) {\n\t\t\tfputs( \"Error: Failed to unveil() /usr\\n\", stderr );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\t\t// Allow reading the input file.\n\t\tif (unveil( input_abstr.input_filename.c_str(), \"r\" ) != 0) {\n\t\t\tfputs( \"Error: Failed to unveil() the input file...\\n\", stderr );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\t\t// Allow reading, writing, and creating the output file.\n\t\tif (unveil( input_abstr.output_filename.c_str(), \"rwc\" ) != 0) {\n\t\t\tfputs( \"Error: Failed to unveil() the output file...\\n\", stderr );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\t\t// Disallow further unveil() calls.\n\t\tif (unveil( NULL, NULL ) != 0) {\n\t\t\tfputs( \"Error: Failed to finalize unveil()\\n\", stderr );\n\t\t}\n\t\tputs( \"Successfully restricted filesystem visibility with unveil()\" );\n#endif\n\n\t\tputs( \"Opening input and output files...\" );\n\t\t// Open input file\n\t\tinput_map.os_file = ssc::open_existing_os_file( input_abstr.input_filename.c_str(), true );\n\t\t// Create output file\n\t\toutput_map.os_file = ssc::create_os_file( input_abstr.output_filename.c_str() );\n\t\t// Determine input file size\n\t\tinput_map.size = ssc::get_file_size( input_map.os_file );\n\t\t// Determine output file size\n                output_map.size = calculate_encrypted_size( input_map.size );\n\t\t// Extend or shrink the output file to match calculated file size\n\t\tputs( \"Resizing output file...\" );\n\t\tssc::set_os_file_size( output_map.os_file, output_map.size );\n\t\t// Memory-Map the files\n\t\tputs( \"Mapping input file...\" );\n\t\tssc::map_file( input_map, true );\n\t\tputs( \"Mapping output file...\" );\n\t\tssc::map_file( output_map, false );\n\t\t// Get the password\n\t\tconstexpr auto const Password_Buffer_Bytes = Max_Password_Length + 1;\n\t\tchar password [Password_Buffer_Bytes];\n\t\tint password_length;\n\t\t{\n\t\t\tssc::Terminal term;\n\t\t\tchar pwcheck [Password_Buffer_Bytes];\n#ifdef __SSC_memlocking__\n\t\t\tssc::lock_os_memory( password, Password_Buffer_Bytes );\n\t\t\tssc::lock_os_memory( pwcheck , Password_Buffer_Bytes );\n\t\t\tputs( \"Successfully locked the password buffer(s)...\" );\n#endif\n\t\t\tbool repeat = true;\n\t\t\tdo {\n\t\t\t\tstatic_assert (sizeof(password) == Password_Buffer_Bytes);\n\t\t\t\tstatic_assert (sizeof(pwcheck)  == Password_Buffer_Bytes);\n\t\t\t\tmemset( password, 0, Password_Buffer_Bytes );\n\t\t\t\tmemset( pwcheck , 0, Password_Buffer_Bytes );\n\t\t\t\tpassword_length = term.get_pw( password, Max_Password_Length, 1 );\n\t\t\t\tstatic_cast<void>(term.get_pw( pwcheck , Max_Password_Length, 1 ));\n\t\t\t\tif (memcmp( password, pwcheck, Password_Buffer_Bytes ) == 0)\n\t\t\t\t\trepeat = false;\n\t\t\t\telse\n\t\t\t\t\tterm.notify( \"Passwords don't match.\" );\n\t\t\t} while (repeat);\n\t\t\tssc::zero_sensitive( pwcheck, Password_Buffer_Bytes );\n#ifdef __SSC_memlocking__\n\t\t\tssc::unlock_os_memory( pwcheck, Password_Buffer_Bytes );\n#endif\n\t\t}\n\t\t// Create a header\n\t\tCBC_V2_Header_t header;\n\t\tstatic_assert (sizeof(header.id) == sizeof(CBC_V2_ID));\n\t\tmemcpy( header.id, CBC_V2_ID, sizeof(header.id) );\n\t\theader.total_size = static_cast<decltype(header.total_size)>(output_map.size);\n\t\tputs( \"Getting entropy from the OS...\" );\n\t\tssc::obtain_os_entropy( header.tweak      , sizeof(header.tweak)       );\n\t\tssc::obtain_os_entropy( header.sspkdf_salt, sizeof(header.sspkdf_salt) );\n\t\tssc::obtain_os_entropy( header.cbc_iv     , sizeof(header.cbc_iv)      );\n\t\theader.num_iter   = input_abstr.number_iterations;\n\t\theader.num_concat = input_abstr.number_concatenations;\n\t\t// Copy header into the file, field at a time, advancing the pointer\n\t\tu8_t * out = output_map.ptr;\n\t\t{\n\t\t\tputs( \"Copying header into the output file...\" );\n\t\t\tmemcpy( out, header.id, sizeof(header.id) );\n\t\t\tout += sizeof(header.id);\n\n\t\t\tmemcpy( out, &header.total_size, sizeof(header.total_size) );\n\t\t\tout += sizeof(header.total_size);\n\n\t\t\tmemcpy( out, header.tweak, sizeof(header.tweak) );\n\t\t\tout += sizeof(header.tweak);\n\n\t\t\tmemcpy( out, header.sspkdf_salt, sizeof(header.sspkdf_salt) );\n\t\t\tout += sizeof(header.sspkdf_salt);\n\n\t\t\tmemcpy( out, header.cbc_iv, sizeof(header.cbc_iv) );\n\t\t\tout += sizeof(header.cbc_iv);\n\n\t\t\tmemcpy( out, &header.num_iter, sizeof(header.num_iter) );\n\t\t\tout += sizeof(header.num_iter);\n\n\t\t\tmemcpy( out, &header.num_concat, sizeof(header.num_concat) );\n\t\t\tout += sizeof(header.num_concat);\n\t\t}\n\n\t\t// Generate a 512-bit symmetric key using the password we got earlier as input\n\t\tputs( \"Generating symmetric key using sspkdf...\" );\n\t\tu8_t derived_key [Block_Bytes];\n#ifdef __SSC_memlocking__\n\t\tssc::lock_os_memory( derived_key, sizeof(derived_key) );\n\t\tputs( \"Successfully locked the derived key...\" );\n#endif\n\t\tssc::sspkdf( derived_key, password, password_length, header.sspkdf_salt, header.num_iter, header.num_concat );\n\t\t// Securely zero over the password buffer after we've used it to generate the symmetric key\n\t\tssc::zero_sensitive( password, sizeof(password) );\n#ifdef __SSC_memlocking__\n\t\tssc::unlock_os_memory( password, sizeof(password) );\n#endif\n\t\t{\n\t\t\t// Encrypt the input file, writing the ciphertext into the memory-mapped output file\n\t\t\tputs( \"Encrypting...\" );\n\t\t\tCBC_t cbc{ Threefish_t{ derived_key, header.tweak } };\n\t\t\tout += cbc.encrypt( input_map.ptr, out, input_map.size, header.cbc_iv );\n\t\t}\n\t\t{\t/* Create a 512-bit Message Authentication Code of the ciphertext, using the derived key and the ciphertext with Skein's native MAC\n\t\t \t   then append the MAC to the end of the ciphertext */\n\t\t\tputs( \"Generating 512-bit Message Authentication Code...\" );\n\t\t\tSkein_t skein;\n\t\t\tskein.message_auth_code( out, output_map.ptr, derived_key, output_map.size - MAC_Bytes, sizeof(derived_key), MAC_Bytes );\n\t\t}\n\t\t// Securely zero over the derived key\n\t\tssc::zero_sensitive( derived_key, sizeof(derived_key) );\n#ifdef __SSC_memlocking__\n\t\tssc::unlock_os_memory( derived_key, sizeof(derived_key) );\n#endif\n\t\t// Synchronize everything written to the output file\n\t\tputs( \"Synchronizing output mapping...\" );\n\t\tssc::sync_map( output_map );\n\t\t// Unmap the input and output files\n\t\tputs( \"Unmapping files...\" );\n\t\tssc::unmap_file( input_map );\n\t\tssc::unmap_file( output_map );\n\t\t// Close the input and output files\n\t\tputs( \"Closing files...\" );\n\t\tssc::close_os_file( input_map.os_file );\n\t\tssc::close_os_file( output_map.os_file );\n\t}/* encrypt */\n\tvoid\n\tdecrypt\t(char const *__restrict input_filename,\n\t\t char const *__restrict output_filename) {\n\t\tusing namespace std;\n\n\t\tssc::OS_Map input_map, output_map;\n#ifdef __OpenBSD__\n\t\t// Allow reading and executing everything under /usr.\n\t\tif (unveil( \"/usr\", \"rx\" ) != 0) {\n\t\t\tfputs( \"Error: Failed to unveil() /usr\\n\", stderr );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\t\t// Allow reading the input file.\n\t\tif (unveil( input_filename, \"r\" ) != 0) {\n\t\t\tfputs( \"Error: Failed to unveil() the input file...\\n\", stderr );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\t\t// Allow reading, writing, and creating the output file.\n\t\tif (unveil( output_filename, \"rwc\" ) != 0) {\n\t\t\tfputs( \"Error: Failed to unveil() the output file...\\n\", stderr );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\t\t// Disallow further unveil() calls.\n\t\tif (unveil( NULL, NULL ) != 0) {\n\t\t\tfputs( \"Error: Failed to finalize unveil()\\n\", stderr );\n\t\t}\n\t\tputs( \"Successfully restricted filesystem visibility with unveil()\" );\n#endif\n\t\tputs( \"Opening input and output files...\" );\n\t\tinput_map.os_file  = ssc::open_existing_os_file( input_filename, true );\n\t\toutput_map.os_file = ssc::create_os_file( output_filename );\n\t\t// Get the size fo the input file\n\t\tinput_map.size = ssc::get_file_size( input_map.os_file );\n\t\t// For now, assume the size of the output file will be the same size as the input file\n\t\toutput_map.size = input_map.size;\n\t\t// Check to see if the input file is too small to have possibly been 3crypt encrypted, using any supported means\n\t\tstatic constexpr auto const Minimum_Possible_File_Size = CBC_V2_Header_t::Total_Size + Block_Bytes + MAC_Bytes;\n\t\tputs( \"Checking input file size...\" );\n\t\tif (input_map.size < Minimum_Possible_File_Size) {\n\t\t\tfprintf( stderr, \"Error: Input file doesn't appear to be large enough to be a %s encrypted file\\n\", CBC_V2_ID );\n\t\t\tssc::close_os_file( input_map.os_file );\n\t\t\tssc::close_os_file( output_map.os_file );\n\t\t\tremove( output_filename );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\t\t// Set the output file to be `f_data.output_filesize` bytes\n\t\tputs( \"Resizing output file...\" );\n\t\tssc::set_os_file_size( output_map.os_file, output_map.size );\n\t\t// Memory-map the input and output files\n\t\tputs( \"Mapping input file...\" );\n\t\tssc::map_file( input_map, true );\n\t\tputs( \"Mapping output file...\" );\n\t\tssc::map_file( output_map, false );\n\t\t// `in` pointer used for reading from the input files, and incremented as it's used to read\n\t\tu8_t const * in = input_map.ptr;\n\t\tCBC_V2_Header_t header;\n\t\t/* Copy all the fields of CBC_V2_Header_t from the memory-mapped file\n\t\t   into the header struct */\n\t\t{\n\t\t\tputs( \"Copying header from the input file into memory...\" );\n\t\t\tmemcpy( header.id, in, sizeof(header.id) );\n\t\t\tin += sizeof(header.id);\n\n\t\t\tmemcpy( &header.total_size, in, sizeof(header.total_size) );\n\t\t\tin += sizeof(header.total_size);\n\n\t\t\tmemcpy( header.tweak, in, sizeof(header.tweak) );\n\t\t\tin += sizeof(header.tweak);\n\n\t\t\tmemcpy( header.sspkdf_salt, in, sizeof(header.sspkdf_salt) );\n\t\t\tin += sizeof(header.sspkdf_salt);\n\n\t\t\tmemcpy( header.cbc_iv, in, sizeof(header.cbc_iv) );\n\t\t\tin += sizeof(header.cbc_iv);\n\n\t\t\tmemcpy( &header.num_iter, in, sizeof(header.num_iter) );\n\t\t\tin += sizeof(header.num_iter);\n\n\t\t\tmemcpy( &header.num_concat, in, sizeof(header.num_concat) );\n\t\t\tin += sizeof(header.num_concat);\n\t\t}\n\t\t// Check for the magic \"3CRYPT_CBC_V2\" at the beginning of the file header\n\t\tstatic_assert (sizeof(header.id) == sizeof(CBC_V2_ID));\n\t\tputs( \"Checking header ID...\" );\n\t\tif (memcmp( header.id, CBC_V2_ID, sizeof(CBC_V2_ID) ) != 0) {\n\t\t\tfprintf( stderr, \"Error: The input file doesn't appear to be a %s encrypted file.\\n\", CBC_V2_ID );\n\t\t\tssc::unmap_file( input_map );\n\t\t\tssc::unmap_file( output_map );\n\t\t\tssc::close_os_file( input_map.os_file );\n\t\t\tssc::close_os_file( output_map.os_file );\n\t\t\tremove( output_filename );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\t\t// Check that the input file is the same size as specified by the file header\n\t\tputs( \"Comparing file size with size in the input file header...\" );\n\t\tif (header.total_size != static_cast<decltype(header.total_size)>(input_map.size)) {\n\t\t\tfprintf( stderr, \"Error: Input file size (%zu) does not equal file size in the file header of the input file (%zu)\\n\",\n\t\t\t\t input_map.size, header.total_size );\n\t\t\tssc::unmap_file( input_map );\n\t\t\tssc::unmap_file( output_map );\n\t\t\tssc::close_os_file( input_map.os_file );\n\t\t\tssc::close_os_file( output_map.os_file );\n\t\t\tremove( output_filename );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\t\t// Get the password\n\t\tchar password [Max_Password_Length + 1] = { 0 };\n#ifdef __SSC_memlocking__\n\t\tssc::lock_os_memory( password, sizeof(password) );\n\t\tputs( \"Successfully locked the password buffer(s)...\" );\n#endif\n\t\tint password_length;\n\t\t{\n\t\t\tssc::Terminal term;\n\t\t\tpassword_length = term.get_pw( password, Max_Password_Length, 1 );\n\t\t}\n\t\t// Generate a 512-bit symmetric key from the given password\n\t\tu8_t derived_key [Block_Bytes];\n#ifdef __SSC_memlocking__\n\t\tssc::lock_os_memory( derived_key, sizeof(derived_key) );\n\t\tputs( \"Successfully locked the derived key...\" );\n#endif\n\t\tputs( \"Generating symmetric key using sspkdf...\" );\n\t\tssc::sspkdf( derived_key, password, password_length, header.sspkdf_salt, header.num_iter, header.num_concat );\n\t\t// Securely zero over the password now that we have the derived key\n\t\tssc::zero_sensitive( password, sizeof(password) );\n#ifdef __SSC_memlocking__\n\t\tssc::unlock_os_memory( password, sizeof(password) );\n#endif\n\t\t{\n\t\t\t// Generate a MAC using the ciphertext and the derived key, and compare it to the MAC at the end of the input file\n\t\t\tu8_t gen_mac [MAC_Bytes];\n\t\t\t{\n\t\t\t\tputs( \"Generating 512-bit Message Authentication Code...\" );\n\t\t\t\tSkein_t skein;\n\t\t\t\tskein.message_auth_code( gen_mac,\n\t\t\t\t\t\t\t input_map.ptr,\n\t\t\t\t\t\t\t derived_key,\n\t\t\t\t\t\t\t input_map.size - MAC_Bytes,\n\t\t\t\t\t\t\t sizeof(derived_key),\n\t\t\t\t\t\t\t sizeof(gen_mac) );\n\t\t\t}\n\t\t\tputs( \"Comparing generated MAC with the MAC at the end of the input file...\" );\n\t\t\tif (memcmp( gen_mac, (input_map.ptr + input_map.size - MAC_Bytes), MAC_Bytes) != 0) {\n\t\t\t\tssc::zero_sensitive( derived_key, sizeof(derived_key) );\n#ifdef __SSC_memlocking__\n\t\t\t\tssc::unlock_os_memory( derived_key, sizeof(derived_key) );\n#endif\n\t\t\t\tfputs( \"Error: Authentication failed.\\n\"\n\t\t\t\t       \"Possibilities: Wrong password, the file is corrupted, or it has been somehow tampered with.\\n\", stderr );\n\t\t\t\tssc::unmap_file( input_map );\n\t\t\t\tssc::unmap_file( output_map );\n\t\t\t\tssc::close_os_file( input_map.os_file );\n\t\t\t\tssc::close_os_file( output_map.os_file );\n\t\t\t\tremove( output_filename );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t}\n\t\tsize_t plaintext_size;\n\t\t{\n\t\t\t// Decrypt the input file's ciphertext into the output file, recording the number of bytes of plaintext in `plaintext_size`\n\t\t\tputs( \"Decrypting...\" );\n\t\t\tCBC_t cbc{ Threefish_t{ derived_key, header.tweak } };\n\t\t\t// Securely zero over the derived key now that we're done with it\n\t\t\tssc::zero_sensitive( derived_key, sizeof(derived_key) );\n#ifdef __SSC_memlocking__\n\t\t\tssc::unlock_os_memory( derived_key, sizeof(derived_key) );\n#endif\n\t\t\tstatic constexpr auto const File_Metadata_Size = CBC_V2_Header_t::Total_Size + MAC_Bytes;\n\t\t\tplaintext_size = cbc.decrypt( in,\n\t\t\t\t\t\t      output_map.ptr,\n\t\t\t\t\t\t      input_map.size - File_Metadata_Size,\n\t\t\t\t\t\t      header.cbc_iv );\n\t\t}\n\t\t// Synchronize the output file\n\t\tputs( \"Synchronizing output mapping...\" );\n\t\tssc::sync_map( output_map );\n\t\t// Unmap the memory-mapped input and output files\n\t\tputs( \"Unmapping files...\" );\n\t\tssc::unmap_file( input_map );\n\t\tssc::unmap_file( output_map );\n\t\t// Truncate the output file to the number of plaintext bytes\n\t\tputs( \"Truncating output file to the number of plaintext bytes...\" );\n\t\tssc::set_os_file_size( output_map.os_file, plaintext_size );\n\t\t// Close the input and output files\n\t\tputs( \"Closing files...\" );\n\t\tssc::close_os_file( input_map.os_file );\n\t\tssc::close_os_file( output_map.os_file );\n\t}/* decrypt */\n\t\n\tvoid\n\tdump_header\t(char const * filename) {\n\t\tusing std::memcpy, std::fprintf, std::fputs, std::putchar, std::exit;\n\t\tusing ssc::OS_Map, ssc::OS_File_t;\n\n\t\tOS_Map os_map;\n\t\tos_map.os_file = ssc::open_existing_os_file( filename, true );\n\t\tos_map.size    = ssc::get_file_size( os_map.os_file );\n\t\tstatic constexpr auto const Minimum_Size = CBC_V2_Header_t::Total_Size + Block_Bytes + MAC_Bytes;\n\t\tif (os_map.size < Minimum_Size) {\n\t\t\tssc::close_os_file( os_map.os_file );\n\t\t\tfprintf( stderr, \"File %s looks too small to be CBC_V2 encrypted\\n\", filename );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\t\tssc::map_file( os_map, true );\n\n\t\tCBC_V2_Header_t header;\n\t\tu8_t mac [MAC_Bytes];\n\t\t{\n\t\t\tu8_t const * p = os_map.ptr;\n\n\t\t\tmemcpy( header.id, p, sizeof(header.id) );\n\t\t\tp += sizeof(header.id);\n\n\t\t\tmemcpy( &header.total_size, p, sizeof(header.total_size) );\n\t\t\tp += sizeof(header.total_size);\n\n\t\t\tmemcpy( header.tweak, p, sizeof(header.tweak) );\n\t\t\tp += sizeof(header.tweak);\n\n\t\t\tmemcpy( header.sspkdf_salt, p, sizeof(header.sspkdf_salt) );\n\t\t\tp += sizeof(header.sspkdf_salt);\n\n\t\t\tmemcpy( header.cbc_iv, p, sizeof(header.cbc_iv) );\n\t\t\tp += sizeof(header.cbc_iv);\n\n\t\t\tmemcpy( &header.num_iter, p, sizeof(header.num_iter) );\n\t\t\tp += sizeof(header.num_iter);\n\n\t\t\tmemcpy( &header.num_concat, p, sizeof(header.num_concat) );\n\n\t\t\tp = os_map.ptr + os_map.size - MAC_Bytes;\n\t\t\tmemcpy( mac, p, sizeof(mac) );\n\t\t}\n\t\tssc::unmap_file( os_map );\n\t\tssc::close_os_file( os_map.os_file );\n\n\t\tfprintf( stdout,   \"File Header ID             : %s\\n\", header.id );\n\t\tfprintf( stdout,   \"File Size                  : %zu\\n\", header.total_size );\n\t\tfputs  (           \"Threefish Tweak            : \", stdout );\n\t\tssc::print_integral_buffer<u8_t>( header.tweak, sizeof(header.tweak) );\n\t\tfputs  (         \"\\nSSPKDF Salt                : \", stdout );\n\t\tssc::print_integral_buffer<u8_t>( header.sspkdf_salt, sizeof(header.sspkdf_salt) );\n\t\tfputs  (         \"\\nCBC Initialization Vector  : \", stdout );\n\t\tssc::print_integral_buffer<u8_t>( header.cbc_iv, sizeof(header.cbc_iv) );\n\t\tfprintf( stdout, \"\\nNumber Iterations          : %u\\n\", header.num_iter );\n\t\tfprintf( stdout,   \"Number Concatenations      : %u\\n\", header.num_concat );\n\t\tfputs(             \"Message Authentication Code: \", stdout );\n\t\tssc::print_integral_buffer<u8_t>( mac, sizeof(mac) );\n\t\tstd::putchar( '\\n' );\n\t}/* ! dump_header */\n} /* ! namespace threecrypt::cbc_v2 */\n"
        },
        {
            "file_name": "cfuge.c",
            "content": "/*\n\tCentrifuge, a password hashing algorithm\n\t2014 (c) Rafael Alvarez\n*/\n#include <openssl/aes.h>\n#include <openssl/sha.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"cfuge.h\"\n\n\n\nint PHS(void *out, size_t outlen, const void *in, size_t inlen, \n\tconst void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost)\n{\n\tuint64_t m,t;\n\n\tif((m_cost > 63)||(t_cost > 63)) return -1;\n\t\n\tm = (uint64_t) 1<<(m_cost);\n\tt = (uint64_t) 1<<(t_cost);\n\treturn cfuge(in,inlen,salt,saltlen,out,outlen,m,t);\n}\n\n\n// 512 bit hash\nvoid H(const uint8_t *in, size_t len, uint8_t *out) {\n\tSHA512(in,len,out);\t\n}\n\n// encryption function (CFB mode)\nstatic AES_KEY \t\tc_key;\nstatic uint8_t \t\tc_iv[16];\nstatic int \t\t\tc_num;\n\nvoid initC(uint8_t *key, uint8_t *iv) {\n\tAES_set_encrypt_key((unsigned char *)key,256,&c_key);\n\tmemset(&c_num,0,sizeof(c_num));\n\tmemcpy(c_iv,iv,AES_BLOCK_SIZE);\n}\n\nvoid C(void *in, void *out, size_t len) {\n\tAES_cfb128_encrypt((uint8_t *)in,(uint8_t *)out,len,&c_key,c_iv,&c_num,AES_ENCRYPT);\n}\n\n\nint cfuge(\tconst uint8_t *password, uint32_t passlen,\t// password and length\n\t\t\tconst uint8_t *salt, uint32_t saltlen,  \t// salt and length\n\t\t\tuint8_t *out, uint32_t outlen,\t\t\t\t// output buffer and length\n\t\t\tconst uint64_t p_mem, \t\t\t\t\t\t// memory parameter \n\t\t\tconst uint64_t p_time \t\t\t\t\t\t// time parameter \n\t\t\t)\t\t\n{\n\tuint8_t *M; \t\t// memory table\n\tuint8_t iv[16];\t\t// initialization value (128 bit) for C\n\tuint8_t key[32];\t// key (256 bit) for C\n\tuint8_t S[256];\t\t// s-box\n\tuint8_t *Seq;\t\t// sequence to evolve s-box\n\n\n\t// allocate memory\n\tM = malloc(p_mem * outlen);\n\tif(!M) return -1;\n\tSeq = calloc(p_time,1);\n\tif(!Seq) return -1;\n\t\n\t//printf(\"%llu \",p_mem * outlen / (1024*1024));\n\n\t// seeding\n\t{\n\t\tuint8_t seedin[128],seedout[64];\n\n\t\tH(password,passlen,seedin);\n\t\tH(salt,saltlen,seedin+64);\n\t\tH(seedin,128,seedout);\n\n\t\tfor(int i=0; i<outlen; i++) \n\t\t\tout[i] = seedout[i%16];\n\t\t\n\t\tmemcpy(iv,seedout+16,16);\n\t\tmemcpy(key,seedout+32,32);\n\n\t\tinitC(key,iv);\n\t}\n\n\t// s-box initialization\n\t{\n\t\tuint8_t buf[256];\n\t\tuint8_t m,l,t;\n\n\t\tmemset(buf,0,256);\n\t\tC(buf,buf,256);\n\n\t\tfor(int i=0; i<256; i++) {\n\t\t\tS[i] = (uint8_t)i;\n\t\t}\n\n\t\tfor(int i=0; i<256; i++) {\n\t\t\tm = (uint8_t)i;\n\t\t\tl = buf[i];\n\t\t\tt = S[m];\n\t\t\tS[m] = S[l];\n\t\t\tS[l] = t;\n\t\t}\n\n\t}\n\n\t// build table\n\t{\n\t\t\n\t\tuint8_t m,l,t;\t\t// indexes to S\n\t\tuint64_t offs = 0;\t// offset into M\n\n\t\tfor(uint64_t i=0; i<p_mem; i++) {\n\t\t\t\n\t\t\t// generate sequence\n\t\t\tC(Seq,Seq,p_time);\n\t\t\t\n\t\t\t// modify S\n\t\t\tfor(uint64_t j=0; j<p_time; j++) {\t\n\t\t\t\tm = (uint8_t) j % 256;\n\t\t\t\tl = Seq[j];\n\t\t\t\tt = S[m];\n\t\t\t\tS[m] = S[l];\n\t\t\t\tS[l] = t;\n\t\t\t}\n\n\t\t\t// process output\n\t\t\tfor(uint32_t j=0; j<outlen; j++) \n\t\t\t\tout[j] = S[out[j]];\n\n\t\t\t// encrypt output\n\t\t\tC(out,out,outlen);\n\t\t\t\n\t\t\t// copy to M\n\t\t\tmemcpy(M+offs,out,outlen);\n\t\t\toffs += outlen;\n\n\t\t}\n\n\t}\n\n\t// output\n\t{\t\t\n\t\tuint64_t index = 0;\t// index into M\n\t\tuint8_t *ptr;\t\t// pointer to start of current M row\n\t\tuint8_t m,l,t;\t\t// indexes to S\n\n\t\t\n\t\t// process entry\n\t\tfor(uint64_t i=0; i<p_mem; i++) {\n\n\t\t\t// generate sequence\n\t\t\tC(Seq,Seq,p_time);\n\n\t\t\t// modify S\n\t\t\tfor(uint64_t j=0; j<p_time; j++) {\t\n\t\t\t\tm = (uint8_t) j % 256;\n\t\t\t\tl = Seq[j];\n\t\t\t\tt = S[m];\n\t\t\t\tS[m] = S[l];\n\t\t\t\tS[l] = t;\n\t\t\t}\n\n\t\t\t// generate next index\n\t\t\tC(&index,&index,8);\n\n\t\t\t// address to M\n\t\t\tptr = M + (index % p_mem) * outlen;\n\n\t\t\t// process and encrypt output\n\t\t\tfor(uint32_t j=0; j<outlen; j++) {\n\t\t\t\tout[j] = (uint8_t)(S[out[j]] + ptr[j]);\n\t\t\t}\n\t\t\tC(out,out,outlen);\n\n\t\t}\n\t}\n\n\n\t// free memory\t\t\n\tif(M) free(M);\n\tif(Seq) free(Seq);\n\treturn 0;\n}\n\n"
        },
        {
            "file_name": "chacha-crypt.c",
            "content": "/* salsa20-crypt.c\n *\n * The crypt function in the ChaCha stream cipher.\n * Heavily based on the Salsa20 implementation in Nettle.\n */\n\n/* nettle, low-level cryptographics library\n *\n * Copyright (C) 2013 Joachim Str\u00c3\u00b6mbergson\n * Copyright (C) 2012 Simon Josefsson\n *  \n * The nettle library is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or (at your\n * option) any later version.\n * \n * The nettle library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n * License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with the nettle library; see the file COPYING.LIB.  If not, write to\n * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n * MA 02111-1301, USA.\n */\n\n/* Based on:\n   chacha-ref.c version 2008.01.20.\n   D. J. Bernstein\n   Public domain.\n*/\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <string.h>\n\n#include \"chacha.h\"\n\n#include \"macros.h\"\n#include \"memxor.h\"\n\nvoid\nchachar12_crypt(struct chacha_ctx *ctx, size_t length, \n                uint8_t *dst, const uint8_t *src)\n{\n  chacha_crypt(ctx, length, 12, dst, src);\n}\n\n\nvoid\nchachar20_crypt(struct chacha_ctx *ctx, size_t length, \n                uint8_t *dst, const uint8_t *src)\n{\n  chacha_crypt(ctx, length, 20, dst, src);\n}\n\n\nvoid\nchacha_crypt(struct chacha_ctx *ctx, size_t length, uint8_t rounds,\n             uint8_t *c, const uint8_t *m)\n{\n  if (!length)\n    return;\n  \n  for (;;)\n    {\n      uint32_t x[_CHACHA_STATE_LENGTH];\n\n      _chacha_core (x, ctx->state, rounds);\n\n      ctx->state[9] += (++ctx->state[8] == 0);\n\n      /* stopping at 2^70 length per nonce is user's responsibility */\n      \n      if (length <= CHACHA_BLOCK_SIZE)\n\t{\n\t  memxor3 (c, m, x, length);\n\t  return;\n\t}\n      memxor3 (c, m, x, CHACHA_BLOCK_SIZE);\n\n      length -= CHACHA_BLOCK_SIZE;\n      c += CHACHA_BLOCK_SIZE;\n      m += CHACHA_BLOCK_SIZE;\n  }\n}\n"
        },
        {
            "file_name": "Clefia.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"Clefia_data.h\"\n\n/* S0 (8-bit S-box based on four 4-bit S-boxes) */\nconst BYTE clefia_s0[256] = {\n  0x57U, 0x49U, 0xd1U, 0xc6U, 0x2fU, 0x33U, 0x74U, 0xfbU,\n  0x95U, 0x6dU, 0x82U, 0xeaU, 0x0eU, 0xb0U, 0xa8U, 0x1cU,\n  0x28U, 0xd0U, 0x4bU, 0x92U, 0x5cU, 0xeeU, 0x85U, 0xb1U,\n  0xc4U, 0x0aU, 0x76U, 0x3dU, 0x63U, 0xf9U, 0x17U, 0xafU,\n  0xbfU, 0xa1U, 0x19U, 0x65U, 0xf7U, 0x7aU, 0x32U, 0x20U,\n  0x06U, 0xceU, 0xe4U, 0x83U, 0x9dU, 0x5bU, 0x4cU, 0xd8U,\n  0x42U, 0x5dU, 0x2eU, 0xe8U, 0xd4U, 0x9bU, 0x0fU, 0x13U,\n  0x3cU, 0x89U, 0x67U, 0xc0U, 0x71U, 0xaaU, 0xb6U, 0xf5U,\n  0xa4U, 0xbeU, 0xfdU, 0x8cU, 0x12U, 0x00U, 0x97U, 0xdaU,\n  0x78U, 0xe1U, 0xcfU, 0x6bU, 0x39U, 0x43U, 0x55U, 0x26U,\n  0x30U, 0x98U, 0xccU, 0xddU, 0xebU, 0x54U, 0xb3U, 0x8fU,\n  0x4eU, 0x16U, 0xfaU, 0x22U, 0xa5U, 0x77U, 0x09U, 0x61U,\n  0xd6U, 0x2aU, 0x53U, 0x37U, 0x45U, 0xc1U, 0x6cU, 0xaeU,\n  0xefU, 0x70U, 0x08U, 0x99U, 0x8bU, 0x1dU, 0xf2U, 0xb4U,\n  0xe9U, 0xc7U, 0x9fU, 0x4aU, 0x31U, 0x25U, 0xfeU, 0x7cU,\n  0xd3U, 0xa2U, 0xbdU, 0x56U, 0x14U, 0x88U, 0x60U, 0x0bU,\n  0xcdU, 0xe2U, 0x34U, 0x50U, 0x9eU, 0xdcU, 0x11U, 0x05U,\n  0x2bU, 0xb7U, 0xa9U, 0x48U, 0xffU, 0x66U, 0x8aU, 0x73U,\n  0x03U, 0x75U, 0x86U, 0xf1U, 0x6aU, 0xa7U, 0x40U, 0xc2U,\n  0xb9U, 0x2cU, 0xdbU, 0x1fU, 0x58U, 0x94U, 0x3eU, 0xedU,\n  0xfcU, 0x1bU, 0xa0U, 0x04U, 0xb8U, 0x8dU, 0xe6U, 0x59U,\n  0x62U, 0x93U, 0x35U, 0x7eU, 0xcaU, 0x21U, 0xdfU, 0x47U,\n  0x15U, 0xf3U, 0xbaU, 0x7fU, 0xa6U, 0x69U, 0xc8U, 0x4dU,\n  0x87U, 0x3bU, 0x9cU, 0x01U, 0xe0U, 0xdeU, 0x24U, 0x52U,\n  0x7bU, 0x0cU, 0x68U, 0x1eU, 0x80U, 0xb2U, 0x5aU, 0xe7U,\n  0xadU, 0xd5U, 0x23U, 0xf4U, 0x46U, 0x3fU, 0x91U, 0xc9U,\n  0x6eU, 0x84U, 0x72U, 0xbbU, 0x0dU, 0x18U, 0xd9U, 0x96U,\n  0xf0U, 0x5fU, 0x41U, 0xacU, 0x27U, 0xc5U, 0xe3U, 0x3aU,\n  0x81U, 0x6fU, 0x07U, 0xa3U, 0x79U, 0xf6U, 0x2dU, 0x38U,\n  0x1aU, 0x44U, 0x5eU, 0xb5U, 0xd2U, 0xecU, 0xcbU, 0x90U,\n  0x9aU, 0x36U, 0xe5U, 0x29U, 0xc3U, 0x4fU, 0xabU, 0x64U,\n  0x51U, 0xf8U, 0x10U, 0xd7U, 0xbcU, 0x02U, 0x7dU, 0x8eU\n};\n\n/* S1 (8-bit S-box based on inverse function) */\nconst BYTE clefia_s1[256] = {\n  0x6cU, 0xdaU, 0xc3U, 0xe9U, 0x4eU, 0x9dU, 0x0aU, 0x3dU,\n  0xb8U, 0x36U, 0xb4U, 0x38U, 0x13U, 0x34U, 0x0cU, 0xd9U,\n  0xbfU, 0x74U, 0x94U, 0x8fU, 0xb7U, 0x9cU, 0xe5U, 0xdcU,\n  0x9eU, 0x07U, 0x49U, 0x4fU, 0x98U, 0x2cU, 0xb0U, 0x93U,\n  0x12U, 0xebU, 0xcdU, 0xb3U, 0x92U, 0xe7U, 0x41U, 0x60U,\n  0xe3U, 0x21U, 0x27U, 0x3bU, 0xe6U, 0x19U, 0xd2U, 0x0eU,\n  0x91U, 0x11U, 0xc7U, 0x3fU, 0x2aU, 0x8eU, 0xa1U, 0xbcU,\n  0x2bU, 0xc8U, 0xc5U, 0x0fU, 0x5bU, 0xf3U, 0x87U, 0x8bU,\n  0xfbU, 0xf5U, 0xdeU, 0x20U, 0xc6U, 0xa7U, 0x84U, 0xceU,\n  0xd8U, 0x65U, 0x51U, 0xc9U, 0xa4U, 0xefU, 0x43U, 0x53U,\n  0x25U, 0x5dU, 0x9bU, 0x31U, 0xe8U, 0x3eU, 0x0dU, 0xd7U,\n  0x80U, 0xffU, 0x69U, 0x8aU, 0xbaU, 0x0bU, 0x73U, 0x5cU,\n  0x6eU, 0x54U, 0x15U, 0x62U, 0xf6U, 0x35U, 0x30U, 0x52U,\n  0xa3U, 0x16U, 0xd3U, 0x28U, 0x32U, 0xfaU, 0xaaU, 0x5eU,\n  0xcfU, 0xeaU, 0xedU, 0x78U, 0x33U, 0x58U, 0x09U, 0x7bU,\n  0x63U, 0xc0U, 0xc1U, 0x46U, 0x1eU, 0xdfU, 0xa9U, 0x99U,\n  0x55U, 0x04U, 0xc4U, 0x86U, 0x39U, 0x77U, 0x82U, 0xecU,\n  0x40U, 0x18U, 0x90U, 0x97U, 0x59U, 0xddU, 0x83U, 0x1fU,\n  0x9aU, 0x37U, 0x06U, 0x24U, 0x64U, 0x7cU, 0xa5U, 0x56U,\n  0x48U, 0x08U, 0x85U, 0xd0U, 0x61U, 0x26U, 0xcaU, 0x6fU,\n  0x7eU, 0x6aU, 0xb6U, 0x71U, 0xa0U, 0x70U, 0x05U, 0xd1U,\n  0x45U, 0x8cU, 0x23U, 0x1cU, 0xf0U, 0xeeU, 0x89U, 0xadU,\n  0x7aU, 0x4bU, 0xc2U, 0x2fU, 0xdbU, 0x5aU, 0x4dU, 0x76U,\n  0x67U, 0x17U, 0x2dU, 0xf4U, 0xcbU, 0xb1U, 0x4aU, 0xa8U,\n  0xb5U, 0x22U, 0x47U, 0x3aU, 0xd5U, 0x10U, 0x4cU, 0x72U,\n  0xccU, 0x00U, 0xf9U, 0xe0U, 0xfdU, 0xe2U, 0xfeU, 0xaeU,\n  0xf8U, 0x5fU, 0xabU, 0xf1U, 0x1bU, 0x42U, 0x81U, 0xd6U,\n  0xbeU, 0x44U, 0x29U, 0xa6U, 0x57U, 0xb9U, 0xafU, 0xf2U,\n  0xd4U, 0x75U, 0x66U, 0xbbU, 0x68U, 0x9fU, 0x50U, 0x02U,\n  0x01U, 0x3cU, 0x7fU, 0x8dU, 0x1aU, 0x88U, 0xbdU, 0xacU,\n  0xf7U, 0xe4U, 0x79U, 0x96U, 0xa2U, 0xfcU, 0x6dU, 0xb2U,\n  0x6bU, 0x03U, 0xe1U, 0x2eU, 0x7dU, 0x14U, 0x95U, 0x1dU\n};\n\nvoid ByteCpy(BYTE *dst, const BYTE *src, int bytelen)\n{\n  while(bytelen-- > 0){\n    *dst++ = *src++;\n  }\n}\n\nvoid ByteXor(BYTE *dst, const BYTE *a, const BYTE *b, int bytelen)\n{\n  while(bytelen-- > 0){\n    *dst++ = *a++ ^ *b++;\n  }\n}\n\nBYTE ClefiaMul2(BYTE x)\n{\n  /* multiplication over GF(2^8) (p(x) = '11d') */\n  if(x & 0x80U){\n    x ^= 0x0eU;\n  }\n  return ((x << 1) | (x >> 7));\n}\n\n#define ClefiaMul4(_x) (ClefiaMul2(ClefiaMul2((_x))))\n#define ClefiaMul6(_x) (ClefiaMul2((_x)) ^ ClefiaMul4((_x)))\n#define ClefiaMul8(_x) (ClefiaMul2(ClefiaMul4((_x))))\n#define ClefiaMulA(_x) (ClefiaMul2((_x)) ^ ClefiaMul8((_x)))\n\nvoid ClefiaF0Xor(BYTE *dst, const BYTE *src, const BYTE *rk)\n{\n  BYTE x[4], y[4], z[4];\n\n  /* F0 */\n  /* Key addition */\n  ByteXor(x, src, rk, 4);\n  /* Substitution layer */\n  z[0] = clefia_s0[x[0]];\n  z[1] = clefia_s1[x[1]];\n  z[2] = clefia_s0[x[2]];\n  z[3] = clefia_s1[x[3]];\n  /* Diffusion layer (M0) */\n  y[0] =            z[0]  ^ ClefiaMul2(z[1]) ^ ClefiaMul4(z[2]) ^ ClefiaMul6(z[3]);\n  y[1] = ClefiaMul2(z[0]) ^            z[1]  ^ ClefiaMul6(z[2]) ^ ClefiaMul4(z[3]);\n  y[2] = ClefiaMul4(z[0]) ^ ClefiaMul6(z[1]) ^            z[2]  ^ ClefiaMul2(z[3]);\n  y[3] = ClefiaMul6(z[0]) ^ ClefiaMul4(z[1]) ^ ClefiaMul2(z[2]) ^            z[3] ;\n\n  /* Xoring after F0 */\n  ByteCpy(dst + 0, src + 0, 4);\n  ByteXor(dst + 4, src + 4, y, 4);\n}\n\nvoid ClefiaF1Xor(BYTE *dst, const BYTE *src, const BYTE *rk)\n{\n  BYTE x[4], y[4], z[4];\n\n  /* F1 */\n  /* Key addition */\n  ByteXor(x, src, rk, 4);\n  /* Substitution layer */\n  z[0] = clefia_s1[x[0]];\n  z[1] = clefia_s0[x[1]];\n  z[2] = clefia_s1[x[2]];\n  z[3] = clefia_s0[x[3]];\n  /* Diffusion layer (M1) */\n  y[0] =            z[0]  ^ ClefiaMul8(z[1]) ^ ClefiaMul2(z[2]) ^ ClefiaMulA(z[3]);\n  y[1] = ClefiaMul8(z[0]) ^            z[1]  ^ ClefiaMulA(z[2]) ^ ClefiaMul2(z[3]);\n  y[2] = ClefiaMul2(z[0]) ^ ClefiaMulA(z[1]) ^            z[2]  ^ ClefiaMul8(z[3]);\n  y[3] = ClefiaMulA(z[0]) ^ ClefiaMul2(z[1]) ^ ClefiaMul8(z[2]) ^            z[3] ;\n\n  /* Xoring after F1 */\n  ByteCpy(dst + 0, src + 0, 4);\n  ByteXor(dst + 4, src + 4, y, 4);\n}\n\nvoid ClefiaGfn4(BYTE *y, const BYTE *x, const BYTE *rk, int r)\n{\n  BYTE fin[16], fout[16];\n\n  ByteCpy(fin, x, 16);\n  while(r-- > 0){\n    ClefiaF0Xor(fout + 0, fin + 0, rk + 0);\n    ClefiaF1Xor(fout + 8, fin + 8, rk + 4);\n    rk += 8;\n    if(r){ /* swapping for encryption */\n      ByteCpy(fin + 0,  fout + 4, 12);\n      ByteCpy(fin + 12, fout + 0, 4);\n    }\n  }\n  ByteCpy(y, fout, 16);\n}\n\nvoid ClefiaGfn8(BYTE *y, const BYTE *x, const BYTE *rk, int r)\n{\n  BYTE fin[32], fout[32];\n\n  ByteCpy(fin, x, 32);\n  while(r-- > 0){\n    ClefiaF0Xor(fout + 0,  fin + 0,  rk + 0);\n    ClefiaF1Xor(fout + 8,  fin + 8,  rk + 4);\n    ClefiaF0Xor(fout + 16, fin + 16, rk + 8);\n    ClefiaF1Xor(fout + 24, fin + 24, rk + 12);\n    rk += 16;\n    if(r){ /* swapping for encryption */\n      ByteCpy(fin + 0,  fout + 4, 28);\n      ByteCpy(fin + 28, fout + 0, 4);\n    }\n  }\n  ByteCpy(y, fout, 32);\n}\n\nvoid ClefiaGfn4Inv(BYTE *y, const BYTE *x, const BYTE *rk, int r)\n{\n  BYTE fin[16], fout[16];\n\n  rk += (r - 1) * 8;\n  ByteCpy(fin, x, 16);\n  while(r-- > 0){\n    ClefiaF0Xor(fout + 0, fin + 0, rk + 0);\n    ClefiaF1Xor(fout + 8, fin + 8, rk + 4);\n    rk -= 8;\n    if(r){ /* swapping for decryption */\n      ByteCpy(fin + 0, fout + 12, 4);\n      ByteCpy(fin + 4, fout + 0,  12);\n    }\n  }\n  ByteCpy(y, fout, 16);\n}\n\nvoid ClefiaDoubleSwap(BYTE *lk)\n{\n  BYTE t[16];\n\n  t[0]  = (lk[0] << 7) | (lk[1]  >> 1);\n  t[1]  = (lk[1] << 7) | (lk[2]  >> 1);\n  t[2]  = (lk[2] << 7) | (lk[3]  >> 1);\n  t[3]  = (lk[3] << 7) | (lk[4]  >> 1);\n  t[4]  = (lk[4] << 7) | (lk[5]  >> 1);\n  t[5]  = (lk[5] << 7) | (lk[6]  >> 1);\n  t[6]  = (lk[6] << 7) | (lk[7]  >> 1);\n  t[7]  = (lk[7] << 7) | (lk[15] & 0x7fU);\n\n  t[8]  = (lk[8]  >> 7) | (lk[0]  & 0xfeU);\n  t[9]  = (lk[9]  >> 7) | (lk[8]  << 1);\n  t[10] = (lk[10] >> 7) | (lk[9]  << 1);\n  t[11] = (lk[11] >> 7) | (lk[10] << 1);\n  t[12] = (lk[12] >> 7) | (lk[11] << 1);\n  t[13] = (lk[13] >> 7) | (lk[12] << 1);\n  t[14] = (lk[14] >> 7) | (lk[13] << 1);\n  t[15] = (lk[15] >> 7) | (lk[14] << 1);\n\n  ByteCpy(lk, t, 16);\n}\n\nvoid ClefiaConSet(BYTE *con, const BYTE *iv, int lk)\n{\n  BYTE t[2];\n  BYTE tmp;\n\n  ByteCpy(t, iv, 2);\n  while(lk-- > 0){\n    con[0] = t[0] ^ 0xb7U; /* P_16 = 0xb7e1 (natural logarithm) */\n    con[1] = t[1] ^ 0xe1U;\n    con[2] = ~((t[0] << 1) | (t[1] >> 7));\n    con[3] = ~((t[1] << 1) | (t[0] >> 7));\n    con[4] = ~t[0] ^ 0x24U; /* Q_16 = 0x243f (circle ratio) */\n    con[5] = ~t[1] ^ 0x3fU;\n    con[6] = t[1];\n    con[7] = t[0];\n    con += 8;\n\n    /* updating T */\n    if(t[1] & 0x01U){\n      t[0] ^= 0xa8U;\n      t[1] ^= 0x30U;\n    }\n    tmp = t[0] << 7;\n    t[0] = (t[0] >> 1) | (t[1] << 7);\n    t[1] = (t[1] >> 1) | tmp;\n  }    \n}\n\nvoid ClefiaKeySet128(BYTE *rk, const BYTE *skey)\n{\n  const BYTE iv[2] = {0x42U, 0x8aU}; /* cubic root of 2 */\n  BYTE lk[16];\n  BYTE con128[4 * 60];\n  int i;\n\n  /* generating CONi^(128) (0 <= i < 60, lk = 30) */\n  ClefiaConSet(con128, iv, 30);\n  /* GFN_{4,12} (generating L from K) */\n  ClefiaGfn4(lk, skey, con128, 12);\n\n  ByteCpy(rk, skey, 8); /* initial whitening key (WK0, WK1) */\n  rk += 8;\n  for(i = 0; i < 9; i++){ /* round key (RKi (0 <= i < 36)) */\n    ByteXor(rk, lk, con128 + i * 16 + (4 * 24), 16);\n    if(i % 2){\n      ByteXor(rk, rk, skey, 16); /* Xoring K */\n    }\n    ClefiaDoubleSwap(lk); /* Updating L (DoubleSwap function) */\n    rk += 16;\n  }\n  ByteCpy(rk, skey + 8, 8); /* final whitening key (WK2, WK3) */\n}\n\nvoid ClefiaKeySet192(BYTE *rk, const BYTE *skey)\n{\n  const BYTE iv[2] = {0x71U, 0x37U}; /* cubic root of 3 */\n  BYTE skey256[32];\n  BYTE lk[32];\n  BYTE con192[4 * 84];\n  int i;\n\n  ByteCpy(skey256, skey, 24);\n  for(i = 0; i < 8; i++){\n    skey256[i + 24] = ~skey[i];\n  }\n\n  /* generating CONi^(192) (0 <= i < 84, lk = 42) */\n  ClefiaConSet(con192, iv, 42);\n  /* GFN_{8,10} (generating L from K) */\n  ClefiaGfn8(lk, skey256, con192, 10);\n\n  ByteXor(rk, skey256, skey256 + 16, 8); /* initial whitening key (WK0, WK1) */\n  rk += 8;\n  for(i = 0; i < 11; i++){ /* round key (RKi (0 <= i < 44)) */\n    if((i / 2) % 2){\n      ByteXor(rk, lk + 16, con192 + i * 16 + (4 * 40), 16); /* LR */\n      if(i % 2){\n        ByteXor(rk, rk, skey256 + 0,  16); /* Xoring KL */\n      }\n      ClefiaDoubleSwap(lk + 16); /* updating LR */\n    }else{\n      ByteXor(rk, lk + 0,  con192 + i * 16 + (4 * 40), 16); /* LL */\n      if(i % 2){\n        ByteXor(rk, rk, skey256 + 16, 16); /* Xoring KR */\n      }\n      ClefiaDoubleSwap(lk + 0);  /* updating LL */\n    }\n    rk += 16;\n  }\n  ByteXor(rk, skey256 + 8, skey256 + 24, 8); /* final whitening key (WK2, WK3) */\n}\n\nvoid ClefiaKeySet256(BYTE *rk, const BYTE *skey)\n{\n  const BYTE iv[2] = {0xb5, 0xc0U}; /* cubic root of 5 */\n  BYTE lk[32];\n  BYTE con256[4 * 92];\n  int i;\n\n  /* generating CONi^(256) (0 <= i < 92, lk = 46) */\n  ClefiaConSet(con256, iv, 46);\n  /* GFN_{8,10} (generating L from K) */\n  ClefiaGfn8(lk, skey, con256, 10);\n\n  ByteXor(rk, skey, skey + 16, 8); /* initial whitening key (WK0, WK1) */\n  rk += 8;\n  for(i = 0; i < 13; i++){ /* round key (RKi (0 <= i < 52)) */\n    if((i / 2) % 2){\n      ByteXor(rk, lk + 16, con256 + i * 16 + (4 * 40), 16); /* LR */\n      if(i % 2){\n        ByteXor(rk, rk, skey + 0,  16); /* Xoring KL */\n      }\n      ClefiaDoubleSwap(lk + 16); /* updating LR */\n    }else{\n      ByteXor(rk, lk + 0,  con256 + i * 16 + (4 * 40), 16); /* LL */\n      if(i % 2){\n        ByteXor(rk, rk, skey + 16, 16); /* Xoring KR */\n      }\n      ClefiaDoubleSwap(lk + 0);  /* updating LL */\n    }\n    rk += 16;\n  }\n  ByteXor(rk, skey + 8, skey + 24, 8); /* final whitening key (WK2, WK3) */\n}\n\nvoid Clefia_set_key(CLEFIA_DATA *pCd,const BYTE *skey,const int key_bitlen)\n{/*const BYTE *rk*/\n  if(key_bitlen==128){\n    ClefiaKeySet128(pCd->rk, skey);\n\tpCd->r=18;\n  }else if(key_bitlen==192){\n    ClefiaKeySet192(pCd->rk, skey);\n    pCd->r=22;\n  }else if(key_bitlen==256){\n    ClefiaKeySet256(pCd->rk, skey);\n    pCd->r=26;\n  }\n}\n\nvoid Clefia_encrypt(const CLEFIA_DATA *pCd,const BYTE *pt,BYTE *ct)\n{\n  BYTE rin[16], rout[16];\n\n  ByteCpy(rin,  pt,  16);\n\n  ByteXor(rin + 4,  rin + 4,  pCd->rk + 0, 4); /* initial key whitening */\n  ByteXor(rin + 12, rin + 12, pCd->rk + 4, 4);\n\n  ClefiaGfn4(rout, rin, pCd->rk + 8, pCd->r); /* GFN_{4,r} */\n\n  ByteCpy(ct, rout, 16);\n  ByteXor(ct + 4,  ct + 4,  pCd->rk + 8 + pCd->r * 8 + 0, 4); /* final key whitening */\n  ByteXor(ct + 12, ct + 12, pCd->rk + 8 + pCd->r * 8 + 4, 4);\n}\n\nvoid Clefia_decrypt(const CLEFIA_DATA *pCd,const BYTE *ct,BYTE *pt)\n{\n  BYTE rin[16], rout[16];\n\n  ByteCpy(rin, ct, 16);\n\n  ByteXor(rin + 4,  rin + 4,  pCd->rk + pCd->r * 8 + 8,  4); /* initial key whitening */\n  ByteXor(rin + 12, rin + 12, pCd->rk + pCd->r * 8 + 12, 4);\n\n  ClefiaGfn4Inv(rout, rin, pCd->rk + 8, pCd->r); /* GFN^{-1}_{4,r} */\n\n  ByteCpy(pt, rout, 16);\n  ByteXor(pt + 4,  pt + 4,  pCd->rk + 8 - 8, 4); /* final key whitening */\n  ByteXor(pt + 12, pt + 12, pCd->rk + 8 - 4, 4);\n}\n"
        },
        {
            "file_name": "cmcc84v1_encrypt.cpp",
            "content": "/*     Copyright (C) <2014> <Jonathan Trostle>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject\nto the following conditions:\n\n    The above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"cmcc84v1_api.h\"\n#include \"cmcc84v1_encrypt.h\"\n// CHANGE api included instead of crypto core headers\n#include \"../../common/api.h\"\n// #include \"crypto_verify_16.h\"\n// #include \"crypto_core_aes128encrypt.h\"\n#define ABS 16  /* ABS = AES_BLOCK_SIZE */\n// CHANGE namespace added\n#define AES(out,in,k) CaesarCommon::crypto_core_aes128encrypt(out,in,k,0)\n\n// CHANGE namespace moved due to includes\nnamespace Cmcc84v1_raw {\nint numRounds = -1;\n\ntypedef unsigned char uc;\n\nint ctr(uc *v, const uc *k, const uc *plain, unsigned long long plain_len,\n    uc *out)\n{\n  /* Reference implementation assumes <= 2^{39}-128 bits will be\n     processed */\n  int size, last_block_length;\n  int whole=1; /*TRUE if last block not whole */\n  long long int no_blocks;\n  uc c[16];\n  int i;\n  long long int j;\n  last_block_length = plain_len % 16;\n  if(last_block_length == 0)\n    last_block_length = 16;\n  if(last_block_length == 16)\n    whole = 0;\n  no_blocks = plain_len/16 + whole;\n  if(no_blocks == 1)\n    size = last_block_length;\n  else\n    size = ABS;\n  for(i=0; i<size; i++)\n    out[i] = plain[i] ^ v[i];\n  no_blocks--;\n  if(no_blocks > 0)\n    {\n      v[12] &= 0x7f;\n      v[8] &= 0x7f;\n    }\n  j = 16;\n  while(no_blocks > 0)\n    {\n      if(v[15] < 255)\n    {\n      v[15] += 1;\n    }\n      else if(v[15] == 255)\n    {\n      v[15] = 0;\n      if(v[14] < 255)\n        v[14] += 1;\n      else if(v[14] == 255)\n        {\n          v[14] = 0;\n          if(v[13] < 255)\n        v[13] += 1;\n          else if(v[13] == 255)\n        {\n          v[13] = 0;\n          v[12] += 1;\n        }\n        }\n    }\n      AES(c,v,k);\n      if(no_blocks == 1)\n    size = last_block_length;\n      else\n    size = ABS;\n      for(i=0; i<size; i++)\n    out[i+j] = plain[i+j] ^ c[i];\n      j += 16;\n      no_blocks--;\n    }\n  return 0;\n}\n\nint get_subkeys(uc *key1, uc *key2, const uc *aes_key)\n{\n  uc zero[ABS]={0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n  int i, msb, new_msb, flag;\n  AES(key1,zero,aes_key);\n  if((key1[0] & 0x80) != 0) flag = 1; else flag = 0;\n  msb = 0;\n  for(i=ABS-1; i >= 0; i--)\n    {\n      new_msb = key1[i] & 0x80;\n      key1[i] = key1[i] << 1;\n      if(msb != 0)\n    key1[i] += 1;\n      msb = new_msb;\n    }\n  if(flag == 1)\n    key1[ABS-1] ^= 0x87;\n  if((key1[0] & 0x80) != 0) flag = 1; else flag = 0;\n  msb = 0;\n  for(i=ABS-1; i >= 0; i--)\n    {\n      new_msb = key1[i] & 0x80;\n      key2[i] = key1[i] << 1;\n      if(msb != 0)\n    key2[i] += 1;\n      msb = new_msb;\n    }\n  if(flag == 1)\n    key2[ABS-1] ^= 0x87;\n  return 0;\n}\n\nint pad(uc *buf, unsigned int pad_length, unsigned long long length,\n    uc *k1, uc *k2)\n{ /* assumes buf has room to pad which is true for cbc_buffer\n     length is length of buf string; length + pad_length is div. by 16*/\n  int i, n;\n  if(pad_length == 0)\n    {\n      /* we have a whole block to pad */\n      for(i=length-ABS; i <= length-1; i++)\n    buf[i] ^= k1[i - length + ABS];\n      return 0;\n    }\n  else if(pad_length > 16 || pad_length < 1)\n    return -1;\n  else /* partial block (1 to 16 bytes), have to add pad bytes\n        16 bytes is corner case where P1 is multiple of block size,\n        pad with 1 byte to get to size of P2, then need 15 more pad bytes\n        must add pad_length bytes */\n    {\n      buf[length] = 0x80;\n      for(i=0; i< pad_length-1;i++)\n    buf[length+1+i] = 0x00; /* NOW XOR last 16 bytes with K2 */\n      n = ABS - pad_length;\n      for(i=0; i < ABS; i++)\n    buf[length-n+i] ^= k2[i];\n    }\n  return 0;\n}\n\nint cmac(uc *msg, const uc *aes_key, unsigned long long length, uc *tag)\n{\n  /* length is length of msg */\n  unsigned int pad_length;\n  int i;\n  uc k1[16], k2[16], temp[16];\n  unsigned long long no_blocks, j;\n  pad_length = ABS - (length % ABS);\n  if(pad_length == 16)\n    pad_length = 0;\n  if(get_subkeys(k1,k2,aes_key) == -1)\n    return -1;\n  if(pad(msg, pad_length, length, k1,k2) == -1)\n    return -1;\n  no_blocks = (length + pad_length)/16;\n  AES(tag,msg,aes_key);\n  for(j=1; j<no_blocks; j++)\n    {\n      for(i=0;i < ABS;i++)\n    temp[i] = msg[16*j + i] ^ tag[i];\n      AES(tag,temp,aes_key);\n    }\n  return 0;\n}\n\nint cbc_encrypt(uc *in, unsigned long long length, uc *out,\n        const uc *aes_key, uc *iv)\n{\n  /* ASSUMES length is divisible by ABS */\n  unsigned long long j, i;\n  int k;\n  unsigned long long no_blocks = length/16;\n  uc ivc[ABS];\n  for(k=0;k<ABS;k++)\n    ivc[k] = iv[k];\n  if((length % 16) != 0)\n    return -1;\n  for(i=0; i < ABS; i++)\n    ivc[i] ^= in[i];\n  AES(out,ivc,aes_key);\n  for(j=1; j < no_blocks; j++)\n    {\n      for(i=0; i < ABS; i++)\n    ivc[i] = in[16*j + i] ^ out[16*(j-1) + i];\n      AES(out + 16*j,ivc,aes_key);\n    }\n  return 0;\n}\n\n\n\nint crypto_aead_encrypt(\n            uc *c, unsigned long long *clen,\n            const uc *m, unsigned long long mlen,\n            const uc *ad, unsigned long long adlen,\n            const uc *nsec,\n            const uc *npub,\n            const uc *k)\n{\n  /* ASSUME CALLER has allocated the buffer c with *clen bytes */\n  /* ASSUME message is in buffer m which has at least mlen bytes */\n  /* uc big_m[ABS] = { [0 ... 15] = 0xb6 }; */\n  uc big_m[ABS] = {0xb6, 0xb6, 0xb6, 0xb6,0xb6, 0xb6, 0xb6, 0xb6,\n                   0xb6, 0xb6, 0xb6, 0xb6,0xb6, 0xb6, 0xb6, 0xb6};\n  unsigned long long p1_length, p2_length, cbc_length, j;\n  int i, pad_length, temp, index;\n  uc k1[16], k2[16], w[16], tag[16], *scratch, *cbc_buffer;\n  uc *x, small[CRYPTO_ABYTES];\n  if(npub == NULL)\n    return -2;\n  *clen = mlen + CRYPTO_ABYTES;\n  index = ABS - CRYPTO_NPUBBYTES;\n  for(i=index; i < ABS; i++)\n    big_m[i] = npub[i - index];\n  p1_length = (mlen + CRYPTO_ABYTES)/2;\n  p2_length = (mlen + CRYPTO_ABYTES) - p1_length;\n  cbc_length = p1_length;\n  if(p1_length < p2_length)\n    cbc_length++;\n  if((temp=cbc_length % ABS) != 0)\n    cbc_length += ABS - temp;\n  pad_length = cbc_length - p1_length;\n  /* malloc the buffer of size cbc_length and add padding to it\n     then cbc it. But Y will end up in this buffer so make the\n     length cbc_length plus adlen plus padding: */\n  // CHANGE type casting added due to c++\n  cbc_buffer = (uc*) malloc(cbc_length + adlen +\n              (ABS - (adlen%ABS))*sizeof(unsigned char));\n  if(cbc_buffer == NULL)\n    return -3;\n  if(p1_length <= mlen)\n    {\n      for(j=0;j<p1_length;j++)\n    cbc_buffer[j] = m[j];\n    }\n  else if(mlen < p1_length)\n    {\n      for(j=0; j<mlen;j++)\n    cbc_buffer[j] = m[j];\n      for(j=mlen;j < p1_length;j++)\n    cbc_buffer[j] = 0x00;\n    }\n  /* pad_length = 0 implies a full block\n     will append A to cbc_buffer after getting X\n     to get Y. Then MAC buffer and preserve Y in place\n     so we can access X in the 3rd equation */\n  if(get_subkeys(k1,k2,k+16) == -1)\n    return -4;\n  if(pad(cbc_buffer,pad_length,p1_length,k1,k2) == -1)\n    return -4;\n  AES(w,big_m,k);\n  /* NOW we cbc_encrypt cbc_buffer */\n  if(cbc_encrypt(cbc_buffer, cbc_length, cbc_buffer, k+16, w) == -1)\n    return -4;\n  /* Now XOR P2 in which will not generally cover all bytes\n     (last bytes will be overwritten with A) */\n  if(p1_length <= mlen)\n    for(j = p1_length; j < mlen;j++)\n      cbc_buffer[j - p1_length] ^= m[j];\n  /* save X for later use */\n  /* with a little extra complexity we could maintain X in\n     cbc_buffer by saving the bytes of X that are affected by\n     padding and then overwriting the affected bytes later on\n     when we need to reconstitute X. This would eliminate the\n     copy below */\n  // CHANGE type casting added due to c++\n  x = (uc*) malloc(p2_length*sizeof(unsigned char));\n  if(x == NULL)\n    return -3;\n  for(j=0; j < p2_length; j++)\n        x[j] = cbc_buffer[j];\n  for(j=p2_length; j < p2_length + adlen; j++)\n    cbc_buffer[j] = ad[j - p2_length];\n  if(cmac(cbc_buffer, k+32, p2_length+adlen, tag) == -1)\n    return -4;\n  // CHANGE type casting added due to c++\n  scratch = (uc*) malloc(cbc_length*sizeof(unsigned char *));\n  if(scratch == NULL)\n    return -3;\n\n  if(p1_length <= mlen)\n    {\n    if(ctr(tag, k+48, m, p1_length,scratch) == -1)\n      return -4;\n    }\n  else if(mlen < p1_length)\n    {\n      for(j=0; j<mlen;j++)\n    small[j] = m[j];\n      for(j=mlen;j < p1_length;j++)\n    small[j] = 0x00;\n      if(ctr(tag, k+48, small, p1_length,scratch) == -1)\n    return -4;\n    }\n\n  /* pad scratch (holds X2), then cbc encrypt it. Then xor in X\n     to get X1. But copy out X2 first. */\n  for(j=0; j<p1_length;j++)\n    c[p2_length+j] = scratch[j];\n  if(get_subkeys(k1,k2,k+64) == -1)\n    return -4;\n  if(pad(scratch, pad_length, p1_length, k1,k2) == -1)\n    return -4;\n  if(cbc_encrypt(scratch,cbc_length,scratch,k+64,w) == -1)\n    return -4;\n  /* XOR with X to get X1 */\n  for(j=0; j<p2_length;j++)\n    c[j] = scratch[j] ^ x[j];\n  free(scratch);\n  scratch = NULL;\n  free(x);\n  x = NULL;\n  free(cbc_buffer);\n  cbc_buffer = NULL;\n  return 0;\n}\n\nint crypto_aead_decrypt(\n            uc *m, unsigned long long *mlen,\n            uc *nsec,\n            const uc *c, unsigned long long clen,\n            const uc *ad, unsigned long long adlen,\n            const uc *npub,\n            const uc *k\n            )\n{\n  /* uc big_m[ABS] = { [0 ... 15] = 0xb6 }; */\n  uc big_m[ABS] = {0xb6, 0xb6, 0xb6, 0xb6,0xb6, 0xb6, 0xb6, 0xb6,\n                   0xb6, 0xb6, 0xb6, 0xb6,0xb6, 0xb6, 0xb6, 0xb6};\n  unsigned long long p1_length, p2_length, cbc_length, j;\n  int i, pad_length, temp, index;\n  uc k1[16], k2[16], w[16], tag[16], *scratch, *cbc_buffer;\n  uc *x;\n  if(npub == NULL)\n    return -2;\n  /* WE EXPECT *mlen to lower bound the length of the buffer m and\n     we expect that m has at least clen - CRYPTO_ABYTES */\n  *mlen = clen - CRYPTO_ABYTES;\n  if(clen < CRYPTO_ABYTES)\n    return -1;\n  index = ABS - CRYPTO_NPUBBYTES;\n  for(i=index; i < ABS; i++)\n    big_m[i] = npub[i - index];\n  p1_length = clen/2;\n  p2_length = clen - p1_length;\n  cbc_length = p1_length;\n  if(p1_length < p2_length)\n    cbc_length++;\n  if((temp=cbc_length % ABS) != 0)\n    cbc_length += ABS - temp;\n  pad_length = cbc_length - p1_length;\n  /* malloc the buffer of size cbc_length and add padding to it\n     then cbc it. But Y will end up in this buffer so make the\n     length cbc_length plus adlen plus padding: */\n  // CHANGE type casting added due to c++\n  cbc_buffer = (uc*) malloc(cbc_length\n         + adlen + (ABS - (adlen%ABS))*sizeof(unsigned char));\n  if(cbc_buffer == NULL)\n    return -3;\n  /* GOT TO HERE IN CHECKING */\n  /* copy X2 into cbc_buffer; it's length is p1_length */\n  for(j=0; j < p1_length; j++)\n    cbc_buffer[j] = c[j+p2_length];\n  /* now pad it, then cbc encrypt it, then xor X1 in */\n\n  if(get_subkeys(k1,k2,k+64) == -1)\n    return -4;\n  if(pad(cbc_buffer,pad_length,p1_length,k1,k2) == -1)\n    return -4;\n  AES(w,big_m,k);\n  /* NOW we cbc_encrypt cbc_buffer */\n  if(cbc_encrypt(cbc_buffer, cbc_length, cbc_buffer, k+64, w) == -1)\n    return -4;\n  /* Now XOR X1 in which will not generally cover all bytes\n     (last bytes will be overwritten with A) */\n  for(j=0; j < p2_length; j++)\n    cbc_buffer[j] ^= c[j];\n  /* save X for later use */\n  /* with a little extra complexity we could maintain X in\n     cbc_buffer by saving the bytes of X that are affected by\n     padding and then overwriting the affected bytes later on\n     when we need to reconstitute X. This would eliminate the\n     copy of the potentially big string below */\n  // CHANGE type casting added due to c++\n  x = (uc*) malloc(p2_length*sizeof(unsigned char));\n  if(x == NULL)\n    return -3;\n  for(j=0; j < p2_length; j++)\n        x[j] = cbc_buffer[j];\n  for(j=p2_length; j < p2_length + adlen; j++)\n     cbc_buffer[j] = ad[j - p2_length];\n  if(cmac(cbc_buffer, k+32, p2_length+adlen, tag) == -1)\n    return -4;\n  // CHANGE type casting added due to c++\n  scratch = (uc*) malloc(cbc_length*sizeof(unsigned char *));\n  if(scratch == NULL)\n    return -3;\n  if(ctr(tag, k+48, c+p2_length, p1_length,scratch) == -1)\n    return -4;\n  /* pad scratch (holds P1), then cbc encrypt it. Then xor in X\n     to get P2. But copy out P1 first. Handle corner case where\n     P1 longer than m */\n  if(p1_length <= *mlen)\n    for(j=0; j < p1_length;j++)\n      m[j] = scratch[j];\n  else\n    {\n      for(j=0; j < *mlen; j++)\n    m[j] = scratch[j];\n      /* check the rest of P1 to make sure they are zero bytes */\n      /*for(j=0; j < p1_length-*mlen; j++)*/\n      for(j = *mlen; j < p1_length; j++) /*check for invalid */\n    {\n      /*if(scratch[*mlen + j] != 0x00)*/\n        if(scratch[j] != 0x00)\n        {\n          return -1;\n        }\n    }\n    }\n  /*pad, cbc_encrypt, then xor with X. Result will be P2 */\n  /* then segment P2 into msg bytes and Z, check Z, copy msg into m */\n  if(get_subkeys(k1,k2,k+16) == -1)\n    return -4;\n  if(pad(scratch, pad_length, p1_length, k1,k2) == -1)\n    return -4;\n  if(cbc_encrypt(scratch,cbc_length,scratch,k+16,w) == -1)\n    return -4;\n  for(j=0; j < p2_length; j++)\n    scratch[j] ^= x[j];\n  if(*mlen > p1_length)\n    {\n      for(j=0; j < (*mlen - p1_length); j++)\n    m[j + p1_length] = scratch[j];\n      for(j=(*mlen - p1_length); j < p2_length; j++)\n    if(scratch[j] != 0x00)\n      return -1;\n    }\n  else\n    for(j=0; j < p2_length; j++)\n      if(scratch[j] != 0x00)\n    return -1;\n  free(scratch);\n  scratch = NULL;\n  free(x);\n  x = NULL;\n  free(cbc_buffer);\n  cbc_buffer = NULL;\n  return 0;\n}\n\n\n} // namespace Cmcc84v1_raw\n"
        },
        {
            "file_name": "common.c",
            "content": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <glib.h>\n#include <openssl/aes.h>\n#include <openssl/sha.h>\n#include <pbc.h>\n\n#include \"common.h\"\n\nvoid\ninit_aes( element_t k, int enc, AES_KEY* key, unsigned char* iv )\n{\n  int key_len;\n  unsigned char* key_buf;\n\n  key_len = element_length_in_bytes(k) < 17 ? 17 : element_length_in_bytes(k);\n  key_buf = (unsigned char*) malloc(key_len);\n  element_to_bytes(key_buf, k);\n\n  if( enc )\n    AES_set_encrypt_key(key_buf + 1, 128, key);\n  else\n    AES_set_decrypt_key(key_buf + 1, 128, key);\n  free(key_buf);\n\n  memset(iv, 0, 16);\n}\n\nGByteArray*\naes_128_cbc_encrypt( GByteArray* pt, element_t k )\n{\n  AES_KEY key;\n  unsigned char iv[16];\n  GByteArray* ct;\n  guint8 len[4];\n  guint8 zero;\n\n  init_aes(k, 1, &key, iv);\n\n  /* TODO make less crufty */\n\n  /* stuff in real length (big endian) before padding */\n  len[0] = (pt->len & 0xff000000)>>24;\n  len[1] = (pt->len & 0xff0000)>>16;\n  len[2] = (pt->len & 0xff00)>>8;\n  len[3] = (pt->len & 0xff)>>0;\n  g_byte_array_prepend(pt, len, 4);\n\n  /* pad out to multiple of 128 bit (16 byte) blocks */\n  zero = 0;\n  while( pt->len % 16 )\n    g_byte_array_append(pt, &zero, 1);\n\n  ct = g_byte_array_new();\n  g_byte_array_set_size(ct, pt->len);\n\n  AES_cbc_encrypt(pt->data, ct->data, pt->len, &key, iv, AES_ENCRYPT);\n\n  return ct;\n}\n\nGByteArray*\naes_128_cbc_decrypt( GByteArray* ct, element_t k )\n{\n  AES_KEY key;\n  unsigned char iv[16];\n  GByteArray* pt;\n  unsigned int len;\n\n  init_aes(k, 0, &key, iv);\n\n  pt = g_byte_array_new();\n  g_byte_array_set_size(pt, ct->len);\n\n  AES_cbc_encrypt(ct->data, pt->data, ct->len, &key, iv, AES_DECRYPT);\n\n  /* TODO make less crufty */\n  \n  /* get real length */\n  len = 0;\n  len = len\n    | ((pt->data[0])<<24) | ((pt->data[1])<<16)\n    | ((pt->data[2])<<8)  | ((pt->data[3])<<0);\n  g_byte_array_remove_index(pt, 0);\n  g_byte_array_remove_index(pt, 0);\n  g_byte_array_remove_index(pt, 0);\n  g_byte_array_remove_index(pt, 0);\n\n  /* truncate any garbage from the padding */\n  g_byte_array_set_size(pt, len);\n\n  return pt;\n}\n\nFILE*\nfopen_read_or_die( char* file )\n{\n\tFILE* f;\n\n\tif( !(f = fopen(file, \"r\")) )\n\t\tdie(\"can't read file: %s\\n\", file);\n\n\treturn f;\n}\n\nFILE*\nfopen_write_or_die( char* file )\n{\n\tFILE* f;\n\n\tif( !(f = fopen(file, \"w\")) )\n\t\tdie(\"can't write file: %s\\n\", file);\n\n\treturn f;\n}\n\nFILE*\nfopen_append_or_die( char* file )\n{\n\tFILE* f;\n\n\tif( !(f = fopen(file, \"a\")) )\n\t\tdie(\"can't append file: %s\\n\", file);\n\n\treturn f;\n}\n\nGByteArray*\nsuck_file( char* file )\n{\n\tFILE* f;\n\tGByteArray* a;\n\tstruct stat s;\n\n\ta = g_byte_array_new();\n\tstat(file, &s);\n\tg_byte_array_set_size(a, s.st_size);\n\n\tf = fopen_read_or_die(file);\n\tfread(a->data, 1, s.st_size, f);\n\tfclose(f);\n\n\treturn a;\n}\n\nchar*\nsuck_file_str( char* file )\n{\n\tGByteArray* a;\n\tchar* s;\n\tunsigned char zero;\n\n\ta = suck_file(file);\n\tzero = 0;\n\tg_byte_array_append(a, &zero, 1);\n\ts = (char*) a->data;\n\tg_byte_array_free(a, 0);\n\n\treturn s;\n}\n\nchar*\nsuck_stdin()\n{\n\tGString* s;\n\tchar* r;\n\tint c;\n\n\ts = g_string_new(\"\");\n\twhile( (c = fgetc(stdin)) != EOF )\n\t\tg_string_append_c(s, c);\n\n\tr = s->str;\n\tg_string_free(s, 0);\n\n\treturn r;\n}\n\nvoid\nspit_file( char* file, GByteArray* b, int free )\n{\n\tFILE* f;\n\n\tf = fopen_write_or_die(file);\n\tfwrite(b->data, 1, b->len, f);\n\tfclose(f);\n\n\tif( free )\n\t\tg_byte_array_free(b, 1);\n}\n\nvoid read_cph_file(char* file, GByteArray** cph_buf)\n{\n\tFILE* f;\n\tint i;\n\tint len;\n\n\t*cph_buf = g_byte_array_new();\n\tf = fopen_read_or_die(file);\n\n\t/* read cph buf */\n\tlen = 0;\n\tfor( i = 3; i >= 0; i-- )\n\t\tlen |= fgetc(f)<<(i*8);\n\tg_byte_array_set_size(*cph_buf, len);\n\tfread((*cph_buf)->data, 1, len, f);\n//\tprintf(\"[common.c][read_cpabe_file][cph_buf->len] %u\\n\", cph_buf->len);\n\t\n//        printf(\"cph_buf->len = %u\\n\", len);\n//        printf(\"cph_buf->data = %s\\n\", (*cph_buf)->data);\n\t\n\tfclose(f);\n}\n\nvoid\nwrite_cph_file( char* file,   GByteArray* cph_buf )\n{\n\tFILE* f;\n\tint i;\n\n\tf = fopen_write_or_die(file);\n\n\t/* write cph_buf */\n\tfor( i = 3; i >= 0; i-- )\n\t\tfputc((cph_buf->len & 0xff<<(i*8))>>(i*8), f);\n\tfwrite(cph_buf->data, 1, cph_buf->len, f);\n\t\n//        printf(\"cph_buf->len = %u\\n\", cph_buf->len);\n//        printf(\"cph_buf->data = %s\\n\", cph_buf->data);\n\t\n\tfclose(f);\n}\n\nvoid read_aes_file( char* file,    \n        int* file_len, GByteArray** aes_buf )\n{\n\tFILE* f;\n\tint i;\n\tint len;\n\n\t*aes_buf = g_byte_array_new();\n\n\tf = fopen_read_or_die(file);\n\n        //printf(\"*** [common][read_cpabe_file] ***\\n\");\n\n\t/* read real file len as 32-bit big endian int */\n\t*file_len = 0;\n\tfor( i = 3; i >= 0; i-- )\n\t\t*file_len |= fgetc(f)<<(i*8);\n\n        //printf(\"file_len = %d\\n\", *file_len);\n\n\n\t/* read aes buf */\n\tlen = 0;\n\tfor( i = 3; i >= 0; i-- )\n\t\tlen |= fgetc(f)<<(i*8);\n\tg_byte_array_set_size(*aes_buf, len);\n\tfread((*aes_buf)->data, 1, len, f);\n\n        //printf(\"aes_buf->len = %u\\n\", len);\n        //printf(\"aes_buf->data = %s\\n\", (*aes_buf)->data);\n\t\n\tfclose(f);\n}\n\nvoid\nwrite_aes_file( char* file, int file_len, GByteArray* aes_buf )\n{\n\tFILE* f;\n\tint i;\n\n\tf = fopen_write_or_die(file);\n\n        //printf(\"*** [common][write_cpabe_file] ***\\n\");\n        \n\t/* write real file len as 32-bit big endian int */\n\tfor( i = 3; i >= 0; i-- )\n\t\tfputc((file_len & 0xff<<(i*8))>>(i*8), f);\n\n        //printf(\"file_len = %d\\n\", file_len);\n\n\t/* write aes_buf */\n\tfor( i = 3; i >= 0; i-- )\n\t\tfputc((aes_buf->len & 0xff<<(i*8))>>(i*8), f);\n\tfwrite(aes_buf->data, 1, aes_buf->len, f);\n\n        //printf(\"aes_buf->len = %u\\n\", aes_buf->len);\n       // printf(\"aes_buf->data = %s\\n\", aes_buf->data);\n\t\n\tfclose(f);\n}\n\n\nvoid read_cpabe_file( char* file,    GByteArray** cph_buf,\n        int* file_len, GByteArray** aes_buf )\n{\n\tFILE* f;\n\tint i;\n\tint len;\n\n\t*cph_buf = g_byte_array_new();\n\t*aes_buf = g_byte_array_new();\n\n\tf = fopen_read_or_die(file);\n\n        //printf(\"*** [common][read_cpabe_file] ***\\n\");\n\n\t/* read real file len as 32-bit big endian int */\n\t*file_len = 0;\n\tfor( i = 3; i >= 0; i-- )\n\t\t*file_len |= fgetc(f)<<(i*8);\n\n        //printf(\"file_len = %d\\n\", *file_len);\n\n\n\t/* read aes buf */\n\tlen = 0;\n\tfor( i = 3; i >= 0; i-- )\n\t\tlen |= fgetc(f)<<(i*8);\n\tg_byte_array_set_size(*aes_buf, len);\n\tfread((*aes_buf)->data, 1, len, f);\n\n        //printf(\"aes_buf->len = %u\\n\", len);\n        //printf(\"aes_buf->data = %s\\n\", (*aes_buf)->data);\n\n\t/* read cph buf */\n\tlen = 0;\n\tfor( i = 3; i >= 0; i-- )\n\t\tlen |= fgetc(f)<<(i*8);\n\tg_byte_array_set_size(*cph_buf, len);\n\tfread((*cph_buf)->data, 1, len, f);\n//\tprintf(\"[common.c][read_cpabe_file][cph_buf->len] %u\\n\", cph_buf->len);\n\t\n        //printf(\"cph_buf->len = %u\\n\", len);\n        //printf(\"cph_buf->data = %s\\n\", (*cph_buf)->data);\n\t\n\tfclose(f);\n}\n\nvoid\nwrite_cpabe_file( char* file,   GByteArray* cph_buf,\n\t\t\t\t\t\t\t\t\tint file_len, GByteArray* aes_buf )\n{\n\tFILE* f;\n\tint i;\n\n\tf = fopen_write_or_die(file);\n\n        //printf(\"*** [common][write_cpabe_file] ***\\n\");\n        \n\t/* write real file len as 32-bit big endian int */\n\tfor( i = 3; i >= 0; i-- )\n\t\tfputc((file_len & 0xff<<(i*8))>>(i*8), f);\n\n        //printf(\"file_len = %d\\n\", file_len);\n\n\t/* write aes_buf */\n\tfor( i = 3; i >= 0; i-- )\n\t\tfputc((aes_buf->len & 0xff<<(i*8))>>(i*8), f);\n\tfwrite(aes_buf->data, 1, aes_buf->len, f);\n\n        //printf(\"aes_buf->len = %u\\n\", aes_buf->len);\n       // printf(\"aes_buf->data = %s\\n\", aes_buf->data);\n\n\n\t/* write cph_buf */\n\tfor( i = 3; i >= 0; i-- )\n\t\tfputc((cph_buf->len & 0xff<<(i*8))>>(i*8), f);\n\tfwrite(cph_buf->data, 1, cph_buf->len, f);\n\t\n\t\n        //printf(\"cph_buf->len = %u\\n\", cph_buf->len);\n        //printf(\"cph_buf->data = %s\\n\", cph_buf->data);\n\t\n\tfclose(f);\n}\n\nvoid\ndie(char* fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\texit(1);\n}\n\n\n"
        },
        {
            "file_name": "core.c",
            "content": "#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <unistd.h>\n#ifndef BSWABE_DEBUG\n#define NDEBUG\n#endif\n//#define PBC_DEBUG\n\n#include <assert.h>\n\n#include <openssl/sha.h>\n#include <glib.h>\n#include <pbc.h>\n\n#include \"bswabe.h\"\n#include \"private.h\"\n\n#define TYPE_A_PARAMS \\\n\t\t\"type a\\n\" \\\n\t\t\"q 87807107996633125224377819847540498158068831994142082\" \\\n\t\t\"1102865339926647563088022295707862517942266222142315585\" \\\n\t\t\"8769582317459277713367317481324925129998224791\\n\" \\\n\t\t\"h 12016012264891146079388821366740534204802954401251311\" \\\n\t\t\"822919615131047207289359704531102844802183906537786776\\n\" \\\n\t\t\"r 730750818665451621361119245571504901405976559617\\n\" \\\n\t\t\"exp2 159\\n\" \\\n\t\t\"exp1 107\\n\" \\\n\t\t\"sign1 1\\n\" \\\n\t\t\"sign0 1\\n\"\n\n#define TYPE_D159_PARAMS \\\n\t\t\"type d\\n\" \\\n\t\t\"q 625852803282871856053922297323874661378036491717\\n\" \\\n\t\t\"n 625852803282871856053923088432465995634661283063\\n\" \\\n\t\t\"h 3\\n\" \\\n\t\t\"r 208617601094290618684641029477488665211553761021\\n\" \\\n\t\t\"a 581595782028432961150765424293919699975513269268\\n\" \\\n\t\t\"b 517921465817243828776542439081147840953753552322\\n\" \\\n\t\t\"k 6\\n\" \\\n\t\t\"nk 60094290356408407130984161127310078516360031868417968262992864809623507269833854678414046779817844853757026858774966331434198257512457993293271849043664655146443229029069463392046837830267994222789160047337432075266619082657640364986415435746294498140589844832666082434658532589211525696\\n\" \\\n\t\t\"hk 1380801711862212484403205699005242141541629761433899149236405232528956996854655261075303661691995273080620762287276051361446528504633283152278831183711301329765591450680250000592437612973269056\\n\" \\\n\t\t\"coeff0 472731500571015189154958232321864199355792223347\\n\" \\\n\t\t\"coeff1 352243926696145937581894994871017455453604730246\\n\" \\\n\t\t\"coeff2 289113341693870057212775990719504267185772707305\\n\" \\\n\t\t\"nqr 431211441436589568382088865288592347194866189652\\n\"\n\nint leaf_count2 = 0;\nchar last_error[256];\n\nchar*\nbswabe_error()\n{\n\treturn last_error;\n}\n\nvoid\nraise_error(char* fmt, ...)\n{\n\tva_list args;\n\n#ifdef BSWABE_DEBUG\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\texit(1);\n#else\n\tva_start(args, fmt);\n\tvsnprintf(last_error, 256, fmt, args);\n\tva_end(args);\n#endif\n}\n\nvoid\nelement_from_string( element_t h, char* s )\n{\n\tunsigned char* r;\n\n\tr = malloc(SHA_DIGEST_LENGTH);\n\tSHA1((unsigned char*) s, strlen(s), r);\n\telement_from_hash(h, r, SHA_DIGEST_LENGTH);\n\n\tfree(r);\n}\nvoid\neval_poly( element_t r, bswabe_polynomial_t* q, element_t x )\n{\n\tint i;\n\telement_t s, t;\n\n\telement_init_same_as(s, r);\n\telement_init_same_as(t, r);\n\n\telement_set0(r);\n\telement_set1(t);\n\n\tfor( i = 0; i < q->deg + 1; i++ )\n\t{\n\t\t/* r += q->coef[i] * t */\n\t\telement_mul(s, q->coef[i], t);\n\t\telement_add(r, r, s);\n\n\t\t/* t = t * x = x^(i+1) */\n\t\telement_mul(t, t, x);\n\t}\n\n\telement_clear(s);\n\telement_clear(t);\n}\n\nbswabe_polynomial_t*\nrand_poly( int deg, element_t zero_val )\n{\n\tint i;\n\tbswabe_polynomial_t* q;\n\n\tq = (bswabe_polynomial_t*) malloc(sizeof(bswabe_polynomial_t));\n\tq->deg = deg;\n\tq->coef = (element_t*) malloc(sizeof(element_t) * (deg + 1));\n\n\tfor( i = 0; i < q->deg + 1; i++ )\n\t\telement_init_same_as(q->coef[i], zero_val);\n\n\telement_set(q->coef[0], zero_val);\n\n\tfor( i = 1; i < q->deg + 1; i++ )\n\t{\n\t\telement_random(q->coef[i]);\n\t}\n\n\treturn q;\n}\n\n/************************** Setup **************************/\nvoid\nbswabe_setup( bswabe_pub_t** pub, bswabe_msk_t** msk )\n{\n\telement_t alpha;\n\telement_t p0;\t\t\t\t// P(0), the secret and zero_val of rpt, the polynomial\n\tint rpt_t = REVOKE_T;\t\t// degree of rpt\n\n\t/* initialize */\n\n\t*pub = malloc(sizeof(bswabe_pub_t));\n\t*msk = malloc(sizeof(bswabe_msk_t));\n\n\t(*pub)->pairing_desc = strdup(TYPE_D159_PARAMS);\n\n\tpairing_init_set_buf((*pub)->p, (*pub)->pairing_desc, strlen((*pub)->pairing_desc));\n\n\telement_init_G1((*pub)->g,           (*pub)->p);\n\telement_init_G1((*pub)->h,           (*pub)->p);\n\telement_init_G2((*pub)->gp,          (*pub)->p);\n\telement_init_GT((*pub)->g_hat_alpha, (*pub)->p);\t//e(g,gp)\n\n\telement_init_Zr(alpha,               (*pub)->p);\n\telement_init_Zr((*msk)->beta,        (*pub)->p);\n\telement_init_G2((*msk)->g_alpha,     (*pub)->p);\t// gp^alpha\n\telement_init_Zr(p0,                  (*pub)->p);\n\n\t/* compute */\n\n\telement_random(alpha);\n\telement_random((*msk)->beta);\n\telement_random((*pub)->g);\n\telement_random((*pub)->gp);\n\n\telement_random(p0);\n\t(*msk)->rpt = rand_poly(rpt_t, p0);\n\n\telement_pow_zn((*msk)->g_alpha, (*pub)->gp,\talpha);\t// g_alpha = gp^alpha\n\telement_pow_zn((*pub)->h, (*pub)->g, (*msk)->beta);\t// h = g^beta\n\n\tpairing_apply((*pub)->g_hat_alpha, (*pub)->g, (*msk)->g_alpha, (*pub)->p);\t// g_hat_alpha = e(g, g_alpha) = e(g, gp^alpha)\n}\n\n/************************** KeyGen **************************/\nbswabe_prv_t*\nbswabe_keygen( bswabe_pub_t* pub, bswabe_msk_t* msk, char** attributes, element_t u_k )\n{\n\tbswabe_prv_t* prv;\n\n\telement_t g_r;\n\telement_t r;\n\telement_t beta_inv;\n\telement_t p_uk;\n\telement_t p_0;\n\n\t/* initialize */\n\n\tprv = malloc(sizeof(bswabe_prv_t));\n\n\telement_init_G2(prv->d, pub->p);\n\telement_init_G2(g_r, pub->p);\n\telement_init_Zr(r, pub->p);\n\telement_init_Zr(beta_inv, pub->p);\n\n\telement_init_Zr(u_k, pub->p);\n\telement_init_Zr(p_uk, pub->p);\n\telement_init_Zr(p_0, pub->p);\n\n\tprv->comps = g_array_new(0, 1, sizeof(bswabe_prv_comp_t));\n\n\t/* compute */\n\n\telement_random(r);\n\telement_pow_zn(g_r, pub->gp, r);\t\t\t// g_r = gp^r\n\n\telement_mul(prv->d, msk->g_alpha, g_r);\t\t// d = gp^alpha * gp^r\n\telement_invert(beta_inv, msk->beta); \t\t// beta_inv = 1/beta\n\telement_pow_zn(prv->d, prv->d, beta_inv);\t// d = gp^((alpha + r)/beta)\n\n\telement_random(u_k);\n\teval_poly(p_uk, (bswabe_polynomial_t*) msk->rpt, u_k);\t// p_k = P(u_k)\n\telement_set(p_0, (msk->rpt)->coef[0]); \t\t\t\t\t//p_0 = the secret\n\n\twhile( *attributes )\n\t{\n\t\tbswabe_prv_comp_t c;\n\t\telement_t h_rp;\n\t\telement_t rp;\n\n\t\tc.attr = *(attributes++);\n\n\t\telement_init_G2(c.d,  pub->p);\n\t\telement_init_G1(c.dp, pub->p);\t//dp, dpp from G1\n\t\telement_init_G1(c.dpp, pub->p);\n\n\t\telement_init_G2(h_rp, pub->p);\n\t\telement_init_Zr(rp,   pub->p);\n\n\t\telement_from_string(h_rp, c.attr);\t// h_rp = H(j)\n\t\telement_random(rp);\n\t\telement_pow_zn(h_rp, h_rp, rp); \t// h_rp = H(j)^rj\n\t\telement_pow_zn(h_rp, h_rp, p_0);\t// h_rp = (H(j)^rj)^p_0 = H(j)^(rj.p_0)\n\n\t\telement_mul(c.d, g_r, h_rp);\t\t// d = gp^r * H(j)^(rj.p_0)\n\t\telement_pow_zn(c.dp, pub->g, rp); \t// dp = gp^rj //sonia: changed g to gp, since D is of G2\n\t\telement_pow_zn(c.dpp, c.dp, p_uk); \t// d\"= d' ^ p(uk)\n\n\t\telement_clear(h_rp);\n\t\telement_clear(rp);\n\t\tg_array_append_val(prv->comps, c);\n\t}\n\n\telement_clear(g_r);\n\telement_clear(r);\n\telement_clear(beta_inv);\n\telement_clear(p_uk);\n\telement_clear(p_0);\n\n\treturn prv;\n}\n\nbswabe_policy_t*\nbase_node( int k, char* s )\n{\n\tbswabe_policy_t* p;\n\n\tp = (bswabe_policy_t*) malloc(sizeof(bswabe_policy_t));\n\tp->k = k;\n\tp->attr = s ? strdup(s) : 0;\n\tif(s && k)\n\t{\n\t\tleaf_count2++;\n\t}\n\tp->children = g_ptr_array_new();\n\tp->q = 0;\n\n\treturn p;\n}\n\n/*\n\tTODO convert this to use a GScanner and handle quotes and / or\n\tescapes to allow attributes with whitespace or = signs in them\n */\n\nbswabe_policy_t*\nparse_policy_postfix( char* s )\n{\n\tchar** toks;\n\tchar** cur_toks;\n\tchar*  tok;\n\tGPtrArray* stack; /* pointers to bswabe_policy_t's */\n\tbswabe_policy_t* root;\n\n\ttoks     = g_strsplit(s, \" \", 0);\n\tcur_toks = toks;\n\tstack    = g_ptr_array_new();\n\n\twhile( *cur_toks )\n\t{\n\t\tint i, k, n;\n\n\t\ttok = *(cur_toks++);\n\n\t\tif( !*tok )\n\t\t\tcontinue;\n\n\t\tif( sscanf(tok, \"%dof%d\", &k, &n) != 2 )\n\t\t\t/* push leaf token */\n\t\t\tg_ptr_array_add(stack, base_node(1, tok));\n\t\telse\n\t\t{\n\t\t\tbswabe_policy_t* node;\n\n\t\t\t/* parse \"kofn\" operator */\n\n\t\t\tif( k < 1 )\n\t\t\t{\n\t\t\t\traise_error(\"error parsing \\\"%s\\\": trivially satisfied operator \\\"%s\\\"\\n\", s, tok);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if( k > n )\n\t\t\t{\n\t\t\t\traise_error(\"error parsing \\\"%s\\\": unsatisfiable operator \\\"%s\\\"\\n\", s, tok);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if( n == 1 )\n\t\t\t{\n\t\t\t\traise_error(\"error parsing \\\"%s\\\": identity operator \\\"%s\\\"\\n\", s, tok);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if( n > stack->len )\n\t\t\t{\n\t\t\t\traise_error(\"error parsing \\\"%s\\\": stack underflow at \\\"%s\\\"\\n\", s, tok);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* pop n things and fill in children */\n\t\t\tnode = base_node(k, 0);\n\t\t\tg_ptr_array_set_size(node->children, n);\n\t\t\tfor( i = n - 1; i >= 0; i-- )\n\t\t\t\tnode->children->pdata[i] = g_ptr_array_remove_index(stack, stack->len - 1);\n\n\t\t\t/* push result */\n\t\t\tg_ptr_array_add(stack, node);\n\t\t}\n\t}\n\n\tif( stack->len > 1 )\n\t{\n\t\traise_error(\"error parsing \\\"%s\\\": extra tokens left on stack\\n\", s);\n\t\treturn 0;\n\t}\n\telse if( stack->len < 1 )\n\t{\n\t\traise_error(\"error parsing \\\"%s\\\": empty policy\\n\", s);\n\t\treturn 0;\n\t}\n\n\troot = g_ptr_array_index(stack, 0);\n\n\tg_strfreev(toks);\n\tg_ptr_array_free(stack, 0);\n\n\treturn root;\n}\n\nvoid\nfill_policy( bswabe_policy_t* p, bswabe_pub_t* pub, element_t e)\n{\n\tint i;\n\telement_t r;\n\telement_t t;\n\telement_t h;\n\n\telement_init_Zr(r, pub->p);\n\telement_init_Zr(t, pub->p);\n\telement_init_G2(h, pub->p);\n\n\tp->q = rand_poly(p->k - 1, e);\n\n\tif( p->children->len == 0 )\n\t{\n\t\telement_init_G1(p->c,  pub->p);\n\t\telement_init_G2(p->cp, pub->p);\n\n\t\telement_from_string(h, p->attr);\n\t\telement_pow_zn(p->c,  pub->g, p->q->coef[0]);\n\t\telement_pow_zn(p->cp, h,      p->q->coef[0]);\n\t}\n\telse\n\t{\n\t\tfor( i = 0; i < p->children->len; i++ )\n\t\t{\n\t\t\telement_set_si(r, i + 1);\n\t\t\teval_poly(t, p->q, r);\n\t\t\tfill_policy(g_ptr_array_index(p->children, i), pub, t);\n\t\t}\n\t}\n\telement_clear(r);\n\telement_clear(t);\n\telement_clear(h);\n}\n\n/************************** Encrypt **************************/\nbswabe_cph_t*\nbswabe_enc( bswabe_pub_t* pub, element_t m, char* policy )\n{\n\tbswabe_cph_t* cph;\n\telement_t s;\n\n\t/* initialize */\n\n\tcph = malloc(sizeof(bswabe_cph_t));\n\n\telement_init_Zr(s, pub->p);\n\telement_init_GT(m, pub->p);\n\telement_init_GT(cph->cs, pub->p);\n\telement_init_G1(cph->c,  pub->p);\n\tcph->p = parse_policy_postfix(policy);\n\n\t/* compute */\n\n\telement_random(m);\n\telement_random(s);\n\n\telement_pow_zn(cph->cs, pub->g_hat_alpha, s); // C~ = e(g, gp)^(alpha * s)\n\telement_mul(cph->cs, cph->cs, m); // C~ = m * e(g, gp)^(alpha * s)\n\n\telement_pow_zn(cph->c, pub->h, s); // C = h^s\n\n\tfill_policy(cph->p, pub, s);\n\n\treturn cph;\n}\n\n/************************** Functions for Decryption with Regular or Delegated Private Key **************************/\n\n/*to check with regular or  delegated key*/\nvoid\ncheck_sat( bswabe_policy_t* p, bswabe_prv_t* prv, bswabe_del_prv_t* del_prv )\n{\n\tint i, l;\n\n\tp->satisfiable = 0;\n\tif( p->children->len == 0 )\n\t{\n\t\tif(prv)\n\t\t{\n\t\t\tfor( i = 0; i < prv->comps->len; i++ )\n\t\t\t\tif( !strcmp(g_array_index(prv->comps, bswabe_prv_comp_t, i).attr, p->attr) )\n\t\t\t\t{\n\t\t\t\t\tp->satisfiable = 1;\n\t\t\t\t\tp->attri = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//printf(\"len = %u\\n\", del_prv->comps->len);\n\t\t\tfor( i = 0; i < del_prv->comps->len; i++ )\n\t\t\t{\n\n\t\t\t\t//printf(\"%s\\t%s\\n\", p->attr, g_array_index(del_prv->comps, bswabe_del_prv_comp_t, i).attr);\n\t\t\t\tif( !strcmp(g_array_index(del_prv->comps, bswabe_del_prv_comp_t, i).attr, p->attr) )\n\t\t\t\t{\n\t\t\t\t\tp->satisfiable = 1;\n\t\t\t\t\tp->attri = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor( i = 0; i < p->children->len; i++ )\n\t\t{\n\t\t\tif (prv) \n\t\t\t\tcheck_sat(g_ptr_array_index(p->children, i), prv, NULL);\n\t\t\telse \n\t\t\t\tcheck_sat(g_ptr_array_index(p->children, i), NULL, del_prv);\n\t\t}\n\n\t\tl = 0;\n\t\tfor( i = 0; i < p->children->len; i++ )\n\t\t\tif( ((bswabe_policy_t*) g_ptr_array_index(p->children, i))->satisfiable )\n\t\t\t\tl++;\n\n\t\tif( l >= p->k )\n\t\t\tp->satisfiable = 1;\n\t}\n}\n\n/*regular or delegated private key*/\nvoid\npick_sat_naive( bswabe_policy_t* p, bswabe_prv_t* prv, bswabe_del_prv_t* del_prv )\n{\n\tint i, k, l;\n\n\tassert(p->satisfiable == 1);\n\n\tif( p->children->len == 0 )\n\t\treturn;\n\n\tp->satl = g_array_new(0, 0, sizeof(int));\n\n\tl = 0;\n\tfor( i = 0; i < p->children->len && l < p->k; i++ )\n\t\tif( ((bswabe_policy_t*) g_ptr_array_index(p->children, i))->satisfiable )\n\t\t{\n\t\t\tif(prv)\n\t\t\t\tpick_sat_naive(g_ptr_array_index(p->children, i), prv, NULL);\n\t\t\telse\n\t\t\t\tpick_sat_naive(g_ptr_array_index(p->children, i), NULL, del_prv);\t\t\t\t\n\t\t\tl++;\n\t\t\tk = i + 1;\n\t\t\tg_array_append_val(p->satl, k);\n\t\t}\n}\n\n/* TODO there should be a better way of doing this */\nbswabe_policy_t* cur_comp_pol;\nint\ncmp_int( const void* a, const void* b )\n{\n\tint k, l;\n\n\tk = ((bswabe_policy_t*) g_ptr_array_index(cur_comp_pol->children, *((int*)a)))->min_leaves;\n\tl = ((bswabe_policy_t*) g_ptr_array_index(cur_comp_pol->children, *((int*)b)))->min_leaves;\n\n\treturn\n\t\t\tk <  l ? -1 :\n\t\t\t\t\tk == l ?  0 : 1;\n}\n\nvoid\npick_sat_min_leaves( bswabe_policy_t* p, bswabe_prv_t* prv )\n{\n\tint i, k, l;\n\tint* c;\n\n\tassert(p->satisfiable == 1);\n\n\tif( p->children->len == 0 )\n\t\tp->min_leaves = 1;\n\telse\n\t{\n\t\tfor( i = 0; i < p->children->len; i++ )\n\t\t\tif( ((bswabe_policy_t*) g_ptr_array_index(p->children, i))->satisfiable )\n\t\t\t\tpick_sat_min_leaves(g_ptr_array_index(p->children, i), prv);\n\n\t\tc = alloca(sizeof(int) * p->children->len);\n\t\tfor( i = 0; i < p->children->len; i++ )\n\t\t\tc[i] = i;\n\n\t\tcur_comp_pol = p;\n\t\tqsort(c, p->children->len, sizeof(int), cmp_int);\n\n\t\tp->satl = g_array_new(0, 0, sizeof(int));\n\t\tp->min_leaves = 0;\n\t\tl = 0;\n\n\t\tfor( i = 0; i < p->children->len && l < p->k; i++ )\n\t\t\tif( ((bswabe_policy_t*) g_ptr_array_index(p->children, c[i]))->satisfiable )\n\t\t\t{\n\t\t\t\tl++;\n\t\t\t\tp->min_leaves += ((bswabe_policy_t*) g_ptr_array_index(p->children, c[i]))->min_leaves;\n\t\t\t\tk = c[i] + 1;\n\t\t\t\tg_array_append_val(p->satl, k);\n\t\t\t}\n\t\tassert(l == p->k);\n\t}\n}\n\nvoid\nlagrange_coef2( element_t r, GArray* s, element_t i )\n{\n\tint k;\n\telement_t t;\n\telement_t j;\n\n\telement_init_same_as(t, r);\n\telement_init_same_as(j, r);\n\n\telement_set1(r);\n\n\tfor( k = 0; k < s->len; k++ )\n\t{\n\t\telement_set(j, g_array_index(s, element_t, k));\n\n\t\tif( element_cmp(j,i) == 0)\n\t\t\tcontinue;\n\t\telement_neg(t, j);\n\t\telement_mul(r, r, t); /* num_muls++;*/\n\t\telement_sub(t, i, j);\n\t\telement_invert(t, t);\n\t\telement_mul(r, r, t); /* num_muls++; */\n\t}\n\n\telement_clear(t);\n\telement_clear(j);\n}\n\nvoid\nlagrange_coef( element_t r, GArray* s, int i )\n{\n\tint j, k;\n\telement_t t;\n\n\telement_init_same_as(t, r);\n\n\telement_set1(r);\n\n\tfor( k = 0; k < s->len; k++ )\n\t{\n\t\tj = g_array_index(s, int, k);\n\n\t\tif( j == i )\n\t\t\tcontinue;\n\t\telement_set_si(t, - j);\n\t\telement_mul(r, r, t); /* num_muls++;*/\n\t\telement_set_si(t, i - j);\n\t\telement_invert(t, t);\n\t\telement_mul(r, r, t); /* num_muls++; */\n\t}\n\n\telement_clear(t);\n}\n/* decrypt with regular key*/\nvoid\ndec_leaf_naive( element_t r, bswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub, element_t lambda_k)\n{\n\telement_t t1;\n\telement_t t2;\n\n\tbswabe_prv_comp_t* c;\n\n\n\tc = &(g_array_index(prv->comps, bswabe_prv_comp_t, p->attri));\n\n\telement_init_GT(t1, pub->p);\n\telement_init_GT(t2, pub->p);\n\n\tpairing_apply(r, p->c,  c->d,  pub->p); /* num_pairings++; */ // r = e(c,d)\n\tpairing_apply(t1, c->dpp, p->cp, pub->p); // e(c', d\")\n\telement_pow_zn(t1, t1, lambda_k);\n\tpairing_apply(t2, c->dp, p->cpp, pub->p); // e(c\", d')\n\n\telement_mul(t1, t1, t2); /* t1 =  e(c', d\")^lambda_k * e(c\", d')*/\n\telement_invert(t1, t1);\n\telement_mul(r, r, t1); // r = e(c,d) / (e(c', d\") * e(c\", d')*/)\n\n\telement_clear(t1);\n\telement_clear(t2);\n}\n\n/*delegated key*/\nvoid\ndec_leaf_naive_delegated( element_t r, bswabe_policy_t* pa, bswabe_policy_t* pb, bswabe_del_prv_t* del_prv, bswabe_pub_t* pub, element_t lambda_AB, element_t lambda_BC)\n{\n\telement_t t1;\n\telement_t t2;\n\telement_t t3;\n\n\tbswabe_del_prv_comp_t* c;\n\n\tc = &(g_array_index(del_prv->comps, bswabe_del_prv_comp_t, pa->attri));\n\n\telement_init_GT(t1, pub->p);\n\telement_init_GT(t2, pub->p);\n\telement_init_GT(t3, pub->p);\n\n\tpairing_apply(r, pa->c,  c->d,  pub->p); /* num_pairings++; */ // r = e(c,d)\n\tpairing_apply(t1, c->dpp, pb->cpp, pub->p); // e(d\"~, pb-c\") = e(d\"~, c'^XB,)\n\telement_pow_zn(t1, t1, lambda_AB); // e(d\"~, c\"XB)^lambda_AB\n\n\tpairing_apply(t3, c->d3p, pa->cp, pub->p); // e(D'''~, C')\n\telement_pow_zn(t3, t3, lambda_AB);// e(D'''~, C')^lambda_AB\n\telement_pow_zn(t3, t3, lambda_BC);  // e(D'''~, C')^lambda_AB . lambda_BC\n\n\telement_mul(t1, t1, t3);\n\n\tpairing_apply(t2, c->dp, pa->cpp, pub->p); // e(d', pa-c\") = e( d', c'^XA)\n\n\telement_mul(t1, t1, t2); /* t1 =  e(c', d\")^lambda_k * e(c\", d')*/\n\telement_invert(t1, t1);\n\telement_mul(r, r, t1); // r = e(c,d) / (e(c', d\") * e(c\", d')*/)\n\n\telement_clear(t1);\n\telement_clear(t2);\n}\n\n\n/*regular key*/\nvoid dec_node_naive( element_t r, bswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub, element_t lambda_k );\n\n/*delegated key*/\nvoid dec_node_naive_delegated( element_t r, bswabe_policy_t* pa, bswabe_policy_t* pb, bswabe_del_prv_t* del_prv, bswabe_pub_t* pub, element_t lambda_AB, element_t lambda_BC );\n\n/*regular key*/\nvoid\ndec_internal_naive( element_t r, bswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub, element_t lambda_k )\n{\n\tint i;\n\telement_t s;\n\telement_t t;\n\n\telement_init_GT(s, pub->p);\n\telement_init_Zr(t, pub->p);\n\n\telement_set1(r);\n\tfor( i = 0; i < p->satl->len; i++ )\n\t{\n\t\tdec_node_naive (s, g_ptr_array_index(p->children, g_array_index(p->satl, int, i) - 1), prv, pub, lambda_k );\n\t\tlagrange_coef(t, p->satl, g_array_index(p->satl, int, i));\n\t\telement_pow_zn(s, s, t); /* num_exps++; */\n\t\telement_mul(r, r, s); /* num_muls++; */\n\t}\n\n\telement_clear(s);\n\telement_clear(t);\n}\n\n/*delegated key*/\nvoid\ndec_internal_naive_delegated( element_t r, bswabe_policy_t* pa, bswabe_policy_t* pb, bswabe_del_prv_t* del_prv, bswabe_pub_t* pub, element_t lambda_AB, element_t lambda_BC )\n{\n\tint i;\n\telement_t s;\n\telement_t t;\n\n\telement_init_GT(s, pub->p);\n\telement_init_Zr(t, pub->p);\n\n\telement_set1(r);\n\tfor( i = 0; i < pa->satl->len; i++ )\n\t{\n\t\tdec_node_naive_delegated (s, g_ptr_array_index(pa->children, g_array_index(pa->satl, int, i) - 1), \n\t\t\t\tg_ptr_array_index(pb->children, g_array_index(pa->satl, int, i) - 1), del_prv, pub, lambda_AB, lambda_BC);\n\t\tlagrange_coef(t, pa->satl, g_array_index(pa->satl, int, i));\n\t\telement_pow_zn(s, s, t); /* num_exps++; */\n\t\telement_mul(r, r, s); /* num_muls++; */\n\t}\n\n\telement_clear(s);\n\telement_clear(t);\n}\n\n/*regular key*/\nvoid\ndec_node_naive( element_t r, bswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub, element_t lambda_k)\n{\n\tassert(p->satisfiable);\n\tif( p->children->len == 0 )\n\t{\n\t\tdec_leaf_naive(r, p, prv, pub, lambda_k);\n\t}\n\telse\n\t\tdec_internal_naive(r, p, prv, pub, lambda_k);\n}\n\n/*delegated key*/\nvoid\ndec_node_naive_delegated( element_t r, bswabe_policy_t* pa, bswabe_policy_t* pb, bswabe_del_prv_t* del_prv, bswabe_pub_t* pub, element_t lambda_AB, element_t lambda_BC )\n{\n\tassert(pa->satisfiable);\n\tif( pa->children->len == 0 )\n\t{\n\t\tdec_leaf_naive_delegated(r, pa, pb, del_prv, pub, lambda_AB, lambda_BC);\n\t}\n\telse\n\t\tdec_internal_naive_delegated(r, pa, pb, del_prv, pub, lambda_AB, lambda_BC);\n}\n\n/*regular key*/\nvoid\ndec_naive( element_t r, bswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub, element_t lambda_k)\n{\n\tdec_node_naive(r, p, prv, pub, lambda_k);\n}\n/*delegated key*/\nvoid\ndec_naive_delegated( element_t r, bswabe_policy_t* pa, bswabe_policy_t* pb, bswabe_del_prv_t* del_prv, bswabe_pub_t* pub, element_t lambda_AB, element_t lambda_BC )\n{\n\tdec_node_naive_delegated(r, pa, pb, del_prv, pub, lambda_AB, lambda_BC);\n}\n\nvoid\ndec_leaf_merge( element_t exp, bswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub )\n{\n\tbswabe_prv_comp_t* c;\n\telement_t s;\n\n\tc = &(g_array_index(prv->comps, bswabe_prv_comp_t, p->attri));\n\n\tif( !c->used )\n\t{\n\t\tc->used = 1;\n\t\telement_init_G1(c->z,  pub->p);\n\t\telement_init_G1(c->zp, pub->p);\n\t\telement_set1(c->z);\n\t\telement_set1(c->zp);\n\t}\n\n\telement_init_G1(s, pub->p);\n\n\telement_pow_zn(s, p->c, exp); /* num_exps++; */\n\telement_mul(c->z, c->z, s); /* num_muls++; */\n\n\telement_pow_zn(s, p->cp, exp); /* num_exps++; */\n\telement_mul(c->zp, c->zp, s); /* num_muls++; */\n\n\telement_clear(s);\n}\n\nvoid dec_node_merge( element_t exp, bswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub );\n\nvoid\ndec_internal_merge( element_t exp, bswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub )\n{\n\tint i;\n\telement_t t;\n\telement_t expnew;\n\n\telement_init_Zr(t, pub->p);\n\telement_init_Zr(expnew, pub->p);\n\n\tfor( i = 0; i < p->satl->len; i++ )\n\t{\n\t\tlagrange_coef(t, p->satl, g_array_index(p->satl, int, i));\n\t\telement_mul(expnew, exp, t); /* num_muls++; */\n\t\tdec_node_merge(expnew, g_ptr_array_index\n\t\t\t\t(p->children, g_array_index(p->satl, int, i) - 1), prv, pub);\n\t}\n\n\telement_clear(t);\n\telement_clear(expnew);\n}\n\nvoid\ndec_node_merge( element_t exp, bswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub )\n{\n\tassert(p->satisfiable);\n\tif( p->children->len == 0 )\n\t\tdec_leaf_merge(exp, p, prv, pub);\n\telse\n\t\tdec_internal_merge(exp, p, prv, pub);\n}\n\nvoid\ndec_merge( element_t r, bswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub )\n{\n\tint i;\n\telement_t one;\n\telement_t s;\n\n\t/* first mark all attributes as unused */\n\tfor( i = 0; i < prv->comps->len; i++ )\n\t\tg_array_index(prv->comps, bswabe_prv_comp_t, i).used = 0;\n\n\t/* now fill in the z's and zp's */\n\telement_init_Zr(one, pub->p);\n\telement_set1(one);\n\tdec_node_merge(one, p, prv, pub);\n\telement_clear(one);\n\n\t/* now do all the pairings and multiply everything together */\n\telement_set1(r);\n\telement_init_GT(s, pub->p);\n\tfor( i = 0; i < prv->comps->len; i++ )\n\t\tif( g_array_index(prv->comps, bswabe_prv_comp_t, i).used )\n\t\t{\n\t\t\tbswabe_prv_comp_t* c = &(g_array_index(prv->comps, bswabe_prv_comp_t, i));\n\n\t\t\tpairing_apply(s, c->z, c->d, pub->p); /* num_pairings++; */\n\t\t\telement_mul(r, r, s); /* num_muls++; */\n\n\t\t\tpairing_apply(s, c->zp, c->dp, pub->p); /* num_pairings++; */\n\t\t\telement_invert(s, s);\n\t\t\telement_mul(r, r, s); /* num_muls++; */\n\t\t}\n\telement_clear(s);\n}\n\nvoid\ndec_leaf_flatten( element_t r, element_t exp,\n\t\tbswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub )\n{\n\tbswabe_prv_comp_t* c;\n\telement_t s;\n\telement_t t;\n\n\tc = &(g_array_index(prv->comps, bswabe_prv_comp_t, p->attri));\n\n\telement_init_GT(s, pub->p);\n\telement_init_GT(t, pub->p);\n\n\tpairing_apply(s, p->c,  c->d,  pub->p); /* num_pairings++; */\n\tpairing_apply(t, p->cp, c->dp, pub->p); /* num_pairings++; */\n\telement_invert(t, t);\n\telement_mul(s, s, t); /* num_muls++; */\n\telement_pow_zn(s, s, exp); /* num_exps++; */\n\n\telement_mul(r, r, s); /* num_muls++; */\n\n\telement_clear(s);\n\telement_clear(t);\n}\n\nvoid dec_node_flatten( element_t r, element_t exp,\n\t\tbswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub );\n\nvoid\ndec_internal_flatten( element_t r, element_t exp,\n\t\tbswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub )\n{\n\tint i;\n\telement_t t;\n\telement_t expnew;\n\n\telement_init_Zr(t, pub->p);\n\telement_init_Zr(expnew, pub->p);\n\n\tfor( i = 0; i < p->satl->len; i++ )\n\t{\n\t\tlagrange_coef(t, p->satl, g_array_index(p->satl, int, i));\n\t\telement_mul(expnew, exp, t); /* num_muls++; */\n\t\tdec_node_flatten(r, expnew, g_ptr_array_index\n\t\t\t\t(p->children, g_array_index(p->satl, int, i) - 1), prv, pub);\n\t}\n\n\telement_clear(t);\n\telement_clear(expnew);\n}\n\nvoid\ndec_node_flatten( element_t r, element_t exp,\n\t\tbswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub )\n{\n\tassert(p->satisfiable);\n\tif( p->children->len == 0 )\n\t\tdec_leaf_flatten(r, exp, p, prv, pub);\n\telse\n\t\tdec_internal_flatten(r, exp, p, prv, pub);\n}\n\nvoid\ndec_flatten( element_t r, bswabe_policy_t* p, bswabe_prv_t* prv, bswabe_pub_t* pub )\n{\n\telement_t one;\n\n\telement_init_Zr(one, pub->p);\n\n\telement_set1(one);\n\telement_set1(r);\n\n\tdec_node_flatten(r, one, p, prv, pub);\n\n\telement_clear(one);\n}\n\n/************************** Decryption with Regular Private Key **************************/\n/*for regular key, dummy is NULL so that we can use the same small functions in both dec and dec_delegate*/\nint\nbswabe_dec( bswabe_pub_t* pub, bswabe_prv_t* prv, bswabe_cph_t* cph, element_t m, element_t lambda_k)\n{\n\telement_t t;\n\n\telement_init_GT(m, pub->p);\n\telement_init_GT(t, pub->p);\n\n\tcheck_sat(cph->p, prv, NULL);\n\tif( !cph->p->satisfiable )\n\t{\n\t\traise_error(\"cannot decrypt, attributes in key do not satisfy policy\\n\");\n\t\treturn 0;\n\t}\n\n\t/* \tif( no_opt_sat ) */\n\tpick_sat_naive(cph->p, prv, NULL); /**/\n\t/* \telse */\n\t//            pick_sat_min_leaves(cph->p, prv);\n\n\t/* \tif( dec_strategy == DEC_NAIVE ) */\n\tdec_naive(t, cph->p, prv, pub, lambda_k); /**/\n\t/* \telse if( dec_strategy == DEC_FLATTEN ) */\n\t//\tdec_flatten(t, cph->p, prv, pub);\n\t/* \telse */\n\t/* \t\tdec_merge(t, cph->p, prv, pub); */\n\n\telement_mul(m, cph->cs, t); /* num_muls++; */\n\n\tpairing_apply(t, cph->c, prv->d, pub->p); /* num_pairings++; */\n\telement_invert(t, t);\n\telement_mul(m, m, t); /* num_muls++; */\n\treturn 1;\n}\n\n/************************** Decryption with Delegated Private Key **************************/\n\n/*the only differnce between cpha and cphb is p->cpp, one is from proxyA, another from proxyB*/\nint\nbswabe_dec_delegated( bswabe_pub_t* pub, bswabe_del_prv_t* del_prv, bswabe_cph_t* cpha, bswabe_cph_t* cphb, element_t m, element_t lambda_AB, element_t lambda_BC)\n{\n\telement_t t;\n\n\telement_init_GT(m, pub->p);\n\telement_init_GT(t, pub->p);\n\n\tcheck_sat(cpha->p, NULL, del_prv);\n\tif( !cpha->p->satisfiable )\n\t{\n\t\traise_error(\"cannot decrypt_delegated, attributes in key do not satisfy policy\\n\");\n\t\treturn 0;\n\t}\n\tpick_sat_naive(cpha->p, NULL,  del_prv);\n\tdec_naive_delegated(t, cpha->p, cphb->p, del_prv, pub, lambda_AB, lambda_BC); /**/\n\telement_mul(m, cpha->cs, t); /* num_muls++; */\n\n\tpairing_apply(t, cpha->c, del_prv->d, pub->p); /* num_pairings++; */\n\telement_invert(t, t);\n\telement_mul(m, m, t); /* num_muls++; */\n\treturn 1;\n}\n\n\n/************************** Revoke **************************/\nbswabe_point*\nbswabe_revoke(bswabe_pub_t* pub, bswabe_msk_t* msk, char** revoked, int count)\n{\n\tbswabe_point* rl;\n\tint i=0;\n\n\trl = (bswabe_point*) malloc(sizeof(bswabe_point));\n\n\trl->count = REVOKE_T;\n\trl->x = (element_t*) malloc(sizeof(element_t) * REVOKE_T);\n\trl->p_x = (element_t*) malloc(sizeof(element_t) * REVOKE_T);\n\n\tfor(i=0; i<count; i++)\n\t{\n\t\telement_init_Zr(rl->x[i], pub->p);\n\t\telement_init_Zr(rl->p_x[i], pub->p);\n\n\t\telement_set_str(rl->x[i], revoked[i] , 10);\n\t\teval_poly(rl->p_x[i], msk->rpt, rl->x[i]);\n\t}\n\n\tfor(; i<REVOKE_T; i++)\n\t{\n\t\telement_init_Zr(rl->x[i], pub->p);\n\t\telement_init_Zr(rl->p_x[i], pub->p);\n\n\t\telement_random(rl->x[i]);\n\t\teval_poly(rl->p_x[i], msk->rpt, rl->x[i]);\n\t}\n\n\treturn rl;\n}\n\n/************************** Convert **************************/\nint size = 0;\nvoid\ntransform(bswabe_policy_t* p, element_t sum, bswabe_pub_t* pub)\n{\n\tint i;\n\n\tif(p->children->len == 0)\n\t{\n\t\telement_init_G2(p->cpp, pub->p);\n\t\telement_pow_zn(p->cpp, p->cp, sum);\n\t\tsize += element_length_in_bytes(p->cpp);\n\t}\n\telse\n\t{\n\t\tfor(i=0; i<p->children->len; i++)\n\t\t\ttransform(g_ptr_array_index(p->children, i), sum, pub);\n\t}\n\n}\nvoid\ncalc_sum(bswabe_pub_t* pub, bswabe_point* rvk, element_t u_k, element_t* li_ps, element_t sum)\n{\n\tint i;\n\n\telement_t t;\n\telement_t r;\n\telement_t ui;\n\n\telement_init_same_as(t, u_k);\n\telement_init_same_as(r, u_k);\n\telement_init_same_as(ui, u_k);\n\n\telement_set0(sum);\n\n\tfor(i=0; i<rvk->count; i++)\n\t{\n\t\telement_set1(r);\n\n\t\telement_neg(t, u_k);\n\t\telement_mul(r, r, t);\n\t\telement_set(ui, rvk->x[i]);\n\t\telement_sub(t, ui, u_k);\n\t\telement_invert(t, t);\n\t\telement_mul(r, r, t);\n\t\telement_set(t, li_ps[i]);\n\t\telement_mul(r, r, t);\n\n\t\telement_add(sum, sum, r);\n\t}\n\n\telement_clear(t);\n\telement_clear(r);\n\telement_clear(ui);\n\n}\nvoid convert(bswabe_pub_t* pub, bswabe_cph_t *cph, bswabe_point* rvk, char* u_k_str, element_t lambda_k, element_t* li_ps)\n{\n\telement_t u_k;\n\telement_t sum;\n\tGArray* s;\n\tint i;\n\n\telement_init_Zr(lambda_k, pub->p);\n\telement_init_Zr(sum, pub->p);\n\telement_init_Zr(u_k, pub->p);\n\n\telement_set_str(u_k, u_k_str, 10);\n\n\tcalc_sum(pub, rvk, u_k, li_ps, sum);\t//SUM(l_i * P(ui))\n\n\ttransform(cph->p, sum, pub);\n\n\ts = g_array_new(0, 0, sizeof(element_t));\n\n\tfor(i=0; i<rvk->count; i++)\n\t{\n\t\tg_array_append_val(s, rvk->x[i]);\n\t}\n\tg_array_append_val(s, u_k);\n\tlagrange_coef2( lambda_k, s , u_k);\n\n}\n\nelement_t*\nbswabe_convert(bswabe_pub_t* pub, bswabe_point* rvk)\n{\n\tint i;\n\n\telement_t lambda_i_p;\n\tGArray* s;\n\n\telement_t* lambda_i_ps;\n\n\telement_init_Zr(lambda_i_p, pub->p);\n\n\ts = g_array_new(0, 0, sizeof(element_t));\n\n\tlambda_i_ps = (element_t*) malloc(sizeof(element_t) * (REVOKE_T));\n\n\tfor(i=0; i<rvk->count; i++)\n\t\tg_array_append_val(s, rvk->x[i]);\n\n\tfor(i=0; i<rvk->count; i++)\n\t{\n\t\tlagrange_coef2( lambda_i_p, s , rvk->x[i]);\n\t\telement_mul(lambda_i_p, lambda_i_p, rvk->p_x[i]); //l_i' * p(ui)\n\n\t\telement_init_same_as(lambda_i_ps[i], lambda_i_p);\n\t\telement_set(lambda_i_ps[i], lambda_i_p);\n\t}\n\telement_clear(lambda_i_p);\n\treturn lambda_i_ps;\n}\n\n/************************** Delegate **************************/\nbswabe_del_prv_t*\nbswabe_delegate( bswabe_pub_t* pub, bswabe_msk_t* msk, bswabe_prv_t* prv, char* u_k_c_str, char** attributes)\n{\n\tint i = 0;\n\n\tbswabe_del_prv_t* del_prv; \t//delegated private key from A->B-> C\n\telement_t p_0_inv; \t\t\t// 1/p(0) of B\n\telement_t u_k_c; \t\t\t// C's identifier\n\telement_t p_c; \t\t\t\t//p(C) calculated by B\n\n\n\tdel_prv = malloc(sizeof(bswabe_del_prv_t));\n\tdel_prv->comps = g_array_new(0, 1, sizeof(bswabe_del_prv_comp_t));\n\n\telement_init_G2(del_prv->d, pub->p);\n\telement_init_Zr(p_0_inv, pub->p); \n\telement_init_Zr(u_k_c, pub->p);  \n\telement_init_Zr(p_c, pub->p);\n\n\telement_set(del_prv->d, prv->d);\n\telement_invert(p_0_inv, (msk->rpt)->coef[0]); // 1/p(0)\n\telement_set_str(u_k_c, u_k_c_str, 10);\n\teval_poly(p_c, (bswabe_polynomial_t*) msk->rpt, u_k_c); // p_c = P(C)\n\n\twhile(*attributes) // no. of attrs to delegate\n\t{\n\t\t//printf(\"%s\\n%d\\n\", *attributes, prv->comps->len);\n\t\tfor( i = 0; i < prv->comps->len; i++ ) // all the attrs in SK_B\n\t\t{\n\t\t\tbswabe_prv_comp_t* b = &g_array_index(prv->comps, bswabe_prv_comp_t, i);\n\n\t\t\t//printf(\"i=%d Key attribute %s\\n\", i, b->attr);\n\n\t\t\tif(!strcmp(b->attr, *attributes))\n\t\t\t{\n\t\t\t\t//printf(\"Matched %s\\n\", *attributes);\n\t\t\t\tbswabe_del_prv_comp_t c;\n\n\t\t\t\telement_init_G2(c.d,  pub->p);\n\t\t\t\telement_init_G1(c.dp, pub->p); //dp, dpp, d3p from G1\n\t\t\t\telement_init_G1(c.dpp, pub->p);\n\t\t\t\telement_init_G1(c.d3p, pub->p);\n\n\t\t\t\tc.attr = *attributes;\n\t\t\t\telement_set(c.d, b->d);\n\t\t\t\telement_set(c.dp, b->dp);\n\t\t\t\telement_pow_zn(c.dpp, b->dpp, p_0_inv);  //d\"^1/P(0)\n\t\t\t\telement_pow_zn(c.d3p, c.dpp, p_c);//(d\"^1/P(0))^P(C)\n\n\t\t\t\tg_array_append_val(del_prv->comps, c);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\tattributes++;\t\t\n\t}\n\telement_clear(p_0_inv); \n\telement_clear(u_k_c);  \n\telement_clear(p_c);\n\n\treturn del_prv;\n}\n\n"
        },
        {
            "file_name": "crypto_core_aes128decrypt.cpp",
            "content": "#include \"api.h\"\n\nnamespace CaesarCommon {\n\nstatic unsigned char multiply(unsigned int c,unsigned int d)\n{\n  unsigned char f[8];\n  unsigned char g[8];\n  unsigned char h[15];\n  unsigned char result;\n  int i;\n  int j;\n\n  for (i = 0;i < 8;++i) f[i] = 1 & (c >> i);\n  for (i = 0;i < 8;++i) g[i] = 1 & (d >> i);\n  for (i = 0;i < 15;++i) h[i] = 0;\n  for (i = 0;i < 8;++i)\n    for (j = 0;j < 8;++j) h[i + j] ^= f[i] & g[j];\n\n  for (i = 6;i >= 0;--i) {\n    h[i + 0] ^= h[i + 8];\n    h[i + 1] ^= h[i + 8];\n    h[i + 3] ^= h[i + 8];\n    h[i + 4] ^= h[i + 8];\n    h[i + 8] ^= h[i + 8];\n  }\n\n  result = 0;\n  for (i = 0;i < 8;++i) result |= h[i] << i;\n  return result;\n}\n\nstatic unsigned char square(unsigned char c)\n{\n  return multiply(c,c);\n}\n\nstatic unsigned char xtime(unsigned char c)\n{\n  return multiply(c,2);\n}\n\nstatic unsigned char invert(unsigned char c)\n{\n  unsigned char c3 = multiply(square(c),c);\n  unsigned char c7 = multiply(square(c3),c);\n  unsigned char c63 = multiply(square(square(square(c7))),c7);\n  unsigned char c127 = multiply(square(c63),c);\n  unsigned char c254 = square(c127);\n  return c254;\n}\n\nstatic unsigned char bytesub(unsigned char c)\n{\n  unsigned char f[8];\n  unsigned char h[8];\n  unsigned char result;\n  int i;\n\n  c = invert(c);\n  for (i = 0;i < 8;++i) f[i] = 1 & (c >> i);\n  h[0] = f[0] ^ f[4] ^ f[5] ^ f[6] ^ f[7] ^ 1;\n  h[1] = f[1] ^ f[5] ^ f[6] ^ f[7] ^ f[0] ^ 1;\n  h[2] = f[2] ^ f[6] ^ f[7] ^ f[0] ^ f[1];\n  h[3] = f[3] ^ f[7] ^ f[0] ^ f[1] ^ f[2];\n  h[4] = f[4] ^ f[0] ^ f[1] ^ f[2] ^ f[3];\n  h[5] = f[5] ^ f[1] ^ f[2] ^ f[3] ^ f[4] ^ 1;\n  h[6] = f[6] ^ f[2] ^ f[3] ^ f[4] ^ f[5] ^ 1;\n  h[7] = f[7] ^ f[3] ^ f[4] ^ f[5] ^ f[6];\n  c = 0;\n  for (i = 0;i < 8;++i) c |= h[i] << i;\n  return c;\n}\n\nstatic unsigned char invbytesub(unsigned char c)\n{\n  unsigned char h[8];\n  unsigned char f[8];\n  int i;\n\n  for (i = 0;i < 8;++i) h[i] = 1 & (c >> i);\n  h[0] ^= 1;\n  h[1] ^= 1;\n  h[5] ^= 1;\n  h[6] ^= 1;\n  f[0] = h[2] ^ h[5] ^ h[7];\n  f[1] = h[3] ^ h[6] ^ h[0];\n  f[2] = h[4] ^ h[7] ^ h[1];\n  f[3] = h[5] ^ h[0] ^ h[2];\n  f[4] = h[6] ^ h[1] ^ h[3];\n  f[5] = h[7] ^ h[2] ^ h[4];\n  f[6] = h[0] ^ h[3] ^ h[5];\n  f[7] = h[1] ^ h[4] ^ h[6];\n  c = 0;\n  for (i = 0;i < 8;++i) c |= f[i] << i;\n  return invert(c);\n}\n\nint crypto_core_aes128decrypt(\n        unsigned char *out,\n  const unsigned char *in,\n  const unsigned char *k,\n  const unsigned char *c\n)\n{\n  unsigned char expanded[4][44];\n  unsigned char state[4][4];\n  unsigned char newstate[4][4];\n  unsigned char roundconstant;\n  int i;\n  int j;\n  int r;\n\n  for (j = 0;j < 4;++j)\n    for (i = 0;i < 4;++i)\n      expanded[i][j] = k[j * 4 + i];\n\n  roundconstant = 1;\n  for (j = 4;j < 44;++j) {\n    unsigned char temp[4];\n    if (j % 4)\n      for (i = 0;i < 4;++i) temp[i] = expanded[i][j - 1];\n    else {\n      for (i = 0;i < 4;++i) temp[i] = bytesub(expanded[(i + 1) % 4][j - 1]);\n      temp[0] ^= roundconstant;\n      roundconstant = xtime(roundconstant);\n    }\n    for (i = 0;i < 4;++i)\n      expanded[i][j] = temp[i] ^ expanded[i][j - 4];\n  }\n\n  for (j = 0;j < 4;++j)\n    for (i = 0;i < 4;++i)\n      state[i][j] = in[j * 4 + i];\n\n  for (r = 9;r >= 0;--r) {\n    for (i = 0;i < 4;++i)\n      for (j = 0;j < 4;++j)\n        state[i][j] ^= expanded[i][r * 4 + 4 + j];\n    if (r < 9)\n      for (j = 0;j < 4;++j) {\n        unsigned char a0 = state[0][j];\n        unsigned char a1 = state[1][j];\n        unsigned char a2 = state[2][j];\n        unsigned char a3 = state[3][j];\n    state[0][j] = multiply(a1,11) ^ multiply(a2,13) ^ multiply(a3,9) ^ multiply(a0,14);\n    state[1][j] = multiply(a2,11) ^ multiply(a3,13) ^ multiply(a0,9) ^ multiply(a1,14);\n    state[2][j] = multiply(a3,11) ^ multiply(a0,13) ^ multiply(a1,9) ^ multiply(a2,14);\n    state[3][j] = multiply(a0,11) ^ multiply(a1,13) ^ multiply(a2,9) ^ multiply(a3,14);\n      }\n    for (i = 0;i < 4;++i)\n      for (j = 0;j < 4;++j)\n        newstate[i][j] = state[i][(j + 4 - i) % 4];\n    for (i = 0;i < 4;++i)\n      for (j = 0;j < 4;++j)\n        state[i][j] = invbytesub(newstate[i][j]);\n  }\n\n  for (j = 0;j < 4;++j)\n    for (i = 0;i < 4;++i)\n      state[i][j] ^= expanded[i][j];\n\n  for (j = 0;j < 4;++j)\n    for (i = 0;i < 4;++i)\n      out[j * 4 + i] = state[i][j];\n\n  return 0;\n}\n\n} // namespace CaesarCommon\n"
        },
        {
            "file_name": "crypto_core_aes128encrypt.cpp",
            "content": "#include \"api.h\"\n\nnamespace CaesarCommon {\nint numRounds;\n\nstatic unsigned char multiply(unsigned int c,unsigned int d)\n{\n  unsigned char f[8];\n  unsigned char g[8];\n  unsigned char h[15];\n  unsigned char result;\n  int i;\n  int j;\n\n  for (i = 0;i < 8;++i) f[i] = 1 & (c >> i);\n  for (i = 0;i < 8;++i) g[i] = 1 & (d >> i);\n  for (i = 0;i < 15;++i) h[i] = 0;\n  for (i = 0;i < 8;++i)\n    for (j = 0;j < 8;++j) h[i + j] ^= f[i] & g[j];\n\n  for (i = 6;i >= 0;--i) {\n    h[i + 0] ^= h[i + 8];\n    h[i + 1] ^= h[i + 8];\n    h[i + 3] ^= h[i + 8];\n    h[i + 4] ^= h[i + 8];\n    h[i + 8] ^= h[i + 8];\n  }\n\n  result = 0;\n  for (i = 0;i < 8;++i) result |= h[i] << i;\n  return result;\n}\n\nstatic unsigned char square(unsigned char c)\n{\n  return multiply(c,c);\n}\n\nstatic unsigned char xtime(unsigned char c)\n{\n  return multiply(c,2);\n}\n\nstatic unsigned char bytesub(unsigned char c)\n{\n  unsigned char c3 = multiply(square(c),c);\n  unsigned char c7 = multiply(square(c3),c);\n  unsigned char c63 = multiply(square(square(square(c7))),c7);\n  unsigned char c127 = multiply(square(c63),c);\n  unsigned char c254 = square(c127);\n  unsigned char f[8];\n  unsigned char h[8];\n  unsigned char result;\n  int i;\n\n  for (i = 0;i < 8;++i) f[i] = 1 & (c254 >> i);\n  h[0] = f[0] ^ f[4] ^ f[5] ^ f[6] ^ f[7] ^ 1;\n  h[1] = f[1] ^ f[5] ^ f[6] ^ f[7] ^ f[0] ^ 1;\n  h[2] = f[2] ^ f[6] ^ f[7] ^ f[0] ^ f[1];\n  h[3] = f[3] ^ f[7] ^ f[0] ^ f[1] ^ f[2];\n  h[4] = f[4] ^ f[0] ^ f[1] ^ f[2] ^ f[3];\n  h[5] = f[5] ^ f[1] ^ f[2] ^ f[3] ^ f[4] ^ 1;\n  h[6] = f[6] ^ f[2] ^ f[3] ^ f[4] ^ f[5] ^ 1;\n  h[7] = f[7] ^ f[3] ^ f[4] ^ f[5] ^ f[6];\n  result = 0;\n  for (i = 0;i < 8;++i) result |= h[i] << i;\n  return result;\n}\n\nint crypto_core_aes128encrypt(\n        unsigned char *out,\n  const unsigned char *in,\n  const unsigned char *k,\n  const unsigned char *c\n)\n{\n  unsigned char expanded[4][44];\n  unsigned char state[4][4];\n  unsigned char newstate[4][4];\n  unsigned char roundconstant;\n  int i;\n  int j;\n  int r;\n\n  for (j = 0;j < 4;++j)\n    for (i = 0;i < 4;++i)\n      expanded[i][j] = k[j * 4 + i];\n\n  roundconstant = 1;\n  for (j = 4;j < 44;++j) {\n    unsigned char temp[4];\n    if (j % 4)\n      for (i = 0;i < 4;++i) temp[i] = expanded[i][j - 1];\n    else {\n      for (i = 0;i < 4;++i) temp[i] = bytesub(expanded[(i + 1) % 4][j - 1]);\n      temp[0] ^= roundconstant;\n      roundconstant = xtime(roundconstant);\n    }\n    for (i = 0;i < 4;++i)\n      expanded[i][j] = temp[i] ^ expanded[i][j - 4];\n  }\n\n  for (j = 0;j < 4;++j)\n    for (i = 0;i < 4;++i)\n      state[i][j] = in[j * 4 + i] ^ expanded[i][j];\n\n  for (r = 0;r < 10;++r) {\n\n    for (i = 0;i < 4;++i)\n      for (j = 0;j < 4;++j)\n        newstate[i][j] = bytesub(state[i][j]);\n    for (i = 0;i < 4;++i)\n      for (j = 0;j < 4;++j)\n        state[i][j] = newstate[i][(j + i) % 4];\n    if (r < 9)\n      for (j = 0;j < 4;++j) {\n        unsigned char a0 = state[0][j];\n        unsigned char a1 = state[1][j];\n        unsigned char a2 = state[2][j];\n        unsigned char a3 = state[3][j];\n    state[0][j] = xtime(a0 ^ a1) ^ a1 ^ a2 ^ a3;\n    state[1][j] = xtime(a1 ^ a2) ^ a2 ^ a3 ^ a0;\n    state[2][j] = xtime(a2 ^ a3) ^ a3 ^ a0 ^ a1;\n    state[3][j] = xtime(a3 ^ a0) ^ a0 ^ a1 ^ a2;\n      }\n    for (i = 0;i < 4;++i)\n      for (j = 0;j < 4;++j)\n        state[i][j] ^= expanded[i][r * 4 + 4 + j];\n  }\n\n  for (j = 0;j < 4;++j)\n    for (i = 0;i < 4;++i)\n      out[j * 4 + i] = state[i][j];\n\n  return 0;\n}\n\n} // namespace CaesarCommon\n"
        },
        {
            "file_name": "crypto_core_aes256encrypt.cpp",
            "content": "#include \"api.h\"\n\nnamespace CaesarCommon {\n\nstatic unsigned char multiply(unsigned int c,unsigned int d)\n{\n  unsigned char f[8];\n  unsigned char g[8];\n  unsigned char h[15];\n  unsigned char result;\n  int i;\n  int j;\n\n  for (i = 0;i < 8;++i) f[i] = 1 & (c >> i);\n  for (i = 0;i < 8;++i) g[i] = 1 & (d >> i);\n  for (i = 0;i < 15;++i) h[i] = 0;\n  for (i = 0;i < 8;++i)\n    for (j = 0;j < 8;++j) h[i + j] ^= f[i] & g[j];\n\n  for (i = 6;i >= 0;--i) {\n    h[i + 0] ^= h[i + 8];\n    h[i + 1] ^= h[i + 8];\n    h[i + 3] ^= h[i + 8];\n    h[i + 4] ^= h[i + 8];\n    h[i + 8] ^= h[i + 8];\n  }\n\n  result = 0;\n  for (i = 0;i < 8;++i) result |= h[i] << i;\n  return result;\n}\n\nstatic unsigned char square(unsigned char c)\n{\n  return multiply(c,c);\n}\n\nstatic unsigned char xtime(unsigned char c)\n{\n  return multiply(c,2);\n}\n\nstatic unsigned char bytesub(unsigned char c)\n{\n  unsigned char c3 = multiply(square(c),c);\n  unsigned char c7 = multiply(square(c3),c);\n  unsigned char c63 = multiply(square(square(square(c7))),c7);\n  unsigned char c127 = multiply(square(c63),c);\n  unsigned char c254 = square(c127);\n  unsigned char f[8];\n  unsigned char h[8];\n  unsigned char result;\n  int i;\n\n  for (i = 0;i < 8;++i) f[i] = 1 & (c254 >> i);\n  h[0] = f[0] ^ f[4] ^ f[5] ^ f[6] ^ f[7] ^ 1;\n  h[1] = f[1] ^ f[5] ^ f[6] ^ f[7] ^ f[0] ^ 1;\n  h[2] = f[2] ^ f[6] ^ f[7] ^ f[0] ^ f[1];\n  h[3] = f[3] ^ f[7] ^ f[0] ^ f[1] ^ f[2];\n  h[4] = f[4] ^ f[0] ^ f[1] ^ f[2] ^ f[3];\n  h[5] = f[5] ^ f[1] ^ f[2] ^ f[3] ^ f[4] ^ 1;\n  h[6] = f[6] ^ f[2] ^ f[3] ^ f[4] ^ f[5] ^ 1;\n  h[7] = f[7] ^ f[3] ^ f[4] ^ f[5] ^ f[6];\n  result = 0;\n  for (i = 0;i < 8;++i) result |= h[i] << i;\n  return result;\n}\n\nint crypto_core_aes256encrypt(\n        unsigned char *out,\n  const unsigned char *in,\n  const unsigned char *k,\n  const unsigned char *c\n)\n{\n  unsigned char expanded[4][60];\n  unsigned char state[4][4];\n  unsigned char newstate[4][4];\n  unsigned char roundconstant;\n  int i;\n  int j;\n  int r;\n\n  for (j = 0;j < 8;++j)\n    for (i = 0;i < 4;++i)\n      expanded[i][j] = k[j * 4 + i];\n\n  roundconstant = 1;\n  for (j = 8;j < 60;++j) {\n    unsigned char temp[4];\n    if (j % 4)\n      for (i = 0;i < 4;++i) temp[i] = expanded[i][j - 1];\n    else if (j % 8)\n      for (i = 0;i < 4;++i) temp[i] = bytesub(expanded[i][j - 1]);\n    else {\n      for (i = 0;i < 4;++i) temp[i] = bytesub(expanded[(i + 1) % 4][j - 1]);\n      temp[0] ^= roundconstant;\n      roundconstant = xtime(roundconstant);\n    }\n    for (i = 0;i < 4;++i)\n      expanded[i][j] = temp[i] ^ expanded[i][j - 8];\n  }\n\n  for (j = 0;j < 4;++j)\n    for (i = 0;i < 4;++i)\n      state[i][j] = in[j * 4 + i] ^ expanded[i][j];\n\n  for (r = 0;r < 14;++r) {\n    for (i = 0;i < 4;++i)\n      for (j = 0;j < 4;++j)\n        newstate[i][j] = bytesub(state[i][j]);\n    for (i = 0;i < 4;++i)\n      for (j = 0;j < 4;++j)\n        state[i][j] = newstate[i][(j + i) % 4];\n    if (r < 13)\n      for (j = 0;j < 4;++j) {\n        unsigned char a0 = state[0][j];\n        unsigned char a1 = state[1][j];\n        unsigned char a2 = state[2][j];\n        unsigned char a3 = state[3][j];\n    state[0][j] = xtime(a0 ^ a1) ^ a1 ^ a2 ^ a3;\n    state[1][j] = xtime(a1 ^ a2) ^ a2 ^ a3 ^ a0;\n    state[2][j] = xtime(a2 ^ a3) ^ a3 ^ a0 ^ a1;\n    state[3][j] = xtime(a3 ^ a0) ^ a0 ^ a1 ^ a2;\n      }\n    for (i = 0;i < 4;++i)\n      for (j = 0;j < 4;++j)\n        state[i][j] ^= expanded[i][r * 4 + 4 + j];\n  }\n\n  for (j = 0;j < 4;++j)\n    for (i = 0;i < 4;++i)\n      out[j * 4 + i] = state[i][j];\n\n  return 0;\n}\n\n} // namespace CaesarCommon\n"
        },
        {
            "file_name": "CSPRNG.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"RaceCond.h\"\n#include \"Sha512.h\"\n#include \"Grostl512.h\"\n#include \"Keccak512.h\"\n#include \"Skein512.h\"\n#include \"MultiBase.h\"\n\n#include \"CSPRNG_data.h\"\n\n#define\tRESEED_COUNTDOWN\t1000\n\nvoid CSPRNG_set_seed(CSPRNG_DATA *pCd,ENUM_HASH hashE,const BYTE *passw,DWORD nonce)\n{\n\tBYTE\tinBuf[64];\n\tBYTE\thash[64];\n\tDWORD\tlen;\n\n\tmemset(pCd,0,sizeof(CSPRNG_DATA));\n\n\tmemset(inBuf,0,64);\n\tmemcpy(inBuf,passw,MAX_PASSW_SIZE);\n\tlen=strlen((char *) inBuf);\n\tmemcpy(&inBuf[len],&nonce,4);\n\tlen+=4;\n\n\tif(hashE==SHA512_HASH)\n\t\t{\n\t\tSHA512_DATA\t\tsha;\n\n\t\tSha512_init(&sha);\n\t\tSha512_data(&sha,inBuf,len);\n\t\tSha512_finalize(&sha,hash);\n\t\t}\n\telse if(hashE==GROSTL512_HASH)\n\t\t{\n\t\tGROSTL512_DATA\tgrostl;\n\n\t\tGrostl512_init(&grostl);\n\t\tGrostl512_data(&grostl,inBuf,len);\n\t\tGrostl512_finalize(&grostl,hash);\n\t\t}\n\telse if(hashE==KECCAK512_HASH)\n\t\t{\n\t\tKECCAK512_DATA\tkeccak;\n\n\t\tKeccak512_init(&keccak);\n\t\tKeccak512_data(&keccak,inBuf,len);\n\t\tKeccak512_finalize(&keccak,hash);\n\t\t}\n\telse if(hashE==SKEIN512_HASH)\n\t\t{\n\t\tSKEIN512_DATA\tskein;\n\n\t\tSkein512_init(&skein);\n\t\tSkein512_data(&skein,inBuf,len);\n\t\tSkein512_finalize(&skein,hash);\n\t\t}\n\n\tMulti_single_setkey(&pCd->msd,RIJNDAEL_ALG,hash);\n\n\tmemcpy(pCd->ctrBuf,&hash[MAX_PASSW_SIZE],DATA_BLOCK_SIZE);\n\tpCd->availCount=0;\t\n}\n\n// auto setup with default\nvoid CSPRNG_autoseed(CSPRNG_DATA *pCd,perc_callback_t backFunc,void *desc)\n{\n\tBYTE\tpassw[MAX_PASSW_SIZE+DATA_BLOCK_SIZE];\n\tBYTE\tnullPassw[MAX_PASSW_SIZE+DATA_BLOCK_SIZE];\n\n\tmemset(pCd,0,sizeof(CSPRNG_DATA));\n\n\tmemset(nullPassw,0,MAX_PASSW_SIZE+DATA_BLOCK_SIZE);\n\tGenerateEntropy(MAX_PASSW_SIZE+DATA_BLOCK_SIZE,passw,backFunc,desc);\n\n\t// GenerateEntropy KO\n\tif(!memcmp(passw,nullPassw,MAX_PASSW_SIZE+DATA_BLOCK_SIZE))\n\t\t{\n\t\tDWORD\tindex;\n\n\t\tLARGE_INTEGER\tqpc;\n\n\t\tQueryPerformanceCounter(&qpc);\n\n\t\tsrand(*((DWORD *) &qpc));\n\n\t\tfor(index=0;index<(MAX_PASSW_SIZE+DATA_BLOCK_SIZE);index++)\n\t\t\t{ passw[index]=(BYTE) rand(); }\n\t\t}\n\n\tMulti_single_setkey(&pCd->msd,RIJNDAEL_ALG,passw);\n\n\tmemcpy(pCd->ctrBuf,&passw[MAX_PASSW_SIZE],DATA_BLOCK_SIZE);\n\tpCd->availCount=0;\t\n}\n\n// little endian\nvoid BlockInc(BYTE *data)\n{\n\t#if\tDATA_BLOCK_SIZE==16\n\t__asm\n\t\t{\n\t\tmov edi,[data]\n\t\tclc\n\n\t\tinc dword ptr [edi+ 0]\n\t\tadc dword ptr [edi+ 4],0\n\t\tadc dword ptr [edi+ 8],0\n\t\tadc dword ptr [edi+12],0\n\t\t}\n\t#else\n\t#error\n\t#endif\n}\n\n// auto reseeding leads to a bad chi-square result after some Mb of data!\nBYTE CSPRNG_get_byte(CSPRNG_DATA *pCd)\n{\n\tif(!pCd->availCount)\n\t\t{\n\t\t// random = AES-256(CTR)\n\t\tMulti_ECB_single_encrypt(&pCd->msd,RIJNDAEL_ALG,pCd->ctrBuf,pCd->randBuf);\n\t\tBlockInc(pCd->ctrBuf);\n\n\t\tpCd->availCount=DATA_BLOCK_SIZE-1;\n\n\t\treturn(*pCd->randBuf);\n\t\t}\n\telse\n\t\t{ return(pCd->randBuf[DATA_BLOCK_SIZE-(pCd->availCount--)]); }\n}\n\nWORD CSPRNG_get_word(CSPRNG_DATA *pCd)\n{\n\tWORD\tretV;\n\n\tretV=(WORD) CSPRNG_get_byte(pCd);\n\tretV<<=8;\n\tretV|=(WORD) CSPRNG_get_byte(pCd);\n\n\treturn(retV);\n}\n\nDWORD CSPRNG_get_dword(CSPRNG_DATA *pCd)\n{\n\tDWORD\tretV;\n\n\tretV=(DWORD) CSPRNG_get_word(pCd);\n\tretV<<=16;\n\tretV|=(DWORD) CSPRNG_get_word(pCd);\n\n\treturn(retV);\n}\n\n#define\tREFRESH_COUNTDOWN\t1000\n\nOBFUNC_RETV CSPRNG_randomize(CSPRNG_DATA *pCd,const DWORD len,BYTE *buf,perc_callback_t pFunc,void *pDesc,test_callback_t tFunc,void *tDesc)\n{\n\tDWORD\ttLen=len;\n\tBYTE\tlastPerc=0;\n\tWORD\trefCount=REFRESH_COUNTDOWN;\n\n\twhile(tLen--)\n\t\t{\n\t\t*(buf++)=CSPRNG_get_byte(pCd);\n\n\t\tif(!refCount)\n\t\t\t{\n\t\t\trefCount=REFRESH_COUNTDOWN;\n\n\t\t\tif(pFunc)\n\t\t\t\t{\n\t\t\t\tBYTE\ttmp=(BYTE) ((((float) (len-tLen))/((float) len))*((float) 100));\n\t\t\t\tif(tmp>lastPerc)\n\t\t\t\t\t{\n\t\t\t\t\tlastPerc=tmp;\n\t\t\t\t\tpFunc(pDesc,lastPerc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(tFunc&&tFunc(tDesc))\n\t\t\t\t{ return(OBFUNC_STOP); }\n\t\t\t}\n\n\t\trefCount--;\n\t\t}\n\n\treturn(OBFUNC_OK);\n}\n\nvoid CSPRNG_array_init(CSPRNG_DATA *pCd,DWORD max,BYTE *buf)\n{\n\tDWORD\tindex;\n\n\tmemset(buf,0xFF,max);\n\tfor(index=0;index<max;index++)\n\t\t{\n\t\tDWORD\trIndex;\n\n\t\tdo\n\t\t\t{ rIndex=CSPRNG_get_byte(pCd)%max; }\n\t\twhile(buf[rIndex]!=0xFF);\n\n\t\tbuf[rIndex]=(BYTE) index;\n\t\t}\n}\n"
        },
        {
            "file_name": "cubehash-test.c",
            "content": "#include <stdio.h>\n#include <stdlib.h>\n\n#include \"cubehash.h\"\n\n\nint main(void) {\n\n  int i;\n\n  uint8_t hash[CHASHSTATESIZE];\n  char message[100] = \"The quick brown fox jumps over the lazy dog\";\n \n  chash_message(160, 16, 32, 160, 512, (uint8_t *)message, 43, &hash);\n  \n  printf(\"The hash for \\\"%s\\\":\\n\", message);\n  for (i = 0; i < (512 / 8); i++) {\n    printf(\"%02x\", hash[i]);\n  }\n  printf(\"\\n\");\n\n  return 0;\n}\n"
        },
        {
            "file_name": "cubehash.c",
            "content": "#include \"cubehash.h\"\n\nvoid chash_init(struct cubehash_ctx *cctx,\n\t\tint in, int r, int b, int f, int h) {\n\n  int i, j, k, l, m;\n\n  /* a parameter i in {1,2,3,...}, ... initialization rounds (16);\n   * a parameter r in {1,2,3,...}, ... rounds per message block, (16);\n   * a parameter b in {1,2,3,...,128}, ... bytes per message block, (32);\n   * a parameter f in {1,2,3,...}, ... finalization rounds, (32);\n   * a parameter h in {8,16,24,...,512}, ... output bits, (512); \n   */\n\n  cctx->i = in;\n  cctx->r = r;\n  cctx->b = b;\n  cctx->f = f;\n  cctx->h = h;\n\n  /* CubeHash produces the initial state as follows.\n   * Set the first three state words x[00000], x[00001], x[00010] to the\n   * integers h/8, b, r respectively. Set the remaining state words to 0.\n   */\n  for (i = 0; i < 2; i++) {\n    for (j = 0; j < 2; j++) {\n      for (k = 0; k < 2; k++) {\n\tfor (l = 0; l < 2; l++) {\n\t  for (m = 0; m < 2; m++) {\n\t    cctx->state[i][j][k][l][m] = 0;\n\t  }\n\t}\n      }\n    }\n  }\n\n  cctx->state[0][0][0][0][0] = cctx->h / 8;\n  cctx->state[0][0][0][0][1] = cctx->b;\n  cctx->state[0][0][0][1][0] = cctx->r;\n\n  /* Then transform the state invertibly through i rounds.\n   * Of course, the implementor can eliminate these transformations\n   * at the expense of storage by precomputing the initial state\n   * for any particular h,b,r.\n   */\n  for (i = 0; i < cctx->i; i++) {\n    chash_round(cctx);\n  }\n\n}\n\n\nvoid chash_round(struct cubehash_ctx *cctx) {\n\n  int j, k, l, m;\n  uint32_t t;\n\n  /* Add x[0jklm] into x[1jklm] modulo 2^32, for each (j,k,l,m). */\n  for (j = 0; j < 2; j++) {\n    for (k = 0; k < 2; k++) {\n      for (l = 0; l < 2; l++) {\n\tfor (m = 0; m < 2; m++) {\n\t  cctx->state[1][j][k][l][m] += cctx->state[0][j][k][l][m];\n\t}\n      }\n    }\n  }\n\n  /*Rotate x[0jklm] upwards by 7 bits, for each (j,k,l,m). */\n  for (j = 0; j < 2; j++) {\n    for (k = 0; k < 2; k++) {\n      for (l = 0; l < 2; l++) {\n\tfor (m = 0; m < 2; m++) {\n\t  cctx->state[0][j][k][l][m] =\n\t    ROTATEUPWARDSN(cctx->state[0][j][k][l][m], 7);\n\t}\n      }\n    }\n  }\n\n  /* Swap x[00klm] with x[01klm], for each (k,l,m). */\n  for (k = 0; k < 2; k++) {\n    for (l = 0; l < 2; l++) {\n      for (m = 0; m < 2; m++) {\n\tWSWAP(cctx->state[0][0][k][l][m], cctx->state[0][1][k][l][m], t);\n      }\n    }\n  }\n\n  /* Xor x[1jklm] into x[0jklm], for each (j,k,l,m). */\n  for (j = 0; j < 2; j++) {\n    for (k = 0; k < 2; k++) {\n      for (l = 0; l < 2; l++) {\n\tfor (m = 0; m < 2; m++) {\n\t  cctx->state[0][j][k][l][m] ^= cctx->state[1][j][k][l][m];\n\t}\n      }\n    }\n  }\n\n  /* Swap x[1jk0m] with x[1jk1m], for each (j,k,m). */\n  for (j = 0; j < 2; j++) {\n    for (k = 0; k < 2; k++) {\n      for (m = 0; m < 2; m++) {\n\tWSWAP(cctx->state[1][j][k][0][m], cctx->state[1][j][k][1][m], t);\n      }\n    }\n  }\n\n  /* Add x[0jklm] into x[1jklm] modulo 2^32, for each (j,k,l,m). */\n  for (j = 0; j < 2; j++) {\n    for (k = 0; k < 2; k++) {\n      for (l = 0; l < 2; l++) {\n\tfor (m = 0; m < 2; m++) {\n\t  cctx->state[1][j][k][l][m] += cctx->state[0][j][k][l][m];\n\t}\n      }\n    }\n  }\n\n  /* Rotate x[0jklm] upwards by 11 bits, for each (j,k,l,m). */\n  for (j = 0; j < 2; j++) {\n    for (k = 0; k < 2; k++) {\n      for (l = 0; l < 2; l++) {\n\tfor (m = 0; m < 2; m++) {\n\t  cctx->state[0][j][k][l][m] =\n\t    ROTATEUPWARDSN(cctx->state[0][j][k][l][m], 11);\n\t}\n      }\n    }\n  }\n\n  /* Swap x[0j0lm] with x[0j1lm], for each (j,l,m). */\n  for (j = 0; j < 2; j++) {\n    for (l = 0; l < 2; l++) {\n      for (m = 0; m < 2; m++) {\n\tWSWAP(cctx->state[0][j][0][l][m], cctx->state[0][j][1][l][m], t);\n      }\n    }\n  }\n\n  /* Xor x[1jklm] into x[0jklm], for each (j,k,l,m). */\n  for (j = 0; j < 2; j++) {\n    for (k = 0; k < 2; k++) {\n      for (l = 0; l < 2; l++) {\n\tfor (m = 0; m < 2; m++) {\n\t  cctx->state[0][j][k][l][m] ^= cctx->state[1][j][k][l][m];\n\t}\n      }\n    }\n  }\n\n\n  /* Swap x[1jkl0] with x[1jkl1], for each (j,k,l). */\n  for (j = 0; j < 2; j++) {\n    for (k = 0; k < 2; k++) {\n      for (l = 0; l < 2; l++) {\n\tWSWAP(cctx->state[1][j][k][l][0], cctx->state[1][j][k][l][1], t);\n      }\n    }\n  }\n\n}\n\n\nvoid chash_update(struct cubehash_ctx *cctx, uint8_t (*in)[CHASHSTATESIZE]) {\n\n  int i, j, k, l, m, b, r;\n  int idx = 0;\n  \n  for (i = 0; i < 2; i++) {\n    for (j = 0; j < 2; j++) {\n      for (k = 0; k < 2; k++) {\n\tfor (l = 0; l < 2; l++) {\n\t  for (m = 0; m < 2; m++) {\n\t    for (b = 0; b < 4; b++) {\n\n\t      /* XOR in the bytes starting low */\n\t      cctx->state[i][j][k][l][m] ^= (uint32_t)(*in)[idx] << (b * 8);\n\t      idx++;\n\n\t      /* If we've XOR'd in a whole block so finish */\n\t      if (idx >= cctx->b) {\n\t\t\n\t\tfor (r = 0; r < cctx->r; r++) {\n\t\t  chash_round(cctx);\n\t\t}\n\n\t\treturn;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  }  \n\n}\n\n\nvoid chash_final(struct cubehash_ctx *cctx, uint8_t (*out)[CHASHSTATESIZE]) {\n\n  int i, j, k, l, m, b, f;\n  int idx;\n\n  cctx->state[1][1][1][1][1] ^= 1;\n  for (f = 0; f < cctx->f; f++) {\n    chash_round(cctx);\n  }\n\n  idx = 0;\n  for (i = 0; i < 2; i++) {\n    for (j = 0; j < 2; j++) {\n      for (k = 0; k < 2; k++) {\n\tfor (l = 0; l < 2; l++) {\n\t  for (m = 0; m < 2; m++) {\n\t    for (b = 0; b < 4; b++) {\n\t      /* Extract out the state */\n\t      (*out)[idx] = (cctx->state[i][j][k][l][m] >> (b * 8)) & 0xff;\n\t      idx++;\n\n\t      /* If we've output the whole hash */\n\t      if (idx >= cctx->h / 8) {\n\n\t\treturn;\n\t      }\n\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n\n}\n\n\nvoid chash_message(int in, int r, int b, int f, int h,\n\t\t   uint8_t *m, size_t s, uint8_t (*hash)[CHASHSTATESIZE]) {\n\n  struct cubehash_ctx cctx;\n  uint8_t block[CHASHSTATESIZE];\n  int i, j;\n\n  chash_init(&cctx, in, r, b, f, h);\n  \n  /* Loop to consume message input in blocks */\n  i = 0;\n  while (1) {\n\n    /* Still doing blocks? */\n    if (i + cctx.b <= s) {\n      memcpy(block, m + i, cctx.b);\n      chash_update(&cctx, (uint8_t (*)[CHASHSTATESIZE])block);\n\n      i += cctx.b; /* move down a block */\n      continue;\n    }\n    else {\n      /* We need to add the pad for the last block */\n      for (j = 0; j < cctx.b; j++) {\n\t/* keep copying remaning message? */\n\tif (i < s) {\n\t  block[j] = m[i];\n\t  i++;\n\t  continue;\n\t}\n\telse if (i == s) {\n\t  /* Add the 1-bit pad */\n\t  block[j] = 0x80;\n\t  i++;\n\t  continue;\n\t}\n\telse {\n\t  /* Add zero bit pads */\n\t  block[j] = 0x00;\n\t}\n      }\n      chash_update(&cctx, (uint8_t (*)[CHASHSTATESIZE])block);\n\n      break;\n    }\n  }\n\n  chash_final(&cctx, hash);\n}\n\n\n"
        },
        {
            "file_name": "damgard_jurik.c",
            "content": "/*\n\tlibdj - A library implementing the Damg\u00c3\u00a5rd-Jurik cryptosystem.\n\n\tCopyright 2012 Fred Douglas (fed2@illinois.edu)\n\tThis library is an extension/modification of libpaillier.\n\tlibpaillier is copyright 2006 SRI International (written by John Bethencourt).\n\n\tThis file is part of libdj.\n\n    libdj is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    libdj is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with libdj.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"gmp.h\"\n#include \"damgard_jurik.h\"\n\n\n//The following functions are taken directly from or slightly modified from libpaillier\n\nvoid init_rand( gmp_randstate_t rand, dj_get_rand_t get_rand, int bytes )\n{\n\tvoid* buf;\n\tmpz_t s;\n\n\tbuf = malloc(bytes);\n\tget_rand(buf, bytes);\n\n\tgmp_randinit_default(rand);\n\tmpz_init(s);\n\tmpz_import(s, bytes, 1, 1, 0, 0, buf);\n\tgmp_randseed(rand, s);\n\tmpz_clear(s);\n\n\tfree(buf);\n}\n\nvoid complete_pubkey(dj_pubkey_t* pub)\n{\n\tint i;\n\tmpz_add_ui(pub->n_plusone, pub->npow[1], 1);\n\tmpz_set_ui(pub->npow[0],1);\n\tfor(i=2;i<pub->s+2;i++)\n\t\tmpz_mul(pub->npow[i],pub->npow[i-1],pub->npow[1]);\n}\n\ndj_plaintext_t* dj_plaintext_from_ui(unsigned int i)\n{\n\tdj_plaintext_t* ret = (dj_plaintext_t*) malloc(sizeof(dj_plaintext_t));\n\tmpz_init_set_ui(ret->m,i);\n\treturn ret;\n}\n\nvoid dj_freepubkey(dj_pubkey_t* pub)\n{\n\tint i;\n\tfor(i=0;i<pub->s+2;i++)\n\t\tmpz_clear(pub->npow[i]);\n\tfree(pub->npow);\n\tmpz_clear(pub->n_plusone);\n\tfree(pub);\n}\n\nvoid dj_freeprvkey(dj_prvkey_t* prv)\n{\n\tmpz_clear(prv->key);\n\tfree(prv);\n}\n\nvoid dj_freeplaintext(dj_plaintext_t* pt)\n{\n\tmpz_clear(pt->m);\n\tfree(pt);\n}\n\nvoid dj_freeciphertext(dj_ciphertext_t* ct)\n{\n\tmpz_clear(ct->c);\n\tfree(ct);\n}\n\nvoid dj_free_partial_prvkey(dj_partial_prvkey_t* keytofree)\n{\n\tmpz_clear(keytofree->s_i);\n\tfree(keytofree);\n}\n\nvoid dj_free_decshare(dj_decshare_t* sharetofree)\n{\n\tmpz_clear(sharetofree->c_i);\n\tfree(sharetofree);\n}\n\nvoid dj_get_rand_file( void* buf, int len, char* file )\n{\n\tFILE* fp;\n\tvoid* p;\n\n\tfp = fopen(file, \"r\");\n\n\tp = buf;\n\twhile( len )\n\t{\n\t\tsize_t s;\n\t\ts = fread(p, 1, len, fp);\n\t\tp += s;\n\t\tlen -= s;\n\t}\n\n\tfclose(fp);\n}\n\nvoid dj_get_rand_devrandom( void* buf, int len )\n{\n\tdj_get_rand_file(buf, len, \"/dev/random\");\n}\n\nvoid dj_get_rand_devurandom( void* buf, int len )\n{\n\tdj_get_rand_file(buf, len, \"/dev/urandom\");\n}\n\n\n/*************Start of new code******************/\n\ndj_ciphertext_t* dj_homomorphic_add(dj_ciphertext_t* res, dj_ciphertext_t* c1, dj_ciphertext_t* c2, dj_pubkey_t* pub)\n{\n\tif(!res)\n\t{\n\t\tres = (dj_ciphertext_t*) malloc(sizeof(dj_ciphertext_t));\n\t\tmpz_init(res->c);\n\t}\n\tmpz_mul(res->c,c1->c,c2->c);\n\tmpz_mod(res->c,res->c,pub->npow[pub->s+1]);\n\treturn res;\n}\n\ndj_ciphertext_t* dj_homomorphic_mul(dj_ciphertext_t* res, dj_ciphertext_t* c1, dj_plaintext_t* m1, dj_pubkey_t* pub)\n{\n\tif(!res)\n\t{\n\t\tres = (dj_ciphertext_t*) malloc(sizeof(dj_ciphertext_t));\n\t\tmpz_init(res->c);\n\t}\n\tmpz_powm(res->c, c1->c, m1->m, pub->npow[pub->s+1]);\n\treturn res;\n}\n\n//(this one is almost identical to the original, except that r is picked from Z*_{n^{s+1}} instead of Z_n)\ndj_ciphertext_t* dj_encrypt(dj_ciphertext_t* res, dj_pubkey_t* pub, dj_plaintext_t* pt, dj_get_rand_t get_rand)\n{\n\tmpz_t r,temp;\n\tgmp_randstate_t rand;\n\t\n\tif(!res)\n\t{\n\t\tres = (dj_ciphertext_t*) malloc(sizeof(dj_ciphertext_t));\n\t\tmpz_init(res->c);\n\t}\n\t\n\tmpz_init(r);\n\tmpz_init(temp);\n\t\n\tinit_rand(rand,get_rand, (pub->bits / 8) * pub->s + 1);\n\t\n\t//pick a random r from Z*_{n^{s+1}}\n\tdo\n\t{\n\t\tdo mpz_urandomm(r,rand,pub->npow[pub->s+1]); while (mpz_cmp_ui(r,0) == 0);\n\t\t//ensure our r is in Z*_{n^{s+1}}, i.e., r and n^{s+1} are coprime\n\t\tmpz_gcd(temp,r,pub->npow[pub->s+1]);\n\t} while(mpz_cmp_ui(temp,1) != 0);\n\t\n\t\n\t//use g = n+1 as suggested in the DJ paper\n\tmpz_powm(r,r,pub->npow[pub->s],pub->npow[pub->s+1]);\n\tmpz_powm(temp,pub->n_plusone,pt->m,pub->npow[pub->s+1]);\n\tmpz_mul(res->c,r,temp);\n\tmpz_mod(res->c,res->c,pub->npow[pub->s+1]);\n\t\n\tmpz_clear(r);\n\tmpz_clear(temp);\n\t\n\tgmp_randclear(rand);\n\treturn res;\n}\n\ndj_plaintext_t* dj_decrypt(dj_plaintext_t* res,\tdj_pubkey_t* pub, dj_prvkey_t* prv,\tdj_ciphertext_t* ct)\n{\n\tint i,j,k;\n\tmpz_t cprime, temp, tempDivisor, i_jCur, i_jPrev;\n\n\tif(!res)\n\t{\n\t\tres = (dj_plaintext_t*) malloc(sizeof(dj_plaintext_t));\n\t\tmpz_init(res->m);\n\t}\n\t\n\tmpz_init(cprime);\n\t\n\t//cprime = c^key mod n^{s+1}\n\tmpz_powm(cprime,ct->c,prv->key,pub->npow[pub->s+1]);\n\t\n\t\n\t\n\t//the algorithm from extracting i from (1+n)^i described in the paper.\n\t\n\t//the algorithm iteratively extracts i mod n, i mod n^2, etc. i mod n starts us off, and is just input - 1 / n.\n\tmpz_init(temp);\n\tmpz_init(tempDivisor);\n\tmpz_init(i_jCur);\n\tmpz_init_set(i_jPrev,cprime);\n\tmpz_sub_ui(i_jPrev,i_jPrev,1);\n\tmpz_divexact(i_jPrev,i_jPrev,pub->npow[1]);\n\tmpz_mod(i_jPrev,i_jPrev,pub->npow[2]);\n\t\n\t//just in case s=1; in that case we need this line to actually set i_jcur\n\tif(pub->s==1)\n\t\tmpz_set(i_jCur,i_jPrev);\n\t\n\t//extract i_j = i mod n^j given i_{j-1}. this is done by taking (input - 1 mod n^{j+1}) / n , and subtracting\n\t//from that: ((  (i_{j-1} choose 2)*n  + (i_{j-1} choose 3)*n^2  + ... +  (i_{j-1} choose j)*n^{j-1}  ))   mod n^j\n\tfor(j=2;j<=pub->s;j++)\n\t{\n\t\t//L((1+n)^i) as they call it \n\t\tmpz_mod(i_jCur,cprime,pub->npow[j+1]);\n\t\tmpz_sub_ui(i_jCur,i_jCur,1);\n\t\tmpz_divexact(i_jCur,i_jCur,pub->npow[1]);\n\t\t\n\t\tmpz_mod(i_jCur,i_jCur,pub->npow[j]);\n\t\t\n\t\t//subtract each of the binomial things\n\t\tfor(k=2;k<=j;k++)\n\t\t{\n\t\t\tmpz_bin_ui(temp,i_jPrev,k);\n\t\t\tmpz_mul(temp,temp,pub->npow[k-1]);\n\t\t\tmpz_mod(temp,temp,pub->npow[j]);\n\t\t\tmpz_sub(i_jCur,i_jCur,temp);\n\t\t\tmpz_mod(i_jCur,i_jCur,pub->npow[j]);\n\t\t}\n\t\tmpz_set(i_jPrev,i_jCur);\n\t}\n\t\n\t//i_jCur is currently the message times the private key.\n\tmpz_invert(temp, prv->key, pub->npow[pub->s]);\n\tmpz_mul(res->m, i_jCur, temp);\n\tmpz_mod(res->m, res->m, pub->npow[pub->s]);\n\t\n\t//cleanup and return\n\tmpz_clear(cprime);\n\tmpz_clear(i_jPrev);\n\tmpz_clear(i_jCur);\n\tmpz_clear(temp);\n\tmpz_clear(tempDivisor);\n\t\n\treturn res;\n}\n\n\ndj_prvkey_t* dj_keygen(dj_prvkey_t* reskey, dj_pubkey_t** resPub, unsigned short int s, int modulusbits, dj_get_rand_t get_rand)\n{\n\tmpz_t p,q,pprime,qprime,m,minv,n,mnpows,temp;\n\t\n\tgmp_randstate_t rand;\n\t\n\tint i,j,x;\n\t\n\tif(!reskey)\n\t{\n\t\treskey = (dj_prvkey_t*) malloc(sizeof(dj_prvkey_t));\n\t\tmpz_init(reskey->key);\n\t}\n\t\n\t//initialization\n\tmpz_init(p);\n\tmpz_init(q);\n\tmpz_init(pprime);\n\tmpz_init(qprime);\n\tmpz_init(m);\n\tmpz_init(minv);\n\tmpz_init(mnpows);\n\tmpz_init(temp);\n\t\n\t(*resPub) = (dj_pubkey_t*) malloc(sizeof(dj_pubkey_t));\n\tmpz_init((*resPub)->n_plusone);\n\t(*resPub)->npow = (mpz_t*) malloc((s+2)*sizeof(mpz_t));\n\tfor(i=0;i<s+2;i++)\n\t\tmpz_init((*resPub)->npow[i]);\n\t\n\tinit_rand(rand, get_rand, modulusbits / 8 + 1);\n\t\n\t//first, pick our secret primes: p and q that are of the form p=2p'+1, q=2q'+1, for p' and q' also prime\n\t//public key is n = pq\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\tmpz_urandomb(p,rand,modulusbits / 2);\n\t\t\tmpz_sub_ui(pprime, p, 1);\n\t\t\tmpz_divexact_ui(pprime, pprime, 2);\n\t\t} while(!mpz_probab_prime_p(p, 10) || !mpz_probab_prime_p(pprime, 10));\n\n\t\tdo\n\t\t{\n\t\t\tmpz_urandomb(q,rand,modulusbits / 2);\n\t\t\tmpz_sub_ui(qprime, q, 1);\n\t\t\tmpz_divexact_ui(qprime, qprime, 2);\n\t\t} while(!mpz_probab_prime_p(q, 10) || !mpz_probab_prime_p(qprime, 10));\n\n\t\t/* compute the public modulus n = p q */\n\t\tmpz_mul((*resPub)->npow[1],p,q);\n\n\t} while(!mpz_tstbit((*resPub)->npow[1],modulusbits - 1) || mpz_cmp(p, q) == 0 || mpz_cmp(pprime, q) == 0 || mpz_cmp(p, qprime) == 0);\n\t(*resPub)->s=s;\n\tcomplete_pubkey(*resPub);\n\t(*resPub)->bits = modulusbits;\n\t\n\t\n\t//now, generate the actual secret key: just lcm(p-1, q-1)\n\tmpz_sub_ui(p,p,1);\n\tmpz_sub_ui(q,q,1);\n\tmpz_lcm(reskey->key, p, q);\n\t\n\t\n\t//cleanup and return\n\tmpz_clear(p);\n\tmpz_clear(q);\n\tmpz_clear(pprime);\n\tmpz_clear(qprime);\n\tmpz_clear(m);\n\tmpz_clear(minv);\n\tmpz_clear(mnpows);\n\tmpz_clear(temp);\n\t\n\tgmp_randclear(rand);\n\t\n\treturn reskey;\n}\n\n\nvoid dj_thresh_centralized_keygen(\tdj_partial_prvkey_t** keyshares,\n\t\t\t\t\t\t\t\t\tdj_pubkey_t** resPub,\n\t\t\t\t\t\t\t\t\tunsigned short int k,\n\t\t\t\t\t\t\t\t\tunsigned short int l,\n\t\t\t\t\t\t\t\t\tunsigned short int s,\n\t\t\t\t\t\t\t\t\tint modulusbits,\n\t\t\t\t\t\t\t\t\tdj_get_rand_t get_rand)\n{\n\tmpz_t p,q,pprime,qprime,m,minv,n,mnpows,temp,computeDelta;\n\tmpz_t a[k];\n\t\n\tgmp_randstate_t rand;\n\t\n\tint i,j,x;\n\t\n\t//initialization\n\tmpz_init(p);\n\tmpz_init(q);\n\tmpz_init(pprime);\n\tmpz_init(qprime);\n\tmpz_init(m);\n\tmpz_init(minv);\n\tmpz_init(mnpows);\n\tmpz_init(temp);\n\tfor(i=0;i<k;i++)\n\t\tmpz_init(a[i]);\n\t\n\t(*resPub) = (dj_pubkey_t*) malloc(sizeof(dj_pubkey_t));\n\tmpz_init((*resPub)->n_plusone);\n\t(*resPub)->npow = (mpz_t*) malloc((s+2)*sizeof(mpz_t));\n\tfor(i=0;i<s+2;i++)\n\t\tmpz_init((*resPub)->npow[i]);\n\n\tmpz_init_set_ui(computeDelta, l);\n\tfor(i=l-1;i>1;i--)\n\t\tmpz_mul_ui(computeDelta, computeDelta, i);\n\t\n\tfor(i=0;i<l;i++)\n\t{\n\t\tkeyshares[i] = (dj_partial_prvkey_t*) malloc(sizeof(dj_partial_prvkey_t));\n\t\tmpz_init(keyshares[i]->s_i);\n\t\tmpz_init_set(keyshares[i]->delta, computeDelta);\n\t}\n\t\n\tmpz_clear(computeDelta);\n\t\n\tinit_rand(rand, get_rand, modulusbits / 8 + 1);\n\t\n\t\n\t//first, pick our secret primes: p and q that are of the form p=2p'+1, q=2q'+1, for p' and q' also prime\n\t//public key is n = pq\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\tmpz_urandomb(p,rand,modulusbits / 2);\n\t\t\tmpz_sub_ui(pprime, p, 1);\n\t\t\tmpz_divexact_ui(pprime, pprime, 2);\n\t\t} while(!mpz_probab_prime_p(p, 10) || !mpz_probab_prime_p(pprime, 10));\n\n\t\tdo\n\t\t{\n\t\t\tmpz_urandomb(q,rand,modulusbits / 2);\n\t\t\tmpz_sub_ui(qprime, q, 1);\n\t\t\tmpz_divexact_ui(qprime, qprime, 2);\n\t\t} while(!mpz_probab_prime_p(q, 10) || !mpz_probab_prime_p(qprime, 10));\n\n\t\t/* compute the public modulus n = p q */\n\t\tmpz_mul((*resPub)->npow[1],p,q);\n\n\t} while(!mpz_tstbit((*resPub)->npow[1],modulusbits - 1) || mpz_cmp(p, q) == 0 || mpz_cmp(pprime, q) == 0 || mpz_cmp(p, qprime) == 0);\n\t(*resPub)->s=s;\n\tcomplete_pubkey(*resPub);\n\t(*resPub)->bits = modulusbits;\n\t\n\t\n\tmpz_mul(m,pprime,qprime);\n\tmpz_mul(mnpows,m,(*resPub)->npow[s]);\n\t\n\t\n\t//now, generate the secret partial keys.\n\t//generate a polynomial (mod mn^s) with coeffs a_0 to a_{k-1}.\n\t//a_0 should be 0 mod m, 1 mod n^s, so set a_0 = (m^-1 mod n^s)(m).\n\t//the other a_i are random from 0 to (mn^s)-1.\n\t\n\t//key i (i starts at 1) is that polynomial evaluated at i.\n\t\n\tmpz_invert(minv,m,(*resPub)->npow[s]);\n\tmpz_mul(a[0],minv,m);\n\t\n\tfor(i=1;i<k;i++)\n\t\tmpz_urandomm(a[i],rand,mnpows);\n\t\n\t//generate l keys as requested. note that i starts at 1, in order to represent the i used in the paper.\n\tfor(i=1;i<=l;i++)\n\t{\n\t\tkeyshares[i-1]->i=i;\n\t\tkeyshares[i-1]->numShares=l;\n\t\tkeyshares[i-1]->threshold=k;\n\t\t\n\t\tmpz_set(keyshares[i-1]->s_i,a[0]);\n\t\tfor(j=1;j<k;j++)\n\t\t{\n\t\t\tmpz_ui_pow_ui(temp,i,j);\n\t\t\tmpz_mul(temp,temp,a[j]);\n\t\t\tmpz_add(keyshares[i-1]->s_i,keyshares[i-1]->s_i,temp);\n\t\t\tmpz_mod(keyshares[i-1]->s_i,keyshares[i-1]->s_i,mnpows);\n\t\t}\n\t}\n\t\n\t//cleanup and return\n\tmpz_clear(p);\n\tmpz_clear(q);\n\tmpz_clear(pprime);\n\tmpz_clear(qprime);\n\tmpz_clear(m);\n\tmpz_clear(minv);\n\tmpz_clear(mnpows);\n\tmpz_clear(temp);\n\tfor(i=0;i<k;i++)\n\t\tmpz_clear(a[i]);\n\t\n\tgmp_randclear(rand);\n}\n\n\n\ndj_decshare_t* dj_partial_decrypt(dj_decshare_t* res, dj_pubkey_t* pub, dj_partial_prvkey_t* prv, dj_ciphertext_t* ct)\n{\n\tint i;\n\n\tif(!res)\n\t{\n\t\tres = (dj_decshare_t*) malloc(sizeof(dj_decshare_t));\n\t\tmpz_init(res->c_i);\n\t\tmpz_init(res->delta);\n\t}\n\t\n\tres->i = prv->i;\n\tres->threshold = prv->threshold;\n\tres->numShares = prv->numShares;\n\tmpz_set(res->delta,prv->delta);\n\t\n\t//c_i = c^{2 delta s_i} mod n^{s+1}\n\tmpz_mul_ui(res->c_i,res->delta,2);\n\tmpz_mul(res->c_i,res->c_i,prv->s_i);\n\tmpz_powm(res->c_i,ct->c,res->c_i,pub->npow[pub->s+1]);\n\t\n\treturn res;\n}\n\n\ndj_plaintext_t* dj_combine_shares(dj_plaintext_t* res, dj_pubkey_t* pub, unsigned short int nSharesPassed, dj_decshare_t** passedshares)\n{\n\tint i,j,k;\n\tunsigned short int sharesPassed=nSharesPassed;\n\tdj_decshare_t* shares[sharesPassed];\n\tmpz_t twoLambdaS0[sharesPassed];\n\tmpz_t cprime, temp, tempDivisor, i_jCur, i_jPrev;\n\tint dupCount=0;\n\t\n\tif(!res)\n\t{\n\t\tres = (dj_plaintext_t*) malloc(sizeof(dj_plaintext_t));\n\t\tmpz_init(res->m);\n\t}\n\t\n\t//first, delete duplicate shares\n\tfor(i=0;i<sharesPassed;i++)\n\t\tshares[i]=passedshares[i];\n\t\n\tfor(i=0;i<sharesPassed;i++)\n\t\tfor(j=0;j<sharesPassed;j++)\n\t\t\tif(i!=j && shares[i]->i == shares[j]->i)\n\t\t\t{\n\t\t\t\tint delthis = i>j?i:j;\n\t\t\t\tfor(k=delthis;k<sharesPassed-1;k++)\n\t\t\t\t\tshares[k]=shares[k+1];\n\t\t\t\tshares[nSharesPassed-1] = 0;\n\t\t\t\tsharesPassed--;\n\t\t\t\tdupCount++;\n\t\t\t}\n\t\n\t//now that duplicates are gone, decryption is doable iff thresh <= # shares we were given\n\tif(shares[0]->threshold > sharesPassed)\n\t{\n\t\tprintf(\"Error! The shares passed to dj_combine_shares have a threshold of %d, but only %d were passed!\\n\",\n\t\t\t\tshares[0]->threshold, sharesPassed);\n\t\tif(dupCount>0)\n\t\t\tprintf(\"Furthermore, %d of the shares were duplicates of others, and so were discarded before checking the # of shares.\\n\",dupCount);\n\t\treturn 0;\n\t}\n\t\n\tfor(i=0;i<sharesPassed;i++)\n\t\tmpz_init(twoLambdaS0[i]);\n\tmpz_init(cprime);\n\tmpz_init(temp);\n\tmpz_init(tempDivisor);\n\t\n\t//here i is just an index, unlike in the keygen function. Instead, it's the i member of the dec share structure\n\t//that corresponds to the i in the paper.\n\t//generate the exponents that each decryption share will be raised to\n\tfor(i=0;i<sharesPassed;i++)\n\t{\n\t\tmpz_set(twoLambdaS0[i],passedshares[0]->delta);\n\t\tmpz_mul_ui(twoLambdaS0[i],twoLambdaS0[i],2);\n\t\t\n\t\tfor(j=0;j<sharesPassed;j++)\n\t\t\tif(i!=j)\n\t\t\t{\n\t\t\t\tmpz_mul_si(twoLambdaS0[i],twoLambdaS0[i],-shares[j]->i);\n\t\t\t\tmpz_set_si(tempDivisor,shares[i]->i - shares[j]->i);\n\t\t\t\tmpz_divexact(twoLambdaS0[i],twoLambdaS0[i],tempDivisor);\n\t\t\t}\n\t}\n\t\n\t//now raise the shares to the powers and multiply them\n\tmpz_set_ui(cprime,1);\n\tfor(i=0;i<sharesPassed;i++)\n\t{\n\t\tmpz_powm(temp,shares[i]->c_i,twoLambdaS0[i],pub->npow[pub->s+1]);\n\t\tmpz_mul(cprime,cprime,temp);\n\t\tmpz_mod(cprime,cprime,pub->npow[pub->s+1]);\n\t}\n\t\n\t\n\t\n\t\n\t//the algorithm from extracting i from (1+n)^i described in the paper.\n\t\n\t//the algorithm iteratively extracts i mod n, i mod n^2, etc. i mod n starts us off, and is just input - 1 / n.\n\tmpz_init(i_jCur);\n\tmpz_init_set(i_jPrev,cprime);\n\tmpz_sub_ui(i_jPrev,i_jPrev,1);\n\tmpz_divexact(i_jPrev,i_jPrev,pub->npow[1]);\n\tmpz_mod(i_jPrev,i_jPrev,pub->npow[2]);\n\t\n\t//just in case s=1; in that case we need this line to actually set i_jcur\n\tif(pub->s==1)\n\t\tmpz_set(i_jCur,i_jPrev);\n\t\n\t//extract i_j = i mod n^j given i_{j-1}. this is done by taking (input - 1 mod n^{j+1}) / n , and subtracting\n\t//from that: ((  (i_{j-1} choose 2)*n  + (i_{j-1} choose 3)*n^2  + ... +  (i_{j-1} choose j)*n^{j-1}  ))   mod n^j\n\tfor(j=2;j<=pub->s;j++)\n\t{\n\t\t//L((1+n)^i) as they call it \n\t\tmpz_mod(i_jCur,cprime,pub->npow[j+1]);\n\t\tmpz_sub_ui(i_jCur,i_jCur,1);\n\t\tmpz_divexact(i_jCur,i_jCur,pub->npow[1]);\n\t\t\n\t\tmpz_mod(i_jCur,i_jCur,pub->npow[j]);\n\t\t\n\t\t//subtract each of the binomial things\n\t\tfor(k=2;k<=j;k++)\n\t\t{\n\t\t\tmpz_bin_ui(temp,i_jPrev,k);\n\t\t\tmpz_mul(temp,temp,pub->npow[k-1]);\n\t\t\tmpz_mod(temp,temp,pub->npow[j]);\n\t\t\tmpz_sub(i_jCur,i_jCur,temp);\n\t\t\tmpz_mod(i_jCur,i_jCur,pub->npow[j]);\n\t\t}\n\t\tmpz_set(i_jPrev,i_jCur);\n\t}\n\t\n\t\n\t\n\t\n\t//now knock out the 4delta^2\n\tmpz_set_ui(temp,4);\n\tmpz_mul(temp,temp,passedshares[0]->delta);\n\tmpz_mul(temp,temp,passedshares[0]->delta);\n\tmpz_invert(temp,temp,pub->npow[pub->s]);\n\t\n\tmpz_mul(res->m,i_jCur,temp);\n\tmpz_mod(res->m,res->m,pub->npow[pub->s]);\n\t\n\t//cleanup and return\n\tfor(i=0;i<sharesPassed;i++)\n\t\tmpz_clear(twoLambdaS0[i]);\n\t\n\tmpz_clear(cprime);\n\tmpz_clear(i_jPrev);\n\tmpz_clear(i_jCur);\n\tmpz_clear(temp);\n\tmpz_clear(tempDivisor);\n\treturn res;\n}\n\n\nvoid dj_set_s(dj_pubkey_t* pub, unsigned short int newS)\n{\n\tint i;\n\t\n\tif(newS == pub->s)\n\t\treturn;\n\telse if(newS < pub->s)\n\t{\n\t\tfor(i=newS+2;i<pub->s+2;i++)\n\t\t\tmpz_clear(pub->npow[i]);\n\t\tpub->npow = (mpz_t*)realloc(pub->npow, (newS+2)*sizeof(mpz_t));\n\t}\n\telse\n\t{\n\t\tpub->npow = (mpz_t*)realloc(pub->npow, (newS+2)*sizeof(mpz_t));\n\t\tfor(i=pub->s+2;i<newS+2;i++)\n\t\t{\n\t\t\tmpz_init(pub->npow[i]);\n\t\t\tmpz_mul(pub->npow[i], pub->npow[i-1], pub->npow[1]);\n\t\t}\n\t}\n\t\n\tpub->s = newS;\n}\n\n"
        },
        {
            "file_name": "decrypt.c",
            "content": "#include \"api.h\"\n#include \"endian.h\"\n#include \"permutations.h\"\n\n#define RATE (64 / 8)\n#define PA_ROUNDS 12\n#define PB_ROUNDS 6\n#define IV                                                        \\\n  ((u64)(8 * (CRYPTO_KEYBYTES)) << 56 | (u64)(8 * (RATE)) << 48 | \\\n   (u64)(PA_ROUNDS) << 40 | (u64)(PB_ROUNDS) << 32)\n\nint crypto_aead_decrypt(unsigned char* m, unsigned long long* mlen,\n                        unsigned char* nsec, const unsigned char* c,\n                        unsigned long long clen, const unsigned char* ad,\n                        unsigned long long adlen, const unsigned char* npub,\n                        const unsigned char* k) {\n  if (clen < CRYPTO_ABYTES) {\n    *mlen = 0;\n    return -1;\n  }\n\n  const u64 K0 = U64BIG(*(u64*)k);\n  const u64 K1 = U64BIG(*(u64*)(k + 8));\n  const u64 N0 = U64BIG(*(u64*)npub);\n  const u64 N1 = U64BIG(*(u64*)(npub + 8));\n  state s;\n  u64 i;\n  (void)nsec;\n\n  // set plaintext size\n  *mlen = clen - CRYPTO_ABYTES;\n\n  // initialization\n  s.x0 = IV;\n  s.x1 = K0;\n  s.x2 = K1;\n  s.x3 = N0;\n  s.x4 = N1;\n  P12();\n  s.x3 ^= K0;\n  s.x4 ^= K1;\n\n  // process associated data\n  if (adlen) {\n    while (adlen >= RATE) {\n      s.x0 ^= U64BIG(*(u64*)ad);\n      P6();\n      adlen -= RATE;\n      ad += RATE;\n    }\n    for (i = 0; i < adlen; ++i, ++ad) s.x0 ^= INS_BYTE64(*ad, i);\n    s.x0 ^= INS_BYTE64(0x80, adlen);\n    P6();\n  }\n  s.x4 ^= 1;\n\n  // process plaintext\n  clen -= CRYPTO_ABYTES;\n  while (clen >= RATE) {\n    *(u64*)m = U64BIG(s.x0) ^ *(u64*)c;\n    s.x0 = U64BIG(*((u64*)c));\n    P6();\n    clen -= RATE;\n    m += RATE;\n    c += RATE;\n  }\n  for (i = 0; i < clen; ++i, ++m, ++c) {\n    *m = EXT_BYTE64(s.x0, i) ^ *c;\n    s.x0 &= ~INS_BYTE64(0xff, i);\n    s.x0 |= INS_BYTE64(*c, i);\n  }\n  s.x0 ^= INS_BYTE64(0x80, clen);\n\n  // finalization\n  s.x1 ^= K0;\n  s.x2 ^= K1;\n  P12();\n  s.x3 ^= K0;\n  s.x4 ^= K1;\n\n  // verify tag (should be constant time, check compiler output)\n  if (((s.x3 ^ U64BIG(*(u64*)c)) | (s.x4 ^ U64BIG(*(u64*)(c + 8)))) != 0) {\n    *mlen = 0;\n    return -1;\n  }\n\n  return 0;\n}\n\n"
        },
        {
            "file_name": "deoxysneq256128v1_deoxys.cpp",
            "content": "/*\n * Deoxys=/=-256-128 Reference C Implementation\n *\n * Copyright 2014:\n *     Jeremy Jean <JJean@ntu.edu.sg>\n *     Ivica Nikolic <INikolic@ntu.edu.sg>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n *\n */\n\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include \"deoxysneq256128v1_deoxys.h\"\n#include \"deoxysneq256128v1_tweakableBC.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Deoxysneq256128v1_raw {\n\n/* Define the three MSB of the tweak (that depend on the stage) */\n#define MSB_AD \t\t\t      (0x2<<5)\n#define MSB_AD_LAST\t\t      (0x6<<5)\n#define MSB_M\t\t\t      (0x0<<5)\n#define MSB_M_LAST_ZERO\t\t  (0x1<<5)\n#define MSB_M_LAST_NONZERO\t  (0x4<<5)\n#define MSB_PAD\t\t\t      (0x4<<5)\n#define MSB_CHKSUM\t\t      (0x5<<5)\n\n/* Number of bits in the TWEAKEY state (256 or 384) */\n#define TWEAKEY_STATE_SIZE    384\n\n/**********************************************************************************\n*** In Deoxys=/=-256-128, the tweak is on 128 bits:\n***     tweak = <stage> || <nonce> || <blockNumber>\n***  where we use:\n***      3 bits for stage\n***     64 bits for nonce\n***     61 bits for blockNumber\n***********************************************************************************/\n\n/*\n** Modifiy the nonce part in the tweak value\n*/\nstatic void set_nonce_in_tweak(uint8_t *tweak, const uint8_t *nonce) {\n    tweak[0] = (tweak[0]&0xe0)   ^ (nonce[0] >> 3);\n    tweak[1]=(nonce[0]&7) << 5 ^ (nonce[1] >> 3);\n    tweak[2]=(nonce[1]&7) << 5 ^ (nonce[2] >> 3);\n    tweak[3]=(nonce[2]&7) << 5 ^ (nonce[3] >> 3);\n    tweak[4]=(nonce[3]&7) << 5 ^ (nonce[4] >> 3);\n    tweak[5]=(nonce[4]&7) << 5 ^ (nonce[5] >> 3);\n    tweak[6]=(nonce[5]&7) << 5 ^ (nonce[6] >> 3);\n    tweak[7]=(nonce[6]&7) << 5 ^ (nonce[7] >> 3);\n    tweak[8]=(nonce[7]&7) << 5;\n}\n\n/*\n** Modifiy the block number in the tweak value\n*/\nstatic void set_block_number_in_tweak(uint8_t *tweak, const uint64_t block_no) {\n    tweak[ 8] = (tweak[8]&0xe0) ^ ((block_no >> 56ULL) & 0x1f);\n    tweak[ 9] = ((block_no >> 48ULL) & 0xff);\n    tweak[10] = ((block_no >> 40ULL) & 0xff);\n    tweak[11] = ((block_no >> 32ULL) & 0xff);\n    tweak[12] = ((block_no >> 24ULL) & 0xff);\n    tweak[13] = ((block_no >> 16ULL) & 0xff);\n    tweak[14] = ((block_no >>  8ULL) & 0xff);\n    tweak[15] = ((block_no >>  0ULL) & 0xff);\n}\n\n/*\n** Modifiy the stage value in the tweak value\n*/\nstatic void set_stage_in_tweak(uint8_t *tweak, const uint8_t value) {\n    tweak[0]=(tweak[0] & 0x1f) ^ value ;\n}\n\n/*\n** Update the tweak value in the tweakey word.\n** In the case of Deoxys-BC-256, the tweakey word is composed of KEY || TWEAK.\n** In the case of Deoxys-BC-384, the tweakey word is composed of KEY_2 || KEY_1 || TWEAK.\n*/\nstatic void set_tweak_in_tweakey(uint8_t *tweakey, uint8_t *tweak) {\n#if TWEAKEY_STATE_SIZE==256\n    memcpy(tweakey+16, tweak, 16);\n#elif TWEAKEY_STATE_SIZE==384\n    memcpy(tweakey+32, tweak, 16);\n#endif\n}\n\n/*\n** XOR an input block to another input block\n*/\nstatic void xor_values(uint8_t *v1, const uint8_t *v2) {\n    int i;\n    for (i=0; i<16; i++) v1[i] ^= v2[i];\n}\n\n/*\n** Deoxys encryption function\n*/\nvoid deoxys_aead_encrypt(const uint8_t *ass_data, size_t ass_data_len,\n                         const uint8_t *message, size_t m_len,\n                         const uint8_t *key,\n                         const uint8_t *nonce,\n                         uint8_t *ciphertext, size_t *c_len)\n{\n\n    uint64_t i;\n    uint64_t j;\n    uint8_t tweak[16];\n    uint8_t tweakey[TWEAKEY_STATE_SIZE/8];\n    uint8_t Auth[16];\n    uint8_t last_block[16];\n    uint8_t Checksum[16];\n    uint8_t Final[16];\n    uint8_t zero_block[16];\n    uint8_t Pad[16];\n    uint8_t temp[16];\n\n    /* Fill the tweak from nonce */\n    memset(tweak, 0, sizeof(tweak));\n\n    /* Set the nonce in the tweak */\n    set_nonce_in_tweak(tweak, nonce);\n\n    /* Fill the key(s) in the tweakey state */\n#if TWEAKEY_STATE_SIZE==256\n    memcpy(tweakey, key, 16);\n#elif TWEAKEY_STATE_SIZE==384\n    memcpy(tweakey, key, 32);\n#endif\n\n    /* Associated data */\n    memset(Auth, 0, 16);\n    set_stage_in_tweak(tweak, MSB_AD);\n\n    /* For each full input blocks */\n    i=1;\n    while (16*i <= ass_data_len) {\n\n        /* Encrypt the current block */\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, ass_data+16*(i-1), tweakey, temp);\n\n        /* Update Auth value */\n        xor_values(Auth, temp);\n\n        /* Go on with the next block */\n        i++;\n    }\n    i--;\n\n    /* Last block if incomplete */\n    if ( (ass_data_len==0) || (ass_data_len > 16*i) ) {\n\n        /* Prepare the last padded block */\n        memset(last_block, 0, 16);\n        memcpy(last_block, ass_data+16*i, ass_data_len-16*i);\n        last_block[ass_data_len-16*i]=0x80;\n\n        /* Encrypt the last block */\n        set_stage_in_tweak(tweak, MSB_AD_LAST);\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, last_block, tweakey, temp);\n\n        /* Update the Auth value */\n        xor_values(Auth, temp);\n    }\n\n    /* Message */\n    memset(Checksum, 0, 16);\n    set_stage_in_tweak(tweak, MSB_M);\n    i=1;\n    while (16*i <= m_len) {\n        xor_values(Checksum, message+16*(i-1));\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, message+16*(i-1), tweakey, ciphertext+16*(i-1));\n        i++;\n    }\n    i--;\n\n    /* Process last block */\n    /* If the block is full, i.e. M_last=epsilon */\n    if (m_len == 16*i) {\n        set_stage_in_tweak(tweak, MSB_M_LAST_ZERO);\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, Checksum, tweakey, Final);\n\n    } else { /* If the block is partial and requires padding */\n        memset(last_block, 0, 16);\n        memcpy(last_block, message +16*i, m_len-16*i);\n        last_block[m_len-16*i]=0x80;\n        xor_values(Checksum, last_block);\n\n        /* Create the zero block for encryption */\n        memset(zero_block, 0, 16);\n\n        /* Encrypt it */\n        set_stage_in_tweak(tweak, MSB_M_LAST_NONZERO);\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, zero_block, tweakey, Pad);\n\n        /* Write the ciphertext block */\n        for (j=0; j<m_len-16*i; j++) {\n            ciphertext[16*i+j]=last_block[j] ^ Pad[j];\n        }\n\n        /* Compute Final value */\n        set_stage_in_tweak(tweak, MSB_CHKSUM);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, Checksum, tweakey, Final);\n    }\n\n    /* Append the authentication tag to the ciphertext */\n    for (i=0; i<16; i++) {\n        ciphertext[m_len+i]=Final[i] ^ Auth[i];\n    }\n\n    /* The authentication tag is one block long, i.e. 16 bytes */\n    *c_len=m_len+16;\n\n}\n\n/*\n** Deoxys decryption function\n*/\nint deoxys_aead_decrypt(const uint8_t *ass_data, size_t ass_data_len,\n                       uint8_t *message, size_t *m_len,\n                       const uint8_t *key,\n                       const uint8_t *nonce,\n                       const uint8_t *ciphertext, size_t c_len)\n{\n\n    uint64_t i;\n    uint64_t j;\n    uint8_t tweak[16];\n    uint8_t tweakey[TWEAKEY_STATE_SIZE/8];\n    uint8_t Auth[16];\n    uint8_t last_block[16];\n    uint8_t Checksum[16];\n    uint8_t Final[16];\n    uint8_t zero_block[16];\n    uint8_t Pad[16];\n    uint8_t Tag[16];\n    uint8_t temp[16];\n\n    /* Get the tag from the last 16 bytes of the ciphertext */\n    memcpy(Tag, ciphertext+c_len-16, 16);\n\n    /* Update c_len to the actual size of the ciphertext (i.e., without the tag) */\n    c_len-=16;\n\n    /* Fill the tweak from nonce */\n    set_nonce_in_tweak(tweak, nonce);\n\n    /* Fill the key(s) in the tweakey state */\n#if TWEAKEY_STATE_SIZE==256\n    memcpy(tweakey, key, 16);\n#elif TWEAKEY_STATE_SIZE==384\n    memcpy(tweakey, key, 32);\n#endif\n\n    /* Associated data */\n    memset(Auth, 0, 16);\n    set_stage_in_tweak(tweak, MSB_AD);\n    i=1;\n    while (16*i <= ass_data_len) {\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, ass_data+16*(i-1), tweakey, temp);\n        xor_values(Auth, temp);\n        i++;\n    }\n    i--;\n\n    /* Last block if incomplete */\n    if ((ass_data_len==0) || (ass_data_len > 16*i) ) {\n        memset(last_block, 0, 16);\n        memcpy(last_block, ass_data+16*i, ass_data_len-16*i);\n        last_block[ass_data_len-16*i]=0x80;\n        set_stage_in_tweak(tweak, MSB_AD_LAST);\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, last_block, tweakey, temp);\n        xor_values(Auth, temp);\n    }\n\n    /* Ciphertext */\n    memset(Checksum, 0, 16);\n    set_stage_in_tweak(tweak, MSB_M);\n    i=1;\n    while(16*i<=c_len) {\n        set_tweak_in_tweakey(tweakey, tweak);\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakDecrypt(TWEAKEY_STATE_SIZE, ciphertext+16*(i-1), tweakey, message+16*(i-1));\n\n        xor_values(Checksum, message+16*(i-1));\n        i++;\n    }\n    i--;\n\n    /* Last block */\n    /* If the block is full, i.e. M_last=epsilon */\n    if (c_len == 16*i) {\n        set_stage_in_tweak(tweak, MSB_M_LAST_ZERO);\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, Checksum, tweakey, Final);\n        xor_values(Final, Auth);\n\n        /* If the tags does not match, return error -1 */\n        if( 0 != memcmp(Final, Tag, sizeof(Tag)) ) {\n            return -1;\n        }\n\n    } else { /* If the block is partial and has been padded */\n\n        /* Prepare the full-zero block */\n        memset(zero_block, 0, 16);\n\n        /* Prepare the tweak */\n        set_stage_in_tweak(tweak, MSB_M_LAST_NONZERO);\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n\n        /* Encrypt */\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, zero_block, tweakey, Pad);\n\n        /* XOR the partial ciphertext */\n        memset(last_block, 0, 16);\n        memcpy(last_block, ciphertext+16*i, c_len-16*i);\n        memset(Pad+c_len-16*i, 0, 16-(c_len-16*i));\n        xor_values(last_block, Pad);\n        last_block[c_len-16*i]=0x80;\n\n        /* Write the message block */\n        for (j=0; j<c_len-16*i; j++) {\n            message[16*i+j]=last_block[j];\n        }\n\n        /* Update checksum */\n        xor_values(Checksum, last_block);\n\n        /* Verify the tag */\n        set_stage_in_tweak(tweak, MSB_CHKSUM);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, Checksum, tweakey, Final);\n        xor_values(Final, Auth);\n\n        /* If the tags does not match, return error -1 */\n        if( 0 != memcmp(Final, Tag, sizeof(Tag)) ) {\n            return -1;\n        }\n    }\n\n    /* Update the length of the plaintext */\n    *m_len=c_len;\n\n    return 0;\n}\n\n} // namespace Deoxysneq256128v1_raw\n"
        },
        {
            "file_name": "determine_decrypt_method.cc",
            "content": "/*\nCopyright (c) 2019 Stuart Steven Calder\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and\nthe following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n#include \"determine_decrypt_method.hh\"\n\nnamespace threecrypt {\n\t/* This function looks at the \"magic bytes\" at the beginning of a file,\n\t*  and tries to determine which 3crypt format it was encrypted with, if any.\n\t*/\n\tDecryption_Method_e\n\tdetermine_decrypt_method\t(char const * filename) {\n\t\t// Get the size of the file.\n\t\tauto const file_size = ssc::get_file_size( filename );\n\t\t// Assume that the file is not a valid 3crypt encrypted file to start.\n\t\tauto method = Decryption_Method_e::None;\n\n\t\t// Discard files that are smaller than the smallest identifier string.\n\t\tif (file_size < Smallest_Identifier_String_Size) {\n\t\t\tstd::fprintf( stderr, \"Error: The file `%s` is too small to be a 3crypt encrypted file.\\n\", filename );\n\t\t\tstd::exit( EXIT_FAILURE );\n\t\t}\n\t\t{\n\t\t\t// Open the file\n\t\t\tstd::FILE * file_ptr;\n\t\t\tif ((file_ptr = std::fopen( filename, \"rb\" )) == nullptr) {\n\t\t\t\tstd::fprintf( stderr, \"Error: Failed to open `%s` to determine its decryption method.\\n\", filename );\n\t\t\t\tstd::exit( EXIT_FAILURE );\n\t\t\t}\n\t\t\t// Create a buffer that can fit the biggest possible identifier string.\n\t\t\tu8_t buffer [Biggest_Identifier_String_Size];\n\t\t\t/* If the file is bigger than the biggest possible identifier string, read in Biggest_Identifier_String_Size bytes,\n\t\t\t* otherwise, read in the entire file to check it.\n\t\t\t*/\n\t\t\tsize_t const bytes_to_read = (file_size > Biggest_Identifier_String_Size) ? Biggest_Identifier_String_Size : file_size;\n\t\t\tsize_t const read_bytes = std::fread( buffer, 1, bytes_to_read, file_ptr );\n\t\t\t// Ensure that all the requested bytes were read in.\n\t\t\tif (read_bytes != bytes_to_read) {\n\t\t\t\tstd::fprintf( stderr, \"Error: Failed to read bytes to determine decryption method: (%zu) requsted, (%zu) read.\\n\",\n\t\t\t\t\t      bytes_to_read, read_bytes );\n\t\t\t\tstd::exit( EXIT_FAILURE );\n\t\t\t}\n\t\t\t// If the CBC_V2 header was included, check to see if the file is a CBC_V2 encrypted file.\n#ifdef CBC_V2_HH\n\t\t\t{\n\t\t\t\tusing namespace cbc_v2;\n\t\t\t\tstatic_assert (sizeof(CBC_V2_Header_t::id) == sizeof(CBC_V2_ID));\n\t\t\t\tif (method == Decryption_Method_e::None &&\n\t\t\t\t    memcmp( buffer, CBC_V2_ID, sizeof(CBC_V2_ID) ) == 0)\n\t\t\t\t{\n\t\t\t\t\tmethod = Decryption_Method_e::CBC_V2;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\t// Close the file.\n\t\t\tif (std::fclose( file_ptr ) != 0) {\n\t\t\t\tstd::fprintf( stderr, \"Error: Failed to close `%s` after checking for its decryption method.\\n\", filename );\n\t\t\t\tstd::exit( EXIT_FAILURE );\n\t\t\t}\n\t\t}\n\t\t// Return the detected needed decryption method.\n\t\treturn method;\n\t}/* determine_decrypt_method */\n} /* ! namespace threecrypt */\n"
        },
        {
            "file_name": "elmd101271v1_encrypt.cpp",
            "content": "/* ==========   Reference Implementation of ELmD((10,10),127,1) ============= */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"elmd101271v1_encrypt.h\"\n#include <openssl/aes.h>\n\n#define rd 10 // Denotes the no. of rounds of 1st layer AES encryption.\n#define IT_GAP 127 // Denotes the no. of blocks after which intermediate tags are generated.\n\n// CHANGE undefining OPENSSL_FIPS because it helps :-/\n#undef OPENSSL_FIPS\n\n#include \"elmd101271v1_aes_round_5.h\"\n#include \"elmd101271v1_module.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Elmd101271v1_raw {\nint numRounds = -1;\n\n/* ============================== Process Associated Data =================================*/\nstatic void process_AD(\n    block W, block Delta_1, const block npub, block param,\n    const u8 *ad, u64 adlen) {\n\n    block Delta_2, blk, result;\n    u8 Is_complete = 1, ozs[16];\n    int i; for(i=1; i<16; i++){ozs[i]=0x00;} ozs[0] = 0x80;\n\n\n\n    /* ===== make the first block blk based on npub and param ===== */\n    load_block(blk, npub, param, 8, 8);\n\n    while(1){\n\n        /* ============= Process the current Block ==================== */\n        process_block(Delta_1, Delta_2, result, blk, W, Is_complete, ENCRYPT, 0, AD);\n\n        /* === Compute the next Block and updating the pointers and counters ===*/\n        if(adlen==0) break;\n\n        else if(adlen <= 16) {\n            load_block(blk, ad, ozs, adlen, 16-adlen);\n            if(adlen != 16) Is_complete = 0;\n            adlen = 0;\n        }\n\n        else {load_block(blk, ad, ozs, 16, 0); ad +=16; adlen -=16;}\n    }\n\n}\n\n/* ===================   ELmD((10,10),127,1) Authenticated Encryption Function =================== */\n\nint crypto_aead_encrypt(\nunsigned char *c,unsigned long long *clen,\nconst unsigned char *m,unsigned long long mlen,\nconst unsigned char *ad,unsigned long long adlen,\nconst unsigned char *nsec,\nconst unsigned char *npub,\nconst unsigned char *k\n)\n{\n    u8 param[]={0xaa,0,0x7f,0x81,0,0,0,0};\n\n    block L, W, Delta_0, Delta_1, Delta_2, blk, result, CS;\n    int i;\n    unsigned long long h, blk_ctr=0, blk_ctr1=0 ;\n    u8 zeroes[16], ozs[16], blen = 16, Is_final = 0, Is_complete =1;\n    for(i=0; i<16; i++)\t{zeroes[i]=0x00;}\n    for(i=1; i<16; i++)\t{ozs[i]=0x00;} ozs[0] = 0x80;\n\n    h = (mlen+8-1) / (IT_GAP * 16);\n    if(h > IT_MAX)\n        h = IT_MAX;\n    *clen = mlen + 24 + h*16 ;\n\n    key_schedule(k);\n\n    /* ==========  Generate the Masks =========== */\n    AES(10, ENCRYPT, L, zeroes, &aes_key1);\n\n    mult_3(Delta_0, L);\n    mult_inv2(Delta_0, Delta_0);\n\n    mult_inv2(Delta_1, L);\n\n    mult_3(Delta_2, L);\n    mult_3(Delta_2, Delta_2);\n    mult_inv2(Delta_2, Delta_2);\n\n    /* ======  Process Associated Data ======== */\n    for(i=0; i<16; i++)\n        W[i]=0x00;\n    process_AD(W, Delta_0, npub, param, ad, adlen);\n\n\n    /* ================  Process Message Blocks ==================== */\n\n\n    /* ====== Process the first Message block, whose first 8 byte is the secret message number ===== */\n\n    if(mlen < 8){ Is_complete = 0; }\n    if(mlen <= 8) { blen = 8 + mlen; }\n    load_block(blk, nsec, m, 8, blen-8); copy_block(CS, blk);\n    process_block(Delta_1, Delta_2, result, blk, W, Is_complete, ENCRYPT, Is_final, MESSAGE);\n\n    store_bytes(c, result, 0, 15); c +=16; blk_ctr++;\n    if(mlen >= 8)  {mlen -= 8; m +=8;}\n    else mlen = 0;\n\n    /* ============= Process Successive Message blocks ================== */\n    while(mlen > 0){\n        if(mlen >= 16){\n            load_block(blk, m, ozs, 16, 0); xor_block(CS, CS, blk);\n            blen = 16; mlen -= 16; m+=16;\n        }\n        else \t{Is_complete = 0; blen = mlen; mlen = 0;\n            load_block(blk, m, ozs, blen, 0); xor_block(CS, CS, blk);\n\n        }\n        process_block(Delta_1, Delta_2, result, blk, W, Is_complete, ENCRYPT, Is_final, MESSAGE);\n        store_bytes(c, result, 0, 15); c +=16; blk_ctr++;\n\n        if(blk_ctr == IT_GAP && blk_ctr1 < IT_MAX && mlen>0) {\n            AES(10, DECRYPT, result, W, &aes_key2);\n            mask(Delta_2, result, result, 1);\n            store_bytes(c, result, 0, 15); c +=16; blk_ctr =0; blk_ctr1++;\n        }\n    }\n\n    /* ================ Process checksum block ====================== */\n    process_block(Delta_1, Delta_2, result, CS, W, 1, ENCRYPT, 1, MESSAGE);\n    store_bytes(c, result, 0, blen-1);\n\n    return 0;\n}\n\n/* ===================   ELmD((10,10),127,1) Verified Decryption Function =================== */\nint crypto_aead_decrypt(\nunsigned char *m,unsigned long long *mlen,\nunsigned char *nsec,\nconst unsigned char *c, unsigned long long clen,\nconst unsigned char *ad, unsigned long long adlen,\nconst unsigned char *npub,\nconst unsigned char *k\n)\n{\n    u8 param[]={0xaa,0,0x7f,0x81,0,0,0,0};\n\n    block L, W, Delta_0, Delta_1, Delta_2, blk, result, CS;\n    int i; u8 zeroes[16], ozs[16], blen = 16, Is_final = 0, Is_complete =1;\n    unsigned long long outputmlen, blk_ctr=0, blk_ctr1=0;\n    for(i=0; i<16; i++)\t{zeroes[i]=0x00;}   \t\t// all zero.\n    for(i=1; i<16; i++)\t{ozs[i]=0x00;} ozs[0] = 0x80; \t//useful for padding.\n\n    if(clen < 24)\n        return -1;\n\n    key_schedule(k);\n\n    /* =========== Generate the Masks ========== */\n    AES(10, ENCRYPT, L, zeroes, &aes_key1);\n\n    mult_3(Delta_0, L);\n    mult_inv2(Delta_0, Delta_0);\n\n    mult_inv2(Delta_1, L);\n\n    mult_3(Delta_2, L);\n    mult_3(Delta_2, Delta_2);\n    mult_inv2(Delta_2, Delta_2);\n\n    /* =============  Process Associated Data  ================ */\n    for(i=0; i<16; i++)\n        W[i]=0x00;\n    process_AD(W, Delta_0, npub, param, ad, adlen);\n\n\n     load_block(CS, zeroes, zeroes, 16, 0);\n\n     /* ================ Process Ciphertext Blocks ============ */\n     load_block(blk, c, zeroes, 16, 0);\n\n     /* =================== Process 1st Block =================== */\n     if(clen<32){\n        process_block(Delta_2, Delta_1, result, blk, W, 0, DECRYPT, Is_final, CIPHERTEXT);\n        store_bytes(m, result, 8, 8+(clen-25)); outputmlen = clen - 24;\n     }\n     else {\n        process_block(Delta_2, Delta_1, result, blk, W, 1, DECRYPT, Is_final, CIPHERTEXT);\n        store_bytes(m, result, 8, 15);  m +=8; outputmlen = 8;\n     }\n     xor_block(CS, CS, result); store_bytes(nsec, result, 0, 7);\n     clen -= 16; c+=16; blk_ctr ++;\n\n     if(clen < 16){\n        if(result[clen] != 0x80) return -1;\n        for(i=clen+1; i<16; i++) {if(result[i]!=0) return -1;}\n       }\n\n    /* ============= Process Successive Ciphertext Blocks ============== */\n    while(clen > 16){\n\n       load_block(blk, c, zeroes, 16, 0);\n       if(clen < 32){\n        process_block(Delta_2, Delta_1, result, blk, W, 0, DECRYPT, Is_final, CIPHERTEXT);\n        store_bytes(m, result, 0, clen - 17); outputmlen += clen-16 ;\n       }\n       else{\n            process_block(Delta_2, Delta_1, result, blk, W, 1, DECRYPT, Is_final, CIPHERTEXT);\n        store_bytes(m, result, 0, 15); outputmlen += 16;\n       }\n\n       xor_block(CS, CS, result);\n       clen -= 16; c+=16; blk_ctr ++;\n\n\n       if(clen < 16){\n        if(result[clen] != 0x80) return -1;\n        for(i=clen+1; i<16; i++) {if(result[i]!=0) return -1;}\n       }\n       else\n           m +=16;\n\n\n       if(blk_ctr == IT_GAP && blk_ctr1 < IT_MAX && clen > 32){\n        AES(10, DECRYPT, result, W, &aes_key2);\n        mask(Delta_2, result, result, 1);\n        for(i=0; i<16; i++) { if(c[i] != result[i]) return -1; }\n        c +=16; clen -= 16; blk_ctr =0; blk_ctr1++;\n       }\n\n    }\n\n    /* ==========  Process checksum block  ============= */\n    Is_final = 1;\n    process_block(Delta_1, Delta_2, result, CS, W, 1, ENCRYPT, Is_final, MESSAGE);\n    for(i=0; i<clen; i++) {if(result[i]!=c[i]) return -1;}\n    *mlen = outputmlen;\n\n    return 0;\n}\n\n} // namespace Elmd101271v1_raw\n"
        },
        {
            "file_name": "enchilada256v1_aescrypt.cpp",
            "content": "/*\n -------------------------------------------------------------------------\n Copyright (c) 2001, Dr Brian Gladman <                 >, Worcester, UK.\n All rights reserved.\n\n LICENSE TERMS\n\n The free distribution and use of this software in both source and binary\n form is allowed (with or without changes) provided that:\n\n   1. distributions of this source code include the above copyright\n      notice, this list of conditions and the following disclaimer;\n\n   2. distributions in binary form include the above copyright\n      notice, this list of conditions and the following disclaimer\n      in the documentation and/or other associated materials;\n\n   3. the copyright holder's name is not used to endorse products\n      built using this software without specific written permission.\n\n DISCLAIMER\n\n This software is provided 'as is' with no explicit or implied warranties\n in respect of its properties, including, but not limited to, correctness\n and fitness for purpose.\n -------------------------------------------------------------------------\n Issue Date: 29/07/2002\n\n This file contains the code for implementing encryption and decryption\n for AES (Rijndael) for block and key sizes of 16, 24 and 32 bytes. It\n can optionally be replaced by code written in assembler using NASM.\n*/\n\n#include \"enchilada256v1_aesopt.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Enchilada256v1_raw {\n\n#if defined(BLOCK_SIZE) && (BLOCK_SIZE & 7)\n#error An illegal block size has been specified.\n#endif\n\n#define unused  77  /* Sunset Strip */\n\n#define si(y,x,k,c) s(y,c) = word_in(x + 4 * c) ^ k[c]\n#define so(y,x,c)   word_out(y + 4 * c, s(x,c))\n\n#if BLOCK_SIZE == 16\n\n#if defined(ARRAYS)\n#define locals(y,x)     x[4],y[4]\n#else\n#define locals(y,x)     x##0,x##1,x##2,x##3,y##0,y##1,y##2,y##3\n /*\n   the following defines prevent the compiler requiring the declaration\n   of generated but unused variables in the fwd_var and inv_var macros\n */\n#define b04 unused\n#define b05 unused\n#define b06 unused\n#define b07 unused\n#define b14 unused\n#define b15 unused\n#define b16 unused\n#define b17 unused\n#endif\n#define l_copy(y, x)    s(y,0) = s(x,0); s(y,1) = s(x,1); \\\n                        s(y,2) = s(x,2); s(y,3) = s(x,3);\n#define state_in(y,x,k) si(y,x,k,0); si(y,x,k,1); si(y,x,k,2); si(y,x,k,3)\n#define state_out(y,x)  so(y,x,0); so(y,x,1); so(y,x,2); so(y,x,3)\n#define round(rm,y,x,k) rm(y,x,k,0); rm(y,x,k,1); rm(y,x,k,2); rm(y,x,k,3)\n\n#elif BLOCK_SIZE == 24\n\n#if defined(ARRAYS)\n#define locals(y,x)     x[6],y[6]\n#else\n#define locals(y,x)     x##0,x##1,x##2,x##3,x##4,x##5, \\\n                        y##0,y##1,y##2,y##3,y##4,y##5\n#define b06 unused\n#define b07 unused\n#define b16 unused\n#define b17 unused\n#endif\n#define l_copy(y, x)    s(y,0) = s(x,0); s(y,1) = s(x,1); \\\n                        s(y,2) = s(x,2); s(y,3) = s(x,3); \\\n                        s(y,4) = s(x,4); s(y,5) = s(x,5);\n#define state_in(y,x,k) si(y,x,k,0); si(y,x,k,1); si(y,x,k,2); \\\n                        si(y,x,k,3); si(y,x,k,4); si(y,x,k,5)\n#define state_out(y,x)  so(y,x,0); so(y,x,1); so(y,x,2); \\\n                        so(y,x,3); so(y,x,4); so(y,x,5)\n#define round(rm,y,x,k) rm(y,x,k,0); rm(y,x,k,1); rm(y,x,k,2); \\\n                        rm(y,x,k,3); rm(y,x,k,4); rm(y,x,k,5)\n#else\n\n#if defined(ARRAYS)\n#define locals(y,x)     x[8],y[8]\n#else\n#define locals(y,x)     x##0,x##1,x##2,x##3,x##4,x##5,x##6,x##7, \\\n                        y##0,y##1,y##2,y##3,y##4,y##5,y##6,y##7\n#endif\n#define l_copy(y, x)    s(y,0) = s(x,0); s(y,1) = s(x,1); \\\n                        s(y,2) = s(x,2); s(y,3) = s(x,3); \\\n                        s(y,4) = s(x,4); s(y,5) = s(x,5); \\\n                        s(y,6) = s(x,6); s(y,7) = s(x,7);\n\n#if BLOCK_SIZE == 32\n\n#define state_in(y,x,k) si(y,x,k,0); si(y,x,k,1); si(y,x,k,2); si(y,x,k,3); \\\n                        si(y,x,k,4); si(y,x,k,5); si(y,x,k,6); si(y,x,k,7)\n#define state_out(y,x)  so(y,x,0); so(y,x,1); so(y,x,2); so(y,x,3); \\\n                        so(y,x,4); so(y,x,5); so(y,x,6); so(y,x,7)\n#define round(rm,y,x,k) rm(y,x,k,0); rm(y,x,k,1); rm(y,x,k,2); rm(y,x,k,3); \\\n                        rm(y,x,k,4); rm(y,x,k,5); rm(y,x,k,6); rm(y,x,k,7)\n#else\n\n#define state_in(y,x,k) \\\nswitch(nc) \\\n{   case 8: si(y,x,k,7); si(y,x,k,6); \\\n    case 6: si(y,x,k,5); si(y,x,k,4); \\\n    case 4: si(y,x,k,3); si(y,x,k,2); \\\n            si(y,x,k,1); si(y,x,k,0); \\\n}\n\n#define state_out(y,x) \\\nswitch(nc) \\\n{   case 8: so(y,x,7); so(y,x,6); \\\n    case 6: so(y,x,5); so(y,x,4); \\\n    case 4: so(y,x,3); so(y,x,2); \\\n            so(y,x,1); so(y,x,0); \\\n}\n\n#if defined(FAST_VARIABLE)\n\n#define round(rm,y,x,k) \\\nswitch(nc) \\\n{   case 8: rm(y,x,k,7); rm(y,x,k,6); \\\n            rm(y,x,k,5); rm(y,x,k,4); \\\n            rm(y,x,k,3); rm(y,x,k,2); \\\n            rm(y,x,k,1); rm(y,x,k,0); \\\n            break; \\\n    case 6: rm(y,x,k,5); rm(y,x,k,4); \\\n            rm(y,x,k,3); rm(y,x,k,2); \\\n            rm(y,x,k,1); rm(y,x,k,0); \\\n            break; \\\n    case 4: rm(y,x,k,3); rm(y,x,k,2); \\\n            rm(y,x,k,1); rm(y,x,k,0); \\\n            break; \\\n}\n#else\n\n#define round(rm,y,x,k) \\\nswitch(nc) \\\n{   case 8: rm(y,x,k,7); rm(y,x,k,6); \\\n    case 6: rm(y,x,k,5); rm(y,x,k,4); \\\n    case 4: rm(y,x,k,3); rm(y,x,k,2); \\\n            rm(y,x,k,1); rm(y,x,k,0); \\\n}\n\n#endif\n\n#endif\n#endif\n\n#if defined(ENCRYPTION)\n\n/* I am grateful to Frank Yellin for the following construction\n   (and that for decryption) which, given the column (c) of the\n   output state variable, gives the input state variables which\n   are needed in its computation for each row (r) of the state.\n\n   For the fixed block size options, compilers should be able to\n   reduce this complex expression (and the equivalent one for\n   decryption) to a static variable reference at compile time.\n   But for variable block size code, there will be some limbs on\n   which conditional clauses will be returned.\n*/\n\n/* y = output word, x = input word, r = row, c = column for r = 0,\n   1, 2 and 3 = column accessed for row r.\n*/\n\n#define fwd_var(x,r,c)\\\n ( r == 0 ?           \\\n    ( c == 0 ? s(x,0) \\\n    : c == 1 ? s(x,1) \\\n    : c == 2 ? s(x,2) \\\n    : c == 3 ? s(x,3) \\\n    : c == 4 ? s(x,4) \\\n    : c == 5 ? s(x,5) \\\n    : c == 6 ? s(x,6) \\\n    :          s(x,7))\\\n : r == 1 ?           \\\n    ( c == 0 ? s(x,1) \\\n    : c == 1 ? s(x,2) \\\n    : c == 2 ? s(x,3) \\\n    : c == 3 ? nc == 4 ? s(x,0) : s(x,4) \\\n    : c == 4 ? s(x,5) \\\n    : c == 5 ? nc == 8 ? s(x,6) : s(x,0) \\\n    : c == 6 ? s(x,7) \\\n    :          s(x,0))\\\n : r == 2 ?           \\\n    ( c == 0 ? nc == 8 ? s(x,3) : s(x,2) \\\n    : c == 1 ? nc == 8 ? s(x,4) : s(x,3) \\\n    : c == 2 ? nc == 4 ? s(x,0) : nc == 8 ? s(x,5) : s(x,4) \\\n    : c == 3 ? nc == 4 ? s(x,1) : nc == 8 ? s(x,6) : s(x,5) \\\n    : c == 4 ? nc == 8 ? s(x,7) : s(x,0) \\\n    : c == 5 ? nc == 8 ? s(x,0) : s(x,1) \\\n    : c == 6 ? s(x,1) \\\n    :          s(x,2))\\\n :                    \\\n    ( c == 0 ? nc == 8 ? s(x,4) : s(x,3) \\\n    : c == 1 ? nc == 4 ? s(x,0) : nc == 8 ? s(x,5) : s(x,4) \\\n    : c == 2 ? nc == 4 ? s(x,1) : nc == 8 ? s(x,6) : s(x,5) \\\n    : c == 3 ? nc == 4 ? s(x,2) : nc == 8 ? s(x,7) : s(x,0) \\\n    : c == 4 ? nc == 8 ? s(x,0) : s(x,1) \\\n    : c == 5 ? nc == 8 ? s(x,1) : s(x,2) \\\n    : c == 6 ? s(x,2) \\\n    :          s(x,3)))\n\n#if defined(FT4_SET)\n#undef  dec_fmvars\n#define dec_fmvars\n#define fwd_rnd(y,x,k,c)    s(y,c)= (k)[c] ^ four_tables(x,ft_tab,fwd_var,rf1,c)\n#elif defined(FT1_SET)\n#undef  dec_fmvars\n#define dec_fmvars\n#define fwd_rnd(y,x,k,c)    s(y,c)= (k)[c] ^ one_table(x,upr,ft_tab,fwd_var,rf1,c)\n#else\n#define fwd_rnd(y,x,k,c)    s(y,c) = fwd_mcol(no_table(x,s_box,fwd_var,rf1,c)) ^ (k)[c]\n#endif\n\n#if defined(FL4_SET)\n#define fwd_lrnd(y,x,k,c)   s(y,c)= (k)[c] ^ four_tables(x,fl_tab,fwd_var,rf1,c)\n#elif defined(FL1_SET)\n#define fwd_lrnd(y,x,k,c)   s(y,c)= (k)[c] ^ one_table(x,ups,fl_tab,fwd_var,rf1,c)\n#else\n#define fwd_lrnd(y,x,k,c)   s(y,c) = no_table(x,s_box,fwd_var,rf1,c) ^ (k)[c]\n#endif\n\naes_rval aes_enc_blk(const unsigned char in_blk[], unsigned char out_blk[], const aes_ctx cx[1])\n{   aes_32t        locals(b0, b1);\n    const aes_32t  *kp = cx->k_sch;\n    dec_fmvars  /* declare variables for fwd_mcol() if needed */\n\n    if(!(cx->n_blk & 1)) return aes_bad;\n\n    state_in(b0, in_blk, kp);\n\n#if (ENC_UNROLL == FULL)\n\n    kp += (cx->n_rnd - 9) * nc;\n\n    switch(cx->n_rnd)\n    {\n    case 14:    round(fwd_rnd,  b1, b0, kp - 4 * nc);\n                round(fwd_rnd,  b0, b1, kp - 3 * nc);\n    case 12:    round(fwd_rnd,  b1, b0, kp - 2 * nc);\n                round(fwd_rnd,  b0, b1, kp -     nc);\n    case 10:    round(fwd_rnd,  b1, b0, kp         );\n                round(fwd_rnd,  b0, b1, kp +     nc);\n                round(fwd_rnd,  b1, b0, kp + 2 * nc);\n                round(fwd_rnd,  b0, b1, kp + 3 * nc);\n                round(fwd_rnd,  b1, b0, kp + 4 * nc);\n                round(fwd_rnd,  b0, b1, kp + 5 * nc);\n                round(fwd_rnd,  b1, b0, kp + 6 * nc);\n                round(fwd_rnd,  b0, b1, kp + 7 * nc);\n                round(fwd_rnd,  b1, b0, kp + 8 * nc);\n                round(fwd_lrnd, b0, b1, kp + 9 * nc);\n    }\n#else\n\n#if (ENC_UNROLL == PARTIAL)\n    {   aes_32t    rnd;\n        for(rnd = 0; rnd < (cx->n_rnd >> 1) - 1; ++rnd)\n        {\n            kp += nc;\n            round(fwd_rnd, b1, b0, kp);\n            kp += nc;\n            round(fwd_rnd, b0, b1, kp);\n        }\n        kp += nc;\n        round(fwd_rnd,  b1, b0, kp);\n#else\n    {   aes_32t    rnd, *p0 = b0, *p1 = b1, *pt;\n        for(rnd = 0; rnd < cx->n_rnd - 1; ++rnd)\n        {\n            kp += nc;\n            round(fwd_rnd, p1, p0, kp);\n            pt = p0, p0 = p1, p1 = pt;\n        }\n#endif\n        kp += nc;\n        round(fwd_lrnd, b0, b1, kp);\n    }\n#endif\n\n    state_out(out_blk, b0);\n    return aes_good;\n}\n\n#endif\n\n#if defined(DECRYPTION)\n\n#define inv_var(x,r,c) \\\n ( r == 0 ?           \\\n    ( c == 0 ? s(x,0) \\\n    : c == 1 ? s(x,1) \\\n    : c == 2 ? s(x,2) \\\n    : c == 3 ? s(x,3) \\\n    : c == 4 ? s(x,4) \\\n    : c == 5 ? s(x,5) \\\n    : c == 6 ? s(x,6) \\\n    :          s(x,7))\\\n : r == 1 ?           \\\n    ( c == 0 ? nc == 4 ? s(x,3) : nc == 8 ? s(x,7) : s(x,5) \\\n    : c == 1 ? s(x,0) \\\n    : c == 2 ? s(x,1) \\\n    : c == 3 ? s(x,2) \\\n    : c == 4 ? s(x,3) \\\n    : c == 5 ? s(x,4) \\\n    : c == 6 ? s(x,5) \\\n    :          s(x,6))\\\n : r == 2 ?           \\\n    ( c == 0 ? nc == 4 ? s(x,2) : nc == 8 ? s(x,5) : s(x,4) \\\n    : c == 1 ? nc == 4 ? s(x,3) : nc == 8 ? s(x,6) : s(x,5) \\\n    : c == 2 ? nc == 8 ? s(x,7) : s(x,0) \\\n    : c == 3 ? nc == 8 ? s(x,0) : s(x,1) \\\n    : c == 4 ? nc == 8 ? s(x,1) : s(x,2) \\\n    : c == 5 ? nc == 8 ? s(x,2) : s(x,3) \\\n    : c == 6 ? s(x,3) \\\n    :          s(x,4))\\\n :                    \\\n    ( c == 0 ? nc == 4 ? s(x,1) : nc == 8 ? s(x,4) : s(x,3) \\\n    : c == 1 ? nc == 4 ? s(x,2) : nc == 8 ? s(x,5) : s(x,4) \\\n    : c == 2 ? nc == 4 ? s(x,3) : nc == 8 ? s(x,6) : s(x,5) \\\n    : c == 3 ? nc == 8 ? s(x,7) : s(x,0) \\\n    : c == 4 ? nc == 8 ? s(x,0) : s(x,1) \\\n    : c == 5 ? nc == 8 ? s(x,1) : s(x,2) \\\n    : c == 6 ? s(x,2) \\\n    :          s(x,3)))\n\n#if defined(IT4_SET)\n#undef  dec_imvars\n#define dec_imvars\n#define inv_rnd(y,x,k,c)    s(y,c)= (k)[c] ^ four_tables(x,it_tab,inv_var,rf1,c)\n#elif defined(IT1_SET)\n#undef  dec_imvars\n#define dec_imvars\n#define inv_rnd(y,x,k,c)    s(y,c)= (k)[c] ^ one_table(x,upr,it_tab,inv_var,rf1,c)\n#else\n#define inv_rnd(y,x,k,c)    s(y,c) = inv_mcol(no_table(x,inv_s_box,inv_var,rf1,c) ^ (k)[c])\n#endif\n\n#if defined(IL4_SET)\n#define inv_lrnd(y,x,k,c)   s(y,c)= (k)[c] ^ four_tables(x,il_tab,inv_var,rf1,c)\n#elif defined(IL1_SET)\n#define inv_lrnd(y,x,k,c)   s(y,c)= (k)[c] ^ one_table(x,ups,il_tab,inv_var,rf1,c)\n#else\n#define inv_lrnd(y,x,k,c)   s(y,c) = no_table(x,inv_s_box,inv_var,rf1,c) ^ (k)[c]\n#endif\n\naes_rval aes_dec_blk(const unsigned char in_blk[], unsigned char out_blk[], const aes_ctx cx[1])\n{   aes_32t        locals(b0, b1);\n    const aes_32t  *kp = cx->k_sch + nc * cx->n_rnd;\n    dec_imvars  /* declare variables for inv_mcol() if needed */\n\n    if(!(cx->n_blk & 2)) return aes_bad;\n\n    state_in(b0, in_blk, kp);\n\n#if (DEC_UNROLL == FULL)\n\n    kp = cx->k_sch + 9 * nc;\n    switch(cx->n_rnd)\n    {\n    case 14:    round(inv_rnd,  b1, b0, kp + 4 * nc);\n                round(inv_rnd,  b0, b1, kp + 3 * nc);\n    case 12:    round(inv_rnd,  b1, b0, kp + 2 * nc);\n                round(inv_rnd,  b0, b1, kp + nc    );\n    case 10:    round(inv_rnd,  b1, b0, kp         );\n                round(inv_rnd,  b0, b1, kp -     nc);\n                round(inv_rnd,  b1, b0, kp - 2 * nc);\n                round(inv_rnd,  b0, b1, kp - 3 * nc);\n                round(inv_rnd,  b1, b0, kp - 4 * nc);\n                round(inv_rnd,  b0, b1, kp - 5 * nc);\n                round(inv_rnd,  b1, b0, kp - 6 * nc);\n                round(inv_rnd,  b0, b1, kp - 7 * nc);\n                round(inv_rnd,  b1, b0, kp - 8 * nc);\n                round(inv_lrnd, b0, b1, kp - 9 * nc);\n    }\n#else\n\n#if (DEC_UNROLL == PARTIAL)\n    {   aes_32t    rnd;\n        for(rnd = 0; rnd < (cx->n_rnd >> 1) - 1; ++rnd)\n        {\n            kp -= nc;\n            round(inv_rnd, b1, b0, kp);\n            kp -= nc;\n            round(inv_rnd, b0, b1, kp);\n        }\n        kp -= nc;\n        round(inv_rnd, b1, b0, kp);\n#else\n    {   aes_32t    rnd, *p0 = b0, *p1 = b1, *pt;\n        for(rnd = 0; rnd < cx->n_rnd - 1; ++rnd)\n        {\n            kp -= nc;\n            round(inv_rnd, p1, p0, kp);\n            pt = p0, p0 = p1, p1 = pt;\n        }\n#endif\n        kp -= nc;\n        round(inv_lrnd, b0, b1, kp);\n    }\n#endif\n\n    state_out(out_blk, b0);\n    return aes_good;\n}\n\n#endif\n\n} // namespace Enchilada256v1_raw\n"
        },
        {
            "file_name": "encrypt copy 2.c",
            "content": "#include \"api.h\"\n#include \"endian.h\"\n#include \"permutations.h\"\n\n#define RATE (64 / 8)\n#define PA_ROUNDS 12\n#define PB_ROUNDS 6\n#define IV                                                        \\\n  ((u64)(8 * (CRYPTO_KEYBYTES)) << 56 | (u64)(8 * (RATE)) << 48 | \\\n   (u64)(PA_ROUNDS) << 40 | (u64)(PB_ROUNDS) << 32)\n\nint crypto_aead_encrypt(unsigned char* c, unsigned long long* clen,\n                        const unsigned char* m, unsigned long long mlen,\n                        const unsigned char* ad, unsigned long long adlen,\n                        const unsigned char* nsec, const unsigned char* npub,\n                        const unsigned char* k) {\n  const u64 K0 = U64BIG(*(u64*)k);\n  const u64 K1 = U64BIG(*(u64*)(k + 8));\n  const u64 N0 = U64BIG(*(u64*)npub);\n  const u64 N1 = U64BIG(*(u64*)(npub + 8));\n  state s;\n  u64 i;\n  (void)nsec;\n\n  // set ciphertext size\n  *clen = mlen + CRYPTO_ABYTES;\n\n  // initialization\n  s.x0 = IV;\n  s.x1 = K0;\n  s.x2 = K1;\n  s.x3 = N0;\n  s.x4 = N1;\n  P12();\n  s.x3 ^= K0;\n  s.x4 ^= K1;\n\n  // process associated data\n  if (adlen) {\n    while (adlen >= RATE) {\n      s.x0 ^= U64BIG(*(u64*)ad);\n      P6();\n      adlen -= RATE;\n      ad += RATE;\n    }\n    for (i = 0; i < adlen; ++i, ++ad) s.x0 ^= INS_BYTE64(*ad, i);\n    s.x0 ^= INS_BYTE64(0x80, adlen);\n    P6();\n  }\n  s.x4 ^= 1;\n\n  // process plaintext\n  while (mlen >= RATE) {\n    s.x0 ^= U64BIG(*(u64*)m);\n    *(u64*)c = U64BIG(s.x0);\n    P6();\n    mlen -= RATE;\n    m += RATE;\n    c += RATE;\n  }\n  for (i = 0; i < mlen; ++i, ++m, ++c) {\n    s.x0 ^= INS_BYTE64(*m, i);\n    *c = EXT_BYTE64(s.x0, i);\n  }\n  s.x0 ^= INS_BYTE64(0x80, mlen);\n\n  // finalization\n  s.x1 ^= K0;\n  s.x2 ^= K1;\n  P12();\n  s.x3 ^= K0;\n  s.x4 ^= K1;\n\n  // set tag\n  *(u64*)c = U64BIG(s.x3);\n  *(u64*)(c + 8) = U64BIG(s.x4);\n\n  return 0;\n}\n\n"
        },
        {
            "file_name": "encrypt copy 3.c",
            "content": "#include \"crypto_aead.h\"\n\n#include \"drysponge.h\"\n\n/**\ngenerating a ciphertext c[0],c[1],...,c[*clen-1]\nfrom a plaintext m[0],m[1],...,m[mlen-1]\nand associated data ad[0],ad[1],...,ad[adlen-1]\nand nonce npub[0],npub[1],...\nand secret key k[0],k[1],...\nthe implementation shall not use nsec\n*/\nint crypto_aead_encrypt(\n    unsigned char *c,unsigned long long *clen,\n    const unsigned char *m,unsigned long long mlen,\n    const unsigned char *ad,unsigned long long adlen,\n    const unsigned char *nsec,\n    const unsigned char *npub,\n    const unsigned char *k\n){\n    (void) nsec; //avoid warning\n    (void) DRYSPONGE_hash; //avoid warning\n    size_t impl_clen;\n    DRYSPONGE_enc(k,DRYSPONGE_KEYSIZE,npub,m,mlen,ad,adlen,c,&impl_clen);\n    *clen = impl_clen;\n    return 0;\n}\n\n/**\nthe code for the AEAD implementation goes here,\ngenerating a plaintext m[0],m[1],...,m[*mlen-1]\nand secret message number nsec[0],nsec[1],...\nfrom a ciphertext c[0],c[1],...,c[clen-1]\nand associated data ad[0],ad[1],...,ad[adlen-1]\nand nonce number npub[0],npub[1],...\nand secret key k[0],k[1],...\n*/\nint crypto_aead_decrypt(\n    unsigned char *m,unsigned long long *mlen,\n    unsigned char *nsec,\n    const unsigned char *c,unsigned long long clen,\n    const unsigned char *ad,unsigned long long adlen,\n    const unsigned char *npub,\n    const unsigned char *k\n){\n    (void) nsec; //avoid warning\n    if(DRYSPONGE_PASS!=DRYSPONGE_dec(k,DRYSPONGE_KEYSIZE,npub,c,clen,ad,adlen,m))\n        return -1;\n    *mlen = clen - DRYSPONGE_TAGSIZE;\n    return 0;\n}\n"
        },
        {
            "file_name": "encrypt copy.c",
            "content": "#include \"crypto_aead.h\"\n#include <string.h>\n#include <stdio.h>\n\n#ifdef _MSC_VER\n#define inline __inline\n#endif\n\n#define n1 5\n#define n2 31\n#define n3 7\n#define n4 22\n#define n5 13\n\ninline void morus_stateupdate(unsigned int msgblk[], unsigned int state[][4])\n{\n        unsigned int temp;\n\n        state[0][0] ^= state[3][0]; state[0][1] ^= state[3][1]; state[0][2] ^= state[3][2]; state[0][3] ^= state[3][3];\n        state[0][0] ^= state[1][0] & state[2][0]; state[0][1] ^= state[1][1] & state[2][1]; state[0][2] ^= state[1][2] & state[2][2]; state[0][3] ^= state[1][3] & state[2][3];\n        state[0][0] = rotl(state[0][0],n1);  state[0][1] = rotl(state[0][1],n1);       state[0][2] = rotl(state[0][2],n1);       state[0][3] = rotl(state[0][3],n1);\n        temp = state[3][3];    state[3][3] = state[3][2];  state[3][2] = state[3][1];  state[3][1] = state[3][0];  state[3][0] = temp;\n\n        state[1][0] ^= msgblk[0];   state[1][1] ^= msgblk[1];   state[1][2] ^= msgblk[2];   state[1][3] ^= msgblk[3];\n        state[1][0] ^= state[4][0]; state[1][1] ^= state[4][1]; state[1][2] ^= state[4][2]; state[1][3] ^= state[4][3];\n        state[1][0] ^= (state[2][0] & state[3][0]); state[1][1] ^= (state[2][1] & state[3][1]); state[1][2] ^= (state[2][2] & state[3][2]); state[1][3] ^= (state[2][3] & state[3][3]);\n        state[1][0] = rotl(state[1][0],n2);  state[1][1] = rotl(state[1][1],n2);       state[1][2] = rotl(state[1][2],n2);       state[1][3] = rotl(state[1][3],n2);\n        temp = state[4][3];    state[4][3] = state[4][1];  state[4][1] = temp;\n        temp = state[4][2];    state[4][2] = state[4][0];  state[4][0] = temp;\n\n        state[2][0] ^= msgblk[0];   state[2][1] ^= msgblk[1];   state[2][2] ^= msgblk[2];   state[2][3] ^= msgblk[3];\n        state[2][0] ^= state[0][0]; state[2][1] ^= state[0][1]; state[2][2] ^= state[0][2]; state[2][3] ^= state[0][3];\n        state[2][0] ^= state[3][0] & state[4][0]; state[2][1] ^= state[3][1] & state[4][1]; state[2][2] ^= state[3][2] & state[4][2]; state[2][3] ^= state[3][3] & state[4][3];\n        state[2][0] = rotl(state[2][0],n3);  state[2][1] = rotl(state[2][1],n3);       state[2][2] = rotl(state[2][2],n3);       state[2][3] = rotl(state[2][3],n3);\n        temp = state[0][0];    state[0][0] = state[0][1];  state[0][1] = state[0][2];  state[0][2] = state[0][3];  state[0][3] = temp;\n\n        state[3][0] ^= msgblk[0];   state[3][1] ^= msgblk[1];   state[3][2] ^= msgblk[2];   state[3][3] ^= msgblk[3];\n        state[3][0] ^= state[1][0]; state[3][1] ^= state[1][1]; state[3][2] ^= state[1][2]; state[3][3] ^= state[1][3];\n        state[3][0] ^= state[4][0] & state[0][0]; state[3][1] ^= state[4][1] & state[0][1]; state[3][2] ^= state[4][2] & state[0][2]; state[3][3] ^= state[4][3] & state[0][3];\n        state[3][0] = rotl(state[3][0],n4);  state[3][1] = rotl(state[3][1],n4);       state[3][2] = rotl(state[3][2],n4);       state[3][3] = rotl(state[3][3],n4);\n        temp = state[1][3];    state[1][3] = state[1][1];  state[1][1] = temp;\n        temp = state[1][2];    state[1][2] = state[1][0];  state[1][0] = temp;\n\n        state[4][0] ^= msgblk[0];   state[4][1] ^= msgblk[1];   state[4][2] ^= msgblk[2];   state[4][3] ^= msgblk[3];\n        state[4][0] ^= state[2][0]; state[4][1] ^= state[2][1]; state[4][2] ^= state[2][2]; state[4][3] ^= state[2][3];\n        state[4][0] ^= state[0][0] & state[1][0]; state[4][1] ^= state[0][1] & state[1][1]; state[4][2] ^= state[0][2] & state[1][2]; state[4][3] ^= state[0][3] & state[1][3];\n        state[4][0] = rotl(state[4][0],n5);  state[4][1] = rotl(state[4][1],n5);       state[4][2] = rotl(state[4][2],n5);       state[4][3] = rotl(state[4][3],n5);\n        temp = state[2][3];    state[2][3] = state[2][2];  state[2][2] = state[2][1];  state[2][1] = state[2][0];  state[2][0] = temp;\n}\n\n/*The input to the initialization is the 128-bit key; 128-bit IV;*/\nvoid morus_initialization(const unsigned char *key, const unsigned char *iv, unsigned int state[][4])\n{\n        int i;\n        unsigned int temp[4]  = {0,0,0,0};\n        unsigned char con0[16] = {0x0,0x1,0x01,0x02,0x03,0x05,0x08,0x0d,0x15,0x22,0x37,0x59,0x90,0xe9,0x79,0x62};\n\tunsigned char con1[16] = {0xdb, 0x3d, 0x18, 0x55, 0x6d, 0xc2, 0x2f, 0xf1, 0x20, 0x11, 0x31, 0x42, 0x73, 0xb5, 0x28, 0xdd};\n\n\tmemcpy(state[0], iv,   16);\n        memcpy(state[1], key,  16);\n        memset(state[2], 0xff, 16);\n        memcpy(state[3], con0, 16);\n        memcpy(state[4], con1, 16);\n\n        for (i = 0; i < 4;  i++) temp[i] = 0;\n        for (i = 0; i < 16; i++) morus_stateupdate(temp, state);\n        for (i = 0; i < 4;  i++) state[1][i] ^= ((unsigned int*)key)[i];\n}\n\n//the finalization state of MORUS\nvoid morus_tag_generation(unsigned long long msglen, unsigned long long adlen, unsigned char *c, unsigned int state[][4])\n{\n        int i,j;\n        unsigned char t[16];\n\n        memcpy(t, state[3], 16);\n\n        ((unsigned long long*)t)[0] ^= (adlen << 3);\n        ((unsigned long long*)t)[1] ^= (msglen << 3);\n\n\tstate[4][0] ^= state[0][0]; state[4][1] ^= state[0][1]; state[4][2] ^= state[0][2]; state[4][3] ^= state[0][3];\n\n        for (i = 0; i < 8; i++) morus_stateupdate((unsigned int*)t, state);\n\n        for (i = 2; i < 5; i++) {\n        for (j = 0; j < 4; j++) {\n            state[1][j] ^= state[i][j];\n        }}\n\t//in this program, the mac length is assumed to be a multiple of bytes\n\tmemcpy(c+msglen, state[1], 16);\n}\n\nint morus_tag_verification(unsigned long long msglen, unsigned long long adlen, const unsigned char *c, unsigned int state[][4])\n{\n\tint i,j;\n\tunsigned char t[16];\n\tint check = 0;\n\n\tmemcpy(t, state[3], 16);\n\n\t((unsigned long long*)t)[0] ^= adlen << 3;\n\t((unsigned long long*)t)[1] ^= msglen << 3;\n\n\tstate[4][0] ^= state[0][0]; state[4][1] ^= state[0][1]; state[4][2] ^= state[0][2]; state[4][3] ^= state[0][3];\n\n        for (i = 0; i < 8; i++) morus_stateupdate((unsigned int*)t, state);\n\n        for (i = 2; i < 5; i++) {\n        for (j = 0; j < 4; j++) {\n             state[1][j] ^= state[i][j];\n        }}\n\t//in this program, the mac length is assumed to be a multiple of bytes\n\tfor (i = 0; i < 16; i++)  check |= (c[msglen+i] ^ ((unsigned char *)state[1])[i]);\n\tif (check == 0) return 0;\n        else return -1;\n}\n\n// one step of encryption: it encrypts a 16-byte block\ninline void morus_enc_aut_step(const unsigned char *plaintextblock, unsigned char *ciphertextblock, unsigned int state[][4])\n{\n\n        //encryption\n        ((unsigned int*)ciphertextblock)[0] = ((unsigned int*)plaintextblock)[0] ^ state[0][0] ^ state[1][1] ^ (state[2][0] & state[3][0]);\n        ((unsigned int*)ciphertextblock)[1] = ((unsigned int*)plaintextblock)[1] ^ state[0][1] ^ state[1][2] ^ (state[2][1] & state[3][1]);\n        ((unsigned int*)ciphertextblock)[2] = ((unsigned int*)plaintextblock)[2] ^ state[0][2] ^ state[1][3] ^ (state[2][2] & state[3][2]);\n        ((unsigned int*)ciphertextblock)[3] = ((unsigned int*)plaintextblock)[3] ^ state[0][3] ^ state[1][0] ^ (state[2][3] & state[3][3]);\n\n        morus_stateupdate(((unsigned int*)plaintextblock), state);\n}\n\n\n// one step of decryption: it decrypts a 16-byte block\ninline void morus_dec_aut_step(unsigned char *plaintextblock, const unsigned char *ciphertextblock, unsigned int state[][4])\n{\n        //decryption\n        ((unsigned int*)plaintextblock)[0] = ((unsigned int*)ciphertextblock)[0] ^ state[0][0] ^ state[1][1] ^ (state[2][0] & state[3][0]);\n        ((unsigned int*)plaintextblock)[1] = ((unsigned int*)ciphertextblock)[1] ^ state[0][1] ^ state[1][2] ^ (state[2][1] & state[3][1]);\n        ((unsigned int*)plaintextblock)[2] = ((unsigned int*)ciphertextblock)[2] ^ state[0][2] ^ state[1][3] ^ (state[2][2] & state[3][2]);\n        ((unsigned int*)plaintextblock)[3] = ((unsigned int*)ciphertextblock)[3] ^ state[0][3] ^ state[1][0] ^ (state[2][3] & state[3][3]);\n\n        morus_stateupdate(((unsigned int*)plaintextblock), state);\n}\n\n\n// encrypt a partial block\nvoid morus_enc_aut_partialblock(const unsigned char *plaintext, unsigned char *ciphertext, unsigned long long len, unsigned int state[][4])\n{\n        unsigned char plaintextblock[16], ciphertextblock[16];\n\n        memset(plaintextblock, 0, 16);\n        memcpy(plaintextblock, plaintext, len);\n\n        //encryption\n        ((unsigned int*)ciphertextblock)[0] = ((unsigned int*)plaintextblock)[0] ^ state[0][0] ^ state[1][1] ^ (state[2][0] & state[3][0]);\n        ((unsigned int*)ciphertextblock)[1] = ((unsigned int*)plaintextblock)[1] ^ state[0][1] ^ state[1][2] ^ (state[2][1] & state[3][1]);\n        ((unsigned int*)ciphertextblock)[2] = ((unsigned int*)plaintextblock)[2] ^ state[0][2] ^ state[1][3] ^ (state[2][2] & state[3][2]);\n        ((unsigned int*)ciphertextblock)[3] = ((unsigned int*)plaintextblock)[3] ^ state[0][3] ^ state[1][0] ^ (state[2][3] & state[3][3]);\n\n        morus_stateupdate(((unsigned int*)plaintextblock), state);\n\n        memcpy(ciphertext, ciphertextblock, len);\n}\n\n\n// decrypt a partial block\nvoid morus_dec_aut_partialblock(unsigned char *plaintext, const unsigned char *ciphertext, unsigned long long len, unsigned int state[][4])\n{\n        unsigned char plaintextblock[16], ciphertextblock[16];\n\n        memset(ciphertextblock, 0, 16);\n        memcpy(ciphertextblock, ciphertext, len);\n\n        //decryption\n        ((unsigned int*)plaintextblock)[0] = ((unsigned int*)ciphertextblock)[0] ^ state[0][0] ^ state[1][1] ^ (state[2][0] & state[3][0]);\n        ((unsigned int*)plaintextblock)[1] = ((unsigned int*)ciphertextblock)[1] ^ state[0][1] ^ state[1][2] ^ (state[2][1] & state[3][1]);\n        ((unsigned int*)plaintextblock)[2] = ((unsigned int*)ciphertextblock)[2] ^ state[0][2] ^ state[1][3] ^ (state[2][2] & state[3][2]);\n        ((unsigned int*)plaintextblock)[3] = ((unsigned int*)ciphertextblock)[3] ^ state[0][3] ^ state[1][0] ^ (state[2][3] & state[3][3]);\n\n        memcpy(plaintext, plaintextblock, len);\n        memset(plaintextblock, 0, 16);\n        memcpy(plaintextblock, plaintext, len);\n\n        morus_stateupdate(((unsigned int*)plaintextblock), state);\n}\n\n\n\n//encrypt a message\nint crypto_aead_encrypt(\n\tunsigned char *c,unsigned long long *clen,\n\tconst unsigned char *m,unsigned long long mlen,\n\tconst unsigned char *ad,unsigned long long adlen,\n\tconst unsigned char *nsec,\n\tconst unsigned char *npub,\n\tconst unsigned char *k,\n\tint verbose\n\t)\n{\n        unsigned long long i;\n        unsigned char ciphertextblock[16];\n        unsigned int morus_state[5][4];\n\n        //initialization\n        morus_initialization(k, npub, morus_state);\n\n        //process the associated data\n        for (i = 0; (i+16) <= adlen; i += 16) {\n              morus_enc_aut_step(ad+i, ciphertextblock, morus_state);\n        }\n\n        //deal with the partial block of associated data\n        //in this program, we assume that the message length is a multiple of bytes.\n        if (  (adlen & 0xf) != 0 )  {\n              morus_enc_aut_partialblock(ad+i, ciphertextblock, adlen & 0xf, morus_state);\n        }\n\n        if(verbose) {\n          for(int j = 0; j < 5; j++) {\n              printf(\"S0_%d: \", j);\n              for(int ii = 0; ii < 16; ii++) {\n                  printf(\"%02X\", ((unsigned char*)morus_state[j])[ii]);\n              }\n              printf(\"\\n\");\n          }\n          printf(\"\\n\");\n        }\n        //encrypt the plaintext\n        for (i = 0; (i+16) <= mlen; i += 16) {\n              morus_enc_aut_step(m+i, c+i, morus_state);\n              if(verbose) {\n                  for(int j = 0; j < 5; j++) {\n                      printf(\"S%lld_%d: \", (i/16)+1, j);\n                      for(int ii = 0; ii < 16; ii++) {\n                          printf(\"%02X\", ((unsigned char*)morus_state[j])[ii]);\n                      }\n                      printf(\"\\n\");\n                  }\n                  printf(\"\\n\");\n              }\n        }\n\n        // Deal with the partial block\n        // In this program, we assume that the message length is a multiple of bytes.\n        if (  (mlen & 0xf) != 0 )  {\n              morus_enc_aut_partialblock(m+i, c+i, mlen & 0xf, morus_state);\n        }\n\n        //finalization stage, we assume that the tag length is a multiple of bytes\n        morus_tag_generation(mlen,adlen, c, morus_state);\n\t*clen = mlen + 16;\n\n\treturn 0;\n}\n\n\nint crypto_aead_decrypt(\n\tunsigned char *m,unsigned long long *mlen,\n\tunsigned char *nsec,\n\tconst unsigned char *c,unsigned long long clen,\n\tconst unsigned char *ad,unsigned long long adlen,\n\tconst unsigned char *npub,\n\tconst unsigned char *k\n\t)\n{\n        unsigned long i;\n        unsigned char ciphertextblock[16];\n        unsigned int morus_state[5][4];\n\n        if (clen < 16) return -1;\n\n        morus_initialization(k, npub, morus_state);\n\n        //process the associated data\n        for (i = 0; (i+16) <= adlen; i += 16) {\n              morus_enc_aut_step(ad+i, ciphertextblock, morus_state);\n        }\n\n        // deal with the partial block of associated data\n        // in this program, we assume that the message length is a multiple of bytes.\n        if (  (adlen & 0xf) != 0 ) {\n              morus_enc_aut_partialblock(ad+i, ciphertextblock, adlen & 0xf, morus_state);\n        }\n\n        // decrypt the ciphertext\n\t*mlen = clen - 16;\n        for (i = 0; (i+16) <= *mlen; i += 16) {\n              morus_dec_aut_step(m+i, c+i, morus_state);\n        }\n\n        // Deal with the partial block\n        // In this program, we assume that the message length is a multiple of bytes.\n        if (  ((*mlen) & 0xf) != 0 )  {\n              morus_dec_aut_partialblock(m+i, c+i, (*mlen) & 0xf, morus_state);\n        }\n\n        //we assume that the tag length is a multiple of bytes\n        //verification\n        return morus_tag_verification(*mlen, adlen, c, morus_state);\n}\n"
        },
        {
            "file_name": "encrypt.c",
            "content": "#include <string.h>\n#include <stdio.h>\n#include \"crypto_aead.h\"\n\n#ifdef _MSC_VER\n#define inline __inline\n#endif\n\n\nvoid aegis128_print_state(unsigned char *state, int i) {\n  unsigned long long* state_ull = (unsigned long long*) state;\n  printf(\"%d: \\n\"\n         \"  %016llX%016llX\\n\"\n         \"  %016llX%016llX\\n\"\n         \"  %016llX%016llX\\n\"\n         \"  %016llX%016llX\\n\"\n         \"  %016llX%016llX\\n\\n\", i, state_ull[0], state_ull[1],\n       state_ull[2], state_ull[3], state_ull[4], state_ull[5],\n       state_ull[6], state_ull[7], state_ull[8], state_ull[9]);\n}\n\n\n// The initialization state of AEGIS\n/*The input to initialization is the 128-bit key; 128-bit IV;*/\nvoid aegis128_initialization(const unsigned char *key, const unsigned char *iv, unsigned char *state)\n{\n        int i;\n        unsigned char constant[32] = {0x0,0x1,0x01,0x02,0x03,0x05,0x08,0x0d,0x15,0x22,0x37,0x59,0x90,0xe9,0x79,0x62,0xdb,0x3d,0x18,0x55,0x6d,0xc2,0x2f,0xf1,0x20,0x11,0x31,0x42,0x73,0xb5,0x28,0xdd};\n\n        unsigned char tmp[16];\n        unsigned char keytmp[16];\n        unsigned char ivtmp[16];\n\n        memcpy(keytmp, key, 16);\n        memcpy(ivtmp, iv, 16);\n\n        memcpy(state, ivtmp, 16);\n        memcpy(state+16, constant+16, 16);\n        memcpy(state+32, constant+0,  16);\n\n        XOR128(state+48, keytmp,  constant);\n        XOR128(state+64, keytmp,  constant + 16);\n        XOR128(state,    state,   keytmp);\n        XOR128(keytmp,   keytmp,  ivtmp);\n\n        for (i = 0; i < 10; i++)  {\n             //state update function\n             memcpy(tmp, state+64, 16);\n             AESROUND(state+64, state+48, state+64);\n             AESROUND(state+48, state+32, state+48);\n             AESROUND(state+32, state+16, state+32);\n             AESROUND(state+16, state+0,  state+16);\n             AESROUND(state+0,  tmp,      state+0);\n\n             //xor msg with state[0]\n             XOR128(keytmp, keytmp, ivtmp);\n             XOR128(state,  state,  keytmp);\n        }\n}\n\n\n//the finalization state of AEGIS\nvoid aegis128_tag_generation(unsigned long long msglen, unsigned long long adlen, unsigned char maclen, unsigned char *mac, unsigned char *state)\n{\n       int i;\n\n        unsigned char tmp[16];\n        unsigned char msgtmp[16];\n\n        ((unsigned long long*)msgtmp)[0] = adlen << 3;\n        ((unsigned long long*)msgtmp)[1] = msglen << 3;\n\n        XOR128(msgtmp, msgtmp, state+48);\n\n        for (i = 0; i < 7; i++) {\n             //state update function\n             memcpy(tmp, state+64, 16);\n\n             AESROUND(state+64, state+48, state+64);\n             AESROUND(state+48, state+32, state+48);\n             AESROUND(state+32, state+16, state+32);\n             AESROUND(state+16, state+0,  state+16);\n             AESROUND(state+0,  tmp,      state+0);\n\n             //xor \"msg\" with state[0]\n             XOR128(state, state, msgtmp);\n        }\n\n        XOR128(state+64, state+64, state+48);\n        XOR128(state+64, state+64, state+32);\n        XOR128(state+64, state+64, state+16);\n        XOR128(state+64, state+64, state+0);\n\n        //in this program, the mac length is assumed to be multiple of bytes\n        memcpy(mac, state+64, maclen);\n}\n\n// one step of encryption\ninline void aegis128_enc_aut_step(const unsigned char *plaintextblk,\n       unsigned char *ciphertextblk, unsigned char *state)\n{\n\n        unsigned char tmp[16];\n\n        AND128(ciphertextblk, state+32, state+48);\n        XOR128(ciphertextblk, ciphertextblk, state+16);\n        XOR128(ciphertextblk, ciphertextblk, state+64);\n        XOR128(ciphertextblk, ciphertextblk, plaintextblk);\n\n        //state update function\n        memcpy(tmp, state+64, 16);\n\n        AESROUND(state+64, state+48, state+64);\n        AESROUND(state+48, state+32, state+48);\n        AESROUND(state+32, state+16, state+32);\n        AESROUND(state+16, state+0,  state+16);\n        AESROUND(state+0,  tmp,      state+0);\n\n        //message is used to update the state.\n        XOR128(state, state, plaintextblk);\n}\n\n\n//one step of decryption\ninline void aegis128_dec_aut_step(unsigned char *plaintextblk,\n       const unsigned char *ciphertextblk, unsigned char *state)\n{\n         unsigned char tmp[16];\n\n        AND128(plaintextblk, state+32, state+48);\n        XOR128(plaintextblk, plaintextblk, state+16);\n        XOR128(plaintextblk, plaintextblk, state+64);\n        XOR128(plaintextblk, plaintextblk, ciphertextblk);\n\n        //state update function\n        memcpy(tmp, state+64, 16);\n\n        AESROUND(state+64, state+48, state+64);\n        AESROUND(state+48, state+32, state+48);\n        AESROUND(state+32, state+16, state+32);\n        AESROUND(state+16, state+0,  state+16);\n        AESROUND(state+0,  tmp,      state+0);\n\n        //message is used to update the state.\n        XOR128(state, state, plaintextblk);\n}\n\n//encrypt a message.\nint crypto_aead_encrypt(\n\tunsigned char *c,unsigned long long *clen,\n\tconst unsigned char *m,unsigned long long mlen,\n\tconst unsigned char *ad,unsigned long long adlen,\n\tconst unsigned char *nsec,\n\tconst unsigned char *npub,\n\tconst unsigned char *k, int verbose\n\t)\n{\n        unsigned long i;\n        unsigned char plaintextblock[16], ciphertextblock[16], mac[16];\n        unsigned char aegis128_state[80];\n\n        //initialization stage\n        aegis128_initialization(k, npub, aegis128_state);\n\n        //process the associated data\n        for (i = 0; (i+16) <= adlen; i += 16) {\n              aegis128_enc_aut_step(ad+i, ciphertextblock, aegis128_state);\n        }\n\n        //deal with the partial block of associated data\n        //in this program, we assume that the message length is multiple of bytes.\n        if (  (adlen & 0xf) != 0 )  {\n              memset(plaintextblock, 0, 16);\n              memcpy(plaintextblock, ad+i, adlen & 0xf);\n              aegis128_enc_aut_step(plaintextblock, ciphertextblock, aegis128_state);\n        }\n\n\n        //encrypt the plaintext\n        for (i = 0; (i+16) <= mlen; i += 16) {\n              if(verbose) aegis128_print_state(aegis128_state, i/16);\n              aegis128_enc_aut_step(m+i, c+i, aegis128_state);\n        }\n\n        // Deal with the partial block\n        // In this program, we assume that the message length is multiple of bytes.\n        if (  (mlen & 0xf) != 0 )  {\n              memset(plaintextblock, 0, 16);\n              memcpy(plaintextblock, m+i, mlen & 0xf);\n              aegis128_enc_aut_step(plaintextblock, ciphertextblock, aegis128_state);\n              memcpy(c+i,ciphertextblock, mlen & 0xf);\n        }\n\n        //finalization stage, we assume that the tag length is a multiple of bytes\n        aegis128_tag_generation(mlen, adlen, 16, mac, aegis128_state);\n        *clen = mlen + 16;\n        memcpy(c+mlen, mac, 16);\n\n        return 0;\n}\n\n\nint crypto_aead_decrypt(\n\tunsigned char *m,unsigned long long *mlen,\n\tunsigned char *nsec,\n\tconst unsigned char *c,unsigned long long clen,\n\tconst unsigned char *ad,unsigned long long adlen,\n\tconst unsigned char *npub,\n\tconst unsigned char *k\n\t)\n{\n        unsigned long i;\n        unsigned char plaintextblock[16], ciphertextblock[16];\n        unsigned char tag[16];\n        unsigned char check = 0;\n        unsigned char aegis128_state[80];\n\n        if (clen < 16) return -1;\n\n        aegis128_initialization(k, npub, aegis128_state);\n\n        //process the associated data\n        for (i = 0; (i+16) <= adlen; i += 16) {\n              aegis128_enc_aut_step(ad+i, ciphertextblock, aegis128_state);\n        }\n\n        //deal with the partial block of associated data\n        //in this program, we assume that the message length is multiple of bytes.\n        if (  (adlen & 0xf) != 0 )  {\n              memset(plaintextblock, 0, 16);\n              memcpy(plaintextblock, ad+i, adlen & 0xf);\n              aegis128_enc_aut_step(plaintextblock, ciphertextblock, aegis128_state);\n        }\n\n\n        *mlen = clen - 16;\n\n        //decrypt the ciphertext\n        for (i = 0; (i+16) <= *mlen; i += 16) {\n              aegis128_dec_aut_step(m+i, c+i, aegis128_state);\n        }\n\n        // Deal with the partial block\n        // In this program, we assume that the message length is multiple of bytes.\n        if (  (*mlen & 0xf) != 0  )  {\n              memset(ciphertextblock, 0, 16);\n              memcpy(ciphertextblock, c+i, *mlen & 0xf);\n              aegis128_dec_aut_step(plaintextblock, ciphertextblock, aegis128_state);\n              memcpy(m+i, plaintextblock, *mlen & 0xf);\n\n              //need to modify the state here (because in the last block, keystream is wrongly used to update the state)\n              memset(plaintextblock, 0, *mlen & 0xf);\n              //aegis128_state[0] = _mm_xor_si128( aegis128_state[0], _mm_load_si128((__m128i*)plaintextblock)  ) ;\n              ((unsigned long long*)aegis128_state)[0] ^= ((unsigned long long*)plaintextblock)[0];\n              ((unsigned long long*)aegis128_state)[1] ^= ((unsigned long long*)plaintextblock)[1];\n        }\n\n        //we assume that the tag length is multiple of bytes\n        aegis128_tag_generation(*mlen, adlen, 16, tag, aegis128_state);\n\n        //verification\n        for (i = 0; i  < 16; i++) check |= (tag[i] ^ c[clen - 16 + i]);\n        if (check == 0) return 0;\n        else return -1;\n}\n"
        },
        {
            "file_name": "Encryptor.cpp",
            "content": "#include \"Encryptor.h\"\n#include \"EACglobals.h\"\n#include \"generators/IRndGen.h\"\n\nEncryptor::Encryptor()\n    : m_cipher(CaesarInterface::getCaesarFunction(pCaesarSettings->algorithm,\n                                  pCaesarSettings->limitAlgRounds ? pCaesarSettings->algorithmRoundsCount : -1)),\n      m_key(new bits_t[pCaesarSettings->keyLength]),\n      m_ad(new bits_t[pCaesarSettings->adLength]),\n      m_smn(new bits_t[pCaesarSettings->smnLength]),\n      m_pmn(new bits_t[pCaesarSettings->pmnLength]),\n      m_plaintext(new bits_t[pCaesarSettings->plaintextLength]),\n      // decrypted plaintext is one block bigger, in case the cipher creates a new block by padding\n      m_decryptedPlaintext(new bits_t[pCaesarSettings->plaintextLength+32]),\n      m_decryptedSmn(new bits_t[pCaesarSettings->smnLength]),\n      m_decryptedPlaintextLength(0),\n      m_setup(false) {\n    pCaesarSettings->ciphertextLength = pCaesarSettings->plaintextLength + pCaesarSettings->cipertextOverhead;\n}\n\nEncryptor::~Encryptor() {\n    if (m_cipher) { delete m_cipher; m_cipher = NULL; }\n    if (m_key) { delete[] m_key; m_key = NULL; }\n    if (m_ad) { delete[] m_ad; m_ad = NULL; }\n    if (m_smn) { delete[] m_smn; m_smn = NULL; }\n    if (m_pmn) { delete[] m_pmn; m_pmn = NULL; }\n    if (m_plaintext) { delete[] m_plaintext; m_plaintext = NULL; }\n    if (m_decryptedPlaintext) { delete[] m_decryptedPlaintext; m_decryptedPlaintext = NULL; }\n    if (m_decryptedSmn) { delete[] m_decryptedSmn; m_decryptedSmn = NULL; }\n}\n\nint Encryptor::initArray(bits_t* data, length_t dataLength, int dataType) {\n    switch (dataType) {\n    case CAESAR_TYPE_ZEROS:\n    case CAESAR_TYPE_COUNTER:\n        memset(data, 0, dataLength);\n        break;\n    case CAESAR_TYPE_RANDOM_ONCE:\n    case CAESAR_TYPE_RANDOM:\n        for (length_t i = 0; i < dataLength; i++) { rndGen->getRandomFromInterval(255, &(data[i])); }\n        break;\n    default:\n        mainLogger.out(LOGGER_ERROR) << \"Unknown data type (\" << dataType << \").\" << endl;\n        return STAT_PROJECT_ERROR;\n    }\n    return STAT_OK;\n}\n\nvoid Encryptor::increaseArray(bits_t* data, length_t dataLength) {\n    for (length_t i = 0; i < dataLength; i++) {\n        if (data[i] != UCHAR_MAX) {\n            data[i]++;\n            return;\n        }\n        data[i] = 0;\n    }\n}\n\nint Encryptor::setup() {\n    if (m_cipher == NULL) { return STAT_PROJECT_ERROR; }\n    int status = STAT_OK;\n    status = initArray(m_ad, pCaesarSettings->adLength, pCaesarSettings->adType);\n    if (status != STAT_OK) { return status; }\n    status = initArray(m_key, pCaesarSettings->keyLength, pCaesarSettings->keyType);\n    if (status != STAT_OK) { return status; }\n    status = initArray(m_smn, pCaesarSettings->smnLength, pCaesarSettings->smnType);\n    if (status != STAT_OK) { return status; }\n    status = initArray(m_pmn, pCaesarSettings->pmnLength, pCaesarSettings->pmnType);\n    if (status != STAT_OK) { return status; }\n    status = initArray(m_plaintext, pCaesarSettings->plaintextLength, pCaesarSettings->plaintextType);\n    if (status != STAT_OK) { return status; }\n    m_setup = true;\n    return status;\n}\n\nint Encryptor::update() {\n    // update counters\n    if (pCaesarSettings->adType == CAESAR_TYPE_COUNTER) { increaseArray(m_ad, pCaesarSettings->adLength); }\n    if (pCaesarSettings->keyType == CAESAR_TYPE_COUNTER) { increaseArray(m_key, pCaesarSettings->keyLength); }\n    if (pCaesarSettings->smnType == CAESAR_TYPE_COUNTER) { increaseArray(m_smn, pCaesarSettings->smnLength); }\n    if (pCaesarSettings->pmnType == CAESAR_TYPE_COUNTER) { increaseArray(m_pmn, pCaesarSettings->pmnLength); }\n    if (pCaesarSettings->plaintextType == CAESAR_TYPE_COUNTER) { increaseArray(m_plaintext, pCaesarSettings->adLength); }\n    // update randoms\n    if (pCaesarSettings->adType == CAESAR_TYPE_RANDOM) { initArray(m_ad, pCaesarSettings->adLength, CAESAR_TYPE_RANDOM); }\n    if (pCaesarSettings->keyType == CAESAR_TYPE_RANDOM) { initArray(m_key, pCaesarSettings->keyLength, CAESAR_TYPE_RANDOM); }\n    if (pCaesarSettings->smnType == CAESAR_TYPE_RANDOM) { initArray(m_smn, pCaesarSettings->smnLength, CAESAR_TYPE_RANDOM); }\n    if (pCaesarSettings->pmnType == CAESAR_TYPE_RANDOM) { initArray(m_pmn, pCaesarSettings->pmnLength, CAESAR_TYPE_RANDOM); }\n    if (pCaesarSettings->plaintextType == CAESAR_TYPE_RANDOM) { initArray(m_plaintext, pCaesarSettings->adLength, CAESAR_TYPE_RANDOM); }\n    return STAT_OK;\n}\n\nint Encryptor::encrypt(bits_t *c, length_t *clen) {\n    if (!m_setup) {\n        mainLogger.out(LOGGER_ERROR) << \"Cipher not properly setup!\" << endl;\n        return STAT_PROJECT_ERROR;\n    }\n\n    int encryptionStatus = 0;\n    encryptionStatus = m_cipher->encrypt(c, clen, m_plaintext, pCaesarSettings->plaintextLength,\n                                         m_ad, pCaesarSettings->adLength, m_smn, m_pmn, m_key);\n    if (encryptionStatus != 0) {\n        mainLogger.out(LOGGER_ERROR) << \"Encryption failed (status \" << encryptionStatus << \").\" << endl;\n        return STAT_PROJECT_ERROR;\n    }\n    encryptionStatus = m_cipher->decrypt(m_decryptedPlaintext, &m_decryptedPlaintextLength, m_decryptedSmn,\n                                         c, *clen, m_ad, pCaesarSettings->adLength, m_pmn, m_key);\n    if (encryptionStatus != 0) {\n        mainLogger.out(LOGGER_ERROR) << \"Decryption failed (status \" << encryptionStatus << \").\" << endl;\n        return STAT_PROJECT_ERROR;\n    }\n\n    // save debug information if required\n    if (pGlobals->settings->outputs.verbosity >= LOGGER_VERBOSITY_DEEP_DEBUG) {\n        ofstream tvFile;\n        tvFile.open(FILE_TEST_VECTORS_HR, ios_base::app);\n        if (!tvFile.is_open()) {\n            mainLogger.out(LOGGER_ERROR) << \"Cannot write file for test vectors (\" << FILE_TEST_VECTORS_HR << \").\" << endl;\n            return STAT_FILE_WRITE_FAIL;\n        }\n        tvFile << \"plain:     \";\n        for (length_t byte = 0; byte < pCaesarSettings->plaintextLength; byte++) {\n            tvFile << hex << setfill('0') << setw(2) << (int) m_plaintext[byte];\n        }\n        tvFile << endl << \"key:       \";\n        for (length_t byte = 0; byte < pCaesarSettings->keyLength; byte++) {\n            tvFile << hex << setfill('0') << setw(2) << (int) m_key[byte];\n        }\n        tvFile << endl << \"ad:        \";\n        for (length_t byte = 0; byte < pCaesarSettings->adLength; byte++) {\n            tvFile << hex << setfill('0') << setw(2) << (int) m_ad[byte];\n        }\n        tvFile << endl << \"smn:       \";\n        for (length_t byte = 0; byte < pCaesarSettings->smnLength; byte++) {\n            tvFile << hex << setfill('0') << setw(2) << (int) m_smn[byte];\n        }\n        tvFile << endl << \"pmn:       \";\n        for (length_t byte = 0; byte < pCaesarSettings->pmnLength; byte++) {\n            tvFile << hex << setfill('0') << setw(2) << (int) m_pmn[byte];\n        }\n        tvFile << endl << \"encrypted: \";\n        for (length_t byte = 0; byte < *clen; byte++) {\n            tvFile << hex << setfill('0') << setw(2) << (int) c[byte];\n        }\n        tvFile << endl << \"decrypted: \";\n        for (length_t byte = 0; byte < m_decryptedPlaintextLength; byte++) {\n            tvFile << hex << setfill('0') << setw(2) << (int)m_decryptedPlaintext[byte];\n        }\n        tvFile << endl << \"dec-smn:   \";\n        for (length_t byte = 0; byte < pCaesarSettings->smnLength; byte++) {\n            tvFile << hex << setfill('0') << setw(2) << (int)m_decryptedSmn[byte];\n        }\n        tvFile << endl << \"---\" << endl;\n        if (tvFile.fail()) {\n            mainLogger.out(LOGGER_ERROR) << \"Problem when saving test vectors (\" << FILE_TEST_VECTORS_HR << \").\" << endl;\n            return STAT_FILE_WRITE_FAIL;\n        }\n        tvFile.close();\n    }\n\n    // veryfing decryption\n    if (pCaesarSettings->plaintextLength != m_decryptedPlaintextLength) {\n        mainLogger.out(LOGGER_ERROR) << \"Decrypted plaintext length mismatch (\" << pCaesarSettings->plaintextLength << \" versus \" << m_decryptedPlaintextLength << \").\" << endl;\n        return STAT_PROJECT_ERROR;\n    }\n    if (memcmp(m_plaintext, m_decryptedPlaintext, m_decryptedPlaintextLength) != 0) {\n        mainLogger.out(LOGGER_ERROR) << \"Decrypted message mismatch.\" << endl;\n        return STAT_PROJECT_ERROR;\n    }\n    if (memcmp(m_smn, m_decryptedSmn, pCaesarSettings->smnLength) != 0) {\n        mainLogger.out(LOGGER_ERROR) << \"Decrypted secret message number mismatch.\" << endl;\n        return STAT_PROJECT_ERROR;\n    }\n\n    return STAT_OK;\n}\n\nstring Encryptor::shortDescription() {\n    if (m_cipher == NULL) {\n        return \"<no cipher allocated>\";\n    }\n    string desription =  m_cipher->shortDescription() + \", \";\n    if (pCaesarSettings->limitAlgRounds) {\n        desription += CommonFnc::toString(pCaesarSettings->algorithmRoundsCount) + \" rounds\";\n    } else {\n        desription += \"unlimited version\";\n    }\n    return desription;\n}\n\nint Encryptor::saveState(TiXmlNode* pRoot) const {\n    TiXmlElement* pElem = NULL;\n    ostringstream ss;\n    // save algorithm details\n    pElem = new TiXmlElement(\"algorithm\");\n    pElem->LinkEndChild(new TiXmlText(CommonFnc::toString(pCaesarSettings->algorithm).c_str()));\n    pElem->SetAttribute(\"description\", m_cipher->shortDescription().c_str());\n    if (pCaesarSettings->limitAlgRounds) {\n        pElem->SetAttribute(\"rounds\", CommonFnc::toString(pCaesarSettings->algorithmRoundsCount).c_str());\n    }\n    pRoot->LinkEndChild(pElem);\n    // save plaintext\n    pElem = new TiXmlElement(\"plaintext\");\n    pElem->LinkEndChild(new TiXmlText(CommonFnc::arrayToHexa(m_plaintext,\n        static_cast<unsigned int>(pCaesarSettings->plaintextLength)).c_str()));\n    pRoot->LinkEndChild(pElem);\n    // save key\n    pElem = new TiXmlElement(\"key\");\n    pElem->LinkEndChild(new TiXmlText(CommonFnc::arrayToHexa(m_key,\n        static_cast<unsigned int>(pCaesarSettings->keyLength)).c_str()));\n    pRoot->LinkEndChild(pElem);\n    // save associated data (ad)\n    pElem = new TiXmlElement(\"ad\");\n    pElem->LinkEndChild(new TiXmlText(CommonFnc::arrayToHexa(m_ad,\n        static_cast<unsigned int>(pCaesarSettings->adLength)).c_str()));\n    pRoot->LinkEndChild(pElem);\n    // save secret message number (smn)\n    pElem = new TiXmlElement(\"smn\");\n    pElem->LinkEndChild(new TiXmlText(CommonFnc::arrayToHexa(m_smn,\n        static_cast<unsigned int>(pCaesarSettings->smnLength)).c_str()));\n    pRoot->LinkEndChild(pElem);\n    // save public message number (pmn)\n    pElem = new TiXmlElement(\"pmn\");\n    pElem->LinkEndChild(new TiXmlText(CommonFnc::arrayToHexa(m_pmn,\n        static_cast<unsigned int>(pCaesarSettings->pmnLength)).c_str()));\n    pRoot->LinkEndChild(pElem);\n\n    return STAT_OK;\n}\n\nint Encryptor::loadState(TiXmlNode* pRoot) {\n    if (m_cipher == NULL) { return STAT_PROJECT_ERROR; }\n    int status = STAT_OK;\n    if (atoi(getXMLElementValue(pRoot, \"algorithm\").c_str()) != pCaesarSettings->algorithm) {\n        mainLogger.out(LOGGER_ERROR) << \"Incompatible algorithm types.\" << endl;\n        return STAT_CONFIG_INCORRECT;\n    }\n    status = CommonFnc::hexaToArray(getXMLElementValue(pRoot, \"plaintext\"), \n        static_cast<unsigned int>(pCaesarSettings->plaintextLength), m_plaintext);\n    if (status != STAT_OK) return status;\n    status = CommonFnc::hexaToArray(getXMLElementValue(pRoot, \"key\"), \n        static_cast<unsigned int>(pCaesarSettings->keyLength), m_key);\n    if (status != STAT_OK) return status;\n    status = CommonFnc::hexaToArray(getXMLElementValue(pRoot, \"ad\"), \n        static_cast<unsigned int>(pCaesarSettings->adLength), m_ad);\n    if (status != STAT_OK) return status;\n    status = CommonFnc::hexaToArray(getXMLElementValue(pRoot, \"smn\"), \n        static_cast<unsigned int>(pCaesarSettings->smnLength), m_smn);\n    if (status != STAT_OK) return status;\n    status = CommonFnc::hexaToArray(getXMLElementValue(pRoot, \"pmn\"), \n        static_cast<unsigned int>(pCaesarSettings->pmnLength), m_pmn);\n    if (status != STAT_OK) return status;\n\n    m_setup = true;\n    return status;\n}\n"
        },
        {
            "file_name": "Frog.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"Frog_data.h\"\n\n#define BLOCK_SWAP\n\n#  pragma intrinsic(_lrotr,_lrotl)\n\n#  define rotr(x,n) _lrotr(x,n)\n#  define rotl(x,n) _lrotl(x,n)\n\n#define bswap(x)    (rotl(x, 8) & 0x00ff00ff | rotr(x, 8) & 0xff00ff00)\n\n#define byte(x,n)   ((BYTE)((x) >> (8 * n)))\n\n#ifdef  BLOCK_SWAP\n#define BYTE_SWAP\n#define WORD_SWAP\n#endif\n\n#ifdef  BYTE_SWAP\n#define io_swap(x)  bswap(x)\n#else\n#define io_swap(x)  (x)\n#endif\n\n#ifdef  WORD_SWAP\n\n#define get_block(x)                            \\\n    ((DWORD *)(x))[0] = io_swap(in_blk[3]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_blk[2]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_blk[1]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_blk[0])\n\n#define put_block(x)                            \\\n    out_blk[3] = io_swap(((DWORD *)(x))[0]);    \\\n    out_blk[2] = io_swap(((DWORD *)(x))[1]);    \\\n    out_blk[1] = io_swap(((DWORD *)(x))[2]);    \\\n    out_blk[0] = io_swap(((DWORD *)(x))[3])\n\n#define get_key(x,len)                          \\\n    ((DWORD *)(x))[4] = ((DWORD *)(x))[5] =     \\\n    ((DWORD *)(x))[6] = ((DWORD *)(x))[7] = 0;  \\\n    switch((((len) + 63) / 64)) {               \\\n    case 2:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[0]);     \\\n    break;                                      \\\n    case 3:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[5]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[0]);     \\\n    break;                                      \\\n    case 4:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[7]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[6]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[5]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[6] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[7] = io_swap(in_key[0]);     \\\n    }\n\n#else\n\n#define get_block(x)                            \\\n    ((DWORD *)(x))[0] = io_swap(in_blk[0]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_blk[1]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_blk[2]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_blk[3])\n\n#define put_block(x)                            \\\n    out_blk[0] = io_swap(((DWORD *)(x))[0]);    \\\n    out_blk[1] = io_swap(((DWORD *)(x))[1]);    \\\n    out_blk[2] = io_swap(((DWORD *)(x))[2]);    \\\n    out_blk[3] = io_swap(((DWORD *)(x))[3])\n\n#define get_key(x,len)                          \\\n    ((DWORD *)(x))[4] = ((DWORD *)(x))[5] =     \\\n    ((DWORD *)(x))[6] = ((DWORD *)(x))[7] = 0;  \\\n    switch((((len) + 63) / 64)) {               \\\n    case 4:                                     \\\n    ((DWORD *)(x))[6] = io_swap(in_key[6]);     \\\n    ((DWORD *)(x))[7] = io_swap(in_key[7]);     \\\n    case 3:                                     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[5]);     \\\n    case 2:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[0]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[3]);     \\\n    }\n\n#endif\n\n#ifdef CORE_TIME\n#  undef BLOCK_SWAP\n#endif\n\n#define\tik_len\t\t2304\n\nconst BYTE  seed[256] =\n{\n    113,  21, 232,  18, 113,  92,  63, 157, 124, 193, 166, 197, 126,  56, 229, 229, \n    156, 162,  54,  17, 230,  89, 189,  87, 169,   0,  81, 204,   8,  70, 203, 225, \n    160,  59, 167, 189, 100, 157,  84,  11,   7, 130,  29,  51,  32,  45, 135, 237, \n    139,  33,  17, 221,  24,  50,  89,  74,  21, 205, 191, 242,  84,  53,   3, 230, \n\n    231, 118,  15,  15, 107,   4,  21,  34,   3, 156,  57,  66,  93, 255, 191,   3, \n     85, 135, 205, 200, 185, 204,  52,  37,  35,  24,  68, 185, 201,  10, 224, 234, \n      7, 120, 201, 115, 216, 103,  57, 255,  93, 110,  42, 249,  68,  14,  29,  55, \n    128,  84,  37, 152, 221, 137,  39,  11, 252,  50, 144,  35, 178, 190,  43, 162, \n\n    103, 249, 109,   8, 235,  33, 158, 111, 252, 205, 169,  54,  10,  20, 221, 201, \n    178, 224,  89, 184, 182,  65, 201,  10,  60,   6, 191, 174,  79,  98,  26, 160, \n    252,  51,  63,  79,   6, 102, 123, 173,  49,   3, 110, 233,  90, 158, 228, 210, \n    209, 237,  30,  95,  28, 179, 204, 220,  72, 163,  77, 166, 192,  98, 165,  25, \n\n    145, 162,  91, 212,  41, 230, 110,   6, 107, 187, 127,  38,  82,  98,  30,  67, \n    225,  80, 208, 134,  60, 250, 153,  87, 148,  60,  66, 165,  72,  29, 165,  82, \n    211, 207,   0, 177, 206,  13,   6,  14,  92, 248,  60, 201, 132,  95,  35, 215, \n    118, 177, 121, 180,  27,  83, 131,  26,  39,  46,  12,   0,   0,   0,   0,   0\n};\n\n// top is 1 greater than that used in FROG specification\n// this routine makes a permutation containing 'top' values\n\nvoid make_perm(BYTE *ip, DWORD top)\n{\n\tBYTE  ua[260];\n    DWORD  i, j, ie, ne;\n\n    for(i = 0; i < top; ++i)\n\n        ua[i] = (BYTE)i;\n\n    ie = 0; ne = top;\n\n    for(i = 0; i < top - 1; ++i)\n    {\n        ie = (ie + ip[i]) % ne;\n\n        ip[i] = ua[ie]; ne--;\n\n        for(j = ie; j < ne; ++j)\n\n            ua[j] = ua[j + 1];\n    }\n\n    ip[top - 1] = ua[0];\n}\n\nvoid make_ikey(key_str *kp)\n{\n\tDWORD  i, j, k, ix, ll;\n    BYTE  ua[16];\n        \n    for(i = 0; i < 8; ++i)\n    {\n        make_perm(kp->f_key[i].k_spu, 256);\n\n        for(j = 0; j < 256; ++j)\n\n            kp->i_key[i][kp->f_key[i].k_spu[j]] = (BYTE)j;\n\n        make_perm(kp->f_key[i].k_bpu, 16);\n\n        for(j = 0; j < 16; ++j)\n\n            ua[j] = 0;\n\n        for(j = ix = 0; j < 15; ++j)\n        {\n            if(!kp->f_key[i].k_bpu[ix])\n            {\n                k = ix;\n\n                do\n                {\n                    k = (k + 1) & 15;\n                }\n                while\n                    (ua[k]);\n\n                kp->f_key[i].k_bpu[ix] = (BYTE)k; ll = k;\n\n                while(kp->f_key[i].k_bpu[ll] != k)\n                \n                    ll = kp->f_key[i].k_bpu[ll];\n\n                kp->f_key[i].k_bpu[ll] = 0;\n            }\n\n            ua[ix] = 1; ix = kp->f_key[i].k_bpu[ix];\n        }\n\n        for(j = 0; j < 16; ++j)\n\n            if(kp->f_key[i].k_bpu[j] == ((j + 1) & 15))\n\n                kp->f_key[i].k_bpu[j] = (BYTE)((j + 2) & 15);\n    }\n}\n\n#define f_rnd(j)                    \\\n    k = pp[j];                      \\\n    blk[j] = sp[blk[j] ^ xp[j]];    \\\n    blk[(j + 1) & 15] ^= blk[j];    \\\n    blk[k] ^= blk[j]\n\n#define b_rnd(j)                    \\\n    ct = blk[j];                    \\\n    blk[pp[j]] ^= blk[j];           \\\n    blk[(j + 1) & 15] ^= blk[j];    \\\n    blk[j] = sp[ct] ^ xp[j]\n\nvoid enc(const FROG_DATA *pFd,const DWORD in_blk[4], DWORD out_blk[4])\n{\n\tDWORD  i, k;\n    BYTE  blk[16], *xp, *sp, *pp;\n    \n    *(DWORD *)(blk +  0) = in_blk[0]; *(DWORD *)(blk +  4) = in_blk[1];\n    *(DWORD *)(blk +  8) = in_blk[2]; *(DWORD *)(blk + 12) = in_blk[3];\n    \n    for(i = 0; i < 8; ++i)\n    {\n        xp = pFd->lkp->f_key[i].k_xbu;\n        sp = pFd->lkp->f_key[i].k_spu;\n        pp = pFd->lkp->f_key[i].k_bpu;\n\n        f_rnd( 0); f_rnd( 1); f_rnd( 2); f_rnd( 3);\n        f_rnd( 4); f_rnd( 5); f_rnd( 6); f_rnd( 7);\n        f_rnd( 8); f_rnd( 9); f_rnd(10); f_rnd(11);\n        f_rnd(12); f_rnd(13); f_rnd(14); f_rnd(15);\n    }\n\n    out_blk[0] = *(DWORD *)(blk +  0); out_blk[1] = *(DWORD *)(blk +  4);\n    out_blk[2] = *(DWORD *)(blk +  8); out_blk[3] = *(DWORD *)(blk + 12);\n}\n\n/* initialise the key schedule from the user supplied key   */\nvoid Frog_set_key(FROG_DATA *pFd,const DWORD *in_key,const DWORD key_len)\n{\n\tDWORD  i, j, k;\n    BYTE  kb[32];\n\n    get_key(kb, key_len);\n\n    for(i = j = k = 0; i < ik_len; ++i)\n    {\n        ((BYTE *)(pFd->sim_key.f_key))[i] = seed[j] ^ kb[k];\n\n        j = (j < 250 ? j + 1 : 0);\n\n        k  = (k < (key_len / 8) - 1 ? k + 1 : 0);\n    }\n\n    make_ikey(&pFd->sim_key); pFd->lkp = &pFd->sim_key;\n\n    kb[0] ^= (key_len / 8); \n\n    for(i = 0; i < ik_len / 16; ++i)\n    {\n        enc(pFd,(DWORD *)kb, (DWORD *)kb);\n\n        for(j = 0; j < 16; ++j)\n\n            ((BYTE *)(pFd->loc_key.f_key))[16 * i + j] = kb[j];\n    }\n\n    make_ikey(&pFd->loc_key);\n\n    pFd->lkp = &pFd->loc_key;\n}\n\n/* encrypt a block of text  */\n\nvoid Frog_encrypt(const FROG_DATA *pFd,const DWORD in_blk[4], DWORD out_blk[4])\n{\n\tDWORD  i, k;\n    BYTE  blk[16], *xp, *sp, *pp;\n    \n    get_block(blk);\n    \n    for(i = 0; i < 8; ++i)\n    {\n        xp = pFd->lkp->f_key[i].k_xbu;\n        sp = pFd->lkp->f_key[i].k_spu;\n        pp = pFd->lkp->f_key[i].k_bpu;\n\n        f_rnd( 0); f_rnd( 1); f_rnd( 2); f_rnd( 3);\n        f_rnd( 4); f_rnd( 5); f_rnd( 6); f_rnd( 7);\n        f_rnd( 8); f_rnd( 9); f_rnd(10); f_rnd(11);\n        f_rnd(12); f_rnd(13); f_rnd(14); f_rnd(15);\n    }\n\n    put_block(blk);\n}\n\n/* decrypt a block of text  */\n\nvoid Frog_decrypt(const FROG_DATA *pFd,const DWORD in_blk[4], DWORD out_blk[4])\n{\n\tint  i;\n    BYTE  blk[16], ct, *xp, *sp, *pp;\n    \n    get_block(blk);\n    \n    for(i = 7; i >= 0; --i)\n    {\n        xp = pFd->lkp->f_key[i].k_xbu;\n        sp = pFd->lkp->i_key[i];\n        pp = pFd->lkp->f_key[i].k_bpu;\n\n        b_rnd(15); b_rnd(14); b_rnd(13); b_rnd(12);\n        b_rnd(11); b_rnd(10); b_rnd( 9); b_rnd( 8);\n        b_rnd( 7); b_rnd( 6); b_rnd( 5); b_rnd( 4);\n        b_rnd( 3); b_rnd( 2); b_rnd( 1); b_rnd( 0);\n    }\n\n    put_block(blk);\n}\n"
        },
        {
            "file_name": "gambit.cpp",
            "content": "#include \"keccak.h\"\n#include \"gambit.h\"\n#include <cassert>\n#include <cstring>\n\n#define KECCAK_BACKWARD_RATIO 100\n// todo: 100 is not an actual value. actual value has to be found.\n\nint PHS(void *out, size_t outlen, const void *in, size_t inlen,\n        const void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost)\n{\n    assert (saltlen = 16);\n\n    uint64_t ROM[1] = {0};\n\n    gambit::dkid256 dkid;\n    std::memset(dkid, 0, sizeof(dkid));\n\n    gambit::gambit256(*(gambit::salt*)salt, (const char*)in, (unsigned int)inlen, ROM, 1, t_cost, m_cost,\n                      dkid, out, (unsigned int)outlen);\n\n    return 0;\n}\n\nnamespace gambit\n{\n    using namespace keccak;\n\n    unsigned int gcd(unsigned int a, unsigned int b)\n    {\n        while (true)\n        {\n            a %= b;\n            if (a == 0) return b;\n            b %= a;\n            if (b == 0) return a;\n        }\n    }\n\n    void gambit(unsigned int r,\n                const void *salt,\n                const char* pwd, unsigned int pwd_len,\n                const uint64_t* ROM, unsigned int ROM_len,\n                unsigned int cost_t, unsigned int cost_m,\n                void *seed)\n    {\n        assert (cost_m & 1);\n        assert (cost_t > 0);\n        assert (cost_m*2 <= cost_t * (r/8) );\n        assert (pwd_len+16+1 <= r);\n\n        uint64_t* mem = new uint64_t[cost_m];\n        memset(mem, 0, sizeof(uint64_t)*cost_m);\n\n        unsigned int f;\n        if (cost_m == 1)\n            f = 1;\n        else\n        {\n            f = cost_m * KECCAK_BACKWARD_RATIO / (KECCAK_BACKWARD_RATIO + 1);\n            while ( (gcd(cost_m, f) != 1) || (gcd(cost_m, f - 1) != 1) ) f--;\n        }\n\n        keccak_state A;\n        A.block_absorb(salt, 0, 16);\n        A.block_absorb(pwd, 16, pwd_len);\n        A.pad101_xor(16 + pwd_len, r-1);\n        A.f();\n\n        unsigned int wrtp = 0;\n        unsigned int rdp = 0;\n        unsigned int romp = 0;\n\n        for (; cost_t > 0; cost_t--)\n        {\n            for (int i = 0; i < 18; i++)\n            {\n                mem[wrtp] ^= A.word_read(i);\n                wrtp++;\n                if (wrtp == cost_m) wrtp = 0;\n\n                A.word_write_xor(i, mem[rdp] ^ ROM[romp]);\n                rdp += f;\n                if (rdp >= cost_m) rdp -= cost_m;\n                romp ++;\n                if (romp >= ROM_len) romp = 0;\n            }\n            A.f();\n        }\n\n        memset(mem, 0, sizeof(uint8_t)*cost_m);\n        delete [] mem;\n\n        A.block_squeeze(seed, r, (200-r));\n    }\n\n    // // // // // // // // 256 // // // // // // // //\n\n    void gambit256(const salt salt,\n                   const char* pwd, unsigned int pwd_len,\n                   const uint64_t* ROM, unsigned int ROM_len,\n                   unsigned int cost_t, unsigned int cost_m,\n                   seed256 seed)\n    {\n        gambit(168, salt, pwd, pwd_len, ROM, ROM_len, cost_t, cost_m, seed);\n    }\n\n    void gambit256(const seed256 &seed,\n                   dkid256 dkid, void *key, int key_len)\n    {\n        assert (key_len <= 168);\n\n        keccak_state A;\n        A.block_absorb(dkid, 0, 168);\n        A.block_absorb(seed, 168, 32);\n        A.f();\n        A.block_squeeze(key, 0, key_len);\n    }\n\n    void gambit256(const salt &salt,\n                   const char* pwd, unsigned int pwd_len,\n                   const uint64_t* ROM, unsigned int ROM_len,\n                   unsigned int cost_t, unsigned int cost_m,\n                   dkid256 dkid, void *key, int key_len)\n    {\n        seed256 seed;\n        gambit256(salt, pwd, pwd_len, ROM, ROM_len, cost_t, cost_m, seed);\n        gambit256(seed, dkid, key, key_len);\n        memset(seed, 0, 32);\n    }\n\n    // // // // // // // // 512 // // // // // // // //\n\n    void gambit512(const salt salt,\n                   const char* pwd, unsigned int pwd_len,\n                   const uint64_t* ROM, unsigned int ROM_len,\n                   unsigned int cost_t, unsigned int cost_m,\n                   seed512 seed)\n    {\n        gambit(136, salt, pwd, pwd_len, ROM, ROM_len, cost_t, cost_m, seed);\n    }\n\n    void gambit512(const seed512 &seed,\n                   dkid512 dkid, void *key, int key_len)\n    {\n        assert (key_len <= 136);\n\n        keccak_state A;\n        A.block_absorb(dkid, 0, 136);\n        A.block_absorb(seed, 136, 64);\n        A.f();\n        A.block_squeeze(key, 0, key_len);\n    }\n\n    void gambit512(const salt &salt,\n                   const char* pwd, unsigned int pwd_len,\n                   const uint64_t* ROM, unsigned int ROM_len,\n                   unsigned int cost_t, unsigned int cost_m,\n                   dkid512 dkid, void *key, int key_len)\n    {\n        seed512 seed;\n        gambit512(salt, pwd, pwd_len, ROM, ROM_len, cost_t, cost_m, seed);\n        gambit512(seed, dkid, key, key_len);\n        memset(seed, 0, 64);\n    }\n}\n"
        },
        {
            "file_name": "Grostl512.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"Grostl512_data.h\"\n\ntypedef enum { SUCCESS = 0, FAIL = 1, BAD_HASHLEN = 2 } HashReturn;\ntypedef enum { P512 = 0, Q512 = 1, P1024 = 2, Q1024 = 3 } Variant;\n\n#define mul1(b) ((BYTE)(b))\n#define mul2(b) ((BYTE)((b)>>7?((b)<<1)^0x1b:((b)<<1)))\n#define mul3(b) (mul2(b)^mul1(b))\n#define mul4(b) mul2(mul2(b))\n#define mul5(b) (mul4(b)^mul1(b))\n#define mul6(b) (mul4(b)^mul2(b))\n#define mul7(b) (mul4(b)^mul2(b)^mul1(b))\n\nconst BYTE S[256] = {\n  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n  0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n  0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n  0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n  0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n  0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n  0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n  0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n  0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n  0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n  0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n  0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n  0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n  0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n  0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n  0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n  0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n};\n\n/* Shift values for short/long variants */\nint Shift[2][2][ROWS] = {\n  {{0,1,2,3,4,5,6,7}, {1,3,5,7,0,2,4,6}},\n  {{0,1,2,3,4,5,6,11}, {1,3,5,11,0,2,4,6}}\n};\n\n/* AddRoundConstant xors a round-dependent constant to the state */\nvoid AddRoundConstant(BYTE x[ROWS][COLS1024], int columns, BYTE round, Variant v)\n{\n  int i,j;\n  switch (v&1) {\n  case 0 :\n    for (i = 0; i < columns; i++) x[0][i] ^= (i<<4)^round;\n    break;\n  case 1 :\n    for (i = 0; i < columns; i++) \n      for (j = 0; j < ROWS-1; j++)\n\tx[j][i] ^= 0xff;\n    for (i = 0; i < columns; i++) x[ROWS-1][i] ^= (i<<4)^0xff^round;\n    break;\n  }\n}\n\n/* SubBytes replaces each byte by a value from the S-box */\nvoid SubBytes(BYTE x[ROWS][COLS1024], int columns)\n{\n  int i, j;\n\n  for (i = 0; i < ROWS; i++)\n    for (j = 0; j < columns; j++)\n      x[i][j] = S[x[i][j]];\n}\n\n/* ShiftBytes cyclically shifts each row to the left by a number of\n   positions */\nvoid ShiftBytes(BYTE x[ROWS][COLS1024], int columns, Variant v)\n{\n  int *R = Shift[v/2][v&1];\n  int i, j;\n  BYTE temp[COLS1024];\n\n  for (i = 0; i < ROWS; i++) {\n    for (j = 0; j < columns; j++) {\n      temp[j] = x[i][(j+R[i])%columns];\n    }\n    for (j = 0; j < columns; j++) {\n      x[i][j] = temp[j];\n    }\n  }\n}\n\n/* MixBytes reversibly mixes the bytes within a column */\nvoid MixBytes(BYTE x[ROWS][COLS1024], int columns)\n{\n  int i, j;\n  BYTE temp[ROWS];\n\n  for (i = 0; i < columns; i++) {\n    for (j = 0; j < ROWS; j++) {\n      temp[j] = \n\tmul2(x[(j+0)%ROWS][i])^\n\tmul2(x[(j+1)%ROWS][i])^\n\tmul3(x[(j+2)%ROWS][i])^\n\tmul4(x[(j+3)%ROWS][i])^\n\tmul5(x[(j+4)%ROWS][i])^\n\tmul3(x[(j+5)%ROWS][i])^\n\tmul5(x[(j+6)%ROWS][i])^\n\tmul7(x[(j+7)%ROWS][i]);\n    }\n    for (j = 0; j < ROWS; j++) {\n      x[j][i] = temp[j];\n    }\n  }\n}\n\n/* apply P-permutation to x */\nvoid P(GROSTL512_DATA *grostl, BYTE x[ROWS][COLS1024])\n{\n  BYTE i;\n  Variant v = grostl->columns==8?P512:P1024;\n  for (i = 0; i < grostl->rounds; i++) {\n    AddRoundConstant(x, grostl->columns, i, v);\n    SubBytes(x, grostl->columns);\n    ShiftBytes(x, grostl->columns, v);\n    MixBytes(x, grostl->columns);\n  }\n}\n\n/* apply Q-permutation to x */\nvoid Q(GROSTL512_DATA *grostl, BYTE x[ROWS][COLS1024])\n{\n  BYTE i;\n  Variant v = grostl->columns==8?Q512:Q1024;\n  for (i = 0; i < grostl->rounds; i++) {\n    AddRoundConstant(x, grostl->columns, i, v);\n    SubBytes(x, grostl->columns);\n    ShiftBytes(x, grostl->columns, v);\n    MixBytes(x, grostl->columns);\n  }\n}\n\n/* digest (up to) msglen bytes */\nvoid Transform(GROSTL512_DATA *grostl,const BYTE *input,DWORD msglen)\n{ \n  int i, j;\n  BYTE temp1[ROWS][COLS1024], temp2[ROWS][COLS1024];\n\n  /* digest one message block at the time */\n  for (; msglen >= ((DWORD) grostl->statesize); \n       msglen -= grostl->statesize, input += grostl->statesize) {\n    /* store message block (m) in temp2, and xor of chaining (h) and\n       message block in temp1 */\n    for (i = 0; i < ROWS; i++) {\n      for (j = 0; j < grostl->columns; j++) {\n\ttemp1[i][j] = grostl->chaining[i][j]^input[j*ROWS+i];\n\ttemp2[i][j] = input[j*ROWS+i];\n      }\n    }\n\n    P(grostl, temp1); /* P(h+m) */\n    Q(grostl, temp2); /* Q(m) */\n\n    /* xor P(h+m) and Q(m) onto chaining, yielding P(h+m)+Q(m)+h */\n    for (i = 0; i < ROWS; i++) {\n      for (j = 0; j < grostl->columns; j++) {\n\tgrostl->chaining[i][j] ^= temp1[i][j]^temp2[i][j];\n      }\n    }\n\n    /* increment block counter */\n    grostl->block_counter++;\n  }\n}\n\n/* do output transformation, P(h)+h */\nvoid OutputTransformation(GROSTL512_DATA *grostl)\n{\n  int i, j;\n  BYTE temp[ROWS][COLS1024];\n\n  /* store chaining (\"h\") in temp */\n  for (i = 0; i < ROWS; i++) {\n    for (j = 0; j < grostl->columns; j++) {\n      temp[i][j] = grostl->chaining[i][j];\n    }\n  }\n\n  /* compute P(temp) = P(h) */\n  P(grostl, temp);\n\n  /* feed chaining forward, yielding P(h)+h */\n  for (i = 0; i < ROWS; i++) {\n    for (j = 0; j < grostl->columns; j++) {\n      grostl->chaining[i][j] ^= temp[i][j];\n    }\n  }\n}\n\nvoid Grostl512_init(GROSTL512_DATA *grostl)\n{\n  int i, j;\n\n  grostl->rounds = ROUNDS1024;\n  grostl->columns = COLS1024;\n  grostl->statesize = SIZE1024;\n\n  /* zeroise chaining variable */\n  for (i = 0; i < ROWS; i++) {\n    for (j = 0; j < grostl->columns; j++) {\n      grostl->chaining[i][j] = 0;\n    }\n  }\n\n  /* store hashbitlen and set initial value */\n  grostl->hashbitlen = 512;\n  for (i = ROWS-sizeof(int); i < ROWS; i++) {\n    grostl->chaining[i][grostl->columns-1] = (BYTE)(512>>(8*(7-i)));\n  }\n\n  /* initialise other variables */\n  grostl->buf_ptr = 0;\n  grostl->block_counter = 0;\n  grostl->bits_in_last_byte = 0;\n}\n\nvoid Grostl512_data(GROSTL512_DATA *grostl,const BYTE *buffer,DWORD len)\n{\n  int index = 0;\n  DWORD msglen = len/8; /* no. of (full) bytes supplied */\n  DWORD rem = len%8;    /* no. of additional bits */\n\n  /* if the buffer contains data that still needs to be digested */\n  if (grostl->buf_ptr) {\n    /* copy data into buffer until buffer is full, or there is no more\n       data */\n    for (index = 0; grostl->buf_ptr < grostl->statesize && ((DWORD) index) < msglen; \n\t index++, grostl->buf_ptr++) {\n      grostl->buffer[grostl->buf_ptr] = buffer[index];\n    }\n\n    if (grostl->buf_ptr < grostl->statesize) {\n      /* this chunk of message does not fill the buffer */\n      if (rem) {\n\t/* if there are additional bits, add them to the buffer */\n\tgrostl->bits_in_last_byte = rem;\n\tgrostl->buffer[grostl->buf_ptr++] = buffer[index];\n      }\n      return;\n    }\n\n    /* the buffer is full, digest */\n    grostl->buf_ptr = 0;\n    Transform(grostl, grostl->buffer, grostl->statesize);\n  }\n\n  /* digest remainder of data modulo the block size */\n  Transform(grostl, buffer+index, msglen-index);\n  index += ((msglen-index)/grostl->statesize)*grostl->statesize;\n\n  /* copy remaining data to buffer */\n  for (; ((DWORD) index) < msglen; index++, grostl->buf_ptr++) {\n    grostl->buffer[grostl->buf_ptr] = buffer[index];\n  }\n      \n  if (rem) {\n    grostl->bits_in_last_byte = rem;\n    grostl->buffer[grostl->buf_ptr++] = buffer[index];\n  }\n}\n\n#define BILB grostl->bits_in_last_byte\nvoid Grostl512_finalize(GROSTL512_DATA *grostl,BYTE *hash)\n{\n  int i, j, hashbytelen = grostl->hashbitlen/8;\n\n  /* 100... padding */\n  if (grostl->bits_in_last_byte) {\n    grostl->buffer[grostl->buf_ptr-1] &= ((1<<BILB)-1)<<(8-BILB);\n    grostl->buffer[grostl->buf_ptr-1] ^= 0x1<<(7-BILB);\n  }\n  else grostl->buffer[grostl->buf_ptr++] = 0x80;\n\n  if (grostl->buf_ptr > grostl->statesize-LENGTHFIELDLEN) {\n    /* padding requires two blocks */\n    while (grostl->buf_ptr < grostl->statesize) {\n      grostl->buffer[grostl->buf_ptr++] = 0;\n    }\n    Transform(grostl, grostl->buffer, grostl->statesize);\n    grostl->buf_ptr = 0;\n  }\n  while (grostl->buf_ptr < grostl->statesize-LENGTHFIELDLEN) {\n    grostl->buffer[grostl->buf_ptr++] = 0;\n  }\n\n  /* length padding */\n  grostl->block_counter++;\n  grostl->buf_ptr = grostl->statesize;\n  while (grostl->buf_ptr > grostl->statesize-LENGTHFIELDLEN) {\n    grostl->buffer[--grostl->buf_ptr] = (BYTE)grostl->block_counter;\n    grostl->block_counter >>= 8;\n  }\n\n  /* digest (last) padding block */\n  Transform(grostl, grostl->buffer, grostl->statesize);\n  /* output transformation */\n  OutputTransformation(grostl);\n\n  /* store hash output */\n  j = 0;\n  for (i = grostl->statesize-hashbytelen; i < grostl->statesize; i++,j++) {\n    hash[j] = grostl->chaining[i%ROWS][i/ROWS];\n  }\n\n  /* zeroise */\n  for (i = 0; i < ROWS; i++) {\n    for (j = 0; j < grostl->columns; j++) {\n      grostl->chaining[i][j] = 0;\n    }\n  }\n  for (i = 0; i < grostl->statesize; i++) {\n    grostl->buffer[i] = 0;\n  }\n}\n"
        },
        {
            "file_name": "hash.c",
            "content": "#include \"api.h\"\n#include \"endian.h\"\n#include \"permutations.h\"\n\n#define RATE (64 / 8)\n#define PA_ROUNDS 12\n\nint crypto_hash(unsigned char* out, const unsigned char* in,\n                unsigned long long inlen) {\n  state s;\n  u64 outlen;\n  u64 i;\n\n  // initialization\n  s.x0 = 0xb57e273b814cd416ull;\n  s.x1 = 0x2b51042562ae2420ull;\n  s.x2 = 0x66a3a7768ddf2218ull;\n  s.x3 = 0x5aad0a7a8153650cull;\n  s.x4 = 0x4f3e0e32539493b6ull;\n\n  // absorb plaintext\n  while (inlen >= RATE) {\n    s.x0 ^= U64BIG(*(u64*)in);\n    P12();\n    inlen -= RATE;\n    in += RATE;\n  }\n  for (i = 0; i < inlen; ++i, ++in) s.x0 ^= INS_BYTE64(*in, i);\n  s.x0 ^= INS_BYTE64(0x80, inlen);\n\n  P12();\n\n  // absorb plaintext\n  outlen = CRYPTO_BYTES;\n  while (outlen > RATE) {\n    *(u64*)out = U64BIG(s.x0);\n    P12();\n    outlen -= RATE;\n    out += RATE;\n  }\n  *(u64*)out = U64BIG(s.x0);\n\n  return 0;\n}\n\n"
        },
        {
            "file_name": "Hierocrypt3.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"Hierocrypt3_data.h\"\n\n#define primitiveGF8 0x163\n\n/*\n* constant parameters\n*/\n\nconst BYTE sbox[256] =\n{\n  0x07, 0xFC, 0x55, 0x70, 0x98, 0x8E, 0x84, 0x4E, 0xBC, 0x75, 0xCE, 0x18,\n  0x02, 0xE9, 0x5D, 0x80, 0x1C, 0x60, 0x78, 0x42, 0x9D, 0x2E, 0xF5, 0xE8,\n  0xC6, 0x7A, 0x2F, 0xA4, 0xB2, 0x5F, 0x19, 0x87, 0x0B, 0x9B, 0x9C, 0xD3,\n  0xC3, 0x77, 0x3D, 0x6F, 0xB9, 0x2D, 0x4D, 0xF7, 0x8C, 0xA7, 0xAC, 0x17,\n  0x3C, 0x5A, 0x41, 0xC9, 0x29, 0xED, 0xDE, 0x27, 0x69, 0x30, 0x72, 0xA8,\n  0x95, 0x3E, 0xF9, 0xD8, 0x21, 0x8B, 0x44, 0xD7, 0x11, 0x0D, 0x48, 0xFD,\n  0x6A, 0x01, 0x57, 0xE5, 0xBD, 0x85, 0xEC, 0x1E, 0x37, 0x9F, 0xB5, 0x9A,\n  0x7C, 0x09, 0xF1, 0xB1, 0x94, 0x81, 0x82, 0x08, 0xFB, 0xC0, 0x51, 0x0F,\n  0x61, 0x7F, 0x1A, 0x56, 0x96, 0x13, 0xC1, 0x67, 0x99, 0x03, 0x5E, 0xB6,\n  0xCA, 0xFA, 0x9E, 0xDF, 0xD6, 0x83, 0xCC, 0xA2, 0x12, 0x23, 0xB7, 0x65,\n  0xD0, 0x39, 0x7D, 0x3B, 0xD5, 0xB0, 0xAF, 0x1F, 0x06, 0xC8, 0x34, 0xC5,\n  0x1B, 0x79, 0x4B, 0x66, 0xBF, 0x88, 0x4A, 0xC4, 0xEF, 0x58, 0x3F, 0x0A,\n  0x2C, 0x73, 0xD1, 0xF8, 0x6B, 0xE6, 0x20, 0xB8, 0x22, 0x43, 0xB3, 0x33,\n  0xE7, 0xF0, 0x71, 0x7E, 0x52, 0x89, 0x47, 0x63, 0x0E, 0x6D, 0xE3, 0xBE,\n  0x59, 0x64, 0xEE, 0xF6, 0x38, 0x5C, 0xF4, 0x5B, 0x49, 0xD4, 0xE0, 0xF3,\n  0xBB, 0x54, 0x26, 0x2B, 0x00, 0x86, 0x90, 0xFF, 0xFE, 0xA6, 0x7B, 0x05,\n  0xAD, 0x68, 0xA1, 0x10, 0xEB, 0xC7, 0xE2, 0xF2, 0x46, 0x8A, 0x6C, 0x14,\n  0x6E, 0xCF, 0x35, 0x45, 0x50, 0xD2, 0x92, 0x74, 0x93, 0xE1, 0xDA, 0xAE,\n  0xA9, 0x53, 0xE4, 0x40, 0xCD, 0xBA, 0x97, 0xA3, 0x91, 0x31, 0x25, 0x76,\n  0x36, 0x32, 0x28, 0x3A, 0x24, 0x4C, 0xDB, 0xD9, 0x8D, 0xDC, 0x62, 0x2A,\n  0xEA, 0x15, 0xDD, 0xC2, 0xA5, 0x0C, 0x04, 0x1D, 0x8F, 0xCB, 0xB4, 0x4F,\n  0x16, 0xAB, 0xAA, 0xA0\n\n};\n\nconst BYTE isbox[256] =\n{\n  0xB8, 0x49, 0x0C, 0x69, 0xF6, 0xBF, 0x80, 0x00, 0x5B, 0x55, 0x8F, 0x20,\n  0xF5, 0x45, 0xA4, 0x5F, 0xC3, 0x44, 0x74, 0x65, 0xCB, 0xF1, 0xFC, 0x2F,\n  0x0B, 0x1E, 0x62, 0x84, 0x10, 0xF7, 0x4F, 0x7F, 0x96, 0x40, 0x98, 0x75,\n  0xE8, 0xE2, 0xB6, 0x37, 0xE6, 0x34, 0xEF, 0xB7, 0x90, 0x29, 0x15, 0x1A,\n  0x39, 0xE1, 0xE5, 0x9B, 0x82, 0xCE, 0xE4, 0x50, 0xAC, 0x79, 0xE7, 0x7B,\n  0x30, 0x26, 0x3D, 0x8E, 0xDB, 0x32, 0x13, 0x99, 0x42, 0xCF, 0xC8, 0xA2,\n  0x46, 0xB0, 0x8A, 0x86, 0xE9, 0x2A, 0x07, 0xFB, 0xD0, 0x5E, 0xA0, 0xD9,\n  0xB5, 0x02, 0x63, 0x4A, 0x8D, 0xA8, 0x31, 0xAF, 0xAD, 0x0E, 0x6A, 0x1D,\n  0x11, 0x60, 0xEE, 0xA3, 0xA9, 0x77, 0x87, 0x67, 0xC1, 0x38, 0x48, 0x94,\n  0xCA, 0xA5, 0xCC, 0x27, 0x03, 0x9E, 0x3A, 0x91, 0xD3, 0x09, 0xE3, 0x25,\n  0x12, 0x85, 0x19, 0xBE, 0x54, 0x7A, 0x9F, 0x61, 0x0F, 0x59, 0x5A, 0x71,\n  0x06, 0x4D, 0xB9, 0x1F, 0x89, 0xA1, 0xC9, 0x41, 0x2C, 0xEC, 0x05, 0xF8,\n  0xBA, 0xE0, 0xD2, 0xD4, 0x58, 0x3C, 0x64, 0xDE, 0x04, 0x68, 0x53, 0x21,\n  0x22, 0x14, 0x6E, 0x51, 0xFF, 0xC2, 0x73, 0xDF, 0x1B, 0xF4, 0xBD, 0x2D,\n  0x3B, 0xD8, 0xFE, 0xFD, 0x2E, 0xC0, 0xD7, 0x7E, 0x7D, 0x57, 0x1C, 0x9A,\n  0xFA, 0x52, 0x6B, 0x76, 0x97, 0x28, 0xDD, 0xB4, 0x08, 0x4C, 0xA7, 0x88,\n  0x5D, 0x66, 0xF3, 0x24, 0x8B, 0x83, 0x18, 0xC5, 0x81, 0x33, 0x6C, 0xF9,\n  0x72, 0xDC, 0x0A, 0xCD, 0x78, 0x92, 0xD1, 0x23, 0xB1, 0x7C, 0x70, 0x43,\n  0x3F, 0xEB, 0xD6, 0xEA, 0xED, 0xF2, 0x36, 0x6F, 0xB2, 0xD5, 0xC6, 0xA6,\n  0xDA, 0x4B, 0x95, 0x9C, 0x17, 0x0D, 0xF0, 0xC4, 0x4E, 0x35, 0xAA, 0x8C,\n  0x9D, 0x56, 0xC7, 0xB3, 0xAE, 0x16, 0xAB, 0x2B, 0x93, 0x3E, 0x6D, 0x5C,\n  0x01, 0x47, 0xBC, 0xBB\n};\n\nconst BYTE hconst[4][4] =\n{\n  0x5a, 0x82, 0x79, 0x99,\n  0x6e, 0xd9, 0xeb, 0xa1,\n  0x8f, 0x1b, 0xbc, 0xdc,\n  0xca, 0x62, 0xc1, 0xd6\n};\nconst int gindex[6][2] =\n{\n  3, 0, 2, 1, 1, 3, 0, 2, 2, 3, 1, 0\n};\nconst int kconst[3][10] =\n{\n  {0, 1, 2, 3, 3, 2, 1, -1, -1, -1},\n  {1, 0, 3, 2, 2, 3, 0, 1, -1, -1},\n  {4, 0, 2, 1, 3, 3, 1, 2, 0, -1}\n};\n\nconst BYTE mds[4][4] =\n{\n  {0xc4, 0x65, 0xc8, 0x8b},\n  {0x8b, 0xc4, 0x65, 0xc8},\n  {0xc8, 0x8b, 0xc4, 0x65},\n  {0x65, 0xc8, 0x8b, 0xc4}\n};\n\nconst BYTE mds_inv[4][4] =\n{\n  {0x82, 0xc4, 0x34, 0xf6},\n  {0xf6, 0x82, 0xc4, 0x34},\n  {0x34, 0xf6, 0x82, 0xc4},\n  {0xc4, 0x34, 0xf6, 0x82}\n};\n\nconst int mdsh[4][4] =\n{\n  {0x5, 0x5, 0xa, 0xe},\n  {0xe, 0x5, 0x5, 0xa},\n  {0xa, 0xe, 0x5, 0x5},\n  {0x5, 0xa, 0xe, 0x5}\n};\n\nconst int mdsh_inv[4][4] =\n{\n  {0xb, 0xe, 0xe, 0x6},\n  {0x6, 0xb, 0xe, 0xe},\n  {0xe, 0x6, 0xb, 0xe},\n  {0xe, 0xe, 0x6, 0xb}\n};\n\nint poly32_deg (DWORD a)\n{\n  int n = -1;\n  for (; a; a >>= 1)\n    n++;\n  return n;\n}\n\nDWORD poly32_mul (DWORD a, DWORD b)\n{\n  DWORD c = 0;\n\n  for (; b; b >>= 1, a <<= 1)\n    if (b & 1)\n      c ^= a;\n\n  return c;\n}\n\nDWORD poly32_mod (DWORD a, DWORD b)\n{\n  int da = poly32_deg (a);\n  int db = poly32_deg (b);\n  DWORD t;\n\n  if (da < db)\n    return a;\n\n  if (da == db)\n    return a ^ b;\n\n  b <<= da - db;\n\n  for (t = 1 << da; da >= db; da--)\n    {\n      if (a & t)\n        a ^= b;\n      b >>= 1;\n      t >>= 1;\n    }\n  return a;\n}\n\nvoid hcrypt_mdsl (BYTE * in, BYTE * out)\n{\n  int i, j;\n  DWORD m;\n  for (i = 0; i < 4; i++)\n    {\n      m = 0;\n      for (j = 0; j < 4; j++)\n        {\n          m ^= poly32_mod (poly32_mul (mds[i][j], in[j]), primitiveGF8);\n        }\n      out[i] = (BYTE) m;\n\n    }\n}\n\nvoid hcrypt_xs (BYTE * in, BYTE * out, const BYTE * k1, const BYTE * k2)\n{\n  BYTE t[4], u[4];\n  int i;\n\n  for (i = 0; i < 4; i++)\n    u[i] = in[i] ^ k1[i];       /* key xOR */\n\n  for (i = 0; i < 4; i++)\n    t[i] = sbox[u[i]];          /* sbox */\n\n  hcrypt_mdsl (t, u);           /* MDS_L */\n\n  for (i = 0; i < 4; i++)\n    t[i] = u[i] ^ k2[i];        /*keyxOR */\n  for (i = 0; i < 4; i++)\n    out[i] = sbox[t[i]];        /* sbox */\n}\n\n/*\n* op. over GF(2^4)  in MDS_H\n*/\n\nvoid mdsh_mul (BYTE * in, BYTE * out, int x)\n{\n  int i;\n  BYTE u[4];\n  for (i = 0; i < 4; i++)\n    u[i] = 0;\n  if (x & 1)\n    {\n      u[0] ^= in[0];\n      u[1] ^= in[1];\n      u[2] ^= in[2];\n      u[3] ^= in[3];\n    }\n  if (x & 2)\n    {\n      u[0] ^= in[1];\n      u[1] ^= in[2];\n      u[2] ^= in[3] ^ in[0];\n      u[3] ^= in[0];\n    }\n  if (x & 4)\n    {\n      u[0] ^= in[2];\n      u[1] ^= in[3] ^ in[0];\n      u[2] ^= in[0] ^ in[1];\n      u[3] ^= in[1];\n    }\n  if (x & 8)\n    {\n      u[0] ^= in[0] ^ in[3];\n      u[1] ^= in[1] ^ in[0];\n      u[2] ^= in[2] ^ in[1];\n      u[3] ^= in[2];\n    }\n  for (i = 0; i < 4; i++)\n    out[i] = u[i];\n}\n\nvoid hcrypt_mdsh (BYTE in[4][4], BYTE out[4][4])\n{\n  int i, j, k;\n  BYTE tmp[4];\n  for (i = 0; i < 4; i++)\n    for (j = 0; j < 4; j++)\n      out[i][j] = 0;\n  for (i = 0; i < 4; i++)\n    {\n      for (j = 0; j < 4; j++)\n        {\n          mdsh_mul (&in[j][0], tmp, mdsh[i][j]);\n          for (k = 0; k < 4; k++)\n            out[i][k] ^= tmp[k];\n        }\n    }\n}\n\nvoid Hierocrypt3_encrypt(const HIEROCRYPT3_DATA *pHd,const BYTE * in,BYTE *out)\n{\n  BYTE t[4][4], u[4][4];\n  int i, j, r;\n  int n;\n  for (r = i = 0; i < 4; i++)\n    {\n      for (j = 0; j < 4; j++, r++)\n        {\n          t[i][j] = in[r];\n        }\n\n    }\n\n  n = 7;\n\n  for (r = 0; r < n; r++)\n    {\n      hcrypt_xs (&t[0][0], &u[0][0], &pHd->ks[r][0][0], &pHd->ks[r][4][0]);\n      hcrypt_xs (&t[1][0], &u[1][0], &pHd->ks[r][1][0], &pHd->ks[r][5][0]);\n      hcrypt_xs (&t[2][0], &u[2][0], &pHd->ks[r][2][0], &pHd->ks[r][6][0]);\n      hcrypt_xs (&t[3][0], &u[3][0], &pHd->ks[r][3][0], &pHd->ks[r][7][0]);\n      hcrypt_mdsh (u, t);\n    }\n\n  hcrypt_xs (&t[0][0], &u[0][0], &pHd->ks[n][0][0], &pHd->ks[n][4][0]);\n  hcrypt_xs (&t[1][0], &u[1][0], &pHd->ks[n][1][0], &pHd->ks[n][5][0]);\n  hcrypt_xs (&t[2][0], &u[2][0], &pHd->ks[n][2][0], &pHd->ks[n][6][0]);\n  hcrypt_xs (&t[3][0], &u[3][0], &pHd->ks[n][3][0], &pHd->ks[n][7][0]);\n\n  for (r = i = 0; i < 4; i++)\n    {\n      for (j = 0; j < 4; j++, r++)\n        {\n          out[r] = u[i][j] ^ pHd->ks[n + 1][i][j];\n        }\n    }\n}\n\nvoid hcrypt_imdsl (BYTE * in, BYTE * out)\n{\n  int i, j;\n  DWORD m;\n  for (i = 0; i < 4; i++)\n    {\n      m = 0;\n      for (j = 0; j < 4; j++)\n        {\n          m ^= poly32_mod (poly32_mul (mds_inv[i][j], in[j]), primitiveGF8);\n        }\n      out[i] = (BYTE) m;\n    }\n}\n\nvoid hcrypt_ixs (BYTE * in, BYTE * out, BYTE * k1, BYTE * k2)\n{\n  BYTE t[4], u[4];\n  int i;\n\n  for (i = 0; i < 4; i++)\n    u[i] = in[i] ^ k1[i];       /* key xOR */\n\n  for (i = 0; i < 4; i++)\n    t[i] = isbox[u[i]];         /* sbox */\n\n  hcrypt_imdsl (t, u);          /*MDS_L */\n\n  for (i = 0; i < 4; i++)\n    t[i] = u[i] ^ k2[i];        /* key xOR */\n\n  for (i = 0; i < 4; i++)\n    out[i] = isbox[t[i]];       /* sbox */\n}\n\nvoid hcrypt_imdsh (BYTE in[4][4], BYTE out[4][4])\n{\n  int i, j, k;\n  BYTE tmp[4];\n  for (i = 0; i < 4; i++)\n    for (j = 0; j < 4; j++)\n      out[i][j] = 0;\n  for (i = 0; i < 4; i++)\n    {\n      for (j = 0; j < 4; j++)\n        {\n          mdsh_mul (&in[j][0], tmp, mdsh_inv[i][j]);\n\n          for (k = 0; k < 4; k++)\n            out[i][k] ^= tmp[k];\n\n        }\n    }\n}\n\nvoid Hierocrypt3_decrypt(const HIEROCRYPT3_DATA *pHd,const BYTE * in,BYTE *out)\n{\n  BYTE t[4][4], u[4][4];\n  int i, j, r;\n  int n;\n  for (r = i = 0; i < 4; i++)\n    {\n      for (j = 0; j < 4; j++, r++)\n        {\n          t[i][j] = in[r];\n        }\n    }\n  n = 7;\n\n  for (r = 0; r < n; r++)\n    {\n      hcrypt_ixs (&t[0][0], &u[0][0], (BYTE *) &pHd->dks[r][0][0], (BYTE *) &pHd->dks[r][4][0]);\n      hcrypt_ixs (&t[1][0], &u[1][0], (BYTE *) &pHd->dks[r][1][0], (BYTE *) &pHd->dks[r][5][0]);\n      hcrypt_ixs (&t[2][0], &u[2][0], (BYTE *) &pHd->dks[r][2][0], (BYTE *) &pHd->dks[r][6][0]);\n      hcrypt_ixs (&t[3][0], &u[3][0], (BYTE *) &pHd->dks[r][3][0], (BYTE *) &pHd->dks[r][7][0]);\n      hcrypt_imdsh (u, t);\n    }\n\n  hcrypt_ixs (&t[0][0], &u[0][0], (BYTE *) &pHd->dks[r][0][0], (BYTE *) &pHd->dks[n][4][0]);\n  hcrypt_ixs (&t[1][0], &u[1][0], (BYTE *) &pHd->dks[r][1][0], (BYTE *) &pHd->dks[n][5][0]);\n  hcrypt_ixs (&t[2][0], &u[2][0], (BYTE *) &pHd->dks[r][2][0], (BYTE *) &pHd->dks[n][6][0]);\n  hcrypt_ixs (&t[3][0], &u[3][0], (BYTE *) &pHd->dks[r][3][0], (BYTE *) &pHd->dks[n][7][0]);\n\n  for (r = i = 0; i < 4; i++)\n    {\n      for (j = 0; j < 4; j++, r++)\n        {\n          out[r] = u[i][j] ^ pHd->dks[n + 1][i][j];\n\n        }\n    }\n}\n\nvoid hcrypt_keyf (BYTE * in, BYTE * fout, BYTE * fkey)\n{\n  int i;\n  /* F in */\n  for (i = 0; i < 8; i++)\n    fout[i] = sbox[in[i] ^ fkey[i]];\n\n  /* P (32) */\n\n  fout[0] ^= fout[4];\n  fout[1] ^= fout[5];\n  fout[2] ^= fout[6];\n  fout[3] ^= fout[7];\n  fout[4] ^= fout[2];\n  fout[5] ^= fout[3];\n  fout[6] ^= fout[0];\n  fout[7] ^= fout[1];\n}\n\nvoid swap_key (BYTE * l, BYTE * r)\n{\n  BYTE t;\n  int i;\n  for (i = 0; i < 8; i++)\n    {\n      t = l[i];\n      l[i] = r[i];\n      r[i] = t;\n    }\n}\n\nvoid hcrypt_keyp (BYTE k[4][8], BYTE kout[8][4], int index)\n{\n  int i;\n  BYTE fout[8];\n  /* P(32) */\n  for (i = 0; i < 4; i++)\n    {\n      k[2][i] ^= k[3][i];\n      k[2][i + 4] ^= k[3][i + 4];\n    }\n  for (i = 0; i < 4; i++)\n    {\n      k[3][i] ^= k[2][i + 4];\n      k[3][i + 4] ^= k[2][i];\n    }\n\n  /* multiple */\n  mdsh_mul (&k[2][0], &k[2][0], 5);\n  mdsh_mul (&k[2][4], &k[2][4], 0xe);\n  mdsh_mul (&k[3][0], &k[3][0], 5);\n  mdsh_mul (&k[3][4], &k[3][4], 0xe);\n\n  for (i = 0; i < 4; i++)\n    k[2][i] ^= hconst[gindex[index][0]][i];\n\n  for (i = 0; i < 4; i++)\n    k[2][i + 4] ^= hconst[gindex[index][1]][i];\n\n  hcrypt_keyf (&k[1][0], fout, &k[2][0]);\n\n  for (i = 0; i < 8; i++)\n    k[0][i] ^= fout[i];         /* L xor f(R) */\n\n  for (i = 0; i < 4; i++)\n    {\n      kout[0][i] = k[0][i];\n      kout[1][i] = k[0][i + 4];\n    }\n\n  for (i = 0; i < 4; i++)\n    {\n      kout[2][i] = fout[i] ^ k[2][i];\n      kout[3][i] = fout[i + 4] ^ k[2][i + 4];\n    }\n\n  for (i = 0; i < 4; i++)\n    {\n      kout[4][i] = fout[i] ^ k[3][i];\n      kout[5][i] = fout[i + 4] ^ k[3][i + 4];\n    }\n\n  for (i = 0; i < 4; i++)\n    {\n      kout[6][i] = k[1][i] ^ k[3][i];\n      kout[7][i] = k[1][i + 4] ^ k[3][i + 4];\n    }\n\n  swap_key (&k[0][0], &k[1][0]);\n}\n\nvoid hcrypt_keyc (BYTE k[4][8], BYTE kout[8][4], int index)\n{\n  int i;\n  BYTE fout[8];\n  swap_key (&k[0][0], &k[1][0]);\n  hcrypt_keyf (&k[1][0], fout, &k[2][0]);\n\n  for (i = 0; i < 8; i++)\n    k[0][i] ^= fout[i];\n\n  for (i = 0; i < 4; i++)\n    {\n      kout[0][i] = k[0][i] ^ k[2][i];\n      kout[1][i] = k[0][i + 4] ^ k[2][i + 4];\n    }\n\n  for (i = 0; i < 4; i++)\n    k[2][i] ^= hconst[gindex[index][0]][i];\n\n\n  for (i = 0; i < 4; i++)\n    k[2][i + 4] ^= hconst[gindex[index][1]][i];\n\n  mdsh_mul (&k[2][0], &k[2][0], 0xb);\n  mdsh_mul (&k[2][4], &k[2][4], 0x3);\n  mdsh_mul (&k[3][0], &k[3][0], 0xb);\n  mdsh_mul (&k[3][4], &k[3][4], 0x3);\n\n  for (i = 0; i < 4; i++)\n    {\n      kout[2][i] = fout[i] ^ k[2][i];\n      kout[3][i] = fout[i + 4] ^ k[2][i + 4];\n    }\n\n  for (i = 0; i < 4; i++)\n    {\n      kout[4][i] = fout[i] ^ k[3][i];\n      kout[5][i] = fout[i + 4] ^ k[3][i + 4];\n    }\n\n  for (i = 0; i < 4; i++)\n    {\n      kout[6][i] = k[1][i] ^ k[3][i];\n      kout[7][i] = k[1][i + 4] ^ k[3][i + 4];\n    }\n\n\n  for (i = 0; i < 4; i++)\n    {\n      k[3][i] ^= k[2][i + 4];\n      k[3][i + 4] ^= k[2][i];\n    }\n  for (i = 0; i < 4; i++)\n    {\n      k[2][i] ^= k[3][i];\n      k[2][i + 4] ^= k[3][i + 4];\n    }\n}\n\nvoid Hierocrypt3_set_key(HIEROCRYPT3_DATA *pHd,const BYTE* key)\n{\n  BYTE k[4][8];\n  BYTE fout[8];\n  int i, j, pos, r, n;\n\n  pos = 0;\n  for (i = 0; i < 4; i++)\n    for (j = 0; j < 8; j++)\n      k[i][j] = key[pos++];\n\n\n  mdsh_mul (&k[2][0], &k[2][0], 5);\n  mdsh_mul (&k[2][4], &k[2][4], 0xe);\n  mdsh_mul (&k[3][0], &k[3][0], 5);\n  mdsh_mul (&k[3][4], &k[3][4], 0xe);\n\n  for (i = 0; i < 4; i++)\n    k[2][i] ^= hconst[gindex[5][0]][i];\n\n  for (i = 0; i < 4; i++)\n    k[2][i + 4] ^= hconst[gindex[5][1]][i];\n\n  hcrypt_keyf (&k[1][0], fout, &k[2][0]);\n\n  for (i = 0; i < 8; i++)\n    k[0][i] ^= fout[i];         /*L+f(R) */\n\n  swap_key (&k[0][0], &k[1][0]);\n\n  for (r = 0; r < 5; r++)\n    hcrypt_keyp (&k[0], &pHd->ks[r][0], kconst[2][r]);\n\n  for (r = 5; r < 9; r++)\n    hcrypt_keyc (&k[0], &pHd->ks[r][0], kconst[2][r]);\n\n  r = 8;\n\n  for (j = 0; j < 4; j++)\n    {\n      for (n = 0; n < 4; n++)\n        {\n          pHd->dks[0][j][n] = pHd->ks[r][j][n];\n        }\n    }\n\n  for (i = 1; i < r; i++)\n    {\n      for (j = 4; j < 8; j++)\n        {\n          hcrypt_imdsl (&pHd->ks[r - i][j][0], &pHd->dks[i - 1][j][0]);\n        }\n      hcrypt_imdsh (&pHd->ks[r - i][0], &pHd->dks[i][0]);\n    }\n\n  for (j = 4; j < 8; j++)\n    {\n      hcrypt_imdsl (&pHd->ks[0][j][0], &pHd->dks[r - 1][j][0]);\n    }\n\n  for (j = 0; j < 4; j++)\n    {\n      for (n = 0; n < 4; n++)\n        {\n          pHd->dks[r][j][n] = pHd->ks[0][j][n];\n        }\n    }\n}\n"
        },
        {
            "file_name": "hmac-sha512.c",
            "content": "/* hmac-sha512.c - optimized hmac-sha512 implementation\n * Copyright 2013, epixoip.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that redistribution of source\n * retains the above copyright.\n */ \n\n#include <string.h>\n#include <stdint.h>\n#include \"sha512.h\"\n\nvoid pf_hmac_sha512 (const unsigned char *key, size_t keylen, const unsigned char *in,  size_t len, uint64_t digest[8])\n{\n\tint i;\n\tunsigned char ipad[128];\n\tunsigned char opad[128];\n\tunsigned char buf[ 128] = {0};\n\n\tuint64_t tmp1 = 0, tmp2 = 0;\n\n\tuint64_t a,  b,  c,  d,  e,  f,  g,  h,\n\t\t aa, bb, cc, dd, ee, ff, gg, hh,\n\t\t o0, o1, o2, o3, o4, o5, o6, o7;\n\n\tuint64_t w0  = 0, w1  = 0, w2  = 0, w3  = 0,\n\t\t w4  = 0, w5  = 0, w6  = 0, w7  = 0,\n\t\t w8  = 0, w9  = 0, w10 = 0, w11 = 0,\n\t\t w12 = 0, w13 = 0, w14 = 0, w15 = 0;\n\n\tmemset (ipad, 0x36, 128);\n\tmemset (opad, 0x5c, 128);\n\n\tfor (i = 0; i < keylen && i < MAXKEY; i++)\n\t{\n\t\tipad[i] ^= key[i];\n\t\topad[i] ^= key[i];\n\t}\n\n\tuchar_to_uint64 ( w0, ipad,  0 << 3);\n\tuchar_to_uint64 ( w1, ipad,  1 << 3);\n\tuchar_to_uint64 ( w2, ipad,  2 << 3);\n\tuchar_to_uint64 ( w3, ipad,  3 << 3);\n\tuchar_to_uint64 ( w4, ipad,  4 << 3);\n\tuchar_to_uint64 ( w5, ipad,  5 << 3);\n\tuchar_to_uint64 ( w6, ipad,  6 << 3);\n\tuchar_to_uint64 ( w7, ipad,  7 << 3);\n\tuchar_to_uint64 ( w8, ipad,  8 << 3);\n\tuchar_to_uint64 ( w9, ipad,  9 << 3);\n\tuchar_to_uint64 (w10, ipad, 10 << 3);\n\tuchar_to_uint64 (w11, ipad, 11 << 3);\n\tuchar_to_uint64 (w12, ipad, 12 << 3);\n\tuchar_to_uint64 (w13, ipad, 13 << 3);\n\tuchar_to_uint64 (w14, ipad, 14 << 3);\n\tuchar_to_uint64 (w15, ipad, 15 << 3);\n\n\taa = 0x6a09e667f3bcc908;\n\tbb = 0xbb67ae8584caa73b;\n\tcc = 0x3c6ef372fe94f82b;\n\tdd = 0xa54ff53a5f1d36f1;\n\tee = 0x510e527fade682d1;\n\tff = 0x9b05688c2b3e6c1f;\n\tgg = 0x1f83d9abfb41bd6b;\n\thh = 0x5be0cd19137e2179;\n\n\tSHA512_BODY;\n\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i] = in[i];\n\tbuf[len] = 0x80;\n\n\tuchar_to_uint64 ( w0, buf,  0 << 3);\n\tuchar_to_uint64 ( w1, buf,  1 << 3);\n\tuchar_to_uint64 ( w2, buf,  2 << 3);\n\tuchar_to_uint64 ( w3, buf,  3 << 3);\n\tuchar_to_uint64 ( w4, buf,  4 << 3);\n\tuchar_to_uint64 ( w5, buf,  5 << 3);\n\tuchar_to_uint64 ( w6, buf,  6 << 3);\n\tuchar_to_uint64 ( w7, buf,  7 << 3);\n\tuchar_to_uint64 ( w8, buf,  8 << 3);\n\tuchar_to_uint64 ( w9, buf,  9 << 3);\n\tuchar_to_uint64 (w10, buf, 10 << 3);\n\tuchar_to_uint64 (w11, buf, 11 << 3);\n\tuchar_to_uint64 (w12, buf, 12 << 3);\n\tuchar_to_uint64 (w13, buf, 13 << 3);\n\tuchar_to_uint64 (w14, buf, 14 << 3);\n\tw15 = (len + 128) << 3;\n\n\tSHA512_BODY;\n\n\to0 = aa;\n\to1 = bb;\n\to2 = cc;\n\to3 = dd;\n\to4 = ee;\n\to5 = ff;\n\to6 = gg;\n\to7 = hh;\n\n\tuchar_to_uint64 ( w0, opad,  0 << 3);\n\tuchar_to_uint64 ( w1, opad,  1 << 3);\n\tuchar_to_uint64 ( w2, opad,  2 << 3);\n\tuchar_to_uint64 ( w3, opad,  3 << 3);\n\tuchar_to_uint64 ( w4, opad,  4 << 3);\n\tuchar_to_uint64 ( w5, opad,  5 << 3);\n\tuchar_to_uint64 ( w6, opad,  6 << 3);\n\tuchar_to_uint64 ( w7, opad,  7 << 3);\n\tuchar_to_uint64 ( w8, opad,  8 << 3);\n\tuchar_to_uint64 ( w9, opad,  9 << 3);\n\tuchar_to_uint64 (w10, opad, 10 << 3);\n\tuchar_to_uint64 (w11, opad, 11 << 3);\n\tuchar_to_uint64 (w12, opad, 12 << 3);\n\tuchar_to_uint64 (w13, opad, 13 << 3);\n\tuchar_to_uint64 (w14, opad, 14 << 3);\n\tuchar_to_uint64 (w15, opad, 15 << 3);\n\n\taa = 0x6a09e667f3bcc908;\n\tbb = 0xbb67ae8584caa73b;\n\tcc = 0x3c6ef372fe94f82b;\n\tdd = 0xa54ff53a5f1d36f1;\n\tee = 0x510e527fade682d1;\n\tff = 0x9b05688c2b3e6c1f;\n\tgg = 0x1f83d9abfb41bd6b;\n\thh = 0x5be0cd19137e2179;\n\n\tSHA512_BODY;\n\n\tw0 = o0;\n\tw1 = o1;\n\tw2 = o2;\n\tw3 = o3;\n\tw4 = o4;\n\tw5 = o5;\n\tw6 = o6;\n\tw7 = o7;\n\tw8  = 0x8000000000000000;\n\tw9  = 0;\n\tw10 = 0;\n\tw11 = 0;\n\tw12 = 0;\n\tw13 = 0;\n\tw14 = 0;\n\tw15 = (64 + 128) << 3;\n\n\tSHA512_BODY;\n\n\tdigest[0] = __builtin_bswap64 (aa);\n\tdigest[1] = __builtin_bswap64 (bb);\n\tdigest[2] = __builtin_bswap64 (cc);\n\tdigest[3] = __builtin_bswap64 (dd);\n\tdigest[4] = __builtin_bswap64 (ee);\n\tdigest[5] = __builtin_bswap64 (ff);\n\tdigest[6] = __builtin_bswap64 (gg);\n\tdigest[7] = __builtin_bswap64 (hh);\n}\n"
        },
        {
            "file_name": "hs1sivv1_encrypt.cpp",
            "content": "/*\n// HS1-SIV Draft v2.0 reference code.\n//\n// Note: This implements HS1-SIV Draft v2, and not v1.\n//\n//\n// ** This version is slow and susceptible to side-channel attacks. **\n// ** Do not use for any purpose other than to understand HS1-SIV.  **\n//\n// Written by Ted Krovetz (ted@krovetz.net). Last modified 20 August 2014.\n//\n// This is free and unencumbered software released into the public domain.\n//\n// Anyone is free to copy, modify, publish, use, compile, sell, or\n// distribute this software, either in source code form or as a compiled\n// binary, for any purpose, commercial or non-commercial, and by any\n// means.\n//\n// In jurisdictions that recognize copyright laws, the author or authors\n// of this software dedicate any and all copyright interest in the\n// software to the public domain. We make this dedication for the benefit\n// of the public at large and to the detriment of our heirs and\n// successors. We intend this dedication to be an overt act of\n// relinquishment in perpetuity of all present and future rights to this\n// software under copyright law.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n//\n// For more information, please refer to <http://unlicense.org/>\n//\n// The author knows of no intellectual property claims relevant to this work.\n*/\n\n/* Exactly one of the following should be set */\n#define HS1_SIV_LO  0\n#define HS1_SIV     1\n#define HS1_SIV_HI  0\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *\n *     I n c l u d e s   a n d   u t i l i t i e s\n *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n#include \"hs1sivv1_api.h\"\n#include \"hs1sivv1_encrypt.h\"\n\n#if HS1_SIV_LO\n#define HS1_SIV_NH_LEN      64\n#define HS1_SIV_HASH_RNDS    2\n#define HS1_SIV_CHACHA_RNDS  8\n#define HS1_SIV_SIV_LEN      CRYPTO_ABYTES\n#elif HS1_SIV\n#define HS1_SIV_NH_LEN      64\n#define HS1_SIV_HASH_RNDS    4\n#define HS1_SIV_CHACHA_RNDS 12\n#define HS1_SIV_SIV_LEN     CRYPTO_ABYTES\n#elif HS1_SIV_HI\n#define HS1_SIV_NH_LEN      64\n#define HS1_SIV_HASH_RNDS    6\n#define HS1_SIV_CHACHA_RNDS 20\n#define HS1_SIV_SIV_LEN     CRYPTO_ABYTES\n#endif\n\n#define __STDC_LIMIT_MACROS\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n/*#include \"prf.h\"*/\n\n// CHANGE namespace moved due to includes\nnamespace Hs1sivv1_raw {\nint numRounds = -1;\n\n#if __GNUC__\n    #define HS1_SIV_ALIGN(n) __attribute__ ((aligned(n)))\n#elif _MSC_VER\n    #define HS1_SIV_ALIGN(n) __declspec(align(n))\n#elif (__STDC_VERSION >= 201112L) || (__cplusplus >= 201103L)\n    #define HS1_SIV_ALIGN(n) alignas(n)\n#else /* Not GNU/Microsoft/C11: delete alignment uses.     */\n    #pragma message ( \"Struct alignment not guaranteed\" )\n    #define HS1_SIV_ALIGN(n)\n#endif\n\nHS1_SIV_ALIGN(16)\ntypedef struct {\n    unsigned char chacha_key[32];\n    unsigned char nh_key[HS1_SIV_NH_LEN+16*(HS1_SIV_HASH_RNDS-1)];\n    unsigned char poly_key[HS1_SIV_HASH_RNDS*8];\n    #if HS1_SIV_ASU_HASH /* ASU */\n    unsigned char asu_key[HS1_SIV_HASH_RNDS*24];\n    #else\n    unsigned char asu_key[];\n    #endif\n} hs1siv_ctx_t;\n\n/* Little-endian reads and writes. */\n\nstatic uint32_t swap32(uint32_t x) {\n    return (((x & 0x000000ffu) << 24) | ((x & 0x0000ff00u) << 8)  |\n            ((x & 0x00ff0000u) >> 8)  | ((x & 0xff000000u) >> 24));\n}\n\nstatic uint64_t swap64(uint64_t x) {\n    return ((x & UINT64_C(0x00000000000000ff)) << 56) |\n           ((x & UINT64_C(0x000000000000ff00)) << 40) |\n           ((x & UINT64_C(0x0000000000ff0000)) << 24) |\n           ((x & UINT64_C(0x00000000ff000000)) <<  8) |\n           ((x & UINT64_C(0x000000ff00000000)) >>  8) |\n           ((x & UINT64_C(0x0000ff0000000000)) >> 24) |\n           ((x & UINT64_C(0x00ff000000000000)) >> 40) |\n           ((x & UINT64_C(0xff00000000000000)) >> 56);\n}\n\nstatic int le() { const union { int x; char e; } l = { 1 }; return l.e; }\nstatic uint32_t read32le(uint32_t *p) { return (le()?*p:swap32(*p)); }\nstatic uint64_t read64le(uint64_t *p) { return (le()?*p:swap64(*p)); }\nstatic void write32le(uint32_t *p, uint32_t w) { *p = (le()?w:swap32(w)); }\nstatic void write64le(uint64_t *p, uint64_t w) { *p = (le()?w:swap64(w)); }\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *\n *     C h a c h a   S e c t i o n -- Implementation borrowed from D Bernstein\n *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* This chacha implementation was adapted from a public domain implementation\n * found at http://cr.yp.to/chacha.html. It has been modified to accommodate\n * 12-byte IVs as specified in \"draft-nir-cfrg-chacha20-poly1305\".\n */\n\ntypedef struct { uint32_t input[16]; } chacha_ctx_t;\n\nstatic uint32_t rotl(uint32_t x, unsigned n) { return (x<<n) | (x>>(32-n)); }\n\n#define QUARTERROUND(a,b,c,d) \\\n  x[a] += x[b]; x[d] = rotl(x[d] ^ x[a],16); \\\n  x[c] += x[d]; x[b] = rotl(x[b] ^ x[c],12); \\\n  x[a] += x[b]; x[d] = rotl(x[d] ^ x[a], 8); \\\n  x[c] += x[d]; x[b] = rotl(x[b] ^ x[c], 7);\n\nstatic void salsa20_wordtobyte(unsigned char output[64],const uint32_t input[16])\n{\n  uint32_t i, x[16];\n\n  for (i = 0;i < 16;++i) x[i] = input[i];\n  for (i = HS1_SIV_CHACHA_RNDS;i != 0;i -= 2) {\n    QUARTERROUND( 0, 4, 8,12)\n    QUARTERROUND( 1, 5, 9,13)\n    QUARTERROUND( 2, 6,10,14)\n    QUARTERROUND( 3, 7,11,15)\n    QUARTERROUND( 0, 5,10,15)\n    QUARTERROUND( 1, 6,11,12)\n    QUARTERROUND( 2, 7, 8,13)\n    QUARTERROUND( 3, 4, 9,14)\n  }\n  for (i = 0;i < 16;++i) x[i] += input[i];\n  for (i = 0;i < 16;++i) write32le((uint32_t *)(output + 4 * i),x[i]);\n}\n\nstatic const char sigma[] = \"expand 32-byte k\";\nstatic const char tau[] = \"expand 16-byte k\";\n\nvoid chacha_keysetup(chacha_ctx_t *x, const unsigned char *k, unsigned kbits)\n{\n  const char *constants;\n\n  x->input[4] = read32le((uint32_t *)(k + 0));\n  x->input[5] = read32le((uint32_t *)(k + 4));\n  x->input[6] = read32le((uint32_t *)(k + 8));\n  x->input[7] = read32le((uint32_t *)(k + 12));\n  if (kbits == 256) { /* recommended */\n    k += 16;\n    constants = sigma;\n  } else { /* kbits == 128 */\n    constants = tau;\n  }\n  x->input[8] = read32le((uint32_t *)(k + 0));\n  x->input[9] = read32le((uint32_t *)(k + 4));\n  x->input[10] = read32le((uint32_t *)(k + 8));\n  x->input[11] = read32le((uint32_t *)(k + 12));\n  x->input[0] = read32le((uint32_t *)(constants + 0));\n  x->input[1] = read32le((uint32_t *)(constants + 4));\n  x->input[2] = read32le((uint32_t *)(constants + 8));\n  x->input[3] = read32le((uint32_t *)(constants + 12));\n}\n\nvoid chacha_ivsetup(chacha_ctx_t *x,const unsigned char *iv)\n{\n  x->input[12] = 0;\n  x->input[13] = read32le((uint32_t *)(iv + 0)); /* Modified for 12-byte iv */\n  x->input[14] = read32le((uint32_t *)(iv + 4));\n  x->input[15] = read32le((uint32_t *)(iv + 8));\n}\n\nvoid chacha_xor(chacha_ctx_t *x,const unsigned char *in,unsigned char *out,unsigned bytes)\n{\n  unsigned char output[64];\n  unsigned i;\n\n  if (!bytes) return;\n  for (;;) {\n    salsa20_wordtobyte(output,x->input);\n    x->input[12] += 1;\n    if (bytes <= 64) {\n      for (i = 0;i < bytes;++i) out[i] = in[i] ^ output[i];\n      return;\n    }\n    for (i = 0;i < 64;++i) out[i] = in[i] ^ output[i];\n    bytes -= 64;\n    out += 64;\n    in += 64;\n  }\n}\n\nvoid hs1siv_chacha256(void *out, unsigned outbytes, unsigned char *iv, void *user_key)\n{\n    chacha_ctx_t ctx;\n\n    // CHANGE typecasting added\n    chacha_keysetup(&ctx, (unsigned char*)user_key, 256);\n    chacha_ivsetup(&ctx,iv);\n    #if ( ! HS1_SIV_XOR )\n    memset(out, 0, outbytes);\n    #endif\n    // CHANGE typecasting added\n    chacha_xor(&ctx,(unsigned char*)out,(unsigned char*)out,outbytes);\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *\n *     H S 1 - H a s h   S e c t i o n\n *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nstatic const uint64_t m60 = ((uint64_t)1 << 60) - 1;\nstatic const uint64_t m61 = ((uint64_t)1 << 61) - 1;\n\n/* dh:dl = a * b : since a and b are both < 64 bits, no overflow in m. */\nstatic void pmul64(uint64_t *dh, uint64_t *dl, uint64_t a, uint64_t b) {\n    uint64_t m = (uint64_t)(uint32_t)(a>>32) * (uint64_t)(uint32_t)b\n               + (uint64_t)(uint32_t)(b>>32) * (uint64_t)(uint32_t)a;\n    uint64_t h = (uint64_t)(uint32_t)(a>>32) * (uint64_t)(uint32_t)(b>>32);\n    uint64_t l = (uint64_t)(uint32_t)a * (uint64_t)(uint32_t)b;\n    h += (m >> 32); l += (m << 32);  /* h:l += (m>>32):(m<<32)      */\n    if (l < (m << 32)) h += 1;       /* Check for carry from l to h */\n    *dl=l; *dh=h;\n}\n\n/* Return 62 bits congruent to ak+m mod (2^61-1). Assumes 60-bit k, m; 62-bit a */\nstatic uint64_t poly_step(uint64_t a, uint64_t m, uint64_t k) {\n    #if (__GNUC__ && __LP64__)\n        __uint128_t tmp = (__uint128_t)a * (__uint128_t)k;\n        return ((uint64_t)tmp & m61) + (uint64_t)(tmp >> 61) + m;\n    #else\n        uint64_t h,l;\n        pmul64(&h,&l,a,k);\n        return (l & m61) + ((h << 3) | (l >> 61)) + m;\n    #endif\n}\n\nstatic uint64_t poly_finalize(uint64_t a) {\n    a = (a & m61) + (a >> 61);   /* a may be 62 bits, so one final reduction */\n    if (a == m61) a = 0;\n    return a;\n}\n\nstatic uint32_t asu_hash(uint64_t x, uint64_t *k) {\n    uint64_t t = k[0] + k[1] * (uint32_t)x + k[2] * (uint32_t)(x >> 32);\n    return (uint32_t)(t >> 32);\n}\n\nvoid prf_hash2(uint64_t *h, uint32_t *in, unsigned inbytes, uint32_t *nhkey, uint64_t *polykey, uint64_t *asukey) {\n    uint64_t s0 = 1, s1 = 1;\n    unsigned i=0, j;\n\n    /* Hash full blocks of HS1_SIV_NH_LEN bytes */\n    for ( ; inbytes >= HS1_SIV_NH_LEN; inbytes -= HS1_SIV_NH_LEN, in += HS1_SIV_NH_LEN/4) {\n        uint64_t a0 = 0, a1 = 0;\n        for (i=0;i<HS1_SIV_NH_LEN/4;i+=8) {\n            a0 += (uint64_t)(read32le(in+i+0) + nhkey[i+0]) * (read32le(in+i+2) + nhkey[i+2]);\n            a0 += (uint64_t)(read32le(in+i+1) + nhkey[i+1]) * (read32le(in+i+3) + nhkey[i+3]);\n            a1 += (uint64_t)(read32le(in+i+0) + nhkey[i+4]) * (read32le(in+i+2) + nhkey[i+6]);\n            a1 += (uint64_t)(read32le(in+i+1) + nhkey[i+5]) * (read32le(in+i+3) + nhkey[i+7]);\n            a0 += (uint64_t)(read32le(in+i+4) + nhkey[i+4]) * (read32le(in+i+6) + nhkey[i+6]);\n            a0 += (uint64_t)(read32le(in+i+5) + nhkey[i+5]) * (read32le(in+i+7) + nhkey[i+7]);\n            a1 += (uint64_t)(read32le(in+i+4) + nhkey[i+8]) * (read32le(in+i+6) + nhkey[i+10]);\n            a1 += (uint64_t)(read32le(in+i+5) + nhkey[i+9]) * (read32le(in+i+7) + nhkey[i+11]);\n        }\n        s0 = poly_step(s0, a0&m60, polykey[0]);\n        s1 = poly_step(s1, a1&m60, polykey[1]);\n    }\n    /* If partial block remains, hash it */\n    i=0;\n    if (inbytes != 0) {\n        uint64_t a0 = 0, a1 = 0;\n        while (inbytes >= 16) {\n            a0 += (uint64_t)(read32le(in+i+0) + nhkey[i+0]) * (read32le(in+i+2) + nhkey[i+2]);\n            a0 += (uint64_t)(read32le(in+i+1) + nhkey[i+1]) * (read32le(in+i+3) + nhkey[i+3]);\n            a1 += (uint64_t)(read32le(in+i+0) + nhkey[i+4]) * (read32le(in+i+2) + nhkey[i+6]);\n            a1 += (uint64_t)(read32le(in+i+1) + nhkey[i+5]) * (read32le(in+i+3) + nhkey[i+7]);\n            i += 4; inbytes -= 16;\n        }\n        if (inbytes) {\n            uint32_t tail[4] = {0,0,0,0};\n            for (j=0;j<inbytes;j++)\n                ((unsigned char *)tail)[j] = ((unsigned char *)(in+i))[j];\n            a0 += (uint64_t)(read32le(tail+0) + nhkey[i+0]) * (read32le(tail+2) + nhkey[i+2]);\n            a0 += (uint64_t)(read32le(tail+1) + nhkey[i+1]) * (read32le(tail+3) + nhkey[i+3]);\n            a1 += (uint64_t)(read32le(tail+0) + nhkey[i+4]) * (read32le(tail+2) + nhkey[i+6]);\n            a1 += (uint64_t)(read32le(tail+1) + nhkey[i+5]) * (read32le(tail+3) + nhkey[i+7]);\n            a0 += inbytes;\n            a1 += inbytes;\n        }\n        s0 = poly_step(s0, a0&m60, polykey[0]);\n        s1 = poly_step(s1, a1&m60, polykey[1]);\n    }\n    s0 = poly_finalize(s0);\n    s1 = poly_finalize(s1);\n    #if (HS1_SIV_HASH_RNDS > 4)\n    write64le(h, (uint64_t)asu_hash(s1, asukey+3) << 32 | asu_hash(s0, asukey);\n    #else\n    (void)asukey;\n    write64le(h,s0);\n    write64le(h+1,s1);\n    #endif\n}\n\nvoid hs1_hash(hs1siv_ctx_t *ctx, void *in, unsigned inbytes, void *out) {\n    uint64_t *h = (uint64_t *)out;\n    unsigned k = (HS1_SIV_HASH_RNDS > 4 ? 1 : 2);\n\n    prf_hash2(h, (uint32_t *)in, inbytes, (uint32_t *)ctx->nh_key, (uint64_t *)ctx->poly_key, (uint64_t *)ctx->asu_key);\n    #if HS1_SIV_HASH_RNDS > 2\n    prf_hash2(h+k, (uint32_t *)in, inbytes, (uint32_t *)ctx->nh_key+8, (uint64_t *)ctx->poly_key+2, (uint64_t *)ctx->asu_key+3);\n    #if HS1_SIV_HASH_RNDS > 4\n    prf_hash2(h+2*k, (uint32_t *)in, inbytes, (uint32_t *)ctx->nh_key+16, (uint64_t *)ctx->poly_key+4, (uint64_t *)ctx->asu_key+6);\n    #if HS1_SIV_HASH_RNDS > 6\n    prf_hash2(h+3*k, (uint32_t *)in, inbytes, (uint32_t *)ctx->nh_key+24, (uint64_t *)ctx->poly_key+6, (uint64_t *)ctx->asu_key+9);\n    #endif\n    #endif\n    #endif\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *\n *     P R F   S e c t i o n\n *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/*\ntypedef struct {\n    unsigned char chacha_key[32];\n    unsigned char nh_key[HS1_SIV_NH_LEN+16*(HS1_SIV_HASH_RNDS-1)];\n    unsigned char poly_key[HS1_SIV_HASH_RNDS*8];\n    #if (HS1_SIV_HASH_RNDS > 4)\n    unsigned char asu_key[HS1_SIV_HASH_RNDS*24];\n    #else\n    unsigned char asu_key[];\n    #endif\n} hs1siv_ctx_t;\n*/\n\nvoid hs1siv_subkeygen(hs1siv_ctx_t *ctx, void *user_key, unsigned key_bytes)\n{\n    unsigned char chacha_key[32];\n    unsigned char iv[12] = {0};\n    unsigned i=0;\n\n    /* Copy user_key as many times as needed to fill 32 byte chacha key */\n    while (i < 32) {\n        unsigned nbytes = 32-i;\n        if (nbytes > key_bytes) nbytes = key_bytes;\n        memcpy(chacha_key+i,user_key,nbytes);\n        i += nbytes;\n    }\n\n    /* Build key-derivation nonce and fill context */\n    iv[0] = key_bytes;\n    iv[2] = HS1_SIV_SIV_LEN;\n    iv[4] = HS1_SIV_CHACHA_RNDS;\n    iv[5] = HS1_SIV_HASH_RNDS;\n    iv[6] = HS1_SIV_NH_LEN;\n    hs1siv_chacha256(ctx, sizeof(hs1siv_ctx_t), iv, chacha_key);\n\n    /* Pre-process internal keys: make future reads little-endian, mod poly key */\n    for (i=0; i<sizeof(ctx->nh_key)/4; i++)\n        ((uint32_t *)ctx->nh_key)[i] = read32le(((uint32_t *)ctx->nh_key)+i);\n    for (i=0; i<sizeof(ctx->poly_key)/8; i++)\n        ((uint64_t *)ctx->poly_key)[i] = read64le(((uint64_t *)ctx->poly_key)+i) & m60;\n    #if (HS1_SIV_HASH_RNDS > 4)\n    for (i=0; i<sizeof(ctx->asu_key)/8; i++)\n        ((uint64_t *)ctx->asu_key)[i] = read64le(((uint64_t *)ctx->asu_key)+i);\n    #endif\n}\n\nvoid hs1(\n    hs1siv_ctx_t *hs1_ctx,\n    void *in, unsigned inbytes,\n    void *iv,\n    void *out, unsigned outbytes\n)\n{\n    #if (HS1_SIV_HASH_RNDS > 4)\n    uint64_t h[HS1_SIV_HASH_RNDS/2];\n    #else\n    uint64_t h[HS1_SIV_HASH_RNDS];\n    #endif\n\n    unsigned i;\n    unsigned char key[32];\n    chacha_ctx_t chacha_ctx;\n\n    hs1_hash(hs1_ctx, in, inbytes, h);\n    memcpy(key, hs1_ctx->chacha_key, 32);\n    for (i=0; i<sizeof(h)/8;i++) ((uint64_t *)key)[i] ^= h[i];\n    chacha_keysetup(&chacha_ctx, key, 256);\n    chacha_ivsetup(&chacha_ctx,(unsigned char *)iv);\n    memset(out,0,outbytes);\n    chacha_xor(&chacha_ctx, (unsigned char *)out, (unsigned char *)out, outbytes);\n}\n\nvoid hs1siv_encrypt(hs1siv_ctx_t *ctx, void *m, unsigned mbytes, void *a, unsigned abytes, void *n, void *t, void *c)\n{\n    unsigned i;\n    unsigned buflen = (abytes+15)/16*16 + (mbytes+15)/16*16 + 16;\n    unsigned char tmp_t[HS1_SIV_SIV_LEN];\n    unsigned char *buf = (unsigned char *)malloc(buflen);\n    memset(buf, 0, buflen);\n    memcpy(buf, a, abytes);\n    memcpy(buf+(abytes+15)/16*16, m, mbytes);\n    write32le((uint32_t *)(buf+buflen-16), abytes);\n    write32le((uint32_t *)(buf+buflen-8), mbytes);\n    hs1(ctx, buf, buflen, n, tmp_t, HS1_SIV_SIV_LEN);\n    free(buf);\n    buf = (unsigned char *)malloc(mbytes+64);\n    hs1(ctx, tmp_t, HS1_SIV_SIV_LEN, n, buf, mbytes+64);\n    for (i=0; i<mbytes; i++)\n        buf[64+i] ^= ((unsigned char *)m)[i];\n    memcpy(c,buf+64,mbytes);\n    memcpy(t,tmp_t,HS1_SIV_SIV_LEN);\n    free(buf);\n}\n\nint hs1siv_decrypt(hs1siv_ctx_t *ctx, void *c, unsigned cbytes, void *a, unsigned abytes, void *n, void *t, void *m)\n{\n    unsigned i, buflen = (abytes+15)/16*16 + (cbytes+15)/16*16 + 16;\n    unsigned char *maybe_m = (unsigned char *)malloc(cbytes);\n    unsigned char maybe_t[HS1_SIV_SIV_LEN];\n    unsigned char *buf = (unsigned char *)malloc(cbytes+64);\n    hs1(ctx, t, HS1_SIV_SIV_LEN, n, buf, cbytes+64);\n    for (i=0; i<cbytes; i++)\n        ((unsigned char *)maybe_m)[i] = ((unsigned char *)c)[i] ^ buf[64+i];\n    free(buf);\n    buf = (unsigned char *)malloc(buflen);\n    memset(buf, 0, buflen);\n    memcpy(buf, a, abytes);\n    memcpy(buf+(abytes+15)/16*16, maybe_m, cbytes);\n    write32le((uint32_t *)(buf+buflen-16), abytes);\n    write32le((uint32_t *)(buf+buflen-8), cbytes);\n    hs1(ctx, buf, buflen, n, maybe_t, HS1_SIV_SIV_LEN);\n    free(buf);\n    if (memcmp(t,maybe_t,HS1_SIV_SIV_LEN) == 0) {\n        memcpy(m,maybe_m,cbytes);\n        free(maybe_m);\n        return 0;\n    } else {\n        free(maybe_m);\n        return -1;\n    }\n}\n\nint crypto_aead_encrypt(\n    unsigned char *c,unsigned long long *clen,\n    const unsigned char *m,unsigned long long mlen,\n    const unsigned char *ad,unsigned long long adlen,\n    const unsigned char *nsec,\n    const unsigned char *npub,\n    const unsigned char *k\n)\n{\n    hs1siv_ctx_t ctx;\n    (void)nsec;\n    hs1siv_subkeygen(&ctx, (void *)k, CRYPTO_KEYBYTES);\n    if (clen) *clen = mlen+CRYPTO_ABYTES;\n    hs1siv_encrypt(&ctx, (void *)m, mlen, (void *)ad, adlen, (void *)npub, c+mlen, c);\n    return 0;\n}\n\nint crypto_aead_decrypt(\n    unsigned char *m,unsigned long long *mlen,\n    unsigned char *nsec,\n    const unsigned char *c,unsigned long long clen,\n    const unsigned char *ad,unsigned long long adlen,\n    const unsigned char *npub,\n    const unsigned char *k\n)\n{\n    hs1siv_ctx_t ctx;\n    (void)nsec;\n    if (mlen) *mlen = clen-CRYPTO_ABYTES;\n    hs1siv_subkeygen(&ctx, (void *)k, CRYPTO_KEYBYTES);\n    return hs1siv_decrypt(&ctx, (void *)c, clen-CRYPTO_ABYTES, (void *)ad, adlen, (void *)npub, (void *)(c+clen-CRYPTO_ABYTES), m);\n}\n\n} // namespace Hs1sivv1_raw\n"
        },
        {
            "file_name": "Idea_nxt128.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"Idea_nxt_common.h\"\n#include \"Idea_nxt128_data.h\"\n\n///////////////////////////////////////////////////////////\n\n#define NXT128_BLOCK_SIZE 16\n\nconst DWORD tbsm0_128[512] = {\n    0x5d5de7bb, 0xba8dd269, 0xdede9ba4, 0x458a6fcb, 0x00000000, 0x00000000,\n    0xb7b72008, 0x97d7a7af, 0xd3d38c23, 0x5fbe95b6, 0xcacaa7ab, 0x6dda65ce,\n    0x3c3c4411, 0x78f01e0f, 0x0d0d1787, 0x1a34fa7d, 0xc3c3bc2f, 0x7ffe9db2,\n    0xf8f8f142, 0x09127c3e, 0xcbcba429, 0x6fde99b0, 0x8d8d6ee7, 0xe33fba5d,\n    0x76769ada, 0xec213be1, 0x898962e4, 0xeb2fb85c, 0xaaaa0783, 0xada355d6,\n    0x121236f1, 0x244809f8, 0x88886166, 0xe92b4422, 0x222266e5, 0x448811f4,\n    0x4f4fd14a, 0x9ec5db91, 0xdbdb9425, 0x4f9e91b4, 0x6d6db7af, 0xda4dca65,\n    0x4747c94c, 0x8ee5df93, 0xe4e4d54b, 0x31627239, 0x4c4cd435, 0x98c92613,\n    0x78788822, 0xf0193c1e, 0x9a9a5797, 0xcd634dda, 0x4949dbb4, 0x92ddd86c,\n    0x93934c13, 0xdf47b5a6, 0xc4c4b553, 0x71e26231, 0xc0c0b950, 0x79f26030,\n    0x8686739e, 0xf51343dd, 0x13133573, 0x264cf586, 0xa9a902fc, 0xabafa854,\n    0x20206018, 0x40801008, 0x5353f543, 0xa6b5d596, 0x1c1c2409, 0x38700e07,\n    0x4e4ed2c8, 0x9cc127ef, 0xcfcfa82a, 0x67ce9bb1, 0x35355f95, 0x6ad4e673,\n    0x39394b90, 0x72e4e070, 0xb4b42577, 0x91db5a2d, 0xa1a11afa, 0xbb8fac56,\n    0x5454fc3f, 0xa8a92a15, 0x6464ac2b, 0xc8693219, 0x0303057f, 0x060cfd82,\n    0xc7c7b02c, 0x77ee9fb3, 0x858576e1, 0xf31fbe5f, 0x5c5ce439, 0xb8892e17,\n    0x5b5bed45, 0xb695d194, 0xcdcdaed7, 0x63c69a4d, 0xd8d8915a, 0x49926c36,\n    0x727296d9, 0xe43139e0, 0x96964392, 0xd5534bd9, 0x4242c6cd, 0x84f121ec,\n    0xb8b83172, 0x89eb5c2e, 0xe1e1daca, 0x3b768c46, 0xa2a21f85, 0xbd8351d4,\n    0x6060a028, 0xc0793018, 0xefefc832, 0x274e8bb9, 0xbdbd3ef3, 0x83ffa251,\n    0x020206fd, 0x040801fc, 0xafaf0802, 0xa7b7aba9, 0x8c8c6d65, 0xe13b4623,\n    0x7373955b, 0xe635c59e, 0x7c7c8421, 0xf8093e1f, 0x7f7f815e, 0xfe05c39d,\n    0x5e5ee2c4, 0xbc812feb, 0xf9f9f2c0, 0x0b168040, 0x6565afa9, 0xca6dce67,\n    0xe6e6d3b6, 0x356a73c5, 0xebebc431, 0x2f5e89b8, 0xadad0eff, 0xa3bfaa55,\n    0x5a5aeec7, 0xb4912dea, 0xa5a516f9, 0xb39fae57, 0x79798ba0, 0xf21dc060,\n    0x8e8e6b98, 0xe53347df, 0x15153f8d, 0x2a54f67b, 0x30305014, 0x60c0180c,\n    0xececcd4d, 0x2142763b, 0xa4a4157b, 0xb19b5229, 0xc2c2bfad, 0x7dfa61cc,\n    0x3e3e42ec, 0x7cf81ff3, 0xe0e0d948, 0x39727038, 0x74749c27, 0xe8293a1d,\n    0x5151f3be, 0xa2bdd46a, 0xfbfbf43d, 0x0f1e81bc, 0x2d2d779f, 0x5ab4ea75,\n    0x6e6eb2d0, 0xdc4137e7, 0x9494456f, 0xd15b4a25, 0x4d4dd7b7, 0x9acdda6d,\n    0x5555ffbd, 0xaaadd66b, 0x34345c17, 0x68d01a0d, 0xaeae0b80, 0xa5b357d7,\n    0x5252f6c1, 0xa4b129e8, 0x7e7e82dc, 0xfc013fe3, 0x9d9d5eeb, 0xc37fb259,\n    0x4a4adecb, 0x94d125ee, 0xf7f7e038, 0x172e87bf, 0x80807960, 0xf90b4020,\n    0xf0f0e944, 0x1932783c, 0xd0d0895c, 0x59b26834, 0x9090496c, 0xd94b4824,\n    0xa7a71004, 0xb797afab, 0xe8e8c14e, 0x2952743a, 0x9f9f5816, 0xc777b3a5,\n    0x5050f03c, 0xa0b92814, 0xd5d586dd, 0x53a6964b, 0xd1d18ade, 0x5bb6944a,\n    0x9898516a, 0xc96b4c26, 0xccccad55, 0x61c26633, 0xa0a01978, 0xb98b5028,\n    0x17173970, 0x2e5cf787, 0xf4f4e547, 0x11227a3d, 0xb6b6238a, 0x95d35bd1,\n    0xc1c1bad2, 0x7bf69c4e, 0x2828781e, 0x50a0140a, 0x5f5fe146, 0xbe85d395,\n    0x26266ae6, 0x4c9813f5, 0x01010382, 0x0204fc7e, 0xabab0401, 0xafa7a9a8,\n    0x25256f99, 0x4a94ee77, 0x38384812, 0x70e01c0e, 0x82827f9d, 0xfd0341dc,\n    0x7d7d87a3, 0xfa0dc261, 0x4848d836, 0x90d92412, 0xfcfcfd41, 0x01027e3f,\n    0x1b1b2d75, 0x366cf184, 0xceceaba8, 0x65ca67cf, 0x3f3f416e, 0x7efce38d,\n    0x6b6bbd51, 0xd655c998, 0xe2e2dfb5, 0x3d7a71c4, 0x6767a954, 0xce65cf9b,\n    0x6666aad6, 0xcc6133e5, 0x4343c54f, 0x86f5dd92, 0x5959ebb8, 0xb29dd068,\n    0x19192b88, 0x3264f078, 0x84847563, 0xf11b4221, 0x3d3d4793, 0x7af4e271,\n    0xf5f5e6c5, 0x13268643, 0x2f2f7162, 0x5ebceb89, 0xc9c9a2d4, 0x6bd6984c,\n    0xbcbc3d71, 0x81fb5e2f, 0xd9d992d8, 0x4b969048, 0x959546ed, 0xd35fb65b,\n    0x29297b9c, 0x52a4e874, 0x4141c3b2, 0x82fddc6e, 0xdada97a7, 0x4d9a6dca,\n    0x1a1a2ef7, 0x34680dfa, 0xb0b02974, 0x99cb582c, 0xe9e9c2cc, 0x2b568844,\n    0x6969bbac, 0xd25dc864, 0xd2d28fa1, 0x5dba69c8, 0x7b7b8d5d, 0xf615c19c,\n    0xd7d78020, 0x57ae97b7, 0x1111338e, 0x2244f47a, 0x9b9b5415, 0xcf67b1a4,\n    0x3333556b, 0x66cce58e, 0x8a8a679b, 0xed2345de, 0x23236567, 0x468ced8a,\n    0x09091b84, 0x1224f87c, 0xd4d4855f, 0x51a26a35, 0x717193a6, 0xe23dc462,\n    0x4444cc33, 0x88e92211, 0x6868b82e, 0xd059341a, 0x6f6fb152, 0xde45cb99,\n    0xf2f2efb9, 0x1d3a79c0, 0x0e0e12f8, 0x1c3807ff, 0xdfdf9826, 0x478e93b5,\n    0x8787701c, 0xf717bfa3, 0xdcdc9d59, 0x41826e37, 0x83837c1f, 0xff07bda2,\n    0x1818280a, 0x30600c06, 0x6a6abed3, 0xd45135e6, 0xeeeecbb0, 0x254a77c7,\n    0x999952e8, 0xcb6fb058, 0x81817ae2, 0xfb0fbc5e, 0x6262a6d5, 0xc47131e4,\n    0x36365aea, 0x6cd81bf1, 0x2e2e72e0, 0x5cb817f7, 0x7a7a8edf, 0xf4113de2,\n    0xfefefbbc, 0x050a7fc3, 0x4545cfb1, 0x8aedde6f, 0x9c9c5d69, 0xc17b4e27,\n    0x75759fa5, 0xea2dc663, 0x91914aee, 0xdb4fb45a, 0x0c0c1405, 0x18300603,\n    0x0f0f117a, 0x1e3cfb81, 0xe7e7d034, 0x376e8fbb, 0xf6f6e3ba, 0x152a7bc1,\n    0x14143c0f, 0x28500a05, 0x6363a557, 0xc675cd9a, 0x1d1d278b, 0x3a74f279,\n    0x0b0b1d79, 0x162cf980, 0x8b8b6419, 0xef27b9a0, 0xb3b32c0b, 0x9fc7a5ae,\n    0xf3f3ec3b, 0x1f3e85be, 0xb2b22f89, 0x9dc359d0, 0x3b3b4d6d, 0x76ece18c,\n    0x08081806, 0x10200402, 0x4b4bdd49, 0x96d5d990, 0x1010300c, 0x20400804,\n    0xa6a61386, 0xb59353d5, 0x323256e9, 0x64c819f0, 0xb9b932f0, 0x8befa050,\n    0xa8a8017e, 0xa9ab542a, 0x92924f91, 0xdd4349d8, 0xf1f1eac6, 0x1b368442,\n    0x5656fac2, 0xaca12be9, 0xdddd9edb, 0x43869249, 0x2121639a, 0x4284ec76,\n    0xbfbf380e, 0x87f7a3ad, 0x04040c03, 0x08100201, 0xbebe3b8c, 0x85f35fd3,\n    0xd6d683a2, 0x55aa6bc9, 0xfdfdfec3, 0x03068241, 0x77779958, 0xee25c79f,\n    0xeaeac7b3, 0x2d5a75c6, 0x3a3a4eef, 0x74e81df2, 0xc8c8a156, 0x69d26432,\n    0x8f8f681a, 0xe737bba1, 0x5757f940, 0xaea5d797, 0x1e1e22f4, 0x3c780ffb,\n    0xfafaf7bf, 0x0d1a7dc2, 0x2b2b7d61, 0x56ace988, 0x5858e83a, 0xb0992c16,\n    0xc5c5b6d1, 0x73e69e4f, 0x27276964, 0x4e9cef8b, 0xacac0d7d, 0xa1bb562b,\n    0xe3e3dc37, 0x3f7e8dba, 0xededcecf, 0x23468a45, 0x97974010, 0xd757b7a7,\n    0xbbbb340d, 0x8fe7a1ac, 0x4646cace, 0x8ce123ed, 0x05050f81, 0x0a14fe7f,\n    0x4040c030, 0x80f92010, 0x31315396, 0x62c4e472, 0xe5e5d6c9, 0x33668e47,\n    0x37375968, 0x6edce78f, 0x2c2c741d, 0x58b0160b, 0x9e9e5b94, 0xc5734fdb,\n    0x0a0a1efb, 0x142805fe, 0xb1b12af6, 0x9bcfa452, 0xb5b526f5, 0x93dfa653,\n    0x06060afe, 0x0c1803fd, 0x6c6cb42d, 0xd849361b, 0x1f1f2176, 0x3e7cf385,\n    0xa3a31c07, 0xbf87adaa, 0x2a2a7ee3, 0x54a815f6, 0x70709024, 0xe039381c,\n    0xfffff83e, 0x070e83bd, 0xbaba378f, 0x8de35dd2, 0x0707097c, 0x0e1cff83,\n    0x24246c1b, 0x48901209, 0x16163af2, 0x2c580bf9, 0xc6c6b3ae, 0x75ea63cd,\n    0x6161a3aa, 0xc27dcc66};\n\nconst DWORD tbsm1_128[512] = {\n    0x5de7bbba, 0x8dd2695d, 0xde9ba445, 0x8a6fcbde, 0x00000000, 0x00000000,\n    0xb7200897, 0xd7a7afb7, 0xd38c235f, 0xbe95b6d3, 0xcaa7ab6d, 0xda65ceca,\n    0x3c441178, 0xf01e0f3c, 0x0d17871a, 0x34fa7d0d, 0xc3bc2f7f, 0xfe9db2c3,\n    0xf8f14209, 0x127c3ef8, 0xcba4296f, 0xde99b0cb, 0x8d6ee7e3, 0x3fba5d8d,\n    0x769adaec, 0x213be176, 0x8962e4eb, 0x2fb85c89, 0xaa0783ad, 0xa355d6aa,\n    0x1236f124, 0x4809f812, 0x886166e9, 0x2b442288, 0x2266e544, 0x8811f422,\n    0x4fd14a9e, 0xc5db914f, 0xdb94254f, 0x9e91b4db, 0x6db7afda, 0x4dca656d,\n    0x47c94c8e, 0xe5df9347, 0xe4d54b31, 0x627239e4, 0x4cd43598, 0xc926134c,\n    0x788822f0, 0x193c1e78, 0x9a5797cd, 0x634dda9a, 0x49dbb492, 0xddd86c49,\n    0x934c13df, 0x47b5a693, 0xc4b55371, 0xe26231c4, 0xc0b95079, 0xf26030c0,\n    0x86739ef5, 0x1343dd86, 0x13357326, 0x4cf58613, 0xa902fcab, 0xafa854a9,\n    0x20601840, 0x80100820, 0x53f543a6, 0xb5d59653, 0x1c240938, 0x700e071c,\n    0x4ed2c89c, 0xc127ef4e, 0xcfa82a67, 0xce9bb1cf, 0x355f956a, 0xd4e67335,\n    0x394b9072, 0xe4e07039, 0xb4257791, 0xdb5a2db4, 0xa11afabb, 0x8fac56a1,\n    0x54fc3fa8, 0xa92a1554, 0x64ac2bc8, 0x69321964, 0x03057f06, 0x0cfd8203,\n    0xc7b02c77, 0xee9fb3c7, 0x8576e1f3, 0x1fbe5f85, 0x5ce439b8, 0x892e175c,\n    0x5bed45b6, 0x95d1945b, 0xcdaed763, 0xc69a4dcd, 0xd8915a49, 0x926c36d8,\n    0x7296d9e4, 0x3139e072, 0x964392d5, 0x534bd996, 0x42c6cd84, 0xf121ec42,\n    0xb8317289, 0xeb5c2eb8, 0xe1daca3b, 0x768c46e1, 0xa21f85bd, 0x8351d4a2,\n    0x60a028c0, 0x79301860, 0xefc83227, 0x4e8bb9ef, 0xbd3ef383, 0xffa251bd,\n    0x0206fd04, 0x0801fc02, 0xaf0802a7, 0xb7aba9af, 0x8c6d65e1, 0x3b46238c,\n    0x73955be6, 0x35c59e73, 0x7c8421f8, 0x093e1f7c, 0x7f815efe, 0x05c39d7f,\n    0x5ee2c4bc, 0x812feb5e, 0xf9f2c00b, 0x168040f9, 0x65afa9ca, 0x6dce6765,\n    0xe6d3b635, 0x6a73c5e6, 0xebc4312f, 0x5e89b8eb, 0xad0effa3, 0xbfaa55ad,\n    0x5aeec7b4, 0x912dea5a, 0xa516f9b3, 0x9fae57a5, 0x798ba0f2, 0x1dc06079,\n    0x8e6b98e5, 0x3347df8e, 0x153f8d2a, 0x54f67b15, 0x30501460, 0xc0180c30,\n    0xeccd4d21, 0x42763bec, 0xa4157bb1, 0x9b5229a4, 0xc2bfad7d, 0xfa61ccc2,\n    0x3e42ec7c, 0xf81ff33e, 0xe0d94839, 0x727038e0, 0x749c27e8, 0x293a1d74,\n    0x51f3bea2, 0xbdd46a51, 0xfbf43d0f, 0x1e81bcfb, 0x2d779f5a, 0xb4ea752d,\n    0x6eb2d0dc, 0x4137e76e, 0x94456fd1, 0x5b4a2594, 0x4dd7b79a, 0xcdda6d4d,\n    0x55ffbdaa, 0xadd66b55, 0x345c1768, 0xd01a0d34, 0xae0b80a5, 0xb357d7ae,\n    0x52f6c1a4, 0xb129e852, 0x7e82dcfc, 0x013fe37e, 0x9d5eebc3, 0x7fb2599d,\n    0x4adecb94, 0xd125ee4a, 0xf7e03817, 0x2e87bff7, 0x807960f9, 0x0b402080,\n    0xf0e94419, 0x32783cf0, 0xd0895c59, 0xb26834d0, 0x90496cd9, 0x4b482490,\n    0xa71004b7, 0x97afaba7, 0xe8c14e29, 0x52743ae8, 0x9f5816c7, 0x77b3a59f,\n    0x50f03ca0, 0xb9281450, 0xd586dd53, 0xa6964bd5, 0xd18ade5b, 0xb6944ad1,\n    0x98516ac9, 0x6b4c2698, 0xccad5561, 0xc26633cc, 0xa01978b9, 0x8b5028a0,\n    0x1739702e, 0x5cf78717, 0xf4e54711, 0x227a3df4, 0xb6238a95, 0xd35bd1b6,\n    0xc1bad27b, 0xf69c4ec1, 0x28781e50, 0xa0140a28, 0x5fe146be, 0x85d3955f,\n    0x266ae64c, 0x9813f526, 0x01038202, 0x04fc7e01, 0xab0401af, 0xa7a9a8ab,\n    0x256f994a, 0x94ee7725, 0x38481270, 0xe01c0e38, 0x827f9dfd, 0x0341dc82,\n    0x7d87a3fa, 0x0dc2617d, 0x48d83690, 0xd9241248, 0xfcfd4101, 0x027e3ffc,\n    0x1b2d7536, 0x6cf1841b, 0xceaba865, 0xca67cfce, 0x3f416e7e, 0xfce38d3f,\n    0x6bbd51d6, 0x55c9986b, 0xe2dfb53d, 0x7a71c4e2, 0x67a954ce, 0x65cf9b67,\n    0x66aad6cc, 0x6133e566, 0x43c54f86, 0xf5dd9243, 0x59ebb8b2, 0x9dd06859,\n    0x192b8832, 0x64f07819, 0x847563f1, 0x1b422184, 0x3d47937a, 0xf4e2713d,\n    0xf5e6c513, 0x268643f5, 0x2f71625e, 0xbceb892f, 0xc9a2d46b, 0xd6984cc9,\n    0xbc3d7181, 0xfb5e2fbc, 0xd992d84b, 0x969048d9, 0x9546edd3, 0x5fb65b95,\n    0x297b9c52, 0xa4e87429, 0x41c3b282, 0xfddc6e41, 0xda97a74d, 0x9a6dcada,\n    0x1a2ef734, 0x680dfa1a, 0xb0297499, 0xcb582cb0, 0xe9c2cc2b, 0x568844e9,\n    0x69bbacd2, 0x5dc86469, 0xd28fa15d, 0xba69c8d2, 0x7b8d5df6, 0x15c19c7b,\n    0xd7802057, 0xae97b7d7, 0x11338e22, 0x44f47a11, 0x9b5415cf, 0x67b1a49b,\n    0x33556b66, 0xcce58e33, 0x8a679bed, 0x2345de8a, 0x23656746, 0x8ced8a23,\n    0x091b8412, 0x24f87c09, 0xd4855f51, 0xa26a35d4, 0x7193a6e2, 0x3dc46271,\n    0x44cc3388, 0xe9221144, 0x68b82ed0, 0x59341a68, 0x6fb152de, 0x45cb996f,\n    0xf2efb91d, 0x3a79c0f2, 0x0e12f81c, 0x3807ff0e, 0xdf982647, 0x8e93b5df,\n    0x87701cf7, 0x17bfa387, 0xdc9d5941, 0x826e37dc, 0x837c1fff, 0x07bda283,\n    0x18280a30, 0x600c0618, 0x6abed3d4, 0x5135e66a, 0xeecbb025, 0x4a77c7ee,\n    0x9952e8cb, 0x6fb05899, 0x817ae2fb, 0x0fbc5e81, 0x62a6d5c4, 0x7131e462,\n    0x365aea6c, 0xd81bf136, 0x2e72e05c, 0xb817f72e, 0x7a8edff4, 0x113de27a,\n    0xfefbbc05, 0x0a7fc3fe, 0x45cfb18a, 0xedde6f45, 0x9c5d69c1, 0x7b4e279c,\n    0x759fa5ea, 0x2dc66375, 0x914aeedb, 0x4fb45a91, 0x0c140518, 0x3006030c,\n    0x0f117a1e, 0x3cfb810f, 0xe7d03437, 0x6e8fbbe7, 0xf6e3ba15, 0x2a7bc1f6,\n    0x143c0f28, 0x500a0514, 0x63a557c6, 0x75cd9a63, 0x1d278b3a, 0x74f2791d,\n    0x0b1d7916, 0x2cf9800b, 0x8b6419ef, 0x27b9a08b, 0xb32c0b9f, 0xc7a5aeb3,\n    0xf3ec3b1f, 0x3e85bef3, 0xb22f899d, 0xc359d0b2, 0x3b4d6d76, 0xece18c3b,\n    0x08180610, 0x20040208, 0x4bdd4996, 0xd5d9904b, 0x10300c20, 0x40080410,\n    0xa61386b5, 0x9353d5a6, 0x3256e964, 0xc819f032, 0xb932f08b, 0xefa050b9,\n    0xa8017ea9, 0xab542aa8, 0x924f91dd, 0x4349d892, 0xf1eac61b, 0x368442f1,\n    0x56fac2ac, 0xa12be956, 0xdd9edb43, 0x869249dd, 0x21639a42, 0x84ec7621,\n    0xbf380e87, 0xf7a3adbf, 0x040c0308, 0x10020104, 0xbe3b8c85, 0xf35fd3be,\n    0xd683a255, 0xaa6bc9d6, 0xfdfec303, 0x068241fd, 0x779958ee, 0x25c79f77,\n    0xeac7b32d, 0x5a75c6ea, 0x3a4eef74, 0xe81df23a, 0xc8a15669, 0xd26432c8,\n    0x8f681ae7, 0x37bba18f, 0x57f940ae, 0xa5d79757, 0x1e22f43c, 0x780ffb1e,\n    0xfaf7bf0d, 0x1a7dc2fa, 0x2b7d6156, 0xace9882b, 0x58e83ab0, 0x992c1658,\n    0xc5b6d173, 0xe69e4fc5, 0x2769644e, 0x9cef8b27, 0xac0d7da1, 0xbb562bac,\n    0xe3dc373f, 0x7e8dbae3, 0xedcecf23, 0x468a45ed, 0x974010d7, 0x57b7a797,\n    0xbb340d8f, 0xe7a1acbb, 0x46cace8c, 0xe123ed46, 0x050f810a, 0x14fe7f05,\n    0x40c03080, 0xf9201040, 0x31539662, 0xc4e47231, 0xe5d6c933, 0x668e47e5,\n    0x3759686e, 0xdce78f37, 0x2c741d58, 0xb0160b2c, 0x9e5b94c5, 0x734fdb9e,\n    0x0a1efb14, 0x2805fe0a, 0xb12af69b, 0xcfa452b1, 0xb526f593, 0xdfa653b5,\n    0x060afe0c, 0x1803fd06, 0x6cb42dd8, 0x49361b6c, 0x1f21763e, 0x7cf3851f,\n    0xa31c07bf, 0x87adaaa3, 0x2a7ee354, 0xa815f62a, 0x709024e0, 0x39381c70,\n    0xfff83e07, 0x0e83bdff, 0xba378f8d, 0xe35dd2ba, 0x07097c0e, 0x1cff8307,\n    0x246c1b48, 0x90120924, 0x163af22c, 0x580bf916, 0xc6b3ae75, 0xea63cdc6,\n    0x61a3aac2, 0x7dcc6661};\n\nconst DWORD tbsm2_128[512] = {\n    0x5dbbba8d, 0xd2695de7, 0xdea4458a, 0x6fcbde9b, 0x00000000, 0x00000000,\n    0xb70897d7, 0xa7afb720, 0xd3235fbe, 0x95b6d38c, 0xcaab6dda, 0x65cecaa7,\n    0x3c1178f0, 0x1e0f3c44, 0x0d871a34, 0xfa7d0d17, 0xc32f7ffe, 0x9db2c3bc,\n    0xf8420912, 0x7c3ef8f1, 0xcb296fde, 0x99b0cba4, 0x8de7e33f, 0xba5d8d6e,\n    0x76daec21, 0x3be1769a, 0x89e4eb2f, 0xb85c8962, 0xaa83ada3, 0x55d6aa07,\n    0x12f12448, 0x09f81236, 0x8866e92b, 0x44228861, 0x22e54488, 0x11f42266,\n    0x4f4a9ec5, 0xdb914fd1, 0xdb254f9e, 0x91b4db94, 0x6dafda4d, 0xca656db7,\n    0x474c8ee5, 0xdf9347c9, 0xe44b3162, 0x7239e4d5, 0x4c3598c9, 0x26134cd4,\n    0x7822f019, 0x3c1e7888, 0x9a97cd63, 0x4dda9a57, 0x49b492dd, 0xd86c49db,\n    0x9313df47, 0xb5a6934c, 0xc45371e2, 0x6231c4b5, 0xc05079f2, 0x6030c0b9,\n    0x869ef513, 0x43dd8673, 0x1373264c, 0xf5861335, 0xa9fcabaf, 0xa854a902,\n    0x20184080, 0x10082060, 0x5343a6b5, 0xd59653f5, 0x1c093870, 0x0e071c24,\n    0x4ec89cc1, 0x27ef4ed2, 0xcf2a67ce, 0x9bb1cfa8, 0x35956ad4, 0xe673355f,\n    0x399072e4, 0xe070394b, 0xb47791db, 0x5a2db425, 0xa1fabb8f, 0xac56a11a,\n    0x543fa8a9, 0x2a1554fc, 0x642bc869, 0x321964ac, 0x037f060c, 0xfd820305,\n    0xc72c77ee, 0x9fb3c7b0, 0x85e1f31f, 0xbe5f8576, 0x5c39b889, 0x2e175ce4,\n    0x5b45b695, 0xd1945bed, 0xcdd763c6, 0x9a4dcdae, 0xd85a4992, 0x6c36d891,\n    0x72d9e431, 0x39e07296, 0x9692d553, 0x4bd99643, 0x42cd84f1, 0x21ec42c6,\n    0xb87289eb, 0x5c2eb831, 0xe1ca3b76, 0x8c46e1da, 0xa285bd83, 0x51d4a21f,\n    0x6028c079, 0x301860a0, 0xef32274e, 0x8bb9efc8, 0xbdf383ff, 0xa251bd3e,\n    0x02fd0408, 0x01fc0206, 0xaf02a7b7, 0xaba9af08, 0x8c65e13b, 0x46238c6d,\n    0x735be635, 0xc59e7395, 0x7c21f809, 0x3e1f7c84, 0x7f5efe05, 0xc39d7f81,\n    0x5ec4bc81, 0x2feb5ee2, 0xf9c00b16, 0x8040f9f2, 0x65a9ca6d, 0xce6765af,\n    0xe6b6356a, 0x73c5e6d3, 0xeb312f5e, 0x89b8ebc4, 0xadffa3bf, 0xaa55ad0e,\n    0x5ac7b491, 0x2dea5aee, 0xa5f9b39f, 0xae57a516, 0x79a0f21d, 0xc060798b,\n    0x8e98e533, 0x47df8e6b, 0x158d2a54, 0xf67b153f, 0x301460c0, 0x180c3050,\n    0xec4d2142, 0x763beccd, 0xa47bb19b, 0x5229a415, 0xc2ad7dfa, 0x61ccc2bf,\n    0x3eec7cf8, 0x1ff33e42, 0xe0483972, 0x7038e0d9, 0x7427e829, 0x3a1d749c,\n    0x51bea2bd, 0xd46a51f3, 0xfb3d0f1e, 0x81bcfbf4, 0x2d9f5ab4, 0xea752d77,\n    0x6ed0dc41, 0x37e76eb2, 0x946fd15b, 0x4a259445, 0x4db79acd, 0xda6d4dd7,\n    0x55bdaaad, 0xd66b55ff, 0x341768d0, 0x1a0d345c, 0xae80a5b3, 0x57d7ae0b,\n    0x52c1a4b1, 0x29e852f6, 0x7edcfc01, 0x3fe37e82, 0x9debc37f, 0xb2599d5e,\n    0x4acb94d1, 0x25ee4ade, 0xf738172e, 0x87bff7e0, 0x8060f90b, 0x40208079,\n    0xf0441932, 0x783cf0e9, 0xd05c59b2, 0x6834d089, 0x906cd94b, 0x48249049,\n    0xa704b797, 0xafaba710, 0xe84e2952, 0x743ae8c1, 0x9f16c777, 0xb3a59f58,\n    0x503ca0b9, 0x281450f0, 0xd5dd53a6, 0x964bd586, 0xd1de5bb6, 0x944ad18a,\n    0x986ac96b, 0x4c269851, 0xcc5561c2, 0x6633ccad, 0xa078b98b, 0x5028a019,\n    0x17702e5c, 0xf7871739, 0xf4471122, 0x7a3df4e5, 0xb68a95d3, 0x5bd1b623,\n    0xc1d27bf6, 0x9c4ec1ba, 0x281e50a0, 0x140a2878, 0x5f46be85, 0xd3955fe1,\n    0x26e64c98, 0x13f5266a, 0x01820204, 0xfc7e0103, 0xab01afa7, 0xa9a8ab04,\n    0x25994a94, 0xee77256f, 0x381270e0, 0x1c0e3848, 0x829dfd03, 0x41dc827f,\n    0x7da3fa0d, 0xc2617d87, 0x483690d9, 0x241248d8, 0xfc410102, 0x7e3ffcfd,\n    0x1b75366c, 0xf1841b2d, 0xcea865ca, 0x67cfceab, 0x3f6e7efc, 0xe38d3f41,\n    0x6b51d655, 0xc9986bbd, 0xe2b53d7a, 0x71c4e2df, 0x6754ce65, 0xcf9b67a9,\n    0x66d6cc61, 0x33e566aa, 0x434f86f5, 0xdd9243c5, 0x59b8b29d, 0xd06859eb,\n    0x19883264, 0xf078192b, 0x8463f11b, 0x42218475, 0x3d937af4, 0xe2713d47,\n    0xf5c51326, 0x8643f5e6, 0x2f625ebc, 0xeb892f71, 0xc9d46bd6, 0x984cc9a2,\n    0xbc7181fb, 0x5e2fbc3d, 0xd9d84b96, 0x9048d992, 0x95edd35f, 0xb65b9546,\n    0x299c52a4, 0xe874297b, 0x41b282fd, 0xdc6e41c3, 0xdaa74d9a, 0x6dcada97,\n    0x1af73468, 0x0dfa1a2e, 0xb07499cb, 0x582cb029, 0xe9cc2b56, 0x8844e9c2,\n    0x69acd25d, 0xc86469bb, 0xd2a15dba, 0x69c8d28f, 0x7b5df615, 0xc19c7b8d,\n    0xd72057ae, 0x97b7d780, 0x118e2244, 0xf47a1133, 0x9b15cf67, 0xb1a49b54,\n    0x336b66cc, 0xe58e3355, 0x8a9bed23, 0x45de8a67, 0x2367468c, 0xed8a2365,\n    0x09841224, 0xf87c091b, 0xd45f51a2, 0x6a35d485, 0x71a6e23d, 0xc4627193,\n    0x443388e9, 0x221144cc, 0x682ed059, 0x341a68b8, 0x6f52de45, 0xcb996fb1,\n    0xf2b91d3a, 0x79c0f2ef, 0x0ef81c38, 0x07ff0e12, 0xdf26478e, 0x93b5df98,\n    0x871cf717, 0xbfa38770, 0xdc594182, 0x6e37dc9d, 0x831fff07, 0xbda2837c,\n    0x180a3060, 0x0c061828, 0x6ad3d451, 0x35e66abe, 0xeeb0254a, 0x77c7eecb,\n    0x99e8cb6f, 0xb0589952, 0x81e2fb0f, 0xbc5e817a, 0x62d5c471, 0x31e462a6,\n    0x36ea6cd8, 0x1bf1365a, 0x2ee05cb8, 0x17f72e72, 0x7adff411, 0x3de27a8e,\n    0xfebc050a, 0x7fc3fefb, 0x45b18aed, 0xde6f45cf, 0x9c69c17b, 0x4e279c5d,\n    0x75a5ea2d, 0xc663759f, 0x91eedb4f, 0xb45a914a, 0x0c051830, 0x06030c14,\n    0x0f7a1e3c, 0xfb810f11, 0xe734376e, 0x8fbbe7d0, 0xf6ba152a, 0x7bc1f6e3,\n    0x140f2850, 0x0a05143c, 0x6357c675, 0xcd9a63a5, 0x1d8b3a74, 0xf2791d27,\n    0x0b79162c, 0xf9800b1d, 0x8b19ef27, 0xb9a08b64, 0xb30b9fc7, 0xa5aeb32c,\n    0xf33b1f3e, 0x85bef3ec, 0xb2899dc3, 0x59d0b22f, 0x3b6d76ec, 0xe18c3b4d,\n    0x08061020, 0x04020818, 0x4b4996d5, 0xd9904bdd, 0x100c2040, 0x08041030,\n    0xa686b593, 0x53d5a613, 0x32e964c8, 0x19f03256, 0xb9f08bef, 0xa050b932,\n    0xa87ea9ab, 0x542aa801, 0x9291dd43, 0x49d8924f, 0xf1c61b36, 0x8442f1ea,\n    0x56c2aca1, 0x2be956fa, 0xdddb4386, 0x9249dd9e, 0x219a4284, 0xec762163,\n    0xbf0e87f7, 0xa3adbf38, 0x04030810, 0x0201040c, 0xbe8c85f3, 0x5fd3be3b,\n    0xd6a255aa, 0x6bc9d683, 0xfdc30306, 0x8241fdfe, 0x7758ee25, 0xc79f7799,\n    0xeab32d5a, 0x75c6eac7, 0x3aef74e8, 0x1df23a4e, 0xc85669d2, 0x6432c8a1,\n    0x8f1ae737, 0xbba18f68, 0x5740aea5, 0xd79757f9, 0x1ef43c78, 0x0ffb1e22,\n    0xfabf0d1a, 0x7dc2faf7, 0x2b6156ac, 0xe9882b7d, 0x583ab099, 0x2c1658e8,\n    0xc5d173e6, 0x9e4fc5b6, 0x27644e9c, 0xef8b2769, 0xac7da1bb, 0x562bac0d,\n    0xe3373f7e, 0x8dbae3dc, 0xedcf2346, 0x8a45edce, 0x9710d757, 0xb7a79740,\n    0xbb0d8fe7, 0xa1acbb34, 0x46ce8ce1, 0x23ed46ca, 0x05810a14, 0xfe7f050f,\n    0x403080f9, 0x201040c0, 0x319662c4, 0xe4723153, 0xe5c93366, 0x8e47e5d6,\n    0x37686edc, 0xe78f3759, 0x2c1d58b0, 0x160b2c74, 0x9e94c573, 0x4fdb9e5b,\n    0x0afb1428, 0x05fe0a1e, 0xb1f69bcf, 0xa452b12a, 0xb5f593df, 0xa653b526,\n    0x06fe0c18, 0x03fd060a, 0x6c2dd849, 0x361b6cb4, 0x1f763e7c, 0xf3851f21,\n    0xa307bf87, 0xadaaa31c, 0x2ae354a8, 0x15f62a7e, 0x7024e039, 0x381c7090,\n    0xff3e070e, 0x83bdfff8, 0xba8f8de3, 0x5dd2ba37, 0x077c0e1c, 0xff830709,\n    0x241b4890, 0x1209246c, 0x16f22c58, 0x0bf9163a, 0xc6ae75ea, 0x63cdc6b3,\n    0x61aac27d, 0xcc6661a3};\n\nconst DWORD tbsm3_128[512] = {\n    0x5dba8dd2, 0x695de7bb, 0xde458a6f, 0xcbde9ba4, 0x00000000, 0x00000000,\n    0xb797d7a7, 0xafb72008, 0xd35fbe95, 0xb6d38c23, 0xca6dda65, 0xcecaa7ab,\n    0x3c78f01e, 0x0f3c4411, 0x0d1a34fa, 0x7d0d1787, 0xc37ffe9d, 0xb2c3bc2f,\n    0xf809127c, 0x3ef8f142, 0xcb6fde99, 0xb0cba429, 0x8de33fba, 0x5d8d6ee7,\n    0x76ec213b, 0xe1769ada, 0x89eb2fb8, 0x5c8962e4, 0xaaada355, 0xd6aa0783,\n    0x12244809, 0xf81236f1, 0x88e92b44, 0x22886166, 0x22448811, 0xf42266e5,\n    0x4f9ec5db, 0x914fd14a, 0xdb4f9e91, 0xb4db9425, 0x6dda4dca, 0x656db7af,\n    0x478ee5df, 0x9347c94c, 0xe4316272, 0x39e4d54b, 0x4c98c926, 0x134cd435,\n    0x78f0193c, 0x1e788822, 0x9acd634d, 0xda9a5797, 0x4992ddd8, 0x6c49dbb4,\n    0x93df47b5, 0xa6934c13, 0xc471e262, 0x31c4b553, 0xc079f260, 0x30c0b950,\n    0x86f51343, 0xdd86739e, 0x13264cf5, 0x86133573, 0xa9abafa8, 0x54a902fc,\n    0x20408010, 0x08206018, 0x53a6b5d5, 0x9653f543, 0x1c38700e, 0x071c2409,\n    0x4e9cc127, 0xef4ed2c8, 0xcf67ce9b, 0xb1cfa82a, 0x356ad4e6, 0x73355f95,\n    0x3972e4e0, 0x70394b90, 0xb491db5a, 0x2db42577, 0xa1bb8fac, 0x56a11afa,\n    0x54a8a92a, 0x1554fc3f, 0x64c86932, 0x1964ac2b, 0x03060cfd, 0x8203057f,\n    0xc777ee9f, 0xb3c7b02c, 0x85f31fbe, 0x5f8576e1, 0x5cb8892e, 0x175ce439,\n    0x5bb695d1, 0x945bed45, 0xcd63c69a, 0x4dcdaed7, 0xd849926c, 0x36d8915a,\n    0x72e43139, 0xe07296d9, 0x96d5534b, 0xd9964392, 0x4284f121, 0xec42c6cd,\n    0xb889eb5c, 0x2eb83172, 0xe13b768c, 0x46e1daca, 0xa2bd8351, 0xd4a21f85,\n    0x60c07930, 0x1860a028, 0xef274e8b, 0xb9efc832, 0xbd83ffa2, 0x51bd3ef3,\n    0x02040801, 0xfc0206fd, 0xafa7b7ab, 0xa9af0802, 0x8ce13b46, 0x238c6d65,\n    0x73e635c5, 0x9e73955b, 0x7cf8093e, 0x1f7c8421, 0x7ffe05c3, 0x9d7f815e,\n    0x5ebc812f, 0xeb5ee2c4, 0xf90b1680, 0x40f9f2c0, 0x65ca6dce, 0x6765afa9,\n    0xe6356a73, 0xc5e6d3b6, 0xeb2f5e89, 0xb8ebc431, 0xada3bfaa, 0x55ad0eff,\n    0x5ab4912d, 0xea5aeec7, 0xa5b39fae, 0x57a516f9, 0x79f21dc0, 0x60798ba0,\n    0x8ee53347, 0xdf8e6b98, 0x152a54f6, 0x7b153f8d, 0x3060c018, 0x0c305014,\n    0xec214276, 0x3beccd4d, 0xa4b19b52, 0x29a4157b, 0xc27dfa61, 0xccc2bfad,\n    0x3e7cf81f, 0xf33e42ec, 0xe0397270, 0x38e0d948, 0x74e8293a, 0x1d749c27,\n    0x51a2bdd4, 0x6a51f3be, 0xfb0f1e81, 0xbcfbf43d, 0x2d5ab4ea, 0x752d779f,\n    0x6edc4137, 0xe76eb2d0, 0x94d15b4a, 0x2594456f, 0x4d9acdda, 0x6d4dd7b7,\n    0x55aaadd6, 0x6b55ffbd, 0x3468d01a, 0x0d345c17, 0xaea5b357, 0xd7ae0b80,\n    0x52a4b129, 0xe852f6c1, 0x7efc013f, 0xe37e82dc, 0x9dc37fb2, 0x599d5eeb,\n    0x4a94d125, 0xee4adecb, 0xf7172e87, 0xbff7e038, 0x80f90b40, 0x20807960,\n    0xf0193278, 0x3cf0e944, 0xd059b268, 0x34d0895c, 0x90d94b48, 0x2490496c,\n    0xa7b797af, 0xaba71004, 0xe8295274, 0x3ae8c14e, 0x9fc777b3, 0xa59f5816,\n    0x50a0b928, 0x1450f03c, 0xd553a696, 0x4bd586dd, 0xd15bb694, 0x4ad18ade,\n    0x98c96b4c, 0x2698516a, 0xcc61c266, 0x33ccad55, 0xa0b98b50, 0x28a01978,\n    0x172e5cf7, 0x87173970, 0xf411227a, 0x3df4e547, 0xb695d35b, 0xd1b6238a,\n    0xc17bf69c, 0x4ec1bad2, 0x2850a014, 0x0a28781e, 0x5fbe85d3, 0x955fe146,\n    0x264c9813, 0xf5266ae6, 0x010204fc, 0x7e010382, 0xabafa7a9, 0xa8ab0401,\n    0x254a94ee, 0x77256f99, 0x3870e01c, 0x0e384812, 0x82fd0341, 0xdc827f9d,\n    0x7dfa0dc2, 0x617d87a3, 0x4890d924, 0x1248d836, 0xfc01027e, 0x3ffcfd41,\n    0x1b366cf1, 0x841b2d75, 0xce65ca67, 0xcfceaba8, 0x3f7efce3, 0x8d3f416e,\n    0x6bd655c9, 0x986bbd51, 0xe23d7a71, 0xc4e2dfb5, 0x67ce65cf, 0x9b67a954,\n    0x66cc6133, 0xe566aad6, 0x4386f5dd, 0x9243c54f, 0x59b29dd0, 0x6859ebb8,\n    0x193264f0, 0x78192b88, 0x84f11b42, 0x21847563, 0x3d7af4e2, 0x713d4793,\n    0xf5132686, 0x43f5e6c5, 0x2f5ebceb, 0x892f7162, 0xc96bd698, 0x4cc9a2d4,\n    0xbc81fb5e, 0x2fbc3d71, 0xd94b9690, 0x48d992d8, 0x95d35fb6, 0x5b9546ed,\n    0x2952a4e8, 0x74297b9c, 0x4182fddc, 0x6e41c3b2, 0xda4d9a6d, 0xcada97a7,\n    0x1a34680d, 0xfa1a2ef7, 0xb099cb58, 0x2cb02974, 0xe92b5688, 0x44e9c2cc,\n    0x69d25dc8, 0x6469bbac, 0xd25dba69, 0xc8d28fa1, 0x7bf615c1, 0x9c7b8d5d,\n    0xd757ae97, 0xb7d78020, 0x112244f4, 0x7a11338e, 0x9bcf67b1, 0xa49b5415,\n    0x3366cce5, 0x8e33556b, 0x8aed2345, 0xde8a679b, 0x23468ced, 0x8a236567,\n    0x091224f8, 0x7c091b84, 0xd451a26a, 0x35d4855f, 0x71e23dc4, 0x627193a6,\n    0x4488e922, 0x1144cc33, 0x68d05934, 0x1a68b82e, 0x6fde45cb, 0x996fb152,\n    0xf21d3a79, 0xc0f2efb9, 0x0e1c3807, 0xff0e12f8, 0xdf478e93, 0xb5df9826,\n    0x87f717bf, 0xa387701c, 0xdc41826e, 0x37dc9d59, 0x83ff07bd, 0xa2837c1f,\n    0x1830600c, 0x0618280a, 0x6ad45135, 0xe66abed3, 0xee254a77, 0xc7eecbb0,\n    0x99cb6fb0, 0x589952e8, 0x81fb0fbc, 0x5e817ae2, 0x62c47131, 0xe462a6d5,\n    0x366cd81b, 0xf1365aea, 0x2e5cb817, 0xf72e72e0, 0x7af4113d, 0xe27a8edf,\n    0xfe050a7f, 0xc3fefbbc, 0x458aedde, 0x6f45cfb1, 0x9cc17b4e, 0x279c5d69,\n    0x75ea2dc6, 0x63759fa5, 0x91db4fb4, 0x5a914aee, 0x0c183006, 0x030c1405,\n    0x0f1e3cfb, 0x810f117a, 0xe7376e8f, 0xbbe7d034, 0xf6152a7b, 0xc1f6e3ba,\n    0x1428500a, 0x05143c0f, 0x63c675cd, 0x9a63a557, 0x1d3a74f2, 0x791d278b,\n    0x0b162cf9, 0x800b1d79, 0x8bef27b9, 0xa08b6419, 0xb39fc7a5, 0xaeb32c0b,\n    0xf31f3e85, 0xbef3ec3b, 0xb29dc359, 0xd0b22f89, 0x3b76ece1, 0x8c3b4d6d,\n    0x08102004, 0x02081806, 0x4b96d5d9, 0x904bdd49, 0x10204008, 0x0410300c,\n    0xa6b59353, 0xd5a61386, 0x3264c819, 0xf03256e9, 0xb98befa0, 0x50b932f0,\n    0xa8a9ab54, 0x2aa8017e, 0x92dd4349, 0xd8924f91, 0xf11b3684, 0x42f1eac6,\n    0x56aca12b, 0xe956fac2, 0xdd438692, 0x49dd9edb, 0x214284ec, 0x7621639a,\n    0xbf87f7a3, 0xadbf380e, 0x04081002, 0x01040c03, 0xbe85f35f, 0xd3be3b8c,\n    0xd655aa6b, 0xc9d683a2, 0xfd030682, 0x41fdfec3, 0x77ee25c7, 0x9f779958,\n    0xea2d5a75, 0xc6eac7b3, 0x3a74e81d, 0xf23a4eef, 0xc869d264, 0x32c8a156,\n    0x8fe737bb, 0xa18f681a, 0x57aea5d7, 0x9757f940, 0x1e3c780f, 0xfb1e22f4,\n    0xfa0d1a7d, 0xc2faf7bf, 0x2b56ace9, 0x882b7d61, 0x58b0992c, 0x1658e83a,\n    0xc573e69e, 0x4fc5b6d1, 0x274e9cef, 0x8b276964, 0xaca1bb56, 0x2bac0d7d,\n    0xe33f7e8d, 0xbae3dc37, 0xed23468a, 0x45edcecf, 0x97d757b7, 0xa7974010,\n    0xbb8fe7a1, 0xacbb340d, 0x468ce123, 0xed46cace, 0x050a14fe, 0x7f050f81,\n    0x4080f920, 0x1040c030, 0x3162c4e4, 0x72315396, 0xe533668e, 0x47e5d6c9,\n    0x376edce7, 0x8f375968, 0x2c58b016, 0x0b2c741d, 0x9ec5734f, 0xdb9e5b94,\n    0x0a142805, 0xfe0a1efb, 0xb19bcfa4, 0x52b12af6, 0xb593dfa6, 0x53b526f5,\n    0x060c1803, 0xfd060afe, 0x6cd84936, 0x1b6cb42d, 0x1f3e7cf3, 0x851f2176,\n    0xa3bf87ad, 0xaaa31c07, 0x2a54a815, 0xf62a7ee3, 0x70e03938, 0x1c709024,\n    0xff070e83, 0xbdfff83e, 0xba8de35d, 0xd2ba378f, 0x070e1cff, 0x8307097c,\n    0x24489012, 0x09246c1b, 0x162c580b, 0xf9163af2, 0xc675ea63, 0xcdc6b3ae,\n    0x61c27dcc, 0x6661a3aa};\n\nconst DWORD tbsm4_128[512] = {\n    0x5d8dd269, 0x5de7bbba, 0xde8a6fcb, 0xde9ba445, 0x00000000, 0x00000000,\n    0xb7d7a7af, 0xb7200897, 0xd3be95b6, 0xd38c235f, 0xcada65ce, 0xcaa7ab6d,\n    0x3cf01e0f, 0x3c441178, 0x0d34fa7d, 0x0d17871a, 0xc3fe9db2, 0xc3bc2f7f,\n    0xf8127c3e, 0xf8f14209, 0xcbde99b0, 0xcba4296f, 0x8d3fba5d, 0x8d6ee7e3,\n    0x76213be1, 0x769adaec, 0x892fb85c, 0x8962e4eb, 0xaaa355d6, 0xaa0783ad,\n    0x124809f8, 0x1236f124, 0x882b4422, 0x886166e9, 0x228811f4, 0x2266e544,\n    0x4fc5db91, 0x4fd14a9e, 0xdb9e91b4, 0xdb94254f, 0x6d4dca65, 0x6db7afda,\n    0x47e5df93, 0x47c94c8e, 0xe4627239, 0xe4d54b31, 0x4cc92613, 0x4cd43598,\n    0x78193c1e, 0x788822f0, 0x9a634dda, 0x9a5797cd, 0x49ddd86c, 0x49dbb492,\n    0x9347b5a6, 0x934c13df, 0xc4e26231, 0xc4b55371, 0xc0f26030, 0xc0b95079,\n    0x861343dd, 0x86739ef5, 0x134cf586, 0x13357326, 0xa9afa854, 0xa902fcab,\n    0x20801008, 0x20601840, 0x53b5d596, 0x53f543a6, 0x1c700e07, 0x1c240938,\n    0x4ec127ef, 0x4ed2c89c, 0xcfce9bb1, 0xcfa82a67, 0x35d4e673, 0x355f956a,\n    0x39e4e070, 0x394b9072, 0xb4db5a2d, 0xb4257791, 0xa18fac56, 0xa11afabb,\n    0x54a92a15, 0x54fc3fa8, 0x64693219, 0x64ac2bc8, 0x030cfd82, 0x03057f06,\n    0xc7ee9fb3, 0xc7b02c77, 0x851fbe5f, 0x8576e1f3, 0x5c892e17, 0x5ce439b8,\n    0x5b95d194, 0x5bed45b6, 0xcdc69a4d, 0xcdaed763, 0xd8926c36, 0xd8915a49,\n    0x723139e0, 0x7296d9e4, 0x96534bd9, 0x964392d5, 0x42f121ec, 0x42c6cd84,\n    0xb8eb5c2e, 0xb8317289, 0xe1768c46, 0xe1daca3b, 0xa28351d4, 0xa21f85bd,\n    0x60793018, 0x60a028c0, 0xef4e8bb9, 0xefc83227, 0xbdffa251, 0xbd3ef383,\n    0x020801fc, 0x0206fd04, 0xafb7aba9, 0xaf0802a7, 0x8c3b4623, 0x8c6d65e1,\n    0x7335c59e, 0x73955be6, 0x7c093e1f, 0x7c8421f8, 0x7f05c39d, 0x7f815efe,\n    0x5e812feb, 0x5ee2c4bc, 0xf9168040, 0xf9f2c00b, 0x656dce67, 0x65afa9ca,\n    0xe66a73c5, 0xe6d3b635, 0xeb5e89b8, 0xebc4312f, 0xadbfaa55, 0xad0effa3,\n    0x5a912dea, 0x5aeec7b4, 0xa59fae57, 0xa516f9b3, 0x791dc060, 0x798ba0f2,\n    0x8e3347df, 0x8e6b98e5, 0x1554f67b, 0x153f8d2a, 0x30c0180c, 0x30501460,\n    0xec42763b, 0xeccd4d21, 0xa49b5229, 0xa4157bb1, 0xc2fa61cc, 0xc2bfad7d,\n    0x3ef81ff3, 0x3e42ec7c, 0xe0727038, 0xe0d94839, 0x74293a1d, 0x749c27e8,\n    0x51bdd46a, 0x51f3bea2, 0xfb1e81bc, 0xfbf43d0f, 0x2db4ea75, 0x2d779f5a,\n    0x6e4137e7, 0x6eb2d0dc, 0x945b4a25, 0x94456fd1, 0x4dcdda6d, 0x4dd7b79a,\n    0x55add66b, 0x55ffbdaa, 0x34d01a0d, 0x345c1768, 0xaeb357d7, 0xae0b80a5,\n    0x52b129e8, 0x52f6c1a4, 0x7e013fe3, 0x7e82dcfc, 0x9d7fb259, 0x9d5eebc3,\n    0x4ad125ee, 0x4adecb94, 0xf72e87bf, 0xf7e03817, 0x800b4020, 0x807960f9,\n    0xf032783c, 0xf0e94419, 0xd0b26834, 0xd0895c59, 0x904b4824, 0x90496cd9,\n    0xa797afab, 0xa71004b7, 0xe852743a, 0xe8c14e29, 0x9f77b3a5, 0x9f5816c7,\n    0x50b92814, 0x50f03ca0, 0xd5a6964b, 0xd586dd53, 0xd1b6944a, 0xd18ade5b,\n    0x986b4c26, 0x98516ac9, 0xccc26633, 0xccad5561, 0xa08b5028, 0xa01978b9,\n    0x175cf787, 0x1739702e, 0xf4227a3d, 0xf4e54711, 0xb6d35bd1, 0xb6238a95,\n    0xc1f69c4e, 0xc1bad27b, 0x28a0140a, 0x28781e50, 0x5f85d395, 0x5fe146be,\n    0x269813f5, 0x266ae64c, 0x0104fc7e, 0x01038202, 0xaba7a9a8, 0xab0401af,\n    0x2594ee77, 0x256f994a, 0x38e01c0e, 0x38481270, 0x820341dc, 0x827f9dfd,\n    0x7d0dc261, 0x7d87a3fa, 0x48d92412, 0x48d83690, 0xfc027e3f, 0xfcfd4101,\n    0x1b6cf184, 0x1b2d7536, 0xceca67cf, 0xceaba865, 0x3ffce38d, 0x3f416e7e,\n    0x6b55c998, 0x6bbd51d6, 0xe27a71c4, 0xe2dfb53d, 0x6765cf9b, 0x67a954ce,\n    0x666133e5, 0x66aad6cc, 0x43f5dd92, 0x43c54f86, 0x599dd068, 0x59ebb8b2,\n    0x1964f078, 0x192b8832, 0x841b4221, 0x847563f1, 0x3df4e271, 0x3d47937a,\n    0xf5268643, 0xf5e6c513, 0x2fbceb89, 0x2f71625e, 0xc9d6984c, 0xc9a2d46b,\n    0xbcfb5e2f, 0xbc3d7181, 0xd9969048, 0xd992d84b, 0x955fb65b, 0x9546edd3,\n    0x29a4e874, 0x297b9c52, 0x41fddc6e, 0x41c3b282, 0xda9a6dca, 0xda97a74d,\n    0x1a680dfa, 0x1a2ef734, 0xb0cb582c, 0xb0297499, 0xe9568844, 0xe9c2cc2b,\n    0x695dc864, 0x69bbacd2, 0xd2ba69c8, 0xd28fa15d, 0x7b15c19c, 0x7b8d5df6,\n    0xd7ae97b7, 0xd7802057, 0x1144f47a, 0x11338e22, 0x9b67b1a4, 0x9b5415cf,\n    0x33cce58e, 0x33556b66, 0x8a2345de, 0x8a679bed, 0x238ced8a, 0x23656746,\n    0x0924f87c, 0x091b8412, 0xd4a26a35, 0xd4855f51, 0x713dc462, 0x7193a6e2,\n    0x44e92211, 0x44cc3388, 0x6859341a, 0x68b82ed0, 0x6f45cb99, 0x6fb152de,\n    0xf23a79c0, 0xf2efb91d, 0x0e3807ff, 0x0e12f81c, 0xdf8e93b5, 0xdf982647,\n    0x8717bfa3, 0x87701cf7, 0xdc826e37, 0xdc9d5941, 0x8307bda2, 0x837c1fff,\n    0x18600c06, 0x18280a30, 0x6a5135e6, 0x6abed3d4, 0xee4a77c7, 0xeecbb025,\n    0x996fb058, 0x9952e8cb, 0x810fbc5e, 0x817ae2fb, 0x627131e4, 0x62a6d5c4,\n    0x36d81bf1, 0x365aea6c, 0x2eb817f7, 0x2e72e05c, 0x7a113de2, 0x7a8edff4,\n    0xfe0a7fc3, 0xfefbbc05, 0x45edde6f, 0x45cfb18a, 0x9c7b4e27, 0x9c5d69c1,\n    0x752dc663, 0x759fa5ea, 0x914fb45a, 0x914aeedb, 0x0c300603, 0x0c140518,\n    0x0f3cfb81, 0x0f117a1e, 0xe76e8fbb, 0xe7d03437, 0xf62a7bc1, 0xf6e3ba15,\n    0x14500a05, 0x143c0f28, 0x6375cd9a, 0x63a557c6, 0x1d74f279, 0x1d278b3a,\n    0x0b2cf980, 0x0b1d7916, 0x8b27b9a0, 0x8b6419ef, 0xb3c7a5ae, 0xb32c0b9f,\n    0xf33e85be, 0xf3ec3b1f, 0xb2c359d0, 0xb22f899d, 0x3bece18c, 0x3b4d6d76,\n    0x08200402, 0x08180610, 0x4bd5d990, 0x4bdd4996, 0x10400804, 0x10300c20,\n    0xa69353d5, 0xa61386b5, 0x32c819f0, 0x3256e964, 0xb9efa050, 0xb932f08b,\n    0xa8ab542a, 0xa8017ea9, 0x924349d8, 0x924f91dd, 0xf1368442, 0xf1eac61b,\n    0x56a12be9, 0x56fac2ac, 0xdd869249, 0xdd9edb43, 0x2184ec76, 0x21639a42,\n    0xbff7a3ad, 0xbf380e87, 0x04100201, 0x040c0308, 0xbef35fd3, 0xbe3b8c85,\n    0xd6aa6bc9, 0xd683a255, 0xfd068241, 0xfdfec303, 0x7725c79f, 0x779958ee,\n    0xea5a75c6, 0xeac7b32d, 0x3ae81df2, 0x3a4eef74, 0xc8d26432, 0xc8a15669,\n    0x8f37bba1, 0x8f681ae7, 0x57a5d797, 0x57f940ae, 0x1e780ffb, 0x1e22f43c,\n    0xfa1a7dc2, 0xfaf7bf0d, 0x2bace988, 0x2b7d6156, 0x58992c16, 0x58e83ab0,\n    0xc5e69e4f, 0xc5b6d173, 0x279cef8b, 0x2769644e, 0xacbb562b, 0xac0d7da1,\n    0xe37e8dba, 0xe3dc373f, 0xed468a45, 0xedcecf23, 0x9757b7a7, 0x974010d7,\n    0xbbe7a1ac, 0xbb340d8f, 0x46e123ed, 0x46cace8c, 0x0514fe7f, 0x050f810a,\n    0x40f92010, 0x40c03080, 0x31c4e472, 0x31539662, 0xe5668e47, 0xe5d6c933,\n    0x37dce78f, 0x3759686e, 0x2cb0160b, 0x2c741d58, 0x9e734fdb, 0x9e5b94c5,\n    0x0a2805fe, 0x0a1efb14, 0xb1cfa452, 0xb12af69b, 0xb5dfa653, 0xb526f593,\n    0x061803fd, 0x060afe0c, 0x6c49361b, 0x6cb42dd8, 0x1f7cf385, 0x1f21763e,\n    0xa387adaa, 0xa31c07bf, 0x2aa815f6, 0x2a7ee354, 0x7039381c, 0x709024e0,\n    0xff0e83bd, 0xfff83e07, 0xbae35dd2, 0xba378f8d, 0x071cff83, 0x07097c0e,\n    0x24901209, 0x246c1b48, 0x16580bf9, 0x163af22c, 0xc6ea63cd, 0xc6b3ae75,\n    0x617dcc66, 0x61a3aac2};\n\nconst DWORD tbsm5_128[512] = {\n    0x5dd2695d, 0xe7bbba8d, 0xde6fcbde, 0x9ba4458a, 0x00000000, 0x00000000,\n    0xb7a7afb7, 0x200897d7, 0xd395b6d3, 0x8c235fbe, 0xca65ceca, 0xa7ab6dda,\n    0x3c1e0f3c, 0x441178f0, 0x0dfa7d0d, 0x17871a34, 0xc39db2c3, 0xbc2f7ffe,\n    0xf87c3ef8, 0xf1420912, 0xcb99b0cb, 0xa4296fde, 0x8dba5d8d, 0x6ee7e33f,\n    0x763be176, 0x9adaec21, 0x89b85c89, 0x62e4eb2f, 0xaa55d6aa, 0x0783ada3,\n    0x1209f812, 0x36f12448, 0x88442288, 0x6166e92b, 0x2211f422, 0x66e54488,\n    0x4fdb914f, 0xd14a9ec5, 0xdb91b4db, 0x94254f9e, 0x6dca656d, 0xb7afda4d,\n    0x47df9347, 0xc94c8ee5, 0xe47239e4, 0xd54b3162, 0x4c26134c, 0xd43598c9,\n    0x783c1e78, 0x8822f019, 0x9a4dda9a, 0x5797cd63, 0x49d86c49, 0xdbb492dd,\n    0x93b5a693, 0x4c13df47, 0xc46231c4, 0xb55371e2, 0xc06030c0, 0xb95079f2,\n    0x8643dd86, 0x739ef513, 0x13f58613, 0x3573264c, 0xa9a854a9, 0x02fcabaf,\n    0x20100820, 0x60184080, 0x53d59653, 0xf543a6b5, 0x1c0e071c, 0x24093870,\n    0x4e27ef4e, 0xd2c89cc1, 0xcf9bb1cf, 0xa82a67ce, 0x35e67335, 0x5f956ad4,\n    0x39e07039, 0x4b9072e4, 0xb45a2db4, 0x257791db, 0xa1ac56a1, 0x1afabb8f,\n    0x542a1554, 0xfc3fa8a9, 0x64321964, 0xac2bc869, 0x03fd8203, 0x057f060c,\n    0xc79fb3c7, 0xb02c77ee, 0x85be5f85, 0x76e1f31f, 0x5c2e175c, 0xe439b889,\n    0x5bd1945b, 0xed45b695, 0xcd9a4dcd, 0xaed763c6, 0xd86c36d8, 0x915a4992,\n    0x7239e072, 0x96d9e431, 0x964bd996, 0x4392d553, 0x4221ec42, 0xc6cd84f1,\n    0xb85c2eb8, 0x317289eb, 0xe18c46e1, 0xdaca3b76, 0xa251d4a2, 0x1f85bd83,\n    0x60301860, 0xa028c079, 0xef8bb9ef, 0xc832274e, 0xbda251bd, 0x3ef383ff,\n    0x0201fc02, 0x06fd0408, 0xafaba9af, 0x0802a7b7, 0x8c46238c, 0x6d65e13b,\n    0x73c59e73, 0x955be635, 0x7c3e1f7c, 0x8421f809, 0x7fc39d7f, 0x815efe05,\n    0x5e2feb5e, 0xe2c4bc81, 0xf98040f9, 0xf2c00b16, 0x65ce6765, 0xafa9ca6d,\n    0xe673c5e6, 0xd3b6356a, 0xeb89b8eb, 0xc4312f5e, 0xadaa55ad, 0x0effa3bf,\n    0x5a2dea5a, 0xeec7b491, 0xa5ae57a5, 0x16f9b39f, 0x79c06079, 0x8ba0f21d,\n    0x8e47df8e, 0x6b98e533, 0x15f67b15, 0x3f8d2a54, 0x30180c30, 0x501460c0,\n    0xec763bec, 0xcd4d2142, 0xa45229a4, 0x157bb19b, 0xc261ccc2, 0xbfad7dfa,\n    0x3e1ff33e, 0x42ec7cf8, 0xe07038e0, 0xd9483972, 0x743a1d74, 0x9c27e829,\n    0x51d46a51, 0xf3bea2bd, 0xfb81bcfb, 0xf43d0f1e, 0x2dea752d, 0x779f5ab4,\n    0x6e37e76e, 0xb2d0dc41, 0x944a2594, 0x456fd15b, 0x4dda6d4d, 0xd7b79acd,\n    0x55d66b55, 0xffbdaaad, 0x341a0d34, 0x5c1768d0, 0xae57d7ae, 0x0b80a5b3,\n    0x5229e852, 0xf6c1a4b1, 0x7e3fe37e, 0x82dcfc01, 0x9db2599d, 0x5eebc37f,\n    0x4a25ee4a, 0xdecb94d1, 0xf787bff7, 0xe038172e, 0x80402080, 0x7960f90b,\n    0xf0783cf0, 0xe9441932, 0xd06834d0, 0x895c59b2, 0x90482490, 0x496cd94b,\n    0xa7afaba7, 0x1004b797, 0xe8743ae8, 0xc14e2952, 0x9fb3a59f, 0x5816c777,\n    0x50281450, 0xf03ca0b9, 0xd5964bd5, 0x86dd53a6, 0xd1944ad1, 0x8ade5bb6,\n    0x984c2698, 0x516ac96b, 0xcc6633cc, 0xad5561c2, 0xa05028a0, 0x1978b98b,\n    0x17f78717, 0x39702e5c, 0xf47a3df4, 0xe5471122, 0xb65bd1b6, 0x238a95d3,\n    0xc19c4ec1, 0xbad27bf6, 0x28140a28, 0x781e50a0, 0x5fd3955f, 0xe146be85,\n    0x2613f526, 0x6ae64c98, 0x01fc7e01, 0x03820204, 0xaba9a8ab, 0x0401afa7,\n    0x25ee7725, 0x6f994a94, 0x381c0e38, 0x481270e0, 0x8241dc82, 0x7f9dfd03,\n    0x7dc2617d, 0x87a3fa0d, 0x48241248, 0xd83690d9, 0xfc7e3ffc, 0xfd410102,\n    0x1bf1841b, 0x2d75366c, 0xce67cfce, 0xaba865ca, 0x3fe38d3f, 0x416e7efc,\n    0x6bc9986b, 0xbd51d655, 0xe271c4e2, 0xdfb53d7a, 0x67cf9b67, 0xa954ce65,\n    0x6633e566, 0xaad6cc61, 0x43dd9243, 0xc54f86f5, 0x59d06859, 0xebb8b29d,\n    0x19f07819, 0x2b883264, 0x84422184, 0x7563f11b, 0x3de2713d, 0x47937af4,\n    0xf58643f5, 0xe6c51326, 0x2feb892f, 0x71625ebc, 0xc9984cc9, 0xa2d46bd6,\n    0xbc5e2fbc, 0x3d7181fb, 0xd99048d9, 0x92d84b96, 0x95b65b95, 0x46edd35f,\n    0x29e87429, 0x7b9c52a4, 0x41dc6e41, 0xc3b282fd, 0xda6dcada, 0x97a74d9a,\n    0x1a0dfa1a, 0x2ef73468, 0xb0582cb0, 0x297499cb, 0xe98844e9, 0xc2cc2b56,\n    0x69c86469, 0xbbacd25d, 0xd269c8d2, 0x8fa15dba, 0x7bc19c7b, 0x8d5df615,\n    0xd797b7d7, 0x802057ae, 0x11f47a11, 0x338e2244, 0x9bb1a49b, 0x5415cf67,\n    0x33e58e33, 0x556b66cc, 0x8a45de8a, 0x679bed23, 0x23ed8a23, 0x6567468c,\n    0x09f87c09, 0x1b841224, 0xd46a35d4, 0x855f51a2, 0x71c46271, 0x93a6e23d,\n    0x44221144, 0xcc3388e9, 0x68341a68, 0xb82ed059, 0x6fcb996f, 0xb152de45,\n    0xf279c0f2, 0xefb91d3a, 0x0e07ff0e, 0x12f81c38, 0xdf93b5df, 0x9826478e,\n    0x87bfa387, 0x701cf717, 0xdc6e37dc, 0x9d594182, 0x83bda283, 0x7c1fff07,\n    0x180c0618, 0x280a3060, 0x6a35e66a, 0xbed3d451, 0xee77c7ee, 0xcbb0254a,\n    0x99b05899, 0x52e8cb6f, 0x81bc5e81, 0x7ae2fb0f, 0x6231e462, 0xa6d5c471,\n    0x361bf136, 0x5aea6cd8, 0x2e17f72e, 0x72e05cb8, 0x7a3de27a, 0x8edff411,\n    0xfe7fc3fe, 0xfbbc050a, 0x45de6f45, 0xcfb18aed, 0x9c4e279c, 0x5d69c17b,\n    0x75c66375, 0x9fa5ea2d, 0x91b45a91, 0x4aeedb4f, 0x0c06030c, 0x14051830,\n    0x0ffb810f, 0x117a1e3c, 0xe78fbbe7, 0xd034376e, 0xf67bc1f6, 0xe3ba152a,\n    0x140a0514, 0x3c0f2850, 0x63cd9a63, 0xa557c675, 0x1df2791d, 0x278b3a74,\n    0x0bf9800b, 0x1d79162c, 0x8bb9a08b, 0x6419ef27, 0xb3a5aeb3, 0x2c0b9fc7,\n    0xf385bef3, 0xec3b1f3e, 0xb259d0b2, 0x2f899dc3, 0x3be18c3b, 0x4d6d76ec,\n    0x08040208, 0x18061020, 0x4bd9904b, 0xdd4996d5, 0x10080410, 0x300c2040,\n    0xa653d5a6, 0x1386b593, 0x3219f032, 0x56e964c8, 0xb9a050b9, 0x32f08bef,\n    0xa8542aa8, 0x017ea9ab, 0x9249d892, 0x4f91dd43, 0xf18442f1, 0xeac61b36,\n    0x562be956, 0xfac2aca1, 0xdd9249dd, 0x9edb4386, 0x21ec7621, 0x639a4284,\n    0xbfa3adbf, 0x380e87f7, 0x04020104, 0x0c030810, 0xbe5fd3be, 0x3b8c85f3,\n    0xd66bc9d6, 0x83a255aa, 0xfd8241fd, 0xfec30306, 0x77c79f77, 0x9958ee25,\n    0xea75c6ea, 0xc7b32d5a, 0x3a1df23a, 0x4eef74e8, 0xc86432c8, 0xa15669d2,\n    0x8fbba18f, 0x681ae737, 0x57d79757, 0xf940aea5, 0x1e0ffb1e, 0x22f43c78,\n    0xfa7dc2fa, 0xf7bf0d1a, 0x2be9882b, 0x7d6156ac, 0x582c1658, 0xe83ab099,\n    0xc59e4fc5, 0xb6d173e6, 0x27ef8b27, 0x69644e9c, 0xac562bac, 0x0d7da1bb,\n    0xe38dbae3, 0xdc373f7e, 0xed8a45ed, 0xcecf2346, 0x97b7a797, 0x4010d757,\n    0xbba1acbb, 0x340d8fe7, 0x4623ed46, 0xcace8ce1, 0x05fe7f05, 0x0f810a14,\n    0x40201040, 0xc03080f9, 0x31e47231, 0x539662c4, 0xe58e47e5, 0xd6c93366,\n    0x37e78f37, 0x59686edc, 0x2c160b2c, 0x741d58b0, 0x9e4fdb9e, 0x5b94c573,\n    0x0a05fe0a, 0x1efb1428, 0xb1a452b1, 0x2af69bcf, 0xb5a653b5, 0x26f593df,\n    0x0603fd06, 0x0afe0c18, 0x6c361b6c, 0xb42dd849, 0x1ff3851f, 0x21763e7c,\n    0xa3adaaa3, 0x1c07bf87, 0x2a15f62a, 0x7ee354a8, 0x70381c70, 0x9024e039,\n    0xff83bdff, 0xf83e070e, 0xba5dd2ba, 0x378f8de3, 0x07ff8307, 0x097c0e1c,\n    0x24120924, 0x6c1b4890, 0x160bf916, 0x3af22c58, 0xc663cdc6, 0xb3ae75ea,\n    0x61cc6661, 0xa3aac27d};\n\nconst DWORD tbsm6_128[512] = {\n    0x5d695de7, 0xbbba8dd2, 0xdecbde9b, 0xa4458a6f, 0x00000000, 0x00000000,\n    0xb7afb720, 0x0897d7a7, 0xd3b6d38c, 0x235fbe95, 0xcacecaa7, 0xab6dda65,\n    0x3c0f3c44, 0x1178f01e, 0x0d7d0d17, 0x871a34fa, 0xc3b2c3bc, 0x2f7ffe9d,\n    0xf83ef8f1, 0x4209127c, 0xcbb0cba4, 0x296fde99, 0x8d5d8d6e, 0xe7e33fba,\n    0x76e1769a, 0xdaec213b, 0x895c8962, 0xe4eb2fb8, 0xaad6aa07, 0x83ada355,\n    0x12f81236, 0xf1244809, 0x88228861, 0x66e92b44, 0x22f42266, 0xe5448811,\n    0x4f914fd1, 0x4a9ec5db, 0xdbb4db94, 0x254f9e91, 0x6d656db7, 0xafda4dca,\n    0x479347c9, 0x4c8ee5df, 0xe439e4d5, 0x4b316272, 0x4c134cd4, 0x3598c926,\n    0x781e7888, 0x22f0193c, 0x9ada9a57, 0x97cd634d, 0x496c49db, 0xb492ddd8,\n    0x93a6934c, 0x13df47b5, 0xc431c4b5, 0x5371e262, 0xc030c0b9, 0x5079f260,\n    0x86dd8673, 0x9ef51343, 0x13861335, 0x73264cf5, 0xa954a902, 0xfcabafa8,\n    0x20082060, 0x18408010, 0x539653f5, 0x43a6b5d5, 0x1c071c24, 0x0938700e,\n    0x4eef4ed2, 0xc89cc127, 0xcfb1cfa8, 0x2a67ce9b, 0x3573355f, 0x956ad4e6,\n    0x3970394b, 0x9072e4e0, 0xb42db425, 0x7791db5a, 0xa156a11a, 0xfabb8fac,\n    0x541554fc, 0x3fa8a92a, 0x641964ac, 0x2bc86932, 0x03820305, 0x7f060cfd,\n    0xc7b3c7b0, 0x2c77ee9f, 0x855f8576, 0xe1f31fbe, 0x5c175ce4, 0x39b8892e,\n    0x5b945bed, 0x45b695d1, 0xcd4dcdae, 0xd763c69a, 0xd836d891, 0x5a49926c,\n    0x72e07296, 0xd9e43139, 0x96d99643, 0x92d5534b, 0x42ec42c6, 0xcd84f121,\n    0xb82eb831, 0x7289eb5c, 0xe146e1da, 0xca3b768c, 0xa2d4a21f, 0x85bd8351,\n    0x601860a0, 0x28c07930, 0xefb9efc8, 0x32274e8b, 0xbd51bd3e, 0xf383ffa2,\n    0x02fc0206, 0xfd040801, 0xafa9af08, 0x02a7b7ab, 0x8c238c6d, 0x65e13b46,\n    0x739e7395, 0x5be635c5, 0x7c1f7c84, 0x21f8093e, 0x7f9d7f81, 0x5efe05c3,\n    0x5eeb5ee2, 0xc4bc812f, 0xf940f9f2, 0xc00b1680, 0x656765af, 0xa9ca6dce,\n    0xe6c5e6d3, 0xb6356a73, 0xebb8ebc4, 0x312f5e89, 0xad55ad0e, 0xffa3bfaa,\n    0x5aea5aee, 0xc7b4912d, 0xa557a516, 0xf9b39fae, 0x7960798b, 0xa0f21dc0,\n    0x8edf8e6b, 0x98e53347, 0x157b153f, 0x8d2a54f6, 0x300c3050, 0x1460c018,\n    0xec3beccd, 0x4d214276, 0xa429a415, 0x7bb19b52, 0xc2ccc2bf, 0xad7dfa61,\n    0x3ef33e42, 0xec7cf81f, 0xe038e0d9, 0x48397270, 0x741d749c, 0x27e8293a,\n    0x516a51f3, 0xbea2bdd4, 0xfbbcfbf4, 0x3d0f1e81, 0x2d752d77, 0x9f5ab4ea,\n    0x6ee76eb2, 0xd0dc4137, 0x94259445, 0x6fd15b4a, 0x4d6d4dd7, 0xb79acdda,\n    0x556b55ff, 0xbdaaadd6, 0x340d345c, 0x1768d01a, 0xaed7ae0b, 0x80a5b357,\n    0x52e852f6, 0xc1a4b129, 0x7ee37e82, 0xdcfc013f, 0x9d599d5e, 0xebc37fb2,\n    0x4aee4ade, 0xcb94d125, 0xf7bff7e0, 0x38172e87, 0x80208079, 0x60f90b40,\n    0xf03cf0e9, 0x44193278, 0xd034d089, 0x5c59b268, 0x90249049, 0x6cd94b48,\n    0xa7aba710, 0x04b797af, 0xe83ae8c1, 0x4e295274, 0x9fa59f58, 0x16c777b3,\n    0x501450f0, 0x3ca0b928, 0xd54bd586, 0xdd53a696, 0xd14ad18a, 0xde5bb694,\n    0x98269851, 0x6ac96b4c, 0xcc33ccad, 0x5561c266, 0xa028a019, 0x78b98b50,\n    0x17871739, 0x702e5cf7, 0xf43df4e5, 0x4711227a, 0xb6d1b623, 0x8a95d35b,\n    0xc14ec1ba, 0xd27bf69c, 0x280a2878, 0x1e50a014, 0x5f955fe1, 0x46be85d3,\n    0x26f5266a, 0xe64c9813, 0x017e0103, 0x820204fc, 0xaba8ab04, 0x01afa7a9,\n    0x2577256f, 0x994a94ee, 0x380e3848, 0x1270e01c, 0x82dc827f, 0x9dfd0341,\n    0x7d617d87, 0xa3fa0dc2, 0x481248d8, 0x3690d924, 0xfc3ffcfd, 0x4101027e,\n    0x1b841b2d, 0x75366cf1, 0xcecfceab, 0xa865ca67, 0x3f8d3f41, 0x6e7efce3,\n    0x6b986bbd, 0x51d655c9, 0xe2c4e2df, 0xb53d7a71, 0x679b67a9, 0x54ce65cf,\n    0x66e566aa, 0xd6cc6133, 0x439243c5, 0x4f86f5dd, 0x596859eb, 0xb8b29dd0,\n    0x1978192b, 0x883264f0, 0x84218475, 0x63f11b42, 0x3d713d47, 0x937af4e2,\n    0xf543f5e6, 0xc5132686, 0x2f892f71, 0x625ebceb, 0xc94cc9a2, 0xd46bd698,\n    0xbc2fbc3d, 0x7181fb5e, 0xd948d992, 0xd84b9690, 0x955b9546, 0xedd35fb6,\n    0x2974297b, 0x9c52a4e8, 0x416e41c3, 0xb282fddc, 0xdacada97, 0xa74d9a6d,\n    0x1afa1a2e, 0xf734680d, 0xb02cb029, 0x7499cb58, 0xe944e9c2, 0xcc2b5688,\n    0x696469bb, 0xacd25dc8, 0xd2c8d28f, 0xa15dba69, 0x7b9c7b8d, 0x5df615c1,\n    0xd7b7d780, 0x2057ae97, 0x117a1133, 0x8e2244f4, 0x9ba49b54, 0x15cf67b1,\n    0x338e3355, 0x6b66cce5, 0x8ade8a67, 0x9bed2345, 0x238a2365, 0x67468ced,\n    0x097c091b, 0x841224f8, 0xd435d485, 0x5f51a26a, 0x71627193, 0xa6e23dc4,\n    0x441144cc, 0x3388e922, 0x681a68b8, 0x2ed05934, 0x6f996fb1, 0x52de45cb,\n    0xf2c0f2ef, 0xb91d3a79, 0x0eff0e12, 0xf81c3807, 0xdfb5df98, 0x26478e93,\n    0x87a38770, 0x1cf717bf, 0xdc37dc9d, 0x5941826e, 0x83a2837c, 0x1fff07bd,\n    0x18061828, 0x0a30600c, 0x6ae66abe, 0xd3d45135, 0xeec7eecb, 0xb0254a77,\n    0x99589952, 0xe8cb6fb0, 0x815e817a, 0xe2fb0fbc, 0x62e462a6, 0xd5c47131,\n    0x36f1365a, 0xea6cd81b, 0x2ef72e72, 0xe05cb817, 0x7ae27a8e, 0xdff4113d,\n    0xfec3fefb, 0xbc050a7f, 0x456f45cf, 0xb18aedde, 0x9c279c5d, 0x69c17b4e,\n    0x7563759f, 0xa5ea2dc6, 0x915a914a, 0xeedb4fb4, 0x0c030c14, 0x05183006,\n    0x0f810f11, 0x7a1e3cfb, 0xe7bbe7d0, 0x34376e8f, 0xf6c1f6e3, 0xba152a7b,\n    0x1405143c, 0x0f28500a, 0x639a63a5, 0x57c675cd, 0x1d791d27, 0x8b3a74f2,\n    0x0b800b1d, 0x79162cf9, 0x8ba08b64, 0x19ef27b9, 0xb3aeb32c, 0x0b9fc7a5,\n    0xf3bef3ec, 0x3b1f3e85, 0xb2d0b22f, 0x899dc359, 0x3b8c3b4d, 0x6d76ece1,\n    0x08020818, 0x06102004, 0x4b904bdd, 0x4996d5d9, 0x10041030, 0x0c204008,\n    0xa6d5a613, 0x86b59353, 0x32f03256, 0xe964c819, 0xb950b932, 0xf08befa0,\n    0xa82aa801, 0x7ea9ab54, 0x92d8924f, 0x91dd4349, 0xf142f1ea, 0xc61b3684,\n    0x56e956fa, 0xc2aca12b, 0xdd49dd9e, 0xdb438692, 0x21762163, 0x9a4284ec,\n    0xbfadbf38, 0x0e87f7a3, 0x0401040c, 0x03081002, 0xbed3be3b, 0x8c85f35f,\n    0xd6c9d683, 0xa255aa6b, 0xfd41fdfe, 0xc3030682, 0x779f7799, 0x58ee25c7,\n    0xeac6eac7, 0xb32d5a75, 0x3af23a4e, 0xef74e81d, 0xc832c8a1, 0x5669d264,\n    0x8fa18f68, 0x1ae737bb, 0x579757f9, 0x40aea5d7, 0x1efb1e22, 0xf43c780f,\n    0xfac2faf7, 0xbf0d1a7d, 0x2b882b7d, 0x6156ace9, 0x581658e8, 0x3ab0992c,\n    0xc54fc5b6, 0xd173e69e, 0x278b2769, 0x644e9cef, 0xac2bac0d, 0x7da1bb56,\n    0xe3bae3dc, 0x373f7e8d, 0xed45edce, 0xcf23468a, 0x97a79740, 0x10d757b7,\n    0xbbacbb34, 0x0d8fe7a1, 0x46ed46ca, 0xce8ce123, 0x057f050f, 0x810a14fe,\n    0x401040c0, 0x3080f920, 0x31723153, 0x9662c4e4, 0xe547e5d6, 0xc933668e,\n    0x378f3759, 0x686edce7, 0x2c0b2c74, 0x1d58b016, 0x9edb9e5b, 0x94c5734f,\n    0x0afe0a1e, 0xfb142805, 0xb152b12a, 0xf69bcfa4, 0xb553b526, 0xf593dfa6,\n    0x06fd060a, 0xfe0c1803, 0x6c1b6cb4, 0x2dd84936, 0x1f851f21, 0x763e7cf3,\n    0xa3aaa31c, 0x07bf87ad, 0x2af62a7e, 0xe354a815, 0x701c7090, 0x24e03938,\n    0xffbdfff8, 0x3e070e83, 0xbad2ba37, 0x8f8de35d, 0x07830709, 0x7c0e1cff,\n    0x2409246c, 0x1b489012, 0x16f9163a, 0xf22c580b, 0xc6cdc6b3, 0xae75ea63,\n    0x616661a3, 0xaac27dcc};\n\nconst DWORD tbsm7_128[512] = {\n    0xe75d5d5d, 0x5d5d5d5d, 0x9bdedede, 0xdededede, 0x00000000, 0x00000000,\n    0x20b7b7b7, 0xb7b7b7b7, 0x8cd3d3d3, 0xd3d3d3d3, 0xa7cacaca, 0xcacacaca,\n    0x443c3c3c, 0x3c3c3c3c, 0x170d0d0d, 0x0d0d0d0d, 0xbcc3c3c3, 0xc3c3c3c3,\n    0xf1f8f8f8, 0xf8f8f8f8, 0xa4cbcbcb, 0xcbcbcbcb, 0x6e8d8d8d, 0x8d8d8d8d,\n    0x9a767676, 0x76767676, 0x62898989, 0x89898989, 0x07aaaaaa, 0xaaaaaaaa,\n    0x36121212, 0x12121212, 0x61888888, 0x88888888, 0x66222222, 0x22222222,\n    0xd14f4f4f, 0x4f4f4f4f, 0x94dbdbdb, 0xdbdbdbdb, 0xb76d6d6d, 0x6d6d6d6d,\n    0xc9474747, 0x47474747, 0xd5e4e4e4, 0xe4e4e4e4, 0xd44c4c4c, 0x4c4c4c4c,\n    0x88787878, 0x78787878, 0x579a9a9a, 0x9a9a9a9a, 0xdb494949, 0x49494949,\n    0x4c939393, 0x93939393, 0xb5c4c4c4, 0xc4c4c4c4, 0xb9c0c0c0, 0xc0c0c0c0,\n    0x73868686, 0x86868686, 0x35131313, 0x13131313, 0x02a9a9a9, 0xa9a9a9a9,\n    0x60202020, 0x20202020, 0xf5535353, 0x53535353, 0x241c1c1c, 0x1c1c1c1c,\n    0xd24e4e4e, 0x4e4e4e4e, 0xa8cfcfcf, 0xcfcfcfcf, 0x5f353535, 0x35353535,\n    0x4b393939, 0x39393939, 0x25b4b4b4, 0xb4b4b4b4, 0x1aa1a1a1, 0xa1a1a1a1,\n    0xfc545454, 0x54545454, 0xac646464, 0x64646464, 0x05030303, 0x03030303,\n    0xb0c7c7c7, 0xc7c7c7c7, 0x76858585, 0x85858585, 0xe45c5c5c, 0x5c5c5c5c,\n    0xed5b5b5b, 0x5b5b5b5b, 0xaecdcdcd, 0xcdcdcdcd, 0x91d8d8d8, 0xd8d8d8d8,\n    0x96727272, 0x72727272, 0x43969696, 0x96969696, 0xc6424242, 0x42424242,\n    0x31b8b8b8, 0xb8b8b8b8, 0xdae1e1e1, 0xe1e1e1e1, 0x1fa2a2a2, 0xa2a2a2a2,\n    0xa0606060, 0x60606060, 0xc8efefef, 0xefefefef, 0x3ebdbdbd, 0xbdbdbdbd,\n    0x06020202, 0x02020202, 0x08afafaf, 0xafafafaf, 0x6d8c8c8c, 0x8c8c8c8c,\n    0x95737373, 0x73737373, 0x847c7c7c, 0x7c7c7c7c, 0x817f7f7f, 0x7f7f7f7f,\n    0xe25e5e5e, 0x5e5e5e5e, 0xf2f9f9f9, 0xf9f9f9f9, 0xaf656565, 0x65656565,\n    0xd3e6e6e6, 0xe6e6e6e6, 0xc4ebebeb, 0xebebebeb, 0x0eadadad, 0xadadadad,\n    0xee5a5a5a, 0x5a5a5a5a, 0x16a5a5a5, 0xa5a5a5a5, 0x8b797979, 0x79797979,\n    0x6b8e8e8e, 0x8e8e8e8e, 0x3f151515, 0x15151515, 0x50303030, 0x30303030,\n    0xcdececec, 0xecececec, 0x15a4a4a4, 0xa4a4a4a4, 0xbfc2c2c2, 0xc2c2c2c2,\n    0x423e3e3e, 0x3e3e3e3e, 0xd9e0e0e0, 0xe0e0e0e0, 0x9c747474, 0x74747474,\n    0xf3515151, 0x51515151, 0xf4fbfbfb, 0xfbfbfbfb, 0x772d2d2d, 0x2d2d2d2d,\n    0xb26e6e6e, 0x6e6e6e6e, 0x45949494, 0x94949494, 0xd74d4d4d, 0x4d4d4d4d,\n    0xff555555, 0x55555555, 0x5c343434, 0x34343434, 0x0baeaeae, 0xaeaeaeae,\n    0xf6525252, 0x52525252, 0x827e7e7e, 0x7e7e7e7e, 0x5e9d9d9d, 0x9d9d9d9d,\n    0xde4a4a4a, 0x4a4a4a4a, 0xe0f7f7f7, 0xf7f7f7f7, 0x79808080, 0x80808080,\n    0xe9f0f0f0, 0xf0f0f0f0, 0x89d0d0d0, 0xd0d0d0d0, 0x49909090, 0x90909090,\n    0x10a7a7a7, 0xa7a7a7a7, 0xc1e8e8e8, 0xe8e8e8e8, 0x589f9f9f, 0x9f9f9f9f,\n    0xf0505050, 0x50505050, 0x86d5d5d5, 0xd5d5d5d5, 0x8ad1d1d1, 0xd1d1d1d1,\n    0x51989898, 0x98989898, 0xadcccccc, 0xcccccccc, 0x19a0a0a0, 0xa0a0a0a0,\n    0x39171717, 0x17171717, 0xe5f4f4f4, 0xf4f4f4f4, 0x23b6b6b6, 0xb6b6b6b6,\n    0xbac1c1c1, 0xc1c1c1c1, 0x78282828, 0x28282828, 0xe15f5f5f, 0x5f5f5f5f,\n    0x6a262626, 0x26262626, 0x03010101, 0x01010101, 0x04ababab, 0xabababab,\n    0x6f252525, 0x25252525, 0x48383838, 0x38383838, 0x7f828282, 0x82828282,\n    0x877d7d7d, 0x7d7d7d7d, 0xd8484848, 0x48484848, 0xfdfcfcfc, 0xfcfcfcfc,\n    0x2d1b1b1b, 0x1b1b1b1b, 0xabcecece, 0xcececece, 0x413f3f3f, 0x3f3f3f3f,\n    0xbd6b6b6b, 0x6b6b6b6b, 0xdfe2e2e2, 0xe2e2e2e2, 0xa9676767, 0x67676767,\n    0xaa666666, 0x66666666, 0xc5434343, 0x43434343, 0xeb595959, 0x59595959,\n    0x2b191919, 0x19191919, 0x75848484, 0x84848484, 0x473d3d3d, 0x3d3d3d3d,\n    0xe6f5f5f5, 0xf5f5f5f5, 0x712f2f2f, 0x2f2f2f2f, 0xa2c9c9c9, 0xc9c9c9c9,\n    0x3dbcbcbc, 0xbcbcbcbc, 0x92d9d9d9, 0xd9d9d9d9, 0x46959595, 0x95959595,\n    0x7b292929, 0x29292929, 0xc3414141, 0x41414141, 0x97dadada, 0xdadadada,\n    0x2e1a1a1a, 0x1a1a1a1a, 0x29b0b0b0, 0xb0b0b0b0, 0xc2e9e9e9, 0xe9e9e9e9,\n    0xbb696969, 0x69696969, 0x8fd2d2d2, 0xd2d2d2d2, 0x8d7b7b7b, 0x7b7b7b7b,\n    0x80d7d7d7, 0xd7d7d7d7, 0x33111111, 0x11111111, 0x549b9b9b, 0x9b9b9b9b,\n    0x55333333, 0x33333333, 0x678a8a8a, 0x8a8a8a8a, 0x65232323, 0x23232323,\n    0x1b090909, 0x09090909, 0x85d4d4d4, 0xd4d4d4d4, 0x93717171, 0x71717171,\n    0xcc444444, 0x44444444, 0xb8686868, 0x68686868, 0xb16f6f6f, 0x6f6f6f6f,\n    0xeff2f2f2, 0xf2f2f2f2, 0x120e0e0e, 0x0e0e0e0e, 0x98dfdfdf, 0xdfdfdfdf,\n    0x70878787, 0x87878787, 0x9ddcdcdc, 0xdcdcdcdc, 0x7c838383, 0x83838383,\n    0x28181818, 0x18181818, 0xbe6a6a6a, 0x6a6a6a6a, 0xcbeeeeee, 0xeeeeeeee,\n    0x52999999, 0x99999999, 0x7a818181, 0x81818181, 0xa6626262, 0x62626262,\n    0x5a363636, 0x36363636, 0x722e2e2e, 0x2e2e2e2e, 0x8e7a7a7a, 0x7a7a7a7a,\n    0xfbfefefe, 0xfefefefe, 0xcf454545, 0x45454545, 0x5d9c9c9c, 0x9c9c9c9c,\n    0x9f757575, 0x75757575, 0x4a919191, 0x91919191, 0x140c0c0c, 0x0c0c0c0c,\n    0x110f0f0f, 0x0f0f0f0f, 0xd0e7e7e7, 0xe7e7e7e7, 0xe3f6f6f6, 0xf6f6f6f6,\n    0x3c141414, 0x14141414, 0xa5636363, 0x63636363, 0x271d1d1d, 0x1d1d1d1d,\n    0x1d0b0b0b, 0x0b0b0b0b, 0x648b8b8b, 0x8b8b8b8b, 0x2cb3b3b3, 0xb3b3b3b3,\n    0xecf3f3f3, 0xf3f3f3f3, 0x2fb2b2b2, 0xb2b2b2b2, 0x4d3b3b3b, 0x3b3b3b3b,\n    0x18080808, 0x08080808, 0xdd4b4b4b, 0x4b4b4b4b, 0x30101010, 0x10101010,\n    0x13a6a6a6, 0xa6a6a6a6, 0x56323232, 0x32323232, 0x32b9b9b9, 0xb9b9b9b9,\n    0x01a8a8a8, 0xa8a8a8a8, 0x4f929292, 0x92929292, 0xeaf1f1f1, 0xf1f1f1f1,\n    0xfa565656, 0x56565656, 0x9edddddd, 0xdddddddd, 0x63212121, 0x21212121,\n    0x38bfbfbf, 0xbfbfbfbf, 0x0c040404, 0x04040404, 0x3bbebebe, 0xbebebebe,\n    0x83d6d6d6, 0xd6d6d6d6, 0xfefdfdfd, 0xfdfdfdfd, 0x99777777, 0x77777777,\n    0xc7eaeaea, 0xeaeaeaea, 0x4e3a3a3a, 0x3a3a3a3a, 0xa1c8c8c8, 0xc8c8c8c8,\n    0x688f8f8f, 0x8f8f8f8f, 0xf9575757, 0x57575757, 0x221e1e1e, 0x1e1e1e1e,\n    0xf7fafafa, 0xfafafafa, 0x7d2b2b2b, 0x2b2b2b2b, 0xe8585858, 0x58585858,\n    0xb6c5c5c5, 0xc5c5c5c5, 0x69272727, 0x27272727, 0x0dacacac, 0xacacacac,\n    0xdce3e3e3, 0xe3e3e3e3, 0xceededed, 0xedededed, 0x40979797, 0x97979797,\n    0x34bbbbbb, 0xbbbbbbbb, 0xca464646, 0x46464646, 0x0f050505, 0x05050505,\n    0xc0404040, 0x40404040, 0x53313131, 0x31313131, 0xd6e5e5e5, 0xe5e5e5e5,\n    0x59373737, 0x37373737, 0x742c2c2c, 0x2c2c2c2c, 0x5b9e9e9e, 0x9e9e9e9e,\n    0x1e0a0a0a, 0x0a0a0a0a, 0x2ab1b1b1, 0xb1b1b1b1, 0x26b5b5b5, 0xb5b5b5b5,\n    0x0a060606, 0x06060606, 0xb46c6c6c, 0x6c6c6c6c, 0x211f1f1f, 0x1f1f1f1f,\n    0x1ca3a3a3, 0xa3a3a3a3, 0x7e2a2a2a, 0x2a2a2a2a, 0x90707070, 0x70707070,\n    0xf8ffffff, 0xffffffff, 0x37bababa, 0xbabababa, 0x09070707, 0x07070707,\n    0x6c242424, 0x24242424, 0x3a161616, 0x16161616, 0xb3c6c6c6, 0xc6c6c6c6,\n    0xa3616161, 0x61616161};\n\nconst DWORD tbs0_128[256] = {\n    0x5d000000, 0xde000000, 0x00000000, 0xb7000000, 0xd3000000, 0xca000000,\n    0x3c000000, 0x0d000000, 0xc3000000, 0xf8000000, 0xcb000000, 0x8d000000,\n    0x76000000, 0x89000000, 0xaa000000, 0x12000000, 0x88000000, 0x22000000,\n    0x4f000000, 0xdb000000, 0x6d000000, 0x47000000, 0xe4000000, 0x4c000000,\n    0x78000000, 0x9a000000, 0x49000000, 0x93000000, 0xc4000000, 0xc0000000,\n    0x86000000, 0x13000000, 0xa9000000, 0x20000000, 0x53000000, 0x1c000000,\n    0x4e000000, 0xcf000000, 0x35000000, 0x39000000, 0xb4000000, 0xa1000000,\n    0x54000000, 0x64000000, 0x03000000, 0xc7000000, 0x85000000, 0x5c000000,\n    0x5b000000, 0xcd000000, 0xd8000000, 0x72000000, 0x96000000, 0x42000000,\n    0xb8000000, 0xe1000000, 0xa2000000, 0x60000000, 0xef000000, 0xbd000000,\n    0x02000000, 0xaf000000, 0x8c000000, 0x73000000, 0x7c000000, 0x7f000000,\n    0x5e000000, 0xf9000000, 0x65000000, 0xe6000000, 0xeb000000, 0xad000000,\n    0x5a000000, 0xa5000000, 0x79000000, 0x8e000000, 0x15000000, 0x30000000,\n    0xec000000, 0xa4000000, 0xc2000000, 0x3e000000, 0xe0000000, 0x74000000,\n    0x51000000, 0xfb000000, 0x2d000000, 0x6e000000, 0x94000000, 0x4d000000,\n    0x55000000, 0x34000000, 0xae000000, 0x52000000, 0x7e000000, 0x9d000000,\n    0x4a000000, 0xf7000000, 0x80000000, 0xf0000000, 0xd0000000, 0x90000000,\n    0xa7000000, 0xe8000000, 0x9f000000, 0x50000000, 0xd5000000, 0xd1000000,\n    0x98000000, 0xcc000000, 0xa0000000, 0x17000000, 0xf4000000, 0xb6000000,\n    0xc1000000, 0x28000000, 0x5f000000, 0x26000000, 0x01000000, 0xab000000,\n    0x25000000, 0x38000000, 0x82000000, 0x7d000000, 0x48000000, 0xfc000000,\n    0x1b000000, 0xce000000, 0x3f000000, 0x6b000000, 0xe2000000, 0x67000000,\n    0x66000000, 0x43000000, 0x59000000, 0x19000000, 0x84000000, 0x3d000000,\n    0xf5000000, 0x2f000000, 0xc9000000, 0xbc000000, 0xd9000000, 0x95000000,\n    0x29000000, 0x41000000, 0xda000000, 0x1a000000, 0xb0000000, 0xe9000000,\n    0x69000000, 0xd2000000, 0x7b000000, 0xd7000000, 0x11000000, 0x9b000000,\n    0x33000000, 0x8a000000, 0x23000000, 0x09000000, 0xd4000000, 0x71000000,\n    0x44000000, 0x68000000, 0x6f000000, 0xf2000000, 0x0e000000, 0xdf000000,\n    0x87000000, 0xdc000000, 0x83000000, 0x18000000, 0x6a000000, 0xee000000,\n    0x99000000, 0x81000000, 0x62000000, 0x36000000, 0x2e000000, 0x7a000000,\n    0xfe000000, 0x45000000, 0x9c000000, 0x75000000, 0x91000000, 0x0c000000,\n    0x0f000000, 0xe7000000, 0xf6000000, 0x14000000, 0x63000000, 0x1d000000,\n    0x0b000000, 0x8b000000, 0xb3000000, 0xf3000000, 0xb2000000, 0x3b000000,\n    0x08000000, 0x4b000000, 0x10000000, 0xa6000000, 0x32000000, 0xb9000000,\n    0xa8000000, 0x92000000, 0xf1000000, 0x56000000, 0xdd000000, 0x21000000,\n    0xbf000000, 0x04000000, 0xbe000000, 0xd6000000, 0xfd000000, 0x77000000,\n    0xea000000, 0x3a000000, 0xc8000000, 0x8f000000, 0x57000000, 0x1e000000,\n    0xfa000000, 0x2b000000, 0x58000000, 0xc5000000, 0x27000000, 0xac000000,\n    0xe3000000, 0xed000000, 0x97000000, 0xbb000000, 0x46000000, 0x05000000,\n    0x40000000, 0x31000000, 0xe5000000, 0x37000000, 0x2c000000, 0x9e000000,\n    0x0a000000, 0xb1000000, 0xb5000000, 0x06000000, 0x6c000000, 0x1f000000,\n    0xa3000000, 0x2a000000, 0x70000000, 0xff000000, 0xba000000, 0x07000000,\n    0x24000000, 0x16000000, 0xc6000000, 0x61000000};\n\nconst DWORD tbs1_128[256] = {\n    0x005d0000, 0x00de0000, 0x00000000, 0x00b70000, 0x00d30000, 0x00ca0000,\n    0x003c0000, 0x000d0000, 0x00c30000, 0x00f80000, 0x00cb0000, 0x008d0000,\n    0x00760000, 0x00890000, 0x00aa0000, 0x00120000, 0x00880000, 0x00220000,\n    0x004f0000, 0x00db0000, 0x006d0000, 0x00470000, 0x00e40000, 0x004c0000,\n    0x00780000, 0x009a0000, 0x00490000, 0x00930000, 0x00c40000, 0x00c00000,\n    0x00860000, 0x00130000, 0x00a90000, 0x00200000, 0x00530000, 0x001c0000,\n    0x004e0000, 0x00cf0000, 0x00350000, 0x00390000, 0x00b40000, 0x00a10000,\n    0x00540000, 0x00640000, 0x00030000, 0x00c70000, 0x00850000, 0x005c0000,\n    0x005b0000, 0x00cd0000, 0x00d80000, 0x00720000, 0x00960000, 0x00420000,\n    0x00b80000, 0x00e10000, 0x00a20000, 0x00600000, 0x00ef0000, 0x00bd0000,\n    0x00020000, 0x00af0000, 0x008c0000, 0x00730000, 0x007c0000, 0x007f0000,\n    0x005e0000, 0x00f90000, 0x00650000, 0x00e60000, 0x00eb0000, 0x00ad0000,\n    0x005a0000, 0x00a50000, 0x00790000, 0x008e0000, 0x00150000, 0x00300000,\n    0x00ec0000, 0x00a40000, 0x00c20000, 0x003e0000, 0x00e00000, 0x00740000,\n    0x00510000, 0x00fb0000, 0x002d0000, 0x006e0000, 0x00940000, 0x004d0000,\n    0x00550000, 0x00340000, 0x00ae0000, 0x00520000, 0x007e0000, 0x009d0000,\n    0x004a0000, 0x00f70000, 0x00800000, 0x00f00000, 0x00d00000, 0x00900000,\n    0x00a70000, 0x00e80000, 0x009f0000, 0x00500000, 0x00d50000, 0x00d10000,\n    0x00980000, 0x00cc0000, 0x00a00000, 0x00170000, 0x00f40000, 0x00b60000,\n    0x00c10000, 0x00280000, 0x005f0000, 0x00260000, 0x00010000, 0x00ab0000,\n    0x00250000, 0x00380000, 0x00820000, 0x007d0000, 0x00480000, 0x00fc0000,\n    0x001b0000, 0x00ce0000, 0x003f0000, 0x006b0000, 0x00e20000, 0x00670000,\n    0x00660000, 0x00430000, 0x00590000, 0x00190000, 0x00840000, 0x003d0000,\n    0x00f50000, 0x002f0000, 0x00c90000, 0x00bc0000, 0x00d90000, 0x00950000,\n    0x00290000, 0x00410000, 0x00da0000, 0x001a0000, 0x00b00000, 0x00e90000,\n    0x00690000, 0x00d20000, 0x007b0000, 0x00d70000, 0x00110000, 0x009b0000,\n    0x00330000, 0x008a0000, 0x00230000, 0x00090000, 0x00d40000, 0x00710000,\n    0x00440000, 0x00680000, 0x006f0000, 0x00f20000, 0x000e0000, 0x00df0000,\n    0x00870000, 0x00dc0000, 0x00830000, 0x00180000, 0x006a0000, 0x00ee0000,\n    0x00990000, 0x00810000, 0x00620000, 0x00360000, 0x002e0000, 0x007a0000,\n    0x00fe0000, 0x00450000, 0x009c0000, 0x00750000, 0x00910000, 0x000c0000,\n    0x000f0000, 0x00e70000, 0x00f60000, 0x00140000, 0x00630000, 0x001d0000,\n    0x000b0000, 0x008b0000, 0x00b30000, 0x00f30000, 0x00b20000, 0x003b0000,\n    0x00080000, 0x004b0000, 0x00100000, 0x00a60000, 0x00320000, 0x00b90000,\n    0x00a80000, 0x00920000, 0x00f10000, 0x00560000, 0x00dd0000, 0x00210000,\n    0x00bf0000, 0x00040000, 0x00be0000, 0x00d60000, 0x00fd0000, 0x00770000,\n    0x00ea0000, 0x003a0000, 0x00c80000, 0x008f0000, 0x00570000, 0x001e0000,\n    0x00fa0000, 0x002b0000, 0x00580000, 0x00c50000, 0x00270000, 0x00ac0000,\n    0x00e30000, 0x00ed0000, 0x00970000, 0x00bb0000, 0x00460000, 0x00050000,\n    0x00400000, 0x00310000, 0x00e50000, 0x00370000, 0x002c0000, 0x009e0000,\n    0x000a0000, 0x00b10000, 0x00b50000, 0x00060000, 0x006c0000, 0x001f0000,\n    0x00a30000, 0x002a0000, 0x00700000, 0x00ff0000, 0x00ba0000, 0x00070000,\n    0x00240000, 0x00160000, 0x00c60000, 0x00610000};\n\nconst WORD tbs2_128[256] = {\n    0x5d00, 0xde00, 0x0000, 0xb700, 0xd300, 0xca00, 0x3c00, 0x0d00, 0xc300,\n    0xf800, 0xcb00, 0x8d00, 0x7600, 0x8900, 0xaa00, 0x1200, 0x8800, 0x2200,\n    0x4f00, 0xdb00, 0x6d00, 0x4700, 0xe400, 0x4c00, 0x7800, 0x9a00, 0x4900,\n    0x9300, 0xc400, 0xc000, 0x8600, 0x1300, 0xa900, 0x2000, 0x5300, 0x1c00,\n    0x4e00, 0xcf00, 0x3500, 0x3900, 0xb400, 0xa100, 0x5400, 0x6400, 0x0300,\n    0xc700, 0x8500, 0x5c00, 0x5b00, 0xcd00, 0xd800, 0x7200, 0x9600, 0x4200,\n    0xb800, 0xe100, 0xa200, 0x6000, 0xef00, 0xbd00, 0x0200, 0xaf00, 0x8c00,\n    0x7300, 0x7c00, 0x7f00, 0x5e00, 0xf900, 0x6500, 0xe600, 0xeb00, 0xad00,\n    0x5a00, 0xa500, 0x7900, 0x8e00, 0x1500, 0x3000, 0xec00, 0xa400, 0xc200,\n    0x3e00, 0xe000, 0x7400, 0x5100, 0xfb00, 0x2d00, 0x6e00, 0x9400, 0x4d00,\n    0x5500, 0x3400, 0xae00, 0x5200, 0x7e00, 0x9d00, 0x4a00, 0xf700, 0x8000,\n    0xf000, 0xd000, 0x9000, 0xa700, 0xe800, 0x9f00, 0x5000, 0xd500, 0xd100,\n    0x9800, 0xcc00, 0xa000, 0x1700, 0xf400, 0xb600, 0xc100, 0x2800, 0x5f00,\n    0x2600, 0x0100, 0xab00, 0x2500, 0x3800, 0x8200, 0x7d00, 0x4800, 0xfc00,\n    0x1b00, 0xce00, 0x3f00, 0x6b00, 0xe200, 0x6700, 0x6600, 0x4300, 0x5900,\n    0x1900, 0x8400, 0x3d00, 0xf500, 0x2f00, 0xc900, 0xbc00, 0xd900, 0x9500,\n    0x2900, 0x4100, 0xda00, 0x1a00, 0xb000, 0xe900, 0x6900, 0xd200, 0x7b00,\n    0xd700, 0x1100, 0x9b00, 0x3300, 0x8a00, 0x2300, 0x0900, 0xd400, 0x7100,\n    0x4400, 0x6800, 0x6f00, 0xf200, 0x0e00, 0xdf00, 0x8700, 0xdc00, 0x8300,\n    0x1800, 0x6a00, 0xee00, 0x9900, 0x8100, 0x6200, 0x3600, 0x2e00, 0x7a00,\n    0xfe00, 0x4500, 0x9c00, 0x7500, 0x9100, 0x0c00, 0x0f00, 0xe700, 0xf600,\n    0x1400, 0x6300, 0x1d00, 0x0b00, 0x8b00, 0xb300, 0xf300, 0xb200, 0x3b00,\n    0x0800, 0x4b00, 0x1000, 0xa600, 0x3200, 0xb900, 0xa800, 0x9200, 0xf100,\n    0x5600, 0xdd00, 0x2100, 0xbf00, 0x0400, 0xbe00, 0xd600, 0xfd00, 0x7700,\n    0xea00, 0x3a00, 0xc800, 0x8f00, 0x5700, 0x1e00, 0xfa00, 0x2b00, 0x5800,\n    0xc500, 0x2700, 0xac00, 0xe300, 0xed00, 0x9700, 0xbb00, 0x4600, 0x0500,\n    0x4000, 0x3100, 0xe500, 0x3700, 0x2c00, 0x9e00, 0x0a00, 0xb100, 0xb500,\n    0x0600, 0x6c00, 0x1f00, 0xa300, 0x2a00, 0x7000, 0xff00, 0xba00, 0x0700,\n    0x2400, 0x1600, 0xc600, 0x6100};\n\nconst BYTE tbs3_128[256] = {\n    0x5d, 0xde, 0x00, 0xb7, 0xd3, 0xca, 0x3c, 0x0d, 0xc3, 0xf8, 0xcb, 0x8d,\n    0x76, 0x89, 0xaa, 0x12, 0x88, 0x22, 0x4f, 0xdb, 0x6d, 0x47, 0xe4, 0x4c,\n    0x78, 0x9a, 0x49, 0x93, 0xc4, 0xc0, 0x86, 0x13, 0xa9, 0x20, 0x53, 0x1c,\n    0x4e, 0xcf, 0x35, 0x39, 0xb4, 0xa1, 0x54, 0x64, 0x03, 0xc7, 0x85, 0x5c,\n    0x5b, 0xcd, 0xd8, 0x72, 0x96, 0x42, 0xb8, 0xe1, 0xa2, 0x60, 0xef, 0xbd,\n    0x02, 0xaf, 0x8c, 0x73, 0x7c, 0x7f, 0x5e, 0xf9, 0x65, 0xe6, 0xeb, 0xad,\n    0x5a, 0xa5, 0x79, 0x8e, 0x15, 0x30, 0xec, 0xa4, 0xc2, 0x3e, 0xe0, 0x74,\n    0x51, 0xfb, 0x2d, 0x6e, 0x94, 0x4d, 0x55, 0x34, 0xae, 0x52, 0x7e, 0x9d,\n    0x4a, 0xf7, 0x80, 0xf0, 0xd0, 0x90, 0xa7, 0xe8, 0x9f, 0x50, 0xd5, 0xd1,\n    0x98, 0xcc, 0xa0, 0x17, 0xf4, 0xb6, 0xc1, 0x28, 0x5f, 0x26, 0x01, 0xab,\n    0x25, 0x38, 0x82, 0x7d, 0x48, 0xfc, 0x1b, 0xce, 0x3f, 0x6b, 0xe2, 0x67,\n    0x66, 0x43, 0x59, 0x19, 0x84, 0x3d, 0xf5, 0x2f, 0xc9, 0xbc, 0xd9, 0x95,\n    0x29, 0x41, 0xda, 0x1a, 0xb0, 0xe9, 0x69, 0xd2, 0x7b, 0xd7, 0x11, 0x9b,\n    0x33, 0x8a, 0x23, 0x09, 0xd4, 0x71, 0x44, 0x68, 0x6f, 0xf2, 0x0e, 0xdf,\n    0x87, 0xdc, 0x83, 0x18, 0x6a, 0xee, 0x99, 0x81, 0x62, 0x36, 0x2e, 0x7a,\n    0xfe, 0x45, 0x9c, 0x75, 0x91, 0x0c, 0x0f, 0xe7, 0xf6, 0x14, 0x63, 0x1d,\n    0x0b, 0x8b, 0xb3, 0xf3, 0xb2, 0x3b, 0x08, 0x4b, 0x10, 0xa6, 0x32, 0xb9,\n    0xa8, 0x92, 0xf1, 0x56, 0xdd, 0x21, 0xbf, 0x04, 0xbe, 0xd6, 0xfd, 0x77,\n    0xea, 0x3a, 0xc8, 0x8f, 0x57, 0x1e, 0xfa, 0x2b, 0x58, 0xc5, 0x27, 0xac,\n    0xe3, 0xed, 0x97, 0xbb, 0x46, 0x05, 0x40, 0x31, 0xe5, 0x37, 0x2c, 0x9e,\n    0x0a, 0xb1, 0xb5, 0x06, 0x6c, 0x1f, 0xa3, 0x2a, 0x70, 0xff, 0xba, 0x07,\n    0x24, 0x16, 0xc6, 0x61};\n\n///////////////////////////////////////////////////////////\n\n#ifndef USE_NXT128\n#error Set USE_NXT128 in nxt_common.h to use NXT128\n#endif\n\n#if ((NXT128_TOTAL_ROUNDS <= 1) || (NXT128_TOTAL_ROUNDS > 255))\n#error NXT128_TOTAL_ROUNDS must be greater than 1 and smaller than 256\n#elif ((defined NXT128_UNROLL_LOOPS) && (NXT128_TOTAL_ROUNDS != 16) \\\n       && (NXT128_TOTAL_ROUNDS != 12))\n#error NXT128_TOTAL_ROUNDS must be 12 or 16 when NXT128_UNROLL_LOOPS is set\n#endif\n\n#define SIGMA_MU8_0(x, y)                 \\\n      tbsm0_128[((x & 0xff000000) >> 23)] \\\n    ^ tbsm1_128[((x & 0x00ff0000) >> 15)] \\\n    ^ tbsm2_128[((x & 0x0000ff00) >>  7)] \\\n    ^ tbsm3_128[((x & 0x000000ff) <<  1)] \\\n    ^ tbsm4_128[((y & 0xff000000) >> 23)] \\\n    ^ tbsm5_128[((y & 0x00ff0000) >> 15)] \\\n    ^ tbsm6_128[((y & 0x0000ff00) >>  7)] \\\n    ^ tbsm7_128[((y & 0x000000ff) <<  1)]\n\n#define SIGMA_MU8_1(x, y)                     \\\n      tbsm0_128[((x & 0xff000000) >> 23) + 1] \\\n    ^ tbsm1_128[((x & 0x00ff0000) >> 15) + 1] \\\n    ^ tbsm2_128[((x & 0x0000ff00) >>  7) + 1] \\\n    ^ tbsm3_128[((x & 0x000000ff) <<  1) + 1] \\\n    ^ tbsm4_128[((y & 0xff000000) >> 23) + 1] \\\n    ^ tbsm5_128[((y & 0x00ff0000) >> 15) + 1] \\\n    ^ tbsm6_128[((y & 0x0000ff00) >>  7) + 1] \\\n    ^ tbsm7_128[((y & 0x000000ff) <<  1) + 1]\n\n#define SIGMA(x)                       \\\n      tbs0_128[(x & 0xff000000) >> 24] \\\n    ^ tbs1_128[(x & 0x00ff0000) >> 16] \\\n    ^ tbs2_128[(x & 0x0000ff00) >>  8] \\\n    ^ tbs3_128[(x & 0x000000ff)      ]\n\n#define F64(i)                              \\\n{                                           \\\n    tmp0 = x0 ^ x1 ^ rk[0];                 \\\n    tmp1 = x2 ^ x3 ^ rk[1];                 \\\n                                            \\\n    smu0 = rk[2] ^ SIGMA_MU8_0(tmp0, tmp1); \\\n    smu1 = rk[3] ^ SIGMA_MU8_1(tmp0, tmp1); \\\n                                            \\\n    f0 = rk[0] ^ SIGMA(smu0);               \\\n    f1 = rk[1] ^ SIGMA(smu1);               \\\n}\n\n#define ELMOR128(i)    \\\n{                      \\\n    F64(i);            \\\n                       \\\n    tmp0 = x0 ^ f0;    \\\n    x0 = NXT_OR(tmp0); \\\n    x1 ^= f0;          \\\n                       \\\n    tmp1 = x2 ^ f1;    \\\n    x2 = NXT_OR(tmp1); \\\n    x3 ^= f1;          \\\n    rk += 4;           \\\n}\n\n#define ELMIO128(i)    \\\n{                      \\\n    F64(i);            \\\n                       \\\n    tmp0 = x0 ^ f0;    \\\n    x0 = NXT_IO(tmp0); \\\n    x1 ^= f0;          \\\n                       \\\n    tmp1 = x2 ^ f1;    \\\n    x2 = NXT_IO(tmp1); \\\n    x3 ^= f1;          \\\n    rk -= 4;           \\\n}\n\n#define ELMID128(i) \\\n{                   \\\n    F64(i);         \\\n                    \\\n    x0 ^= f0;       \\\n    x1 ^= f0;       \\\n                    \\\n    x2 ^= f1;       \\\n    x3 ^= f1;       \\\n}\n\nvoid Ideanxt128_encrypt(const nxt128_ctx *ctx,const BYTE *in,BYTE *out)\n{\n    DWORD x0, x1, x2, x3;\n    DWORD tmp0, tmp1;\n    DWORD f0, f1;\n    DWORD smu0, smu1;\n    DWORD *rk;\n\n#ifndef NXT128_UNROLL_LOOPS\n    int i;\n#endif\n\n    PACK32(in     , &x0);\n    PACK32(in +  4, &x1);\n    PACK32(in +  8, &x2);\n    PACK32(in + 12, &x3);\n\n    rk = (DWORD *) ctx->rk;\n\n#ifdef NXT128_UNROLL_LOOPS\n#if NXT128_TOTAL_ROUNDS == 16\n    ELMOR128( 0); ELMOR128( 4); ELMOR128( 8); ELMOR128(12); ELMOR128(16);\n    ELMOR128(20); ELMOR128(24); ELMOR128(28); ELMOR128(32); ELMOR128(36);\n    ELMOR128(40); ELMOR128(44); ELMOR128(48); ELMOR128(52); ELMOR128(56);\n    ELMID128(60);\n#elif NXT128_TOTAL_ROUNDS == 12\n    ELMOR128( 0); ELMOR128( 4); ELMOR128( 8); ELMOR128(12); ELMOR128(16);\n    ELMOR128(20); ELMOR128(24); ELMOR128(28); ELMOR128(32); ELMOR128(36);\n    ELMOR128(40);\n    ELMID128(44);\n#endif\n#else /* !NXT128_UNROLL_LOOPS */\n    for (i = 0; i < (NXT128_TOTAL_ROUNDS - 1); i++) {\n        ELMOR128(0);\n    }\n    ELMID128(0);\n#endif /* !NXT128_UNROLL_LOOPS */\n\n    UNPACK32(x0, out     );\n    UNPACK32(x1, out +  4);\n    UNPACK32(x2, out +  8);\n    UNPACK32(x3, out + 12);\n}\n\nvoid Ideanxt128_decrypt(const nxt128_ctx *ctx,const BYTE *in,BYTE *out)\n{\n    DWORD x0, x1, x2, x3;\n    DWORD tmp0, tmp1;\n    DWORD f0, f1;\n    DWORD smu0, smu1;\n    DWORD *rk;\n\n#ifndef NXT128_UNROLL_LOOPS\n    int i;\n#endif\n\n    PACK32(in     , &x0);\n    PACK32(in +  4, &x1);\n    PACK32(in +  8, &x2);\n    PACK32(in + 12, &x3);\n\n    rk = ((DWORD *) ctx->rk) + 4 * (NXT128_TOTAL_ROUNDS - 1);\n\n#ifdef NXT128_UNROLL_LOOPS\n#if NXT128_TOTAL_ROUNDS == 16\n    ELMIO128(60); ELMIO128(56); ELMIO128(52); ELMIO128(48); ELMIO128(44);\n    ELMIO128(40); ELMIO128(36); ELMIO128(32); ELMIO128(28); ELMIO128(24);\n    ELMIO128(20); ELMIO128(16); ELMIO128(12); ELMIO128( 8); ELMIO128( 4);\n    ELMID128(0);\n#elif NXT128_TOTAL_ROUNDS == 12\n    ELMIO128(44); ELMIO128(40); ELMIO128(36); ELMIO128(32); ELMIO128(28);\n    ELMIO128(24); ELMIO128(20); ELMIO128(16); ELMIO128(12); ELMIO128( 8);\n    ELMIO128( 4);\n    ELMID128(0);\n#endif\n#else /* !NXT128_UNROLL_LOOPS */\n    for (i = 0; i < (NXT128_TOTAL_ROUNDS - 1); i++) {\n        ELMIO128(0);\n    }\n    ELMID128(0);\n#endif /* !NXT128_UNROLL_LOOPS */\n\n    UNPACK32(x0, out     );\n    UNPACK32(x1, out +  4);\n    UNPACK32(x2, out +  8);\n    UNPACK32(x3, out + 12);\n}\n\n#define MIX128(x, y)                           \\\n{                                              \\\n    *(y    ) = *(x + 2) ^ *(x + 4) ^ *(x + 6); \\\n    *(y + 1) = *(x + 3) ^ *(x + 5) ^ *(x + 7); \\\n    *(y + 2) = *(x    ) ^ *(x + 4) ^ *(x + 6); \\\n    *(y + 3) = *(x + 1) ^ *(x + 5) ^ *(x + 7); \\\n    *(y + 4) = *(x    ) ^ *(x + 2) ^ *(x + 6); \\\n    *(y + 5) = *(x + 1) ^ *(x + 3) ^ *(x + 7); \\\n    *(y + 6) = *(x    ) ^ *(x + 2) ^ *(x + 4); \\\n    *(y + 7) = *(x + 1) ^ *(x + 3) ^ *(x + 5); \\\n}\n\nvoid nxt128_dnl128(const BYTE *mkey,DWORD *reg,DWORD *rkey,BYTE eq)\n{\n    DWORD t0[8];\n    DWORD t1[8];\n    DWORD dkey32[8];\n    DWORD x0, x1, x2, x3;\n    DWORD tmp0, tmp1;\n    DWORD smu0, smu1;\n    DWORD f0, f1;\n    DWORD *rk;\n    DWORD lfsr_value;\n    BYTE dkey[32];\n    int i;\n\n    /* D-part */\n    for (i = 0; i < 10; i++) {\n        LFSR(reg, lfsr_value);\n        dkey[0 + i * 3] = mkey[0 + i * 3] ^ ((BYTE) (lfsr_value >> 16));\n        dkey[1 + i * 3] = mkey[1 + i * 3] ^ ((BYTE) (lfsr_value >> 8));\n        dkey[2 + i * 3] = mkey[2 + i * 3] ^ ((BYTE) (lfsr_value));\n    }\n\n    LFSR(reg, lfsr_value);\n    dkey[30] = mkey[30] ^ ((BYTE) (lfsr_value >> 16));\n    dkey[31] = mkey[31] ^ ((BYTE) (lfsr_value >> 8));\n\n    /* NL128-part */\n    rk = dkey32;\n\n    PACK32(dkey     , dkey32    );\n    PACK32(dkey +  4, dkey32 + 1);\n    PACK32(dkey +  8, dkey32 + 2);\n    PACK32(dkey + 12, dkey32 + 3);\n    PACK32(dkey + 16, dkey32 + 4);\n    PACK32(dkey + 20, dkey32 + 5);\n    PACK32(dkey + 24, dkey32 + 6);\n    PACK32(dkey + 28, dkey32 + 7);\n\n    t1[0] = SIGMA_MU8_0(dkey32[0], dkey32[1]);\n    t1[1] = SIGMA_MU8_1(dkey32[0], dkey32[1]);\n    t1[2] = SIGMA_MU8_0(dkey32[2], dkey32[3]);\n    t1[3] = SIGMA_MU8_1(dkey32[2], dkey32[3]);\n    t1[4] = SIGMA_MU8_0(dkey32[4], dkey32[5]);\n    t1[5] = SIGMA_MU8_1(dkey32[4], dkey32[5]);\n    t1[6] = SIGMA_MU8_0(dkey32[6], dkey32[7]);\n    t1[7] = SIGMA_MU8_1(dkey32[6], dkey32[7]);\n\n    MIX128(t1, t0);\n\n    PACK32(pad     , t1    );\n    PACK32(pad +  4, t1 + 1);\n    PACK32(pad +  8, t1 + 2);\n    PACK32(pad + 12, t1 + 3);\n    PACK32(pad + 16, t1 + 4);\n    PACK32(pad + 20, t1 + 5);\n    PACK32(pad + 24, t1 + 6);\n    PACK32(pad + 28, t1 + 7);\n\n    t0[0] ^= t1[0];\n    t0[1] ^= t1[1];\n    t0[2] ^= t1[2];\n    t0[3] ^= t1[3];\n    t0[4] ^= t1[4];\n    t0[5] ^= t1[5];\n    t0[6] ^= t1[6];\n    t0[7] ^= t1[7];\n\n    if (eq) {\n        t0[0] = ~t0[0];\n        t0[1] = ~t0[1];\n        t0[2] = ~t0[2];\n        t0[3] = ~t0[3];\n        t0[4] = ~t0[4];\n        t0[5] = ~t0[5];\n        t0[6] = ~t0[6];\n        t0[7] = ~t0[7];\n    }\n\n    x0 = SIGMA(t0[0]) ^ SIGMA(t0[4]);\n    x1 = SIGMA(t0[1]) ^ SIGMA(t0[5]);\n    x2 = SIGMA(t0[2]) ^ SIGMA(t0[6]);\n    x3 = SIGMA(t0[3]) ^ SIGMA(t0[7]);\n\n    ELMOR128(0);\n    ELMID128(0);\n\n    rkey[0] = x0;\n    rkey[1] = x1;\n    rkey[2] = x2;\n    rkey[3] = x3;\n}\n\nvoid Ideanxt128_set_key(nxt128_ctx *ctx,const BYTE *key,const WORD key_len)\n{\n    const WORD ek = 256;\n    BYTE pk[32];\n    BYTE mk[32];\n    DWORD reg;\n    int i;\n    BYTE eq;\n\n    //assert((key_len % 8 == 0) && (key_len <= 256));\n\n    /* Initialization and LFSR Pre-clocking */\n    reg = 0x006a0000 | ((NXT128_TOTAL_ROUNDS << 8) & 0x0000ff00)\n          | ((~NXT128_TOTAL_ROUNDS) & 0x000000ff);\n    if (reg & 0x1) {\n        reg ^= 0x100001b;\n    }\n    reg >>= 1;\n\n    eq = (key_len == ek);\n\n    if (key_len < ek) {\n        nxt_p(key, (key_len >> 3), pk, ek);\n        nxt_m(pk, mk, ek);\n\n        for (i = 0; i < NXT128_TOTAL_ROUNDS; i++) {\n            nxt128_dnl128(mk, &reg, &ctx->rk[i * 4], eq);\n        }\n    } else {\n        for (i = 0; i < NXT128_TOTAL_ROUNDS; i++) {\n            nxt128_dnl128(key, &reg, &ctx->rk[i * 4], eq);\n        }\n    }\n}\n"
        },
        {
            "file_name": "Idea_nxt_common.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"Idea_nxt_common.h\"\n\nconst BYTE pad[32] = {\n    0xb7, 0xe1, 0x51, 0x62, 0x8a, 0xed, 0x2a, 0x6a, 0xbf, 0x71, 0x58, 0x80,\n    0x9c, 0xf4, 0xf3, 0xc7, 0x62, 0xe7, 0x16, 0x0f, 0x38, 0xb4, 0xda, 0x56,\n    0xa7, 0x84, 0xd9, 0x04, 0x51, 0x90, 0xcf, 0xef\n};\n\nvoid nxt_p(const BYTE *key, BYTE l, BYTE *pkey, WORD ek)\n{\n    memcpy(pkey, key, l);\n    memcpy(pkey + l, pad, (ek >> 3) - l);\n}\n\nvoid nxt_m(const BYTE *pkey, BYTE *mkey, WORD ek)\n{\n    const BYTE mkey_m2 = 0x6a;\n    const BYTE mkey_m1 = 0x76;\n    int bound;\n    int i;\n\n    bound = (ek >> 3) - 1;\n\n    mkey[0] = pkey[0] ^ (mkey_m1 + mkey_m2);\n    mkey[1] = pkey[1] ^ (mkey[0] + mkey_m1);\n\n    for (i = 2; i <= bound; i++) {\n        mkey[i] = pkey[i] ^ (mkey[i - 1] + mkey[i - 2]);\n    }\n}\n"
        },
        {
            "file_name": "ifeedaes128n104v1_encrypt.cpp",
            "content": "#include \"ifeedaes128n104v1_encrypt.h\"\n#include \"ifeedaes128n104v1_api.h\"\n#include <stdio.h>\n\n// CHANGE namespace moved due to includes\nnamespace Ifeedaes128n104v1_raw {\nint numRounds = -1;\n\n//AES round key\nunsigned char RoundKey[176];\n//AES S-box\nint sbox[256] =\n{\n    //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n};\n\nunsigned char RC[] = {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91};\n\nvoid keyschedule(unsigned char *primekey, int roundNum)\n{\n    int KN, i;\n    switch(roundNum)\n    {\n    case 10:\n        KN = 16;\n        break;\n    case 12:\n        KN = 24;\n        break;\n    case 14:\n        KN = 32;\n        break;\n    }\n\n    for(i = 0; i < KN; i++)\n    {\n        RoundKey[i] = primekey[i];\n    }\n\n    for(i = KN / 4; i < (roundNum + 1) * 4; i++)\n    {\n\n        if(i % 4 == 0)\n        {\n\n            RoundKey[4 * i] = sbox[RoundKey[4 * (i - 1) + 1]] ^ RC[i / 4] ^ RoundKey[4 * (i - 4)];\n\n            RoundKey[4 * i + 1] = sbox[RoundKey[4 * (i - 1) + 2]] ^ RoundKey[4 * (i - 4) + 1];\n\n            RoundKey[4 * i + 2] = sbox[RoundKey[4 * (i - 1) + 3]] ^ RoundKey[4 * (i - 4) + 2];\n\n            RoundKey[(4 * i + 3)] = sbox[RoundKey[4 * (i - 1)]] ^ RoundKey[4 * (i - 4) + 3];\n        }\n        else\n        {\n\n            RoundKey[4 * i] = RoundKey[4 * (i - 1)] ^ RoundKey[4 * (i - 4)];\n            RoundKey[4 * i + 1] = RoundKey[4 * (i - 1) + 1] ^ RoundKey[4 * (i - 4) + 1];\n            RoundKey[4 * i + 2] = RoundKey[4 * (i - 1) + 2] ^ RoundKey[4 * (i - 4) + 2];\n            RoundKey[4 * i + 3] = RoundKey[4 * (i - 1) + 3] ^ RoundKey[4 * (i - 4) + 3];\n        }\n\n    }\n\n}\n\n\nvoid AES128Enc(unsigned char *in, unsigned char *out)\n{\n    int i, j, round = 0;\n    unsigned char temp;\n    unsigned char Tmp, Tm, t;\n    unsigned char state[4][4];\n\n\n    for(i = 0; i < 4; i++)\n        for(j = 0; j < 4; j++)\n            state[j][i] = in[i * 4 + j];\n\n\n    for(i = 0; i < 4; i++)\n        for(j = 0; j < 4; j++)\n            state[j][i] ^= RoundKey[ i * 4 + j];\n\n\n    for(round = 1; round < 10; round++)\n    {\n\n        for(i = 0; i < 4; i++)\n            for(j = 0; j < 4; j++)\n                state[i][j] = sbox[state[i][j]];\n\n\n        temp = state[1][0];\n        state[1][0] = state[1][1];\n        state[1][1] = state[1][2];\n        state[1][2] = state[1][3];\n        state[1][3] = temp;\n\n\n        temp = state[2][0];\n        state[2][0] = state[2][2];\n        state[2][2] = temp;\n\n        temp = state[2][1];\n        state[2][1] = state[2][3];\n        state[2][3] = temp;\n\n\n        temp = state[3][0];\n        state[3][0] = state[3][3];\n        state[3][3] = state[3][2];\n        state[3][2] = state[3][1];\n        state[3][1] = temp;\n\n\n\n        for(i = 0; i < 4; i++)\n        {\n            t = state[0][i];\n            Tmp = state[0][i] ^ state[1][i] ^ state[2][i] ^ state[3][i] ;\n            Tm = state[0][i] ^ state[1][i] ;\n            Tm = ((Tm << 1) ^ (((Tm >> 7) & 1) * 0x1b));\n            state[0][i] ^= Tm ^ Tmp ;\n            Tm = state[1][i] ^ state[2][i] ;\n            Tm = ((Tm << 1) ^ (((Tm >> 7) & 1) * 0x1b));\n            state[1][i] ^= Tm ^ Tmp ;\n            Tm = state[2][i] ^ state[3][i] ;\n            Tm = ((Tm << 1) ^ (((Tm >> 7) & 1) * 0x1b));\n            state[2][i] ^= Tm ^ Tmp ;\n            Tm = state[3][i] ^ t ;\n            Tm = ((Tm << 1) ^ (((Tm >> 7) & 1) * 0x1b));\n            state[3][i] ^= Tm ^ Tmp ;\n        }\n\n\n\n        for(i = 0; i < 4; i++)\n            for(j = 0; j < 4; j++)\n                state[j][i] ^= RoundKey[round * 16 + i * 4 + j];\n\n    }\n\n\n    for(i = 0; i < 4; i++)\n        for(j = 0; j < 4; j++)\n            state[i][j] = sbox[state[i][j]];\n\n\n    temp = state[1][0];\n    state[1][0] = state[1][1];\n    state[1][1] = state[1][2];\n    state[1][2] = state[1][3];\n    state[1][3] = temp;\n\n\n    temp = state[2][0];\n    state[2][0] = state[2][2];\n    state[2][2] = temp;\n\n    temp = state[2][1];\n    state[2][1] = state[2][3];\n    state[2][3] = temp;\n\n\n    temp = state[3][0];\n    state[3][0] = state[3][3];\n    state[3][3] = state[3][2];\n    state[3][2] = state[3][1];\n    state[3][1] = temp;\n\n    for(i = 0; i < 4; i++)\n        for(j = 0; j < 4; j++)\n            state[j][i] ^= RoundKey[160 + i * 4 + j];\n\n\n    for(i = 0; i < 4; i++)\n        for(j = 0; j < 4; j++)\n            out[i * 4 + j] = state[j][i];\n\n\n}\n\nvoid Times2(unsigned char times1[16], unsigned char times2[16])\n{\n    int i;\n    for (i = 0; i < 15; i++)\n    {\n        times2[i] = (times1[i] << 1) ^ (times1[i + 1] >> 7);\n    }\n\n    times2[15] = times1[15] << 1;\n    if ((times1[0] >> 7) != 0)\n    {\n        times2[15] ^= 0x87;\n    }\n}\n\nint crypto_aead_encrypt(\n    unsigned char *c, unsigned long long *clen,\n    const unsigned char *m, unsigned long long mlen,\n    const unsigned char *ad, unsigned long long adlen,\n    const unsigned char *nsec,\n    const unsigned char *npub,\n    const unsigned char *k\n)\n{\n    unsigned char SumB[16], LastABlock[16], MacAESTag[16], Key[16], Double[16];\n    unsigned long long a; // a is the block length of associated data A\n    unsigned char PaddedPMN[16];\n    unsigned char LastPlaintextBlock[16], PaddedBlock[16];\n    unsigned long long l; // l is the block length of plaintext\n    unsigned char StolenR[16];\n    unsigned char Z[3][16], NextZ[16], U[16];\n    unsigned char AESInputBlock[16], AESOutputBlock[16];\n    unsigned long long i, j;\n\n    //Precomputations, AES Key Scheduling\n    for(j = 0; j < 16; j++) Key[j] = k[j];\n    keyschedule(Key, 10);\n\n    //Precomputations, calculating Z0, Z1, Z2 masks\n    for(j = 0; j < 16; j++) AESInputBlock[j] = 0x0;\n    AES128Enc(AESInputBlock, Z[0]);\n\n    for(i = 0; i < 2; i++)\t Times2(Z[i], Z[i + 1]);\n\n    Times2(Z[2], NextZ); // NextZ is now Z3\n\n    //Authenticating associated data ad by MacAES\n    if(adlen == 0)\n    {\n        for(j = 0; j < 16; j++) MacAESTag[j] = 0x0;\n    }\n    else\n    {\n        if (adlen % 16 == 0)  a = adlen / 16;\n        else a = adlen / 16 + 1;\n\n        for(j = 0; j < 16; j++)  SumB[j] = 0x0;\n\n        for(i = 0; i < a - 1; i++)\n        {\n            for(j = 0; j < 16; j++)  AESInputBlock[j] = ad[i * 16 + j] ^ NextZ[j];\n\n            AES128Enc(AESInputBlock, AESOutputBlock);\n\n            for(j = 0; j < 16; j++) SumB[j] = SumB[j] ^ AESOutputBlock[j];\n\n            Times2(NextZ, Double);\n\n            for(j = 0; j < 16; j++) NextZ[j] = Double[j]; // producing next Z\n        }\n\n        if(adlen % 16 != 0)\n        {\n            for(j = 0; j < adlen % 16; j++) LastABlock[j] = ad[(a - 1) * 16 + j];\n            LastABlock[adlen % 16] = 0x80;\n            for(j = adlen % 16 + 1; j < 16; j++)\t\tLastABlock[j] = 0x0;\n\n            for(j = 0; j < 16; j++) AESInputBlock[j] = SumB[j] ^ LastABlock[j] ^ Z[1][j];\n        }\n        else\n        {\n            for(j = 0; j < 16; j++) AESInputBlock[j] = SumB[j] ^ ad[(a - 1) * 16 + j] ^ Z[2][j];\n        }\n\n        AES128Enc(AESInputBlock, MacAESTag);\n\n    }\n\n\n    *clen = mlen + 16;\n\n    // padding PublicPlaintextNumber with 10*\n    for(j = 0; j < CRYPTO_NPUBBYTES; j++) PaddedPMN[j] = npub[j];\n    PaddedPMN[CRYPTO_NPUBBYTES] = 0x80;\n    for(j = CRYPTO_NPUBBYTES + 1; j < 16; j++)\t PaddedPMN[j] = 0x0;\n\n    // generating the secret value U\n    AES128Enc(PaddedPMN, U);\n\n    if(mlen==0)\n    {\n         for(j = 0; j < 16; j++)  AESInputBlock[j] = Z[2][j]^ U[j];\n\n         AES128Enc(AESInputBlock, AESOutputBlock);\n\n         for(j = 0; j < 16; j++) c[j] = AESOutputBlock[j] ^ MacAESTag[j];\n\n    }\n    else\n    {\n        l = mlen / 16;\n\n    if (mlen % 16 != 0)\n    {\n        l = l + 1;\n\n        for(j = 0; j < mlen % 16; j++)\n        {\n            LastPlaintextBlock[j] = m[(l - 1) * 16 + j];\n            PaddedBlock[j] = 0x0;\n        }\n\n        LastPlaintextBlock[mlen % 16] = 0x0;\n        PaddedBlock[mlen % 16] = 0x80;\n\n        for(j = mlen % 16 + 1; j < 16; j++)\n        {\n            LastPlaintextBlock[j] = 0x0;\n            PaddedBlock[j] = 0x0;\n        }\n    }\n    else\n    {\n\n        for(j = 0; j < 16; j++)\n        {\n            LastPlaintextBlock[j] = m[(l - 1) * 16 + j];\n            PaddedBlock[j] = 0x0;\n        }\n    }\n\n    // Encryption for Plaintext\n    // Producing the first l-1 ciphertext blocks\n\n    Times2(Z[2], NextZ); // NextZ now is Z3\n    for(j = 0; j < 16; j++)  AESInputBlock[j] = NextZ[j] ^ U[j]; // NextZ now is Z3\n\n    AES128Enc(AESInputBlock, AESOutputBlock);\n\n    for(i = 0; i < l - 1; i++)\n    {\n        Times2(NextZ, Double); // producing the next Z\n\n        for(j = 0; j < 16; j++)\n        {\n            NextZ[j] = Double[j];\n            AESInputBlock[j] = m[i * 16 + j] ^ NextZ[j] ^ U[j];\n            c[i * 16 + j] = AESOutputBlock[j] ^ AESInputBlock[j];\n        }\n        AES128Enc(AESInputBlock, AESOutputBlock);\n    }\n\n    // Producing the last ciphertext block, note that its length may be smaller than 16\n    // Producing the stolen ciphertext R\n    if (mlen % 16 != 0)\n    {\n        for(j = 0; j < mlen % 16; j++)\n        {\n            c[(l - 1) * 16 + j] = AESOutputBlock[j] ^ LastPlaintextBlock[j];\n            StolenR[j] = 0x0;\n        }\n        for(j = (mlen % 16); j < 16; j++) StolenR[j] = AESOutputBlock[j] ^ PaddedBlock[j];\n    }\n    else\n    {\n        for(j = 0; j < 16; j++) c[(l - 1) * 16 + j] = AESOutputBlock[j] ^ LastPlaintextBlock[j];\n\n    }\n\n    // Producing the final Tag\n    if (mlen % 16 != 0)\n    {\n        for(j = 0; j < 16; j++)   AESInputBlock[j] = LastPlaintextBlock[j] ^ StolenR[j] ^ Z[1][j] ^ U[j];\n        AES128Enc(AESInputBlock, AESOutputBlock);\n        for(j = 0; j < 16; j++) c[(l - 1) * 16 + (mlen % 16) + j] = AESOutputBlock[j] ^ MacAESTag[j];\n    }\n    else\n    {\n        for(j = 0; j < 16; j++)   AESInputBlock[j] = LastPlaintextBlock[j] ^ Z[2][j] ^ U[j];\n        AES128Enc(AESInputBlock, AESOutputBlock);\n        for(j = 0; j < 16; j++) c[l * 16 + j] = AESOutputBlock[j] ^ MacAESTag[j];\n    }\n\n    }\n\n    return 0;\n}\n\n\nint crypto_aead_decrypt(\n    unsigned char *m, unsigned long long *mlen,\n    unsigned char *nsec,\n    const unsigned char *c, unsigned long long clen,\n    const unsigned char *ad, unsigned long long adlen,\n    const unsigned char *npub,\n    const unsigned char *k\n)\n{\n    unsigned char SumB[16], LastABlock[16], MacAESTag[16], Key[16], Double[16];\n    unsigned long long a; // a is the block length of associated data A\n    unsigned char PaddedPMN[16];\n    unsigned char LastCiphertextBlock[16], PaddedBlock[16];\n    unsigned long long l; // l is the block length of plaintext\n    unsigned char StolenR[16];\n    unsigned char Z[3][16], NextZ[16], U[16];\n    unsigned char AESInputBlock[16], AESOutputBlock[16];\n    unsigned long long i, j;\n\n    //Precomputations, AES Key Scheduling\n    for(j = 0; j < 16; j++) Key[j] = k[j];\n    keyschedule(Key, 10);\n\n    //Precomputations, calculating Z0, Z1, Z2 masks\n    for(j = 0; j < 16; j++) AESInputBlock[j] = 0x0;\n    AES128Enc(AESInputBlock, Z[0]);\n\n    for(i = 0; i < 2; i++)\t Times2(Z[i], Z[i + 1]);\n\n    Times2(Z[2], NextZ); // this is now Z3\n\n    //Authenticating associated data ad by MacAES\n    if(adlen == 0)\n    {\n        for(j = 0; j < 16; j++) MacAESTag[j] = 0x0;\n    }\n    else\n    {\n        if (adlen % 16 == 0)  a = adlen / 16;\n        else a = adlen / 16 + 1;\n\n        for(j = 0; j < 16; j++)  SumB[j] = 0x0;\n\n        for(i = 0; i < a - 1; i++)\n        {\n            for(j = 0; j < 16; j++)  AESInputBlock[j] = ad[i * 16 + j] ^ NextZ[j];\n\n            AES128Enc(AESInputBlock, AESOutputBlock);\n\n            for(j = 0; j < 16; j++) SumB[j] = SumB[j] ^ AESOutputBlock[j];\n\n            Times2(NextZ, Double);\n\n            for(j = 0; j < 16; j++) NextZ[j] = Double[j]; // producing the next Z\n        }\n\n        if(adlen % 16 != 0)\n        {\n            for(j = 0; j < adlen % 16; j++) LastABlock[j] = ad[(a - 1) * 16 + j];\n            LastABlock[adlen % 16] = 0x80;\n            for(j = adlen % 16 + 1; j < 16; j++)\t\tLastABlock[j] = 0x0;\n\n            for(j = 0; j < 16; j++) AESInputBlock[j] = SumB[j] ^ LastABlock[j] ^ Z[1][j];\n        }\n        else\n        {\n            for(j = 0; j < 16; j++) AESInputBlock[j] = SumB[j] ^ ad[(a - 1) * 16 + j] ^ Z[2][j];\n        }\n\n        AES128Enc(AESInputBlock, MacAESTag);\n    }\n\n\n\n    if(clen < 16) return -2; // invaild ciphertext\n\n    *mlen = clen - 16;\n\n    // padding PublicPlaintextNumber with 10*\n    for(j = 0; j < CRYPTO_NPUBBYTES; j++) PaddedPMN[j] = npub[j];\n    PaddedPMN[CRYPTO_NPUBBYTES] = 0x80;\n    for(j = CRYPTO_NPUBBYTES + 1; j < 16; j++)\t PaddedPMN[j] = 0x0;\n\n    // generating the secret value U\n    AES128Enc(PaddedPMN, U);\n\n    if(clen == 16)\n    {\n        for(j=0;j<16;j++) AESInputBlock[j] = Z[2][j] ^ U[j];\n\n        AES128Enc(AESInputBlock, AESOutputBlock);\n\n        for(j = 0; j < 16; j++)\n        {\n            if(c[j] != (AESOutputBlock[j] ^ MacAESTag[j])) return -1;\n        }\n\n    }\n    else {\n\n    l = clen / 16 - 1;\n    if (clen % 16 != 0)\n    {\n        l = l + 1;\n        for(j = 0; j < clen % 16; j++)\n        {\n            LastCiphertextBlock[j] = c[(l - 1) * 16 + j]; // note that this is C_l, not C_{l+1} related to the final tag\n            PaddedBlock[j] = 0x0;\n        }\n\n        LastCiphertextBlock[clen % 16] = 0x0;\n        PaddedBlock[clen % 16] = 0x80;\n\n        for(j = clen % 16 + 1; j < 16; j++)\n        {\n            LastCiphertextBlock[j] = 0x0;\n            PaddedBlock[j] = 0x0;\n        }\n    }\n    else\n    {\n        // l = l - 1;\n        for(j = 0; j < 16; j++)\n        {\n            LastCiphertextBlock[j] = c[(l - 1) * 16 + j];\n            PaddedBlock[j] = 0x0;\n        }\n    }\n\n\n    // Decryption from Ciphertext\n    // Producing the first l-1 plaintext blocks\n\n    Times2(Z[2], NextZ); // NextZ is now Z3\n\n    for(j = 0; j < 16; j++)  AESInputBlock[j] = NextZ[j] ^ U[j]; // NextZ is now Z3\n\n    AES128Enc(AESInputBlock, AESOutputBlock);\n\n    for(i = 0; i < l - 1; i++)\n    {\n        Times2(NextZ, Double); // producing the next Z\n\n        for(j = 0; j < 16; j++)\n        {\n            AESInputBlock[j] = AESOutputBlock[j] ^ c[i * 16 + j];\n            m[i * 16 + j] = AESInputBlock[j] ^ Double[j] ^ U[j];\n            NextZ[j] = Double[j];\n        }\n        AES128Enc(AESInputBlock, AESOutputBlock);\n    }\n\n    // Producing the last plaintext block\n    // Producing the stolen ciphertext R\n    if (clen % 16 != 0)\n    {\n        for(j = 0; j < clen % 16; j++)\n        {\n            m[(l - 1) * 16 + j] = AESOutputBlock[j] ^ c[(l - 1) * 16 + j];\n            StolenR[j] = 0x0;\n        }\n        for(j = (clen % 16); j < 16; j++) StolenR[j] = AESOutputBlock[j] ^ PaddedBlock[j];\n    }\n    else\n    {\n        for(j = 0; j < 16; j++)\n        {\n            m[(l - 1) * 16 + j] = AESOutputBlock[j] ^ c[(l - 1) * 16 + j];\n            StolenR[j] = 0x0;\n        }\n    }\n\n    // Checking the final Tag\n    if (clen % 16 != 0)\n    {\n        for(j = 0; j < (clen % 16); j++)   AESInputBlock[j] = m[(l - 1) * 16 + j] ^ Z[1][j] ^ U[j];\n        for(j = (clen % 16); j < 16; j++) AESInputBlock[j] = StolenR[j] ^ Z[1][j] ^ U[j];\n        AES128Enc(AESInputBlock, AESOutputBlock);\n\n        for(j = 0; j < 16; j++)\n        {\n            if(c[(l - 1) * 16 + clen % 16 + j] != (AESOutputBlock[j] ^ MacAESTag[j])) return -1;\n        }\n    }\n    else\n    {\n        for(j = 0; j < 16; j++)   AESInputBlock[j] = m[(l - 1) * 16 + j] ^ Z[2][j] ^ U[j];\n        AES128Enc(AESInputBlock, AESOutputBlock);\n\n        for(j = 0; j < 16; j++)\n        {\n            if(c[l * 16 + j] != (AESOutputBlock[j] ^ MacAESTag[j])) return -1;\n        }\n    }\n    }\n\n    return 0;\n}\n\n\n} // namespace Ifeedaes128n104v1_raw\n"
        },
        {
            "file_name": "itoa64.c",
            "content": "#include \"common.h\"\n#include \"itoa64.h\"\n\nint encode64 (char *dst, unsigned char *src, int size)\n{\n\tchar *dptr = dst;\n\tunsigned char *sptr = src;\n\tunsigned char *end  = sptr + size;\n\tunsigned char c1, c2;\n\n\tdo {\n\t\tc1 = *sptr++;\n\t\t*dptr++ = itoa64[shr(c1, 2)];\n\t\tc1 = shl((c1 & 0x03), 4);\n\n\t\tif (sptr >= end)\n\t\t{\n\t\t\t*dptr++ = itoa64[c1];\n\t\t\tbreak;\n\t\t}\n\n\t\tc2 = *sptr++;\n\t\tc1 |= shr(c2, 4) & 0x0f;\n\t\t*dptr++ = itoa64[c1];\n\t\tc1 = shl((c2 & 0x0f), 2);\n\n\t\tif (sptr >= end)\n\t\t{\n\t\t\t*dptr++ = itoa64[c1];\n\t\t\tbreak;\n\t\t}\n\n\t\tc2 = *sptr++;\n\t\tc1 |= shr(c2, 6) & 0x03;\n\t\t*dptr++ = itoa64[c1];\n\t\t*dptr++ = itoa64[c2 & 0x3f];\n\t} while (sptr < end);\n\n\t*dptr = '\\0';\n\n\treturn (dptr - dst);\n}\n\nint decode64 (unsigned char *dst, int size, char *src)\n{\n\tunsigned char *sptr = (unsigned char *) src;\n\tunsigned char *dptr = dst;\n\tunsigned char *end  = dst + size;\n\tunsigned char c1, c2, c3, c4;\n\n\tdo\n\t{\n\t\tc1 = char64(*sptr);\n\t\tc2 = char64(*(sptr + 1));\n\n\t\tif (c1 == 255 || c2 == 255) break;\n\n\t\t*dptr++ = shl(c1, 2) | shr((c2 & 0x30), 4);\n\t\tif (dptr >= end) break;\n\n\t\tc3 = char64(*(sptr + 2));\n\t\tif (c3 == 255) break;\n\n\t\t*dptr++ = shl((c2 & 0x0f), 4) | shr((c3 & 0x3c), 2);\n\t\tif (dptr >= end) break;\n\n\t\tc4 = char64(*(sptr + 3));\n\t\tif (c4 == 255) break;\n\n\t\t*dptr++ = shl((c3 & 0x03), 6) | c4;\n\t\tsptr += 4;\n\t} while (dptr < end);\n\n\treturn (dptr - dst);\n}\n"
        },
        {
            "file_name": "joltikneq12864v1_joltik.cpp",
            "content": "/*\n * Joltik=/=-128-64 Reference C Implementation\n *\n * Copyright 2014:\n *     Jeremy Jean <JJean@ntu.edu.sg>\n *     Ivica Nikolic <INikolic@ntu.edu.sg>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n *\n */\n\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include \"joltikneq12864v1_joltik.h\"\n#include \"joltikneq12864v1_tweakableBC.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Joltikneq12864v1_raw {\n\n/* Define the three MSB of the tweak (that depend on the stage) */\n#define MSB_AD \t\t\t      (0x2<<5)\n#define MSB_AD_LAST\t\t      (0x6<<5)\n#define MSB_M\t\t\t      (0x0<<5)\n#define MSB_M_LAST_ZERO\t\t  (0x1<<5)\n#define MSB_M_LAST_NONZERO\t  (0x4<<5)\n#define MSB_PAD\t\t\t      (0x4<<5)\n#define MSB_CHKSUM\t\t      (0x5<<5)\n\n/* Number of bits in the TWEAKEY state (128 or 192) */\n#define TWEAKEY_STATE_SIZE    192\n\n/**********************************************************************************\n*** In Joltik=/=-128-64, the tweak is on 64 bits:\n***     tweak = <stage> || <nonce> || <blockNumber>\n***  where we use:\n***      3 bits for stage\n***     32 bits for nonce\n***     29 bits for blockNumber\n***********************************************************************************/\n/*\n** Modifiy the nonce part in the tweak value\n*/\nstatic void set_nonce_in_tweak(uint8_t *tweak, const uint8_t *nonce) {\n    tweak[0] =\t(tweak[0]&0xe0)    ^ (nonce[0] >> 3);\n    tweak[1] = ((nonce[0]&7) << 5) ^ (nonce[1] >> 3);\n    tweak[2] = ((nonce[1]&7) << 5) ^ (nonce[2] >> 3);\n    tweak[3] = ((nonce[2]&7) << 5) ^ (nonce[3] >> 3);\n    tweak[4] = ((nonce[3]&7) << 5);\n}\n\n/*\n** Modifiy the block number in the tweak value\n*/\nstatic void set_block_number_in_tweak(uint8_t *tweak, const uint64_t block_no) {\n    tweak[4] = (tweak[4]&0xe0) ^ ((block_no >> 24ULL) & 0x1f);\n    tweak[5] = ((block_no >> 16ULL) & 0xff);\n    tweak[6] = ((block_no >>  8ULL) & 0xff);\n    tweak[7] = ((block_no >>  0ULL) & 0xff);\n}\n\n/*\n** Modifiy the stage value in the tweak value\n*/\nstatic void set_stage_in_tweak(uint8_t *tweak, const uint8_t value) {\n    tweak[0]=(tweak[0] & 0x1f) ^ value ;\n}\n\n/*\n** Update the tweak value in the tweakey word.\n** In the case of Joltik-BC-256, the tweakey word is composed of KEY || TWEAK.\n** In the case of Joltik-BC-384, the tweakey word is composed of KEY_2 || KEY_1 || TWEAK.\n*/\nstatic void set_tweak_in_tweakey(uint8_t *tweakey, uint8_t *tweak) {\n#if TWEAKEY_STATE_SIZE==128\n    memcpy(tweakey+8, tweak, 8);\n#elif TWEAKEY_STATE_SIZE==192\n    memcpy(tweakey+16, tweak, 8);\n#endif\n}\n\n/*\n** XOR an input block to another input block\n*/\nstatic void xor_values(uint8_t *v1, const uint8_t *v2) {\n    int i;\n    for (i=0; i<8; i++) v1[i] ^= v2[i];\n}\n\n/*\n** Joltik encryption function\n*/\nvoid joltik_aead_encrypt(const uint8_t *ass_data, size_t ass_data_len,\n                         const uint8_t *message, size_t m_len,\n                         const uint8_t *key,\n                         const uint8_t *nonce,\n                         uint8_t *ciphertext, size_t *c_len)\n{\n\n    uint64_t i;\n    uint64_t j;\n    uint8_t tweak[8];\n    uint8_t tweakey[TWEAKEY_STATE_SIZE/8];\n    uint8_t Auth[8];\n    uint8_t last_block[8];\n    uint8_t Checksum[8];\n    uint8_t Final[8];\n    uint8_t zero_block[8];\n    uint8_t Pad[8];\n    uint8_t temp[8];\n\n    /* Fill the tweak from nonce */\n    memset(tweak, 0, sizeof(tweak));\n\n    /* Set the nonce in the tweak */\n    set_nonce_in_tweak(tweak, nonce);\n\n    /* Fill the key(s) in the tweakey state */\n#if TWEAKEY_STATE_SIZE==128\n    memcpy(tweakey, key, 8);\n#elif TWEAKEY_STATE_SIZE==192\n    memcpy(tweakey, key, 16);\n#endif\n\n    /* Associated data */\n    memset(Auth, 0, 8);\n    set_stage_in_tweak(tweak, MSB_AD);\n\n    /* For each full input blocks */\n    i=1;\n    while (8*i <= ass_data_len) {\n\n        /* Encrypt the current block */\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, ass_data+8*(i-1), tweakey, temp);\n\n        /* Update Auth value */\n        xor_values(Auth, temp);\n\n        /* Go on with the next block */\n        i++;\n    }\n    i--;\n\n    /* Last block if incomplete */\n    if ( (ass_data_len==0) || (ass_data_len > 8*i) ) {\n\n        /* Prepare the last padded block */\n        memset(last_block, 0, 8);\n        memcpy(last_block, ass_data+8*i, ass_data_len-8*i);\n        last_block[ass_data_len-8*i]=0x80;\n\n        /* Encrypt the last block */\n        set_stage_in_tweak(tweak, MSB_AD_LAST);\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, last_block, tweakey, temp);\n\n        /* Update the Auth value */\n        xor_values(Auth, temp);\n    }\n\n    /* Message */\n    memset(Checksum, 0, 8);\n    set_stage_in_tweak(tweak, MSB_M);\n    i=1;\n    while (8*i <= m_len) {\n        xor_values(Checksum, message+8*(i-1));\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, message+8*(i-1), tweakey, ciphertext+8*(i-1));\n        i++;\n    }\n    i--;\n\n    /* Process last block */\n    /* If the block is full, i.e. M_last=epsilon */\n    if (m_len == 8*i) {\n        set_stage_in_tweak(tweak, MSB_M_LAST_ZERO);\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, Checksum, tweakey, Final);\n\n    } else { /* If the block is partial and requires padding */\n        memset(last_block, 0, 8);\n        memcpy(last_block, message+8*i, m_len-8*i);\n        last_block[m_len-8*i]=0x80;\n        xor_values(Checksum, last_block);\n\n        /* Create the zero block for encryption */\n        memset(zero_block, 0, 8);\n\n        /* Encrypt it */\n        set_stage_in_tweak(tweak, MSB_M_LAST_NONZERO);\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, zero_block, tweakey, Pad);\n\n        for (j=0; j<m_len-8*i; j++) {\n            ciphertext[8*i+j]=last_block[j] ^ Pad[j];\n        }\n        set_stage_in_tweak(tweak, MSB_CHKSUM);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, Checksum, tweakey, Final);\n    }\n\n    /* Append the authentication tag to the ciphertext */\n    for (i=0; i<8; i++) {\n        ciphertext[m_len+i]=Final[i] ^ Auth[i];\n    }\n\n    /* The authentication tag is one block long, i.e. 8 bytes */\n    *c_len=m_len+8;\n\n}\n\n/*\n** Joltik decryption function\n*/\nint joltik_aead_decrypt(const uint8_t *ass_data, size_t ass_data_len,\n                        uint8_t *message, size_t *m_len,\n                        const uint8_t *key,\n                        const uint8_t *nonce,\n                        const uint8_t *ciphertext, size_t c_len)\n{\n\n    uint64_t i;\n    uint64_t j;\n    uint8_t tweak[8];\n    uint8_t tweakey[TWEAKEY_STATE_SIZE/8];\n    uint8_t Auth[8];\n    uint8_t last_block[8];\n    uint8_t Checksum[8];\n    uint8_t Final[8];\n    uint8_t zero_block[8];\n    uint8_t Pad[8];\n    uint8_t Tag[8];\n    uint8_t temp[8];\n\n    /* Get the tag from the last 8 bytes of the ciphertext */\n    memcpy(Tag, ciphertext+c_len-8, 8);\n\n    /* Update c_len to the actual size of the ciphertext (i.e., without the tag) */\n    c_len-=8;\n\n    /* Fill the tweak from nonce */\n    set_nonce_in_tweak(tweak, nonce);\n\n    /* Fill the key(s) in the tweakey state */\n#if TWEAKEY_STATE_SIZE==128\n    memcpy(tweakey, key, 8);\n#elif TWEAKEY_STATE_SIZE==192\n    memcpy(tweakey, key, 16);\n#endif\n\n    /* Associated data */\n    memset(Auth, 0, 8);\n    set_stage_in_tweak(tweak, MSB_AD);\n    i=1;\n    while (8*i <= ass_data_len) {\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, ass_data+8*(i-1), tweakey, temp);\n        xor_values(Auth, temp);\n        i++;\n    }\n    i--;\n\n    /* Last block if incomplete */\n    if ((ass_data_len==0) || (ass_data_len > 8*i) ) {\n        memset(last_block, 0, 8);\n        memcpy(last_block, ass_data+8*i, ass_data_len-8*i);\n        last_block[ass_data_len-8*i]=0x80;\n        set_stage_in_tweak(tweak, MSB_AD_LAST);\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, last_block, tweakey, temp);\n        xor_values(Auth, temp);\n    }\n\n    /* Ciphertext */\n    memset(Checksum, 0, 8);\n    set_stage_in_tweak(tweak, MSB_M);\n    i=1;\n    while(8*i<=c_len) {\n        set_tweak_in_tweakey(tweakey, tweak);\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakDecrypt(TWEAKEY_STATE_SIZE, ciphertext+8*(i-1), tweakey, message+8*(i-1));\n\n        xor_values(Checksum, message+8*(i-1));\n        i++;\n    }\n    i--;\n\n    /* Last block */\n    /* If the block is full, i.e. M_last=epsilon */\n    if (c_len == 8*i) {\n        set_stage_in_tweak(tweak, MSB_M_LAST_ZERO);\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, Checksum, tweakey, Final);\n        xor_values(Final, Auth);\n\n        /* If the tags does not match, return error -1 */\n        if( 0 != memcmp(Final, Tag, sizeof(Tag)) ) {\n            return -1;\n        }\n\n    } else { /* If the block is partial and has been padded */\n\n        /* Prepare the full-zero block */\n        memset(zero_block, 0, 8);\n\n        /* Prepare the tweak */\n        set_stage_in_tweak(tweak, MSB_M_LAST_NONZERO);\n        set_block_number_in_tweak(tweak, i);\n        set_tweak_in_tweakey(tweakey, tweak);\n\n        /* Encrypt */\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, zero_block, tweakey, Pad);\n\n        /* XOR the partial ciphertext */\n        memset(last_block, 0, 8);\n        memcpy(last_block, ciphertext+8*i, c_len-8*i);\n        memset(Pad+c_len-8*i, 0, 8-(c_len-8*i));\n        xor_values(last_block, Pad);\n        last_block[c_len-8*i]=0x80;\n\n        for (j=0; j<c_len-8*i; j++) {\n            message[8*i+j]=last_block[j];\n        }\n\n        /* Update checksum */\n        xor_values(Checksum, last_block);\n\n        /* Verify the tag */\n        set_stage_in_tweak(tweak, MSB_CHKSUM);\n        set_tweak_in_tweakey(tweakey, tweak);\n        aesTweakEncrypt(TWEAKEY_STATE_SIZE, Checksum, tweakey, Final);\n        xor_values(Final, Auth);\n\n        /* If the tags does not match, return error -1 */\n        if( 0 != memcmp(Final, Tag, sizeof(Tag)) ) {\n            return -1;\n        }\n    }\n\n    *m_len=c_len;\n    return 0;\n}\n\n} // namespace Joltikneq12864v1_raw\n"
        },
        {
            "file_name": "juliusv1draft_aes.cpp",
            "content": "namespace Juliusv1draft_raw {\n\n#define uchar unsigned char // 8-bit byte\n#define uint unsigned long // 32-bit word\n\n// This is the specified AES SBox. To look up a substitution value, put the first\n// nibble in the first index (row) and the second nibble in the second index (column).\nconst uchar aes_sbox[16][16] = {\n   0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,\n   0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,\n   0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,\n   0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,\n   0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,\n   0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,\n   0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,\n   0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,\n   0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,\n   0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,\n   0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,\n   0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,\n   0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,\n   0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,\n   0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,\n   0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16\n};\n\nconst uchar aes_invsbox[16][16] = {\n   0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB,\n   0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB,\n   0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E,\n   0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25,\n   0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92,\n   0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84,\n   0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06,\n   0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B,\n   0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73,\n   0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E,\n   0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B,\n   0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4,\n   0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F,\n   0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF,\n   0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61,\n   0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D\n};\n\n// - This table stores pre-calculated values for all possible GF(2^8) calculations.This\n// table is only used by the (Inv)MixColumns steps.\n// USAGE: The second index (column) is the coefficient of multiplication. Only 7 different\n// coefficients are used: 0x01, 0x02, 0x03, 0x09, 0x0b, 0x0d, 0x0e, but multiplication by\n// 1 is negligible leaving only 6 coefficients. Each column of the table is devoted to one\n// of these coefficients, in the ascending order of value, from values 0x00 to 0xFF.\n// (Columns are listed double-wide to conserve vertical space.)\nuchar gf_mul[256][6] = {\n   {0x00,0x00,0x00,0x00,0x00,0x00},{0x02,0x03,0x09,0x0b,0x0d,0x0e},\n   {0x04,0x06,0x12,0x16,0x1a,0x1c},{0x06,0x05,0x1b,0x1d,0x17,0x12},\n   {0x08,0x0c,0x24,0x2c,0x34,0x38},{0x0a,0x0f,0x2d,0x27,0x39,0x36},\n   {0x0c,0x0a,0x36,0x3a,0x2e,0x24},{0x0e,0x09,0x3f,0x31,0x23,0x2a},\n   {0x10,0x18,0x48,0x58,0x68,0x70},{0x12,0x1b,0x41,0x53,0x65,0x7e},\n   {0x14,0x1e,0x5a,0x4e,0x72,0x6c},{0x16,0x1d,0x53,0x45,0x7f,0x62},\n   {0x18,0x14,0x6c,0x74,0x5c,0x48},{0x1a,0x17,0x65,0x7f,0x51,0x46},\n   {0x1c,0x12,0x7e,0x62,0x46,0x54},{0x1e,0x11,0x77,0x69,0x4b,0x5a},\n   {0x20,0x30,0x90,0xb0,0xd0,0xe0},{0x22,0x33,0x99,0xbb,0xdd,0xee},\n   {0x24,0x36,0x82,0xa6,0xca,0xfc},{0x26,0x35,0x8b,0xad,0xc7,0xf2},\n   {0x28,0x3c,0xb4,0x9c,0xe4,0xd8},{0x2a,0x3f,0xbd,0x97,0xe9,0xd6},\n   {0x2c,0x3a,0xa6,0x8a,0xfe,0xc4},{0x2e,0x39,0xaf,0x81,0xf3,0xca},\n   {0x30,0x28,0xd8,0xe8,0xb8,0x90},{0x32,0x2b,0xd1,0xe3,0xb5,0x9e},\n   {0x34,0x2e,0xca,0xfe,0xa2,0x8c},{0x36,0x2d,0xc3,0xf5,0xaf,0x82},\n   {0x38,0x24,0xfc,0xc4,0x8c,0xa8},{0x3a,0x27,0xf5,0xcf,0x81,0xa6},\n   {0x3c,0x22,0xee,0xd2,0x96,0xb4},{0x3e,0x21,0xe7,0xd9,0x9b,0xba},\n   {0x40,0x60,0x3b,0x7b,0xbb,0xdb},{0x42,0x63,0x32,0x70,0xb6,0xd5},\n   {0x44,0x66,0x29,0x6d,0xa1,0xc7},{0x46,0x65,0x20,0x66,0xac,0xc9},\n   {0x48,0x6c,0x1f,0x57,0x8f,0xe3},{0x4a,0x6f,0x16,0x5c,0x82,0xed},\n   {0x4c,0x6a,0x0d,0x41,0x95,0xff},{0x4e,0x69,0x04,0x4a,0x98,0xf1},\n   {0x50,0x78,0x73,0x23,0xd3,0xab},{0x52,0x7b,0x7a,0x28,0xde,0xa5},\n   {0x54,0x7e,0x61,0x35,0xc9,0xb7},{0x56,0x7d,0x68,0x3e,0xc4,0xb9},\n   {0x58,0x74,0x57,0x0f,0xe7,0x93},{0x5a,0x77,0x5e,0x04,0xea,0x9d},\n   {0x5c,0x72,0x45,0x19,0xfd,0x8f},{0x5e,0x71,0x4c,0x12,0xf0,0x81},\n   {0x60,0x50,0xab,0xcb,0x6b,0x3b},{0x62,0x53,0xa2,0xc0,0x66,0x35},\n   {0x64,0x56,0xb9,0xdd,0x71,0x27},{0x66,0x55,0xb0,0xd6,0x7c,0x29},\n   {0x68,0x5c,0x8f,0xe7,0x5f,0x03},{0x6a,0x5f,0x86,0xec,0x52,0x0d},\n   {0x6c,0x5a,0x9d,0xf1,0x45,0x1f},{0x6e,0x59,0x94,0xfa,0x48,0x11},\n   {0x70,0x48,0xe3,0x93,0x03,0x4b},{0x72,0x4b,0xea,0x98,0x0e,0x45},\n   {0x74,0x4e,0xf1,0x85,0x19,0x57},{0x76,0x4d,0xf8,0x8e,0x14,0x59},\n   {0x78,0x44,0xc7,0xbf,0x37,0x73},{0x7a,0x47,0xce,0xb4,0x3a,0x7d},\n   {0x7c,0x42,0xd5,0xa9,0x2d,0x6f},{0x7e,0x41,0xdc,0xa2,0x20,0x61},\n   {0x80,0xc0,0x76,0xf6,0x6d,0xad},{0x82,0xc3,0x7f,0xfd,0x60,0xa3},\n   {0x84,0xc6,0x64,0xe0,0x77,0xb1},{0x86,0xc5,0x6d,0xeb,0x7a,0xbf},\n   {0x88,0xcc,0x52,0xda,0x59,0x95},{0x8a,0xcf,0x5b,0xd1,0x54,0x9b},\n   {0x8c,0xca,0x40,0xcc,0x43,0x89},{0x8e,0xc9,0x49,0xc7,0x4e,0x87},\n   {0x90,0xd8,0x3e,0xae,0x05,0xdd},{0x92,0xdb,0x37,0xa5,0x08,0xd3},\n   {0x94,0xde,0x2c,0xb8,0x1f,0xc1},{0x96,0xdd,0x25,0xb3,0x12,0xcf},\n   {0x98,0xd4,0x1a,0x82,0x31,0xe5},{0x9a,0xd7,0x13,0x89,0x3c,0xeb},\n   {0x9c,0xd2,0x08,0x94,0x2b,0xf9},{0x9e,0xd1,0x01,0x9f,0x26,0xf7},\n   {0xa0,0xf0,0xe6,0x46,0xbd,0x4d},{0xa2,0xf3,0xef,0x4d,0xb0,0x43},\n   {0xa4,0xf6,0xf4,0x50,0xa7,0x51},{0xa6,0xf5,0xfd,0x5b,0xaa,0x5f},\n   {0xa8,0xfc,0xc2,0x6a,0x89,0x75},{0xaa,0xff,0xcb,0x61,0x84,0x7b},\n   {0xac,0xfa,0xd0,0x7c,0x93,0x69},{0xae,0xf9,0xd9,0x77,0x9e,0x67},\n   {0xb0,0xe8,0xae,0x1e,0xd5,0x3d},{0xb2,0xeb,0xa7,0x15,0xd8,0x33},\n   {0xb4,0xee,0xbc,0x08,0xcf,0x21},{0xb6,0xed,0xb5,0x03,0xc2,0x2f},\n   {0xb8,0xe4,0x8a,0x32,0xe1,0x05},{0xba,0xe7,0x83,0x39,0xec,0x0b},\n   {0xbc,0xe2,0x98,0x24,0xfb,0x19},{0xbe,0xe1,0x91,0x2f,0xf6,0x17},\n   {0xc0,0xa0,0x4d,0x8d,0xd6,0x76},{0xc2,0xa3,0x44,0x86,0xdb,0x78},\n   {0xc4,0xa6,0x5f,0x9b,0xcc,0x6a},{0xc6,0xa5,0x56,0x90,0xc1,0x64},\n   {0xc8,0xac,0x69,0xa1,0xe2,0x4e},{0xca,0xaf,0x60,0xaa,0xef,0x40},\n   {0xcc,0xaa,0x7b,0xb7,0xf8,0x52},{0xce,0xa9,0x72,0xbc,0xf5,0x5c},\n   {0xd0,0xb8,0x05,0xd5,0xbe,0x06},{0xd2,0xbb,0x0c,0xde,0xb3,0x08},\n   {0xd4,0xbe,0x17,0xc3,0xa4,0x1a},{0xd6,0xbd,0x1e,0xc8,0xa9,0x14},\n   {0xd8,0xb4,0x21,0xf9,0x8a,0x3e},{0xda,0xb7,0x28,0xf2,0x87,0x30},\n   {0xdc,0xb2,0x33,0xef,0x90,0x22},{0xde,0xb1,0x3a,0xe4,0x9d,0x2c},\n   {0xe0,0x90,0xdd,0x3d,0x06,0x96},{0xe2,0x93,0xd4,0x36,0x0b,0x98},\n   {0xe4,0x96,0xcf,0x2b,0x1c,0x8a},{0xe6,0x95,0xc6,0x20,0x11,0x84},\n   {0xe8,0x9c,0xf9,0x11,0x32,0xae},{0xea,0x9f,0xf0,0x1a,0x3f,0xa0},\n   {0xec,0x9a,0xeb,0x07,0x28,0xb2},{0xee,0x99,0xe2,0x0c,0x25,0xbc},\n   {0xf0,0x88,0x95,0x65,0x6e,0xe6},{0xf2,0x8b,0x9c,0x6e,0x63,0xe8},\n   {0xf4,0x8e,0x87,0x73,0x74,0xfa},{0xf6,0x8d,0x8e,0x78,0x79,0xf4},\n   {0xf8,0x84,0xb1,0x49,0x5a,0xde},{0xfa,0x87,0xb8,0x42,0x57,0xd0},\n   {0xfc,0x82,0xa3,0x5f,0x40,0xc2},{0xfe,0x81,0xaa,0x54,0x4d,0xcc},\n   {0x1b,0x9b,0xec,0xf7,0xda,0x41},{0x19,0x98,0xe5,0xfc,0xd7,0x4f},\n   {0x1f,0x9d,0xfe,0xe1,0xc0,0x5d},{0x1d,0x9e,0xf7,0xea,0xcd,0x53},\n   {0x13,0x97,0xc8,0xdb,0xee,0x79},{0x11,0x94,0xc1,0xd0,0xe3,0x77},\n   {0x17,0x91,0xda,0xcd,0xf4,0x65},{0x15,0x92,0xd3,0xc6,0xf9,0x6b},\n   {0x0b,0x83,0xa4,0xaf,0xb2,0x31},{0x09,0x80,0xad,0xa4,0xbf,0x3f},\n   {0x0f,0x85,0xb6,0xb9,0xa8,0x2d},{0x0d,0x86,0xbf,0xb2,0xa5,0x23},\n   {0x03,0x8f,0x80,0x83,0x86,0x09},{0x01,0x8c,0x89,0x88,0x8b,0x07},\n   {0x07,0x89,0x92,0x95,0x9c,0x15},{0x05,0x8a,0x9b,0x9e,0x91,0x1b},\n   {0x3b,0xab,0x7c,0x47,0x0a,0xa1},{0x39,0xa8,0x75,0x4c,0x07,0xaf},\n   {0x3f,0xad,0x6e,0x51,0x10,0xbd},{0x3d,0xae,0x67,0x5a,0x1d,0xb3},\n   {0x33,0xa7,0x58,0x6b,0x3e,0x99},{0x31,0xa4,0x51,0x60,0x33,0x97},\n   {0x37,0xa1,0x4a,0x7d,0x24,0x85},{0x35,0xa2,0x43,0x76,0x29,0x8b},\n   {0x2b,0xb3,0x34,0x1f,0x62,0xd1},{0x29,0xb0,0x3d,0x14,0x6f,0xdf},\n   {0x2f,0xb5,0x26,0x09,0x78,0xcd},{0x2d,0xb6,0x2f,0x02,0x75,0xc3},\n   {0x23,0xbf,0x10,0x33,0x56,0xe9},{0x21,0xbc,0x19,0x38,0x5b,0xe7},\n   {0x27,0xb9,0x02,0x25,0x4c,0xf5},{0x25,0xba,0x0b,0x2e,0x41,0xfb},\n   {0x5b,0xfb,0xd7,0x8c,0x61,0x9a},{0x59,0xf8,0xde,0x87,0x6c,0x94},\n   {0x5f,0xfd,0xc5,0x9a,0x7b,0x86},{0x5d,0xfe,0xcc,0x91,0x76,0x88},\n   {0x53,0xf7,0xf3,0xa0,0x55,0xa2},{0x51,0xf4,0xfa,0xab,0x58,0xac},\n   {0x57,0xf1,0xe1,0xb6,0x4f,0xbe},{0x55,0xf2,0xe8,0xbd,0x42,0xb0},\n   {0x4b,0xe3,0x9f,0xd4,0x09,0xea},{0x49,0xe0,0x96,0xdf,0x04,0xe4},\n   {0x4f,0xe5,0x8d,0xc2,0x13,0xf6},{0x4d,0xe6,0x84,0xc9,0x1e,0xf8},\n   {0x43,0xef,0xbb,0xf8,0x3d,0xd2},{0x41,0xec,0xb2,0xf3,0x30,0xdc},\n   {0x47,0xe9,0xa9,0xee,0x27,0xce},{0x45,0xea,0xa0,0xe5,0x2a,0xc0},\n   {0x7b,0xcb,0x47,0x3c,0xb1,0x7a},{0x79,0xc8,0x4e,0x37,0xbc,0x74},\n   {0x7f,0xcd,0x55,0x2a,0xab,0x66},{0x7d,0xce,0x5c,0x21,0xa6,0x68},\n   {0x73,0xc7,0x63,0x10,0x85,0x42},{0x71,0xc4,0x6a,0x1b,0x88,0x4c},\n   {0x77,0xc1,0x71,0x06,0x9f,0x5e},{0x75,0xc2,0x78,0x0d,0x92,0x50},\n   {0x6b,0xd3,0x0f,0x64,0xd9,0x0a},{0x69,0xd0,0x06,0x6f,0xd4,0x04},\n   {0x6f,0xd5,0x1d,0x72,0xc3,0x16},{0x6d,0xd6,0x14,0x79,0xce,0x18},\n   {0x63,0xdf,0x2b,0x48,0xed,0x32},{0x61,0xdc,0x22,0x43,0xe0,0x3c},\n   {0x67,0xd9,0x39,0x5e,0xf7,0x2e},{0x65,0xda,0x30,0x55,0xfa,0x20},\n   {0x9b,0x5b,0x9a,0x01,0xb7,0xec},{0x99,0x58,0x93,0x0a,0xba,0xe2},\n   {0x9f,0x5d,0x88,0x17,0xad,0xf0},{0x9d,0x5e,0x81,0x1c,0xa0,0xfe},\n   {0x93,0x57,0xbe,0x2d,0x83,0xd4},{0x91,0x54,0xb7,0x26,0x8e,0xda},\n   {0x97,0x51,0xac,0x3b,0x99,0xc8},{0x95,0x52,0xa5,0x30,0x94,0xc6},\n   {0x8b,0x43,0xd2,0x59,0xdf,0x9c},{0x89,0x40,0xdb,0x52,0xd2,0x92},\n   {0x8f,0x45,0xc0,0x4f,0xc5,0x80},{0x8d,0x46,0xc9,0x44,0xc8,0x8e},\n   {0x83,0x4f,0xf6,0x75,0xeb,0xa4},{0x81,0x4c,0xff,0x7e,0xe6,0xaa},\n   {0x87,0x49,0xe4,0x63,0xf1,0xb8},{0x85,0x4a,0xed,0x68,0xfc,0xb6},\n   {0xbb,0x6b,0x0a,0xb1,0x67,0x0c},{0xb9,0x68,0x03,0xba,0x6a,0x02},\n   {0xbf,0x6d,0x18,0xa7,0x7d,0x10},{0xbd,0x6e,0x11,0xac,0x70,0x1e},\n   {0xb3,0x67,0x2e,0x9d,0x53,0x34},{0xb1,0x64,0x27,0x96,0x5e,0x3a},\n   {0xb7,0x61,0x3c,0x8b,0x49,0x28},{0xb5,0x62,0x35,0x80,0x44,0x26},\n   {0xab,0x73,0x42,0xe9,0x0f,0x7c},{0xa9,0x70,0x4b,0xe2,0x02,0x72},\n   {0xaf,0x75,0x50,0xff,0x15,0x60},{0xad,0x76,0x59,0xf4,0x18,0x6e},\n   {0xa3,0x7f,0x66,0xc5,0x3b,0x44},{0xa1,0x7c,0x6f,0xce,0x36,0x4a},\n   {0xa7,0x79,0x74,0xd3,0x21,0x58},{0xa5,0x7a,0x7d,0xd8,0x2c,0x56},\n   {0xdb,0x3b,0xa1,0x7a,0x0c,0x37},{0xd9,0x38,0xa8,0x71,0x01,0x39},\n   {0xdf,0x3d,0xb3,0x6c,0x16,0x2b},{0xdd,0x3e,0xba,0x67,0x1b,0x25},\n   {0xd3,0x37,0x85,0x56,0x38,0x0f},{0xd1,0x34,0x8c,0x5d,0x35,0x01},\n   {0xd7,0x31,0x97,0x40,0x22,0x13},{0xd5,0x32,0x9e,0x4b,0x2f,0x1d},\n   {0xcb,0x23,0xe9,0x22,0x64,0x47},{0xc9,0x20,0xe0,0x29,0x69,0x49},\n   {0xcf,0x25,0xfb,0x34,0x7e,0x5b},{0xcd,0x26,0xf2,0x3f,0x73,0x55},\n   {0xc3,0x2f,0xcd,0x0e,0x50,0x7f},{0xc1,0x2c,0xc4,0x05,0x5d,0x71},\n   {0xc7,0x29,0xdf,0x18,0x4a,0x63},{0xc5,0x2a,0xd6,0x13,0x47,0x6d},\n   {0xfb,0x0b,0x31,0xca,0xdc,0xd7},{0xf9,0x08,0x38,0xc1,0xd1,0xd9},\n   {0xff,0x0d,0x23,0xdc,0xc6,0xcb},{0xfd,0x0e,0x2a,0xd7,0xcb,0xc5},\n   {0xf3,0x07,0x15,0xe6,0xe8,0xef},{0xf1,0x04,0x1c,0xed,0xe5,0xe1},\n   {0xf7,0x01,0x07,0xf0,0xf2,0xf3},{0xf5,0x02,0x0e,0xfb,0xff,0xfd},\n   {0xeb,0x13,0x79,0x92,0xb4,0xa7},{0xe9,0x10,0x70,0x99,0xb9,0xa9},\n   {0xef,0x15,0x6b,0x84,0xae,0xbb},{0xed,0x16,0x62,0x8f,0xa3,0xb5},\n   {0xe3,0x1f,0x5d,0xbe,0x80,0x9f},{0xe1,0x1c,0x54,0xb5,0x8d,0x91},\n   {0xe7,0x19,0x4f,0xa8,0x9a,0x83},{0xe5,0x1a,0x46,0xa3,0x97,0x8d}\n};\n\n/********************\n** ADD ROUND KEY\n********************/\n\n// Performs the AddRoundKey step. Each round has its own pre-generated 16-byte key in the\n// form of 4 integers (the \"w\" array). Each integer is XOR'd by one column of the state.\n// Also performs the job of InvAddRoundKey(); since the function is a simple XOR process,\n// it is its own inverse.\nvoid AddRoundKey(uchar state[][4], uint w[])\n{\n   uchar subkey[4];\n   // memcpy(subkey,&w[idx],4); // Not accurate for big endian machines\n   // Subkey 1\n   subkey[0] = w[0] >> 24;\n   subkey[1] = w[0] >> 16;\n   subkey[2] = w[0] >> 8;\n   subkey[3] = w[0];\n   state[0][0] ^= subkey[0];\n   state[1][0] ^= subkey[1];\n   state[2][0] ^= subkey[2];\n   state[3][0] ^= subkey[3];\n   // Subkey 2\n   subkey[0] = w[1] >> 24;\n   subkey[1] = w[1] >> 16;\n   subkey[2] = w[1] >> 8;\n   subkey[3] = w[1];\n   state[0][1] ^= subkey[0];\n   state[1][1] ^= subkey[1];\n   state[2][1] ^= subkey[2];\n   state[3][1] ^= subkey[3];\n   // Subkey 3\n   subkey[0] = w[2] >> 24;\n   subkey[1] = w[2] >> 16;\n   subkey[2] = w[2] >> 8;\n   subkey[3] = w[2];\n   state[0][2] ^= subkey[0];\n   state[1][2] ^= subkey[1];\n   state[2][2] ^= subkey[2];\n   state[3][2] ^= subkey[3];\n   // Subkey 4\n   subkey[0] = w[3] >> 24;\n   subkey[1] = w[3] >> 16;\n   subkey[2] = w[3] >> 8;\n   subkey[3] = w[3];\n   state[0][3] ^= subkey[0];\n   state[1][3] ^= subkey[1];\n   state[2][3] ^= subkey[2];\n   state[3][3] ^= subkey[3];\n}\n\n/********************\n** (Inv)SubBytes\n********************/\n\n// Performs the SubBytes step. All bytes in the state are substituted with a \n// pre-calculated value from a lookup table.\nvoid SubBytes(uchar state[][4])\n{\n   state[0][0] = aes_sbox[state[0][0] >> 4][state[0][0] & 0x0F];\n   state[0][1] = aes_sbox[state[0][1] >> 4][state[0][1] & 0x0F];\n   state[0][2] = aes_sbox[state[0][2] >> 4][state[0][2] & 0x0F];\n   state[0][3] = aes_sbox[state[0][3] >> 4][state[0][3] & 0x0F];\n   state[1][0] = aes_sbox[state[1][0] >> 4][state[1][0] & 0x0F];\n   state[1][1] = aes_sbox[state[1][1] >> 4][state[1][1] & 0x0F];\n   state[1][2] = aes_sbox[state[1][2] >> 4][state[1][2] & 0x0F];\n   state[1][3] = aes_sbox[state[1][3] >> 4][state[1][3] & 0x0F];\n   state[2][0] = aes_sbox[state[2][0] >> 4][state[2][0] & 0x0F];\n   state[2][1] = aes_sbox[state[2][1] >> 4][state[2][1] & 0x0F];\n   state[2][2] = aes_sbox[state[2][2] >> 4][state[2][2] & 0x0F];\n   state[2][3] = aes_sbox[state[2][3] >> 4][state[2][3] & 0x0F];\n   state[3][0] = aes_sbox[state[3][0] >> 4][state[3][0] & 0x0F];\n   state[3][1] = aes_sbox[state[3][1] >> 4][state[3][1] & 0x0F];\n   state[3][2] = aes_sbox[state[3][2] >> 4][state[3][2] & 0x0F];\n   state[3][3] = aes_sbox[state[3][3] >> 4][state[3][3] & 0x0F];\n}\n\nvoid InvSubBytes(uchar state[][4])\n{\n   state[0][0] = aes_invsbox[state[0][0] >> 4][state[0][0] & 0x0F];\n   state[0][1] = aes_invsbox[state[0][1] >> 4][state[0][1] & 0x0F];\n   state[0][2] = aes_invsbox[state[0][2] >> 4][state[0][2] & 0x0F];\n   state[0][3] = aes_invsbox[state[0][3] >> 4][state[0][3] & 0x0F];\n   state[1][0] = aes_invsbox[state[1][0] >> 4][state[1][0] & 0x0F];\n   state[1][1] = aes_invsbox[state[1][1] >> 4][state[1][1] & 0x0F];\n   state[1][2] = aes_invsbox[state[1][2] >> 4][state[1][2] & 0x0F];\n   state[1][3] = aes_invsbox[state[1][3] >> 4][state[1][3] & 0x0F];\n   state[2][0] = aes_invsbox[state[2][0] >> 4][state[2][0] & 0x0F];\n   state[2][1] = aes_invsbox[state[2][1] >> 4][state[2][1] & 0x0F];\n   state[2][2] = aes_invsbox[state[2][2] >> 4][state[2][2] & 0x0F];\n   state[2][3] = aes_invsbox[state[2][3] >> 4][state[2][3] & 0x0F];\n   state[3][0] = aes_invsbox[state[3][0] >> 4][state[3][0] & 0x0F];\n   state[3][1] = aes_invsbox[state[3][1] >> 4][state[3][1] & 0x0F];\n   state[3][2] = aes_invsbox[state[3][2] >> 4][state[3][2] & 0x0F];\n   state[3][3] = aes_invsbox[state[3][3] >> 4][state[3][3] & 0x0F];\n}\n\n/********************\n** (Inv)ShiftRows\n********************/\n\n// Performs the ShiftRows step. All rows are shifted cylindrically to the left.\nvoid ShiftRows(uchar state[][4])\n{\n   int t;\n   // Shift left by 1\n   t = state[1][0];\n   state[1][0] = state[1][1];\n   state[1][1] = state[1][2];\n   state[1][2] = state[1][3];\n   state[1][3] = t;\n   // Shift left by 2\n   t = state[2][0];\n   state[2][0] = state[2][2];\n   state[2][2] = t;\n   t = state[2][1];\n   state[2][1] = state[2][3];\n   state[2][3] = t;\n   // Shift left by 3\n   t = state[3][0];\n   state[3][0] = state[3][3];\n   state[3][3] = state[3][2];\n   state[3][2] = state[3][1];\n   state[3][1] = t;\n}\n\n// All rows are shifted cylindrically to the right.\nvoid InvShiftRows(uchar state[][4])\n{\n   int t;\n   // Shift right by 1\n   t = state[1][3];\n   state[1][3] = state[1][2];\n   state[1][2] = state[1][1];\n   state[1][1] = state[1][0];\n   state[1][0] = t;\n   // Shift right by 2\n   t = state[2][3];\n   state[2][3] = state[2][1];\n   state[2][1] = t;\n   t = state[2][2];\n   state[2][2] = state[2][0];\n   state[2][0] = t;\n   // Shift right by 3\n   t = state[3][3];\n   state[3][3] = state[3][0];\n   state[3][0] = state[3][1];\n   state[3][1] = state[3][2];\n   state[3][2] = t;\n}\n\n/********************\n** (Inv)MixColumns\n********************/\n\n// Performs the MixColums step. The state is multiplied by itself using matrix\n// multiplication in a Galios Field 2^8. All multiplication is pre-computed in a table.\n// Addition is equivilent to XOR. (Must always make a copy of the column as the original\n// values will be destoyed.)\nvoid MixColumns(uchar state[][4])\n{\n   uchar col[4];\n   // Column 1\n   col[0] = state[0][0];\n   col[1] = state[1][0];\n   col[2] = state[2][0];\n   col[3] = state[3][0];\n   state[0][0] = gf_mul[col[0]][0];\n   state[0][0] ^= gf_mul[col[1]][1];\n   state[0][0] ^= col[2];\n   state[0][0] ^= col[3];\n   state[1][0] = col[0];\n   state[1][0] ^= gf_mul[col[1]][0];\n   state[1][0] ^= gf_mul[col[2]][1];\n   state[1][0] ^= col[3];\n   state[2][0] = col[0];\n   state[2][0] ^= col[1];\n   state[2][0] ^= gf_mul[col[2]][0];\n   state[2][0] ^= gf_mul[col[3]][1];\n   state[3][0] = gf_mul[col[0]][1];\n   state[3][0] ^= col[1];\n   state[3][0] ^= col[2];\n   state[3][0] ^= gf_mul[col[3]][0];\n   // Column 2\n   col[0] = state[0][1];\n   col[1] = state[1][1];\n   col[2] = state[2][1];\n   col[3] = state[3][1];\n   state[0][1] = gf_mul[col[0]][0];\n   state[0][1] ^= gf_mul[col[1]][1];\n   state[0][1] ^= col[2];\n   state[0][1] ^= col[3];\n   state[1][1] = col[0];\n   state[1][1] ^= gf_mul[col[1]][0];\n   state[1][1] ^= gf_mul[col[2]][1];\n   state[1][1] ^= col[3];\n   state[2][1] = col[0];\n   state[2][1] ^= col[1];\n   state[2][1] ^= gf_mul[col[2]][0];\n   state[2][1] ^= gf_mul[col[3]][1];\n   state[3][1] = gf_mul[col[0]][1];\n   state[3][1] ^= col[1];\n   state[3][1] ^= col[2];\n   state[3][1] ^= gf_mul[col[3]][0];\n   // Column 3\n   col[0] = state[0][2];\n   col[1] = state[1][2];\n   col[2] = state[2][2];\n   col[3] = state[3][2];\n   state[0][2] = gf_mul[col[0]][0];\n   state[0][2] ^= gf_mul[col[1]][1];\n   state[0][2] ^= col[2];\n   state[0][2] ^= col[3];\n   state[1][2] = col[0];\n   state[1][2] ^= gf_mul[col[1]][0];\n   state[1][2] ^= gf_mul[col[2]][1];\n   state[1][2] ^= col[3];\n   state[2][2] = col[0];\n   state[2][2] ^= col[1];\n   state[2][2] ^= gf_mul[col[2]][0];\n   state[2][2] ^= gf_mul[col[3]][1];\n   state[3][2] = gf_mul[col[0]][1];\n   state[3][2] ^= col[1];\n   state[3][2] ^= col[2];\n   state[3][2] ^= gf_mul[col[3]][0];\n   // Column 4\n   col[0] = state[0][3];\n   col[1] = state[1][3];\n   col[2] = state[2][3];\n   col[3] = state[3][3];\n   state[0][3] = gf_mul[col[0]][0];\n   state[0][3] ^= gf_mul[col[1]][1];\n   state[0][3] ^= col[2];\n   state[0][3] ^= col[3];\n   state[1][3] = col[0];\n   state[1][3] ^= gf_mul[col[1]][0];\n   state[1][3] ^= gf_mul[col[2]][1];\n   state[1][3] ^= col[3];\n   state[2][3] = col[0];\n   state[2][3] ^= col[1];\n   state[2][3] ^= gf_mul[col[2]][0];\n   state[2][3] ^= gf_mul[col[3]][1];\n   state[3][3] = gf_mul[col[0]][1];\n   state[3][3] ^= col[1];\n   state[3][3] ^= col[2];\n   state[3][3] ^= gf_mul[col[3]][0];\n}\n\nvoid InvMixColumns(uchar state[][4])\n{\n   int idx;\n   uchar col[4],t;\n   // Column 1\n   col[0] = state[0][0];\n   col[1] = state[1][0];\n   col[2] = state[2][0];\n   col[3] = state[3][0];\n   state[0][0] = gf_mul[col[0]][5];\n   state[0][0] ^= gf_mul[col[1]][3];\n   state[0][0] ^= gf_mul[col[2]][4];\n   state[0][0] ^= gf_mul[col[3]][2];\n   state[1][0] = gf_mul[col[0]][2];\n   state[1][0] ^= gf_mul[col[1]][5];\n   state[1][0] ^= gf_mul[col[2]][3];\n   state[1][0] ^= gf_mul[col[3]][4];\n   state[2][0] = gf_mul[col[0]][4];\n   state[2][0] ^= gf_mul[col[1]][2];\n   state[2][0] ^= gf_mul[col[2]][5];\n   state[2][0] ^= gf_mul[col[3]][3];\n   state[3][0] = gf_mul[col[0]][3];\n   state[3][0] ^= gf_mul[col[1]][4];\n   state[3][0] ^= gf_mul[col[2]][2];\n   state[3][0] ^= gf_mul[col[3]][5];\n   // Column 2\n   col[0] = state[0][1];\n   col[1] = state[1][1];\n   col[2] = state[2][1];\n   col[3] = state[3][1];\n   state[0][1] = gf_mul[col[0]][5];\n   state[0][1] ^= gf_mul[col[1]][3];\n   state[0][1] ^= gf_mul[col[2]][4];\n   state[0][1] ^= gf_mul[col[3]][2];\n   state[1][1] = gf_mul[col[0]][2];\n   state[1][1] ^= gf_mul[col[1]][5];\n   state[1][1] ^= gf_mul[col[2]][3];\n   state[1][1] ^= gf_mul[col[3]][4];\n   state[2][1] = gf_mul[col[0]][4];\n   state[2][1] ^= gf_mul[col[1]][2];\n   state[2][1] ^= gf_mul[col[2]][5];\n   state[2][1] ^= gf_mul[col[3]][3];\n   state[3][1] = gf_mul[col[0]][3];\n   state[3][1] ^= gf_mul[col[1]][4];\n   state[3][1] ^= gf_mul[col[2]][2];\n   state[3][1] ^= gf_mul[col[3]][5];\n   // Column 3\n   col[0] = state[0][2];\n   col[1] = state[1][2];\n   col[2] = state[2][2];\n   col[3] = state[3][2];\n   state[0][2] = gf_mul[col[0]][5];\n   state[0][2] ^= gf_mul[col[1]][3];\n   state[0][2] ^= gf_mul[col[2]][4];\n   state[0][2] ^= gf_mul[col[3]][2];\n   state[1][2] = gf_mul[col[0]][2];\n   state[1][2] ^= gf_mul[col[1]][5];\n   state[1][2] ^= gf_mul[col[2]][3];\n   state[1][2] ^= gf_mul[col[3]][4];\n   state[2][2] = gf_mul[col[0]][4];\n   state[2][2] ^= gf_mul[col[1]][2];\n   state[2][2] ^= gf_mul[col[2]][5];\n   state[2][2] ^= gf_mul[col[3]][3];\n   state[3][2] = gf_mul[col[0]][3];\n   state[3][2] ^= gf_mul[col[1]][4];\n   state[3][2] ^= gf_mul[col[2]][2];\n   state[3][2] ^= gf_mul[col[3]][5];\n   // Column 4\n   col[0] = state[0][3];\n   col[1] = state[1][3];\n   col[2] = state[2][3];\n   col[3] = state[3][3];\n   state[0][3] = gf_mul[col[0]][5];\n   state[0][3] ^= gf_mul[col[1]][3];\n   state[0][3] ^= gf_mul[col[2]][4];\n   state[0][3] ^= gf_mul[col[3]][2];\n   state[1][3] = gf_mul[col[0]][2];\n   state[1][3] ^= gf_mul[col[1]][5];\n   state[1][3] ^= gf_mul[col[2]][3];\n   state[1][3] ^= gf_mul[col[3]][4];\n   state[2][3] = gf_mul[col[0]][4];\n   state[2][3] ^= gf_mul[col[1]][2];\n   state[2][3] ^= gf_mul[col[2]][5];\n   state[2][3] ^= gf_mul[col[3]][3];\n   state[3][3] = gf_mul[col[0]][3];\n   state[3][3] ^= gf_mul[col[1]][4];\n   state[3][3] ^= gf_mul[col[2]][2];\n   state[3][3] ^= gf_mul[col[3]][5];\n}\n\n/********************\n** DEBUGGING FUNCTIONS\n********************/\n\n// This prints the \"state\" grid as a linear hex string\nvoid printstate(uchar state[][4])\n{\n   int idx,idx2;\n   for (idx=0; idx < 4; idx++)\n      for (idx2=0; idx2 < 4; idx2++)\n         printf(\"%02x\",state[idx2][idx]);\n   puts(\"\");\n}\n\n// This prints the key (4 consecutive ints) used for a given round as a linear hex string.\nvoid print_rnd_key(uint key[])\n{\n   int idx;\n   for (idx=0; idx < 4; idx++)\n      printf(\"%08x\",key[idx]);\n   puts(\"\");\n}\n\n/********************\n** KEY EXPANSION\n********************/\n\n// Performs the SubWord substitution for KeyExpansion. Each byte in the supplied integer\n// is looked up in the substitution box and replaced by its corresponding value.\nuint SubWord(uint word)\n{\n   unsigned int result;\n\n   result = (int)aes_sbox[(word >> 4) & 0x0000000F][word & 0x0000000F];\n   result += (int)aes_sbox[(word >> 12) & 0x0000000F][(word >> 8) & 0x0000000F] << 8;\n   result += (int)aes_sbox[(word >> 20) & 0x0000000F][(word >> 16) & 0x0000000F] << 16;\n   result += (int)aes_sbox[(word >> 28) & 0x0000000F][(word >> 24) & 0x0000000F] << 24;\n   return(result);\n}\n\n// Performs the RotWord function for KeyExpansion. The first byte in the integer is rotated\n// to the end.\n#define KE_ROTWORD(x) ( ((x) << 8) | ((x) >> 24) )\n\n// Performs the action of generating the keys that will be used in every round of\n// encryption. \"key\" is the user-supplied input key, \"w\" is the output key schedule,\n// \"keysize\" is the length in bits of \"key\", must be 128, 192, or 256.\nvoid KeyExpansion(const uchar key[], uint w[], int keysize)\n{\n   int Nb=4,Nr,Nk,idx;\n   uint temp,Rcon[]={0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000,\n                     0x40000000,0x80000000,0x1b000000,0x36000000,0x6c000000,0xd8000000,\n                     0xab000000,0x4d000000,0x9a000000};\n   switch (keysize) {\n      case 128: Nr = 10; Nk = 4; break;\n      case 192: Nr = 12; Nk = 6; break;\n      case 256: Nr = 14; Nk = 8; break;\n      default: return;\n   }\n\n   for (idx=0; idx < Nk; ++idx) {\n      w[idx] = ((key[4 * idx]) << 24) | ((key[4 * idx + 1]) << 16) |\n               ((key[4 * idx + 2]) << 8) | ((key[4 * idx + 3]));\n   }\n\n   for (idx = Nk; idx < Nb * (Nr+1); ++idx) {\n      temp = w[idx - 1];\n      if ((idx % Nk) == 0)\n         temp = SubWord(KE_ROTWORD(temp)) ^ Rcon[(idx-1)/Nk];\n      else if (Nk > 6 && (idx % Nk) == 4)\n         temp = SubWord(temp);\n      w[idx] = w[idx-Nk] ^ temp;\n   }\n}\n\n/********************\n** AES (En/De)Crypt\n********************/\n\n// \"in\" is the block of 16 sequencial bytes that is to be encrypted. \"out\" is the encrypted\n// sequencial output. \"key\" is an array consisting of the KEY value that was generated\n// using KeySchedule() previously. \"keysize\" MUST be 128, 192, 256 in size.\nvoid aes_encrypt(uchar in[], uchar out[], uint key[], int keysize)\n{\n   uchar state[4][4];\n   // Copy input array (should be 16 bytes long) to a matrix (sequential bytes are ordered\n   // by row, not col) called \"state\" for processing.\n   // *** Implementation note: The official AES documentation references the state by\n   // column, then row. Accessing an element in C requires row then column. Thus, all state\n   // references in AES must have the column and row indexes reversed for C implementation.\n   state[0][0] = in[0];\n   state[1][0] = in[1];\n   state[2][0] = in[2];\n   state[3][0] = in[3];\n   state[0][1] = in[4];\n   state[1][1] = in[5];\n   state[2][1] = in[6];\n   state[3][1] = in[7];\n   state[0][2] = in[8];\n   state[1][2] = in[9];\n   state[2][2] = in[10];\n   state[3][2] = in[11];\n   state[0][3] = in[12];\n   state[1][3] = in[13];\n   state[2][3] = in[14];\n   state[3][3] = in[15];\n\n   // Perform the necessary number of rounds. The round key is added first.\n   // The last round does not perform the MixColumns step.\n   AddRoundKey(state,&key[0]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[4]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[8]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[12]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[16]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[20]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[24]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[28]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[32]);\n   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[36]);\n   if (keysize != 128) {\n      SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[40]);\n      SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[44]);\n      if (keysize != 192) {\n         SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[48]);\n         SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[52]);\n         SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[56]);\n      }\n      else {\n         SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[48]);\n      }\n   }\n   else {\n      SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[40]);\n   }\n\n   // Copy the state to the output array\n   out[0] = state[0][0];\n   out[1] = state[1][0];\n   out[2] = state[2][0];\n   out[3] = state[3][0];\n   out[4] = state[0][1];\n   out[5] = state[1][1];\n   out[6] = state[2][1];\n   out[7] = state[3][1];\n   out[8] = state[0][2];\n   out[9] = state[1][2];\n   out[10] = state[2][2];\n   out[11] = state[3][2];\n   out[12] = state[0][3];\n   out[13] = state[1][3];\n   out[14] = state[2][3];\n   out[15] = state[3][3];\n}\n\nvoid aes_decrypt(uchar in[], uchar out[], uint key[], int keysize)\n{\n   uchar state[4][4];\n   // Copy the input to the state.\n   state[0][0] = in[0];\n   state[1][0] = in[1];\n   state[2][0] = in[2];\n   state[3][0] = in[3];\n   state[0][1] = in[4];\n   state[1][1] = in[5];\n   state[2][1] = in[6];\n   state[3][1] = in[7];\n   state[0][2] = in[8];\n   state[1][2] = in[9];\n   state[2][2] = in[10];\n   state[3][2] = in[11];\n   state[0][3] = in[12];\n   state[1][3] = in[13];\n   state[2][3] = in[14];\n   state[3][3] = in[15];\n\n   // Perform the necessary number of rounds. The round key is added first.\n   // The last round does not perform the MixColumns step.\n   if (keysize > 128) {\n      if (keysize > 192) {\n         AddRoundKey(state,&key[56]);\n         InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[52]);InvMixColumns(state);\n         InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[48]);InvMixColumns(state);\n      }\n      else {\n         AddRoundKey(state,&key[48]);\n      }\n      InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[44]);InvMixColumns(state);\n      InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[40]);InvMixColumns(state);\n   }\n   else {\n      AddRoundKey(state,&key[40]);\n   }\n   InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[36]);InvMixColumns(state);\n   InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[32]);InvMixColumns(state);\n   InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[28]);InvMixColumns(state);\n   InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[24]);InvMixColumns(state);\n   InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[20]);InvMixColumns(state);\n   InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[16]);InvMixColumns(state);\n   InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[12]);InvMixColumns(state);\n   InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[8]);InvMixColumns(state);\n   InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[4]);InvMixColumns(state);\n   InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[0]);\n\n   // Copy the state to the output array\n   out[0] = state[0][0];\n   out[1] = state[1][0];\n   out[2] = state[2][0];\n   out[3] = state[3][0];\n   out[4] = state[0][1];\n   out[5] = state[1][1];\n   out[6] = state[2][1];\n   out[7] = state[3][1];\n   out[8] = state[0][2];\n   out[9] = state[1][2];\n   out[10] = state[2][2];\n   out[11] = state[3][2];\n   out[12] = state[0][3];\n   out[13] = state[1][3];\n   out[14] = state[2][3];\n   out[15] = state[3][3];\n}\n\n} // namespace Juliusv1draft_raw\n"
        },
        {
            "file_name": "juliusv1draft_encrypt.cpp",
            "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BLK_SIZE 16\n#define NPUB_SIZE 16\n#define KEY_SIZE 16\n#define EXPANDED_KEY_SIZE 44\n\n#include \"Juliusv1draft_functions.cpp\"\n\n// CHANGE namespace moved due to includes\nnamespace Juliusv1draft_raw {\nint numRounds = -1;\n\nvoid julius_regular_involution(unsigned char *pad, unsigned long long padlen, \n\t\tunsigned long long reg_index, unsigned long expanded_key[EXPANDED_KEY_SIZE]){\n\tint i; //RRR j?\n\tunsigned long long cur;\n\tunsigned char seed[BLK_SIZE];\n\tunsigned char mu[BLK_SIZE];\n\tunsigned char tmp_mask[BLK_SIZE];\n\tunsigned char delta[BLK_SIZE];\n\tfor(i = 0; i < BLK_SIZE; i++){\n\t\tdelta[i] = 0;\n\t}\n\taes_128_encrypt(delta, expanded_key);\n\t\n\tevaluate_by_delta(seed, delta, pad, padlen / BLK_SIZE);\n\tmemcpy(mu, seed, BLK_SIZE);\n\taes_128_encrypt(mu, expanded_key);\n\t\n\tif(((padlen - reg_index) / BLK_SIZE) % 2 == 0){\n\t\tcur = reg_index;\n\t\tmemcpy(tmp_mask, mu, BLK_SIZE);\n\t\tfor(cur = reg_index; cur < padlen; cur = cur + BLK_SIZE){\n\t\t\tadd_to_first(&pad[cur], tmp_mask);\n\t\t\tmul_by_delta(tmp_mask, delta);\n\t\t}\n\t}else{\n\t\tcur = reg_index;\n\t\tmemcpy(tmp_mask, mu, BLK_SIZE);\n\t\t\n\t\t//first block:\n\t\tadd_to_first(&pad[cur], tmp_mask);\n\t\tcur = cur + BLK_SIZE;\n\t\t\n\t\t//second block:\n\t\tif(cur < padlen){\n\t\t\tmul_by_delta(tmp_mask, delta);\n\t\t\tadd_to_first(&pad[cur], tmp_mask);\n\t\t\tadd_to_first(&pad[cur], mu);\n\t\t\tcur = cur + BLK_SIZE;\n\t\t}\n\t\t\n\t\t//rest of the blocks:\n\t\tfor(; cur < padlen; cur = cur + BLK_SIZE){\n\t\t\tadd_to_first(&pad[cur], tmp_mask);\n\t\t\tmul_by_delta(tmp_mask, delta);\n\t\t}\n\t}\n\t\n}\n\n\n\nvoid regular_ecb_encrypt(unsigned char *reg, unsigned long long reg_len, \n\t\tunsigned long expanded_key[EXPANDED_KEY_SIZE]){\n\tunsigned long long cur;\n\tfor(cur = 0; cur < reg_len; cur = cur + BLK_SIZE){\n\t\taes_128_encrypt(&reg[cur], expanded_key); \n\t}\n} \n\nvoid regular_ecb_decrypt(unsigned char *reg, unsigned long long reg_len,\n\t\tunsigned long expanded_key[EXPANDED_KEY_SIZE]){\n\tunsigned long long cur;\n\tfor(cur = 0; cur < reg_len; cur = cur + BLK_SIZE){\n\t\taes_128_decrypt(&reg[cur], expanded_key); \n\t}\n}\n\n\n\n\n\n\n\nint crypto_aead_encrypt(\n\t\tunsigned char *c,unsigned long long *clen,\n\t\tconst unsigned char *m, unsigned long long mlen,\n\t\tconst unsigned char *ad, unsigned long long adlen,\n\t\tconst unsigned char *nsec, const unsigned char *npub,\n\t\tconst unsigned char *k){\n\t\t\n\t\t\n\tunsigned long expanded_key[EXPANDED_KEY_SIZE];\n\tKeyExpansion(k, expanded_key, 128);\n\t*clen = calc_ciphertext_len_regular_version(mlen);\n\tunsigned long long padlen = \n\t\t\tcalc_pad_len_regular_version(mlen, adlen, NPUB_SIZE);\n\tunsigned char* pad = (unsigned char *) malloc(padlen);\n\tint i;\n\tint adres, pres;\n\tif(adlen % BLK_SIZE == 0){\n\t\tadres = 0;\n\t}else{\n\t\tadres = BLK_SIZE - (adlen % BLK_SIZE);\n\t}\n\tif(mlen % BLK_SIZE == 0){\n\t\tpres = 0;\n\t}else{\n\t\tpres = BLK_SIZE - (mlen % BLK_SIZE);\n\t}\n\tunsigned long long tmp;\n\tunsigned long long reg_index;\n\tunsigned long long cur = 0;\n\t\n\t//padding:\n\tfor(i = 0; i < BLK_SIZE - 1; i++){\n\t\tpad[cur] = 0;\n\t\tcur++;\n\t}\n\tpad[cur] = 1;\n\tcur++;\n\t\n\t\n\tmemcpy(&pad[cur], npub, NPUB_SIZE);\n\tcur = cur + NPUB_SIZE;\n\t\n\t\n\ttmp = adlen;\n\tfor(i = 0; i < 8; i++){\n\t\tpad[cur + 7 - i] = tmp % 256;\n\t\ttmp = tmp / 256;\n\t}\n\tcur = cur + 8;\n\t\n\t\n\ttmp = mlen;\n\tfor(i = 0; i < 8; i++){\n\t\tpad[cur + 7 - i] = tmp % 256;\n\t\ttmp = tmp / 256;\n\t}\n\tcur = cur + 8;\n\t\n\t\n\tmemcpy(&pad[cur], ad, adlen);\n\tcur = cur + adlen;\n\treg_index = cur + adres;\n\t\n\t\n\tfor(i = 0; i < BLK_SIZE + adres + pres; i++){\n\t\tpad[cur] = 0;\n\t\tcur++;\n\t}\n\t\n\t\n\tmemcpy(&pad[cur], m, mlen);\n\t//end of padding.\n\t\n\t//the julius involution:\n\tjulius_regular_involution(pad, padlen, reg_index, expanded_key);\n\t\n\t\n\t//ecb\n\tregular_ecb_encrypt(&pad[reg_index], *clen, expanded_key);\n\t\n\t\n\tmemcpy(c, &pad[reg_index], *clen);\n\tfree(pad);\n\t\n\treturn 0;\n}\n\n\n\n\n\nint crypto_aead_decrypt(\n\t\tunsigned char *m,unsigned long long mlen,\n\t\tunsigned char *nsec, const unsigned char *c,\n\t\tunsigned long long clen, const unsigned char *ad,\n\t\tunsigned long long adlen, const unsigned char *npub,\n\t\tconst unsigned char *k){\n\t\t   \n\tunsigned long expanded_key[EXPANDED_KEY_SIZE];\n\tKeyExpansion(k, expanded_key, 128);\t\n\t\n\tunsigned char tmp_blk[BLK_SIZE];\n\tunsigned long long tmp_num[10]; //there is a strange bug when I write unsigned long long *tmp_num;\n\t\n\t//cases of short ciphertext:\n\tif(clen < BLK_SIZE){\n\t\treturn -1;\n\t}\n\tif(clen == BLK_SIZE){\n\t\tcrypto_aead_encrypt(tmp_blk, tmp_num, NULL, 0, ad, adlen, NULL, npub, k);\n\t\tif((memcpy(tmp_blk, c, BLK_SIZE) == 0) && (*tmp_num == BLK_SIZE)){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}if((clen > BLK_SIZE) && (clen < 2 * BLK_SIZE)){\n\t\treturn -1;\n\t}\n\t\n\t\n\t\n\t\n\tunsigned long long padlen = \n\t\t\tcalc_pad_len_regular_version(mlen, adlen, (unsigned long long) NPUB_SIZE);\n\tunsigned char* pad = (unsigned char *) malloc(padlen);\n\tint i;\n\tint adres, pres;\n\tif(adlen % BLK_SIZE == 0){\n\t\tadres = 0;\n\t}else{\n\t\tadres = BLK_SIZE - (adlen % BLK_SIZE);\n\t}\n\tif(mlen % BLK_SIZE == 0){\n\t\tpres = 0;\n\t}else{\n\t\tpres = BLK_SIZE - (mlen % BLK_SIZE);\n\t}\n\tunsigned long long tmp; //RR?\n\tunsigned long long reg_index;\n\tunsigned long long cur = 0;\n\t\n\t//padding:\n\tfor(i = 0; i < BLK_SIZE - 1; i++){\n\t\tpad[cur] = 0;\n\t\tcur++;\n\t}\n\tpad[cur] = 1;\n\tcur++;\n\t\n\t\n\tmemcpy(&pad[cur], npub, NPUB_SIZE);\n\tcur = cur + NPUB_SIZE;\n\t\n\t\n\ttmp = adlen;\n\tfor(i = 0; i < 8; i++){\n\t\tpad[cur + 7 - i] = tmp % 256;\n\t\ttmp = tmp / 256;\n\t}\n\tcur = cur + 8;\n\t\n\t\n\ttmp = mlen;\n\tfor(i = 0; i < 8; i++){\n\t\tpad[cur + 7 - i] = tmp % 256;\n\t\ttmp = tmp / 256;\n\t}\n\tcur = cur + 8;\n\t\n\t\n\tmemcpy(&pad[cur], ad, adlen);\n\tcur = cur + adlen;\n\t\n\t\n\tfor(i = 0; i < adres; i++){\n\t\tpad[cur] = 0;\n\t\tcur++;\n\t}\n\treg_index = cur;\n\t\n\t\n\tmemcpy(&pad[reg_index], c, clen);\n\t//end of padding.\n\t\n\t\n\t\n\t\n\t//ecb decryption:\n\tregular_ecb_decrypt(&pad[reg_index], clen, expanded_key);\n\t\n\t\n\tfor(cur = reg_index; cur < reg_index + BLK_SIZE + pres; cur++){\n\t\tif(pad[cur] != 0){\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tmemcpy(m, &pad[cur], mlen);\n\tfree(pad);\n\t\n\treturn 0;\n}\n\n\n\n\n\n} // namespace Juliusv1draft_raw\n"
        },
        {
            "file_name": "juliusv1draft_functions.cpp",
            "content": "#include \"AES/aes.c\"\n\n// CHANGE namespace moved due to includes\nnamespace Juliusv1draft_raw {\n\nvoid add_to_first(unsigned char blk1[BLK_SIZE], unsigned char blk2[BLK_SIZE]){\n\tint i;\n\tfor(i = 0; i < BLK_SIZE; i++){\n\t\tblk1[i] = blk1[i] ^ blk2[i];\n\t}\n}\n\nvoid mul_by_x(unsigned char blk[BLK_SIZE]){\n\tint i;\n\tunsigned char tmp = (blk[0] / 128) * 135;\n\tfor(i = 0; i < 15; i++){\n\t\tblk[i] = (2 * blk[i]) ^ (blk[i+1] / 128);\n\t}\n\tblk[15] = (2 * blk[15]) ^ tmp;\t\n}\n\nvoid mul_by_delta(unsigned char blk[BLK_SIZE], unsigned char delta[BLK_SIZE]){\n\tint i,j;\n\tint power;\n\tunsigned char res[BLK_SIZE] = {0};\n\tunsigned char tmp[BLK_SIZE];\n\tmemcpy(tmp, blk, BLK_SIZE);\n\tfor(i = 15; i >= 0; i--){\n\t\tpower = 1;\n\t\tfor(j = 0; j < 8; j++){\n\t\t\tif(delta[i] >= power){\n\t\t\t\tadd_to_first(res, tmp);\n\t\t\t}\n\t\t\tpower = power * 2;\n\t\t\tmul_by_x(tmp);\n\t\t}\n\t}\n\tmemcpy(blk, res, BLK_SIZE);\n}\n\n\nvoid evaluate_by_delta(unsigned char res[BLK_SIZE], unsigned char delta[BLK_SIZE], \n\t\tunsigned char *str, unsigned long long blks_len){\n\tint i;\n\tunsigned long long cur = BLK_SIZE;\n\tmemcpy(res, str, BLK_SIZE);\n\tfor(i = 0; i < blks_len - 1; i++){\n\t\tmul_by_delta(res, delta);\n\t\tadd_to_first(res, &str[cur]);\n\t\tcur = cur + BLK_SIZE;\n\t}\t\t\t\t\n}\n\n\n\n\nunsigned long long calc_pad_len_regular_version(unsigned long long mlen, \n\t\tunsigned long long adlen, int npublen){\n\tint tmp;\n\tunsigned long long ret = 48 + mlen + adlen + npublen;\n\ttmp = mlen % BLK_SIZE;\n\tif(tmp != 0){\n\t\tret = ret + 16 - tmp;\n\t}\n\ttmp = (adlen + npublen) % BLK_SIZE;\n\tif(tmp != 0){\n\t\tret = ret + 16 - tmp;\n\t}\n\t\n\treturn ret;\n}\n\nunsigned long long calc_ciphertext_len_regular_version(unsigned long long mlen){\n\tint tmp;\n\tunsigned long long ret = 16 + mlen;\n\t\n\ttmp = mlen % BLK_SIZE;\n\tif(tmp != 0){\n\t\tret = ret + 16 - tmp;\n\t}\n\t\n\t\n\treturn ret; \n}\n\n\nvoid aes_128_encrypt(unsigned char blk[BLK_SIZE], unsigned long expanded_key[EXPANDED_KEY_SIZE]){\n\tunsigned char tmp_blk[BLK_SIZE];\n\tmemcpy(tmp_blk, blk, BLK_SIZE);\n\taes_encrypt(tmp_blk, blk, expanded_key, 128);\n}\n\nvoid aes_128_decrypt(unsigned char blk[BLK_SIZE], unsigned long expanded_key[EXPANDED_KEY_SIZE]){\n\tunsigned char tmp_blk[BLK_SIZE];\n\tmemcpy(tmp_blk, blk, BLK_SIZE);\n\taes_decrypt(tmp_blk, blk, expanded_key, 128);\n}\n\n\n} // namespace Juliusv1draft_raw\n"
        },
        {
            "file_name": "keccak.cpp",
            "content": "#include \"keccak.h\"\n#include <string.h>\n\nnamespace keccak\n{\n\n    void buffer_xor(void* target, const void* source, int length)\n    {\n        while (length > 8)\n        {\n            *((uint64_t*)target) ^= *((uint64_t*)source);\n            target += 8;\n            source += 8;\n            length -= 8;\n        }\n        while (length > 0)\n        {\n            *((uint8_t*)target) ^= *((uint8_t*)source);\n            target += 1;\n            source += 1;\n            length--;\n        }\n    }\n\n    /* ****************************** keccak_state ******************************* */\n\n    keccak_state::keccak_state()\n    {\n        zero(0, 200);\n    }\n\n    keccak_state::~keccak_state()\n    {\n        zero(0, 200);\n    }\n\n#define ROTL(x, b) (((x) << (b)) | ((x) >> (64-(b))))\n#define ROTR(x, b) (((x) >> (b)) | ((x) << (64-(b))))\n\n    void keccak_state::round(uint64_t rc)\n    {\n        uint64_t C0, C1, C2, C3, C4, D;\n        uint64_t B[5][5];\n\n        C0 = A[0][0] ^ A[1][0] ^ A[2][0] ^ A[3][0] ^ A[4][0];\n        C1 = A[0][1] ^ A[1][1] ^ A[2][1] ^ A[3][1] ^ A[4][1];\n        C2 = A[0][2] ^ A[1][2] ^ A[2][2] ^ A[3][2] ^ A[4][2];\n        C3 = A[0][3] ^ A[1][3] ^ A[2][3] ^ A[3][3] ^ A[4][3];\n        C4 = A[0][4] ^ A[1][4] ^ A[2][4] ^ A[3][4] ^ A[4][4];\n\n        D = C4 ^ ROTL(C1, 1);\n        A[0][0] ^= D;\n        A[1][0] ^= D;\n        A[2][0] ^= D;\n        A[3][0] ^= D;\n        A[4][0] ^= D;\n\n        D = C0 ^ ROTL(C2, 1);\n        A[0][1] ^= D;\n        A[1][1] ^= D;\n        A[2][1] ^= D;\n        A[3][1] ^= D;\n        A[4][1] ^= D;\n\n        D = C1 ^ ROTL(C3, 1);\n        A[0][2] ^= D;\n        A[1][2] ^= D;\n        A[2][2] ^= D;\n        A[3][2] ^= D;\n        A[4][2] ^= D;\n\n        D = C2 ^ ROTL(C4, 1);\n        A[0][3] ^= D;\n        A[1][3] ^= D;\n        A[2][3] ^= D;\n        A[3][3] ^= D;\n        A[4][3] ^= D;\n\n        D = C3 ^ ROTL(C0, 1);\n        A[0][4] ^= D;\n        A[1][4] ^= D;\n        A[2][4] ^= D;\n        A[3][4] ^= D;\n        A[4][4] ^= D;\n\n        // B[0][0] = A[0][0]\n        B[1][0] = ROTR(A[1][1], 64-44);\n        B[2][0] = ROTR(A[2][2], 64-43);\n        B[3][0] = ROTL(A[3][3], 21);\n        B[4][0] = ROTL(A[4][4], 14);\n        B[0][1] = ROTL(A[0][3], 28);\n        B[1][1] = ROTL(A[1][4], 20);\n        B[2][1] = ROTL(A[2][0], 3);\n        B[3][1] = ROTR(A[3][1], 64-45);\n        B[4][1] = ROTR(A[4][2], 64-61);\n        B[0][2] = ROTL(A[0][1], 1);\n        B[1][2] = ROTL(A[1][2], 6);\n        B[2][2] = ROTL(A[2][3], 25);\n        B[3][2] = ROTL(A[3][4], 8);\n        B[4][2] = ROTL(A[4][0], 18);\n        B[0][3] = ROTL(A[0][4], 27);\n        B[1][3] = ROTR(A[1][0], 64-36);\n        B[2][3] = ROTL(A[2][1], 10);\n        B[3][3] = ROTL(A[3][2], 15);\n        B[4][3] = ROTR(A[4][3], 64-56);\n        B[0][4] = ROTR(A[0][2], 64-62);\n        B[1][4] = ROTR(A[1][3], 64-55);\n        B[2][4] = ROTR(A[2][4], 64-39);\n        B[3][4] = ROTR(A[3][0], 64-41);\n        B[4][4] = ROTL(A[4][1], 2);\n\n        A[0][1] = B[1][0] ^ (~B[2][0] & B[3][0]);\n        A[0][2] = B[2][0] ^ (~B[3][0] & B[4][0]);\n        A[0][3] = B[3][0] ^ (~B[4][0] & A[0][0]); // ! A\n        A[0][4] = B[4][0] ^ (~A[0][0] & B[1][0]); // ! A\n        A[1][0] = B[0][1] ^ (~B[1][1] & B[2][1]);\n        A[1][1] = B[1][1] ^ (~B[2][1] & B[3][1]);\n        A[1][2] = B[2][1] ^ (~B[3][1] & B[4][1]);\n        A[1][3] = B[3][1] ^ (~B[4][1] & B[0][1]);\n        A[1][4] = B[4][1] ^ (~B[0][1] & B[1][1]);\n        A[2][0] = B[0][2] ^ (~B[1][2] & B[2][2]);\n        A[2][1] = B[1][2] ^ (~B[2][2] & B[3][2]);\n        A[2][2] = B[2][2] ^ (~B[3][2] & B[4][2]);\n        A[2][3] = B[3][2] ^ (~B[4][2] & B[0][2]);\n        A[2][4] = B[4][2] ^ (~B[0][2] & B[1][2]);\n        A[3][0] = B[0][3] ^ (~B[1][3] & B[2][3]);\n        A[3][1] = B[1][3] ^ (~B[2][3] & B[3][3]);\n        A[3][2] = B[2][3] ^ (~B[3][3] & B[4][3]);\n        A[3][3] = B[3][3] ^ (~B[4][3] & B[0][3]);\n        A[3][4] = B[4][3] ^ (~B[0][3] & B[1][3]);\n        A[4][0] = B[0][4] ^ (~B[1][4] & B[2][4]);\n        A[4][1] = B[1][4] ^ (~B[2][4] & B[3][4]);\n        A[4][2] = B[2][4] ^ (~B[3][4] & B[4][4]);\n        A[4][3] = B[3][4] ^ (~B[4][4] & B[0][4]);\n        A[4][4] = B[4][4] ^ (~B[0][4] & B[1][4]);\n        A[0][0] = A[0][0] ^ (~B[1][0] & B[2][0]); // ! A\n\n        A[0][0] ^= rc;\n    }\n\n    void keccak_state::f(int rounds)\n    {\n        int rc = 0;\n        for (int r = 0; r < rounds; r++)\n        {\n            round(round_constants[rc]);\n            if (rc==254) rc = 0; else rc++;\n        }\n    }\n\n    void keccak_state::pad101_xor(int from_b, int to_b)\n    {\n        ((uint8_t*)&A)[from_b] ^= 0x01;\n        ((uint8_t*)&A)[to_b] ^= 0x80;\n    }\n\n    void keccak_state::zero(int from_b, int length)\n    {\n        memset( (uint8_t*)&A + from_b, 0, length);\n    }\n\n    void keccak_state::block_absorb(const void *buffer, int from_b, int length)\n    {\n        buffer_xor((uint8_t*)&A + from_b, buffer, length);\n    }\n\n    void keccak_state::block_squeeze(void *buffer, int from_b, int length)\n    {\n        memcpy(buffer, (uint8_t*)&A + from_b, length);\n    }\n\n    uint64_t keccak_state::word_read(int idx)\n    {\n        return ((uint64_t*)&A)[idx];\n    }\n\n    void keccak_state::word_write_xor(int idx, const uint64_t word)\n    {\n        ((uint64_t*)&A)[idx] ^= word;\n    }\n\n    const uint64_t keccak_state::round_constants[] = {\n        0x0000000000000001,\n        0x0000000000008082,\n        0x800000000000808A,\n        0x8000000080008000,\n        0x000000000000808B,\n        0x0000000080000001,\n        0x8000000080008081,\n        0x8000000000008009,\n        0x000000000000008A,\n        0x0000000000000088,\n        0x0000000080008009,\n        0x000000008000000A,\n        0x000000008000808B,\n        0x800000000000008B,\n        0x8000000000008089,\n        0x8000000000008003,\n        0x8000000000008002,\n        0x8000000000000080,\n        0x000000000000800A,\n        0x800000008000000A,\n        0x8000000080008081,\n        0x8000000000008080,\n        0x0000000080000001,\n        0x8000000080008008,\n        0x8000000080008082,\n        0x800000008000800A,\n        0x8000000000000003,\n        0x8000000080000009,\n        0x8000000000008082,\n        0x0000000000008009,\n        0x8000000000000080,\n        0x0000000000008083,\n        0x8000000000000081,\n        0x0000000000000001,\n        0x000000000000800B,\n        0x8000000080008001,\n        0x0000000000000080,\n        0x8000000000008000,\n        0x8000000080008001,\n        0x0000000000000009,\n        0x800000008000808B,\n        0x0000000000000081,\n        0x8000000000000082,\n        0x000000008000008B,\n        0x8000000080008009,\n        0x8000000080000000,\n        0x0000000080000080,\n        0x0000000080008003,\n        0x8000000080008082,\n        0x8000000080008083,\n        0x8000000080000088,\n        0x0000000000008089,\n        0x0000000000008009,\n        0x8000000000000009,\n        0x0000000080008008,\n        0x0000000080008001,\n        0x800000000000008A,\n        0x800000000000000B,\n        0x0000000000000089,\n        0x0000000080000002,\n        0x800000000000800B,\n        0x000000008000800B,\n        0x000000000000808B,\n        0x0000000080000088,\n        0x800000000000800A,\n        0x0000000080000089,\n        0x8000000000000001,\n        0x8000000000008088,\n        0x8000000000000081,\n        0x0000000000000088,\n        0x0000000080008080,\n        0x0000000000000081,\n        0x800000000000000B,\n        0x0000000000000000,\n        0x0000000000000089,\n        0x000000008000008B,\n        0x8000000080008080,\n        0x800000000000008B,\n        0x8000000000008000,\n        0x8000000080008088,\n        0x0000000080000082,\n        0x000000000000000B,\n        0x800000000000000A,\n        0x0000000000008082,\n        0x8000000000008003,\n        0x800000000000808B,\n        0x800000008000000B,\n        0x800000008000008A,\n        0x0000000080000081,\n        0x0000000080000081,\n        0x0000000080000008,\n        0x0000000000000083,\n        0x8000000080008003,\n        0x0000000080008088,\n        0x8000000080000088,\n        0x0000000000008000,\n        0x0000000080008082,\n        0x0000000080008089,\n        0x8000000080008083,\n        0x8000000080000001,\n        0x0000000080008002,\n        0x8000000080000089,\n        0x0000000000000082,\n        0x8000000080000008,\n        0x8000000000000089,\n        0x8000000080000008,\n        0x8000000000000000,\n        0x8000000000000083,\n        0x0000000080008080,\n        0x0000000000000008,\n        0x8000000080000080,\n        0x8000000080008080,\n        0x8000000000000002,\n        0x800000008000808B,\n        0x0000000000000008,\n        0x8000000080000009,\n        0x800000000000800B,\n        0x0000000080008082,\n        0x0000000080008000,\n        0x8000000000008008,\n        0x0000000000008081,\n        0x8000000080008089,\n        0x0000000080008089,\n        0x800000008000800A,\n        0x800000000000008A,\n        0x8000000000000082,\n        0x0000000080000002,\n        0x8000000000008082,\n        0x0000000000008080,\n        0x800000008000000B,\n        0x8000000080000003,\n        0x000000000000000A,\n        0x8000000000008001,\n        0x8000000080000083,\n        0x8000000000008083,\n        0x000000000000008B,\n        0x000000000000800A,\n        0x8000000080000083,\n        0x800000000000800A,\n        0x0000000080000000,\n        0x800000008000008A,\n        0x0000000080000008,\n        0x000000000000000A,\n        0x8000000000008088,\n        0x8000000000000008,\n        0x0000000080000003,\n        0x8000000000000000,\n        0x800000000000000A,\n        0x000000000000800B,\n        0x8000000080008088,\n        0x000000008000000B,\n        0x0000000080000080,\n        0x000000008000808A,\n        0x8000000000008009,\n        0x0000000000000003,\n        0x0000000080000003,\n        0x8000000000000089,\n        0x8000000080000081,\n        0x800000008000008B,\n        0x0000000080008003,\n        0x800000008000800B,\n        0x8000000000008008,\n        0x0000000000008008,\n        0x8000000000008002,\n        0x8000000000000009,\n        0x0000000080008081,\n        0x000000000000808A,\n        0x000000008000800A,\n        0x0000000000000080,\n        0x8000000000008089,\n        0x800000000000808A,\n        0x8000000080008089,\n        0x0000000080008000,\n        0x8000000000008081,\n        0x000000008000800A,\n        0x0000000000000009,\n        0x8000000080008002,\n        0x000000008000000A,\n        0x0000000080008002,\n        0x8000000080000000,\n        0x0000000080000009,\n        0x0000000000008088,\n        0x0000000000000002,\n        0x0000000080008008,\n        0x0000000080008088,\n        0x8000000080000001,\n        0x000000008000808B,\n        0x8000000000000002,\n        0x8000000080008002,\n        0x0000000080000083,\n        0x0000000000008089,\n        0x0000000000008080,\n        0x8000000080000082,\n        0x8000000000000088,\n        0x800000008000808A,\n        0x000000000000808A,\n        0x0000000080008083,\n        0x000000008000000B,\n        0x0000000080000009,\n        0x0000000000008001,\n        0x0000000080000089,\n        0x8000000000000088,\n        0x8000000080008003,\n        0x0000000080008001,\n        0x8000000000000003,\n        0x8000000080000080,\n        0x8000000080008009,\n        0x8000000080000089,\n        0x000000000000000B,\n        0x8000000000000083,\n        0x0000000080008009,\n        0x0000000080000083,\n        0x0000000000008000,\n        0x000000008000800B,\n        0x0000000000008002,\n        0x0000000000000003,\n        0x000000008000008A,\n        0x8000000080000002,\n        0x0000000000008001,\n        0x0000000080000000,\n        0x8000000080000003,\n        0x0000000000000083,\n        0x800000008000808A,\n        0x0000000000008003,\n        0x0000000000008008,\n        0x800000000000808B,\n        0x8000000080000082,\n        0x8000000000000001,\n        0x8000000000008001,\n        0x800000008000000A,\n        0x8000000080008008,\n        0x800000008000800B,\n        0x8000000000008081,\n        0x0000000080008083,\n        0x0000000080000082,\n        0x0000000000000082,\n        0x8000000080000081,\n        0x8000000080000002,\n        0x0000000000008088,\n        0x000000000000008B,\n        0x0000000000008083,\n        0x8000000000000008,\n        0x000000008000008A,\n        0x800000008000008B,\n        0x000000008000808A,\n        0x8000000000008080,\n        0x0000000080000088,\n        0x8000000000008083,\n        0x0000000000000002,\n        0x0000000080008081,\n        0x0000000000008003,\n        0x0000000000008081,\n        0x8000000080008000,\n        0x0000000000008002,\n        0x000000000000008A};\n\n}\n"
        },
        {
            "file_name": "Keccak512.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"Keccak512_data.h\"\n\ntypedef enum { SUCCESS = 0, FAIL = 1, BAD_HASHLEN = 2 } HashReturn;\n\n#define cKeccakR_SizeInBytes    (cKeccakR / 8)\n\n#ifndef crypto_hash_BYTES\n    #ifdef cKeccakFixedOutputLengthInBytes\n        #define crypto_hash_BYTES cKeccakFixedOutputLengthInBytes\n    #else\n        #define crypto_hash_BYTES cKeccakR_SizeInBytes\n    #endif\n#endif\n#if (crypto_hash_BYTES > cKeccakR_SizeInBytes)\n    #error \"Full squeezing not yet implemented\"\n#endif\n\n#define IS_BIG_ENDIAN      4321 /* byte 0 is most significant (mc68k) */\n#define IS_LITTLE_ENDIAN   1234 /* byte 0 is least significant (i386) */\n#define PLATFORM_BYTE_ORDER IS_LITTLE_ENDIAN /* WARNING: This implementation works on little-endian platform. Support for big-endinanness is implemented, but not tested. */\n\n#if     (cKeccakB   == 1600)\n    typedef QWORD  UINT64;\n    typedef UINT64 tKeccakLane;\n    #define cKeccakNumberOfRounds   24\n#elif   (cKeccakB   == 800)\n    typedef DWORD        UINT32;\n    // WARNING: on 8-bit and 16-bit platforms, this should be replaced by:\n    //typedef unsigned long       UINT32;\n    typedef UINT32 tKeccakLane;\n    #define cKeccakNumberOfRounds   22\n#elif   (cKeccakB   == 400)\n    typedef WORD      UINT16;\n    typedef UINT16 tKeccakLane;\n    #define cKeccakNumberOfRounds   20\n#elif   (cKeccakB   == 200)\n    typedef BYTE       UINT8;\n    typedef UINT8 tKeccakLane;\n    #define cKeccakNumberOfRounds   18\n#else\n    #error  \"Unsupported Keccak-f width\"\n#endif\n\n#define cKeccakLaneSizeInBits   (sizeof(tKeccakLane) * 8)\n\n#define ROL(a, offset) (tKeccakLane)((((tKeccakLane)a) << ((offset) % cKeccakLaneSizeInBits)) ^ (((tKeccakLane)a) >> (cKeccakLaneSizeInBits-((offset) % cKeccakLaneSizeInBits))))\n\nvoid KeccakF( tKeccakLane * state, const tKeccakLane *in, int laneCount );\n\nint crypto_hash(BYTE *out, const BYTE *in, QWORD inlen )\n{\n    tKeccakLane\t\tstate[5 * 5];\n\t#if (crypto_hash_BYTES >= cKeccakR_SizeInBytes)\n    #define temp out\n\t#else\n    BYTE \ttemp[cKeccakR_SizeInBytes];\n\t#endif\n\n    memset( state, 0, sizeof(state) );\n\n    for ( /* empty */; inlen >= cKeccakR_SizeInBytes; inlen -= cKeccakR_SizeInBytes, in += cKeccakR_SizeInBytes )\n    {\n        KeccakF( state, (const tKeccakLane*)in, cKeccakR_SizeInBytes / sizeof(tKeccakLane) );\n    }\n\n    /*    Last data and padding\t*/\n    memcpy( temp, in, (size_t)inlen );\n    temp[inlen++] = 1;\n    memset( temp+inlen, 0, cKeccakR_SizeInBytes - (size_t)inlen );\n    temp[cKeccakR_SizeInBytes-1] |= 0x80;\n    KeccakF( state, (const tKeccakLane*)temp, cKeccakR_SizeInBytes / sizeof(tKeccakLane) );\n\n    #if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN) || (cKeccakB == 200)\n\n    memcpy( out, state, crypto_hash_BYTES );\n\n\t#else\n\n    for ( i = 0; i < (crypto_hash_BYTES / sizeof(tKeccakLane)); ++i )\n\t{\n\t\ttSmallUInt\t\tj;\n\t    tKeccakLane\t\tt;\n\n\t\tt = state[i];\n\t\tfor ( j = 0; j < sizeof(tKeccakLane); ++j )\n\t\t{\n\t\t\t*(out++) = (BYTE)t;\n\t\t\tt >>= 8;\n\t\t}\n\t}\n\n\t#endif\n\t#if (crypto_hash_BYTES >= cKeccakR_SizeInBytes)\n    #undef temp\n\t#endif\n\n    return ( 0 );\n}\n\nconst tKeccakLane KeccakF_RoundConstants[cKeccakNumberOfRounds] = \n{\n    (tKeccakLane)0x0000000000000001,\n    (tKeccakLane)0x0000000000008082,\n    (tKeccakLane)0x800000000000808a,\n    (tKeccakLane)0x8000000080008000,\n    (tKeccakLane)0x000000000000808b,\n    (tKeccakLane)0x0000000080000001,\n    (tKeccakLane)0x8000000080008081,\n    (tKeccakLane)0x8000000000008009,\n    (tKeccakLane)0x000000000000008a,\n    (tKeccakLane)0x0000000000000088,\n    (tKeccakLane)0x0000000080008009,\n    (tKeccakLane)0x000000008000000a,\n    (tKeccakLane)0x000000008000808b,\n    (tKeccakLane)0x800000000000008b,\n    (tKeccakLane)0x8000000000008089,\n    (tKeccakLane)0x8000000000008003,\n    (tKeccakLane)0x8000000000008002,\n    (tKeccakLane)0x8000000000000080\n\t#if\t\t(cKeccakB\t>= 400)\n  , (tKeccakLane)0x000000000000800a,\n    (tKeccakLane)0x800000008000000a\n\t#if\t\t(cKeccakB\t>= 800)\n  , (tKeccakLane)0x8000000080008081,\n    (tKeccakLane)0x8000000000008080\n\t#if\t\t(cKeccakB\t== 1600)\n  , (tKeccakLane)0x0000000080000001,\n    (tKeccakLane)0x8000000080008008\n\t#endif\n\t#endif\n\t#endif\n};\n\nconst WORD KeccakF_RotationConstants[25] = \n{\n\t 1,  3,  6, 10, 15, 21, 28, 36, 45, 55,  2, 14, 27, 41, 56,  8, 25, 43, 62, 18, 39, 61, 20, 44\n};\n\nconst WORD KeccakF_PiLane[25] = \n{\n    10,  7, 11, 17, 18,  3,  5, 16,  8, 21, 24,  4, 15, 23, 19, 13, 12,  2, 20, 14, 22,  9,  6,  1 \n};\n\nconst WORD KeccakF_Mod5[10] = \n{\n    0, 1, 2, 3, 4, 0, 1, 2, 3, 4\n};\n\nvoid KeccakF( tKeccakLane * state, const tKeccakLane *in, int laneCount )\n{\n\tWORD x, y;\n    tKeccakLane temp;\n    tKeccakLane BC[5];\n\n\t#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN) || (cKeccakB == 200)\n    while ( --laneCount >= 0 )\n\t{\n        state[laneCount] ^= in[laneCount];\n\t}\n\t#else\n\ttemp = 0; /* please compiler */\n    while ( --laneCount >= 0 )\n\t{\n\t\tfor ( x = 0; x < sizeof(tKeccakLane); ++x )\n\t\t{\n\t\t\ttemp <<= 8;\n\t\t\ttemp |= ((char*)&in[laneCount])[x];\n\t\t}\n        state[laneCount] = temp;\n\t}\n\t#endif\n\n\t#define\tround\tlaneCount\n    for( round = 0; round < cKeccakNumberOfRounds; ++round )\n    {\n\t\t// Theta\n\t\tfor ( x = 0; x < 5; ++x )\n\t\t{\n\t\t\tBC[x] = state[x] ^ state[5 + x] ^ state[10 + x] ^ state[15 + x] ^ state[20 + x];\n\t\t}\n\t\tfor ( x = 0; x < 5; ++x )\n\t\t{\n\t\t\ttemp = BC[KeccakF_Mod5[x+4]] ^ ROL(BC[KeccakF_Mod5[x+1]], 1);\n\t\t\tfor ( y = 0; y < 25; y += 5 )\n\t\t\t{\n\t\t\t\tstate[y + x] ^= temp;\n\t\t\t}\n\t\t}\n\n        // Rho Pi\n\t\ttemp = state[1];\n\t\tfor ( x = 0; x < 24; ++x )\n\t\t{\n\t\t\tBC[0] = state[KeccakF_PiLane[x]];\n\t\t\tstate[KeccakF_PiLane[x]] = ROL( temp, KeccakF_RotationConstants[x] );\n\t\t\ttemp = BC[0];\n\t\t}\n\n\t\t//\tChi\n\t\tfor ( y = 0; y < 25; y += 5 )\n\t\t{\n\t\t\tBC[0] = state[y + 0];\n\t\t\tBC[1] = state[y + 1];\n\t\t\tBC[2] = state[y + 2];\n\t\t\tBC[3] = state[y + 3];\n\t\t\tBC[4] = state[y + 4];\n\t\t\tfor ( x = 0; x < 5; ++x )\n\t\t\t{\n\t\t\t\tstate[y + x] = BC[x] ^((~BC[KeccakF_Mod5[x+1]]) & BC[KeccakF_Mod5[x+2]]);\n\t\t\t}\n\t\t}\n\n\t\t//\tIota\n\t\tstate[0] ^= KeccakF_RoundConstants[round];\n    }\n\t#undef\tround\n\n}\n\nvoid Keccak512_init(KECCAK512_DATA *keccak)\n{\n\tkeccak->bitsInQueue = 0;\n\tmemset( keccak->state, 0, sizeof(keccak->state) );\n}\n\nvoid Keccak512_data(KECCAK512_DATA *keccak, const BYTE *buffer, DWORD len)\n{\n\tif ( (keccak->bitsInQueue < 0) || ((keccak->bitsInQueue % 8) != 0) )\n\t{\n\t\t/*\t Final() already called or bits already in queue not modulo 8.\t*/\n\t\treturn;\n\t}\n\n\t/*\tIf already data in queue, continue queuing first */\n\tfor ( /* empty */; (len >= 8) && (keccak->bitsInQueue != 0); len -= 8 )\n\t{\n\t\tkeccak->state[keccak->bitsInQueue / 8] ^= *(buffer++);\n\t\tif ( (keccak->bitsInQueue += 8) == cKeccakR )\n\t\t{\n\t\t\tKeccakF( (tKeccakLane *)keccak->state, 0, 0 );\n\t\t\tkeccak->bitsInQueue = 0;\n\t\t}\n\t}\n\n\t/*\tAbsorb complete blocks */\n\tfor ( /* */; len >= cKeccakR; len -= cKeccakR, buffer += cKeccakR_SizeInBytes )\n\t{\n\t\tKeccakF( (tKeccakLane *)keccak->state, (const tKeccakLane *)buffer, cKeccakR_SizeInBytes / sizeof(tKeccakLane) );\n\t}\n\n\t/*\tQueue remaining data bytes */\n\tfor ( /* empty */; len >=8; len -= 8, keccak->bitsInQueue += 8 )\n\t{\n\t\tkeccak->state[keccak->bitsInQueue / 8] ^= *(buffer++);\n\t}\n\t/*\tQueue eventual remaining data bits plus add first padding bit */\n\tif ( len != 0 )\n\t{\n\t\tkeccak->state[keccak->bitsInQueue / 8] ^= (*buffer >> (8 - len));\n\t\tkeccak->bitsInQueue += (int)len;\n\t}\n}\n\nvoid Keccak512_finalize(KECCAK512_DATA *keccak, BYTE *hash)\n{\n\tWORD\ti;\n\tint\t\thashbytelen=64;\n\n\tif ( keccak->bitsInQueue < 0 )\n\t{\n\t\t/*\t Final() already called.\t*/\n\t\treturn;\n\t}\n\n    // Padding\n    if (keccak->bitsInQueue + 1 == cKeccakR_SizeInBytes*8) {\n        keccak->state[cKeccakR_SizeInBytes-1] ^= 0x80;\n\t\tKeccakF( (tKeccakLane *)keccak->state, 0, 0 );\n    }\n    else {\n        keccak->state[keccak->bitsInQueue/8] ^= 1 << (keccak->bitsInQueue % 8);\n    }\n    keccak->state[cKeccakR_SizeInBytes-1] ^= 0x80;\n    KeccakF( (tKeccakLane *)keccak->state, 0, 0 );\n\n    // Output\n\tfor ( /* empty */; hashbytelen != 0; hash += i, hashbytelen -= i )\n\t{\n\t\ti = (hashbytelen < cKeccakR_SizeInBytes) ? hashbytelen : cKeccakR_SizeInBytes;\n\n\t\t#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN) || (cKeccakB == 200)\n\n\t    memcpy( hash, keccak->state, i );\n\n\t\t#else\n\n\t    for ( offset = 0; offset < i; offset += sizeof(tKeccakLane) )\n\t\t{\n\t\t\ttSmallUInt\t\tj;\n\n\t\t\tfor ( j = 0; j < sizeof(tKeccakLane); ++j )\n\t\t\t{\n\t\t\t\thash[offset + j] = keccak->state[offset + (sizeof(tKeccakLane) - 1) - j];\n\t\t\t}\n\t\t}\n\n\t\t#endif\n\n\t\tif ( i != hashbytelen )\n\t\t{\n\t\t\tKeccakF( (tKeccakLane *)keccak->state, 0, 0 );\n\t\t}\n\t}\n\n\tkeccak->bitsInQueue = -1;\t/* flag final state */\n}\n"
        },
        {
            "file_name": "KeccakF-1600-opt32.c",
            "content": "/*\nThe Keccak sponge function, designed by Guido Bertoni, Joan Daemen,\nMicha\u00c3\u00abl Peeters and Gilles Van Assche. For more information, feedback or\nquestions, please refer to our website: http://keccak.noekeon.org/\n\nImplementation by the designers,\nhereby denoted as \"the implementer\".\n\nTo the extent possible under law, the implementer has waived all copyright\nand related or neighboring rights to the source code in this file.\nhttp://creativecommons.org/publicdomain/zero/1.0/\n*/\n\n#include <string.h>\n#include \"brg_endian.h\"\n#include \"KeccakF-1600-opt32-settings.h\"\n#include \"KeccakF-1600-interface.h\"\n\ntypedef unsigned char UINT8;\ntypedef unsigned short UINT16;\ntypedef unsigned int UINT32;\ntypedef unsigned long long int UINT64;\n\n#ifdef UseInterleaveTables\nint interleaveTablesBuilt = 0;\nUINT16 interleaveTable[65536];\nUINT16 deinterleaveTable[65536];\n\nvoid buildInterleaveTables()\n{\n    UINT32 i, j;\n    UINT16 x;\n\n    if (!interleaveTablesBuilt) {\n        for(i=0; i<65536; i++) {\n            x = 0;\n            for(j=0; j<16; j++) {\n                if (i & (1 << j))\n                    x |= (1 << (j/2 + 8*(j%2)));\n            }\n            interleaveTable[i] = x;\n            deinterleaveTable[x] = (UINT16)i;\n        }\n        interleaveTablesBuilt = 1;\n    }\n}\n\n#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)\n\n#define xor2bytesIntoInterleavedWords(even, odd, source, j) \\\n    i##j = interleaveTable[((const UINT16*)source)[j]]; \\\n    ((UINT8*)even)[j] ^= i##j & 0xFF; \\\n    ((UINT8*)odd)[j] ^= i##j >> 8;\n\n#define setInterleavedWordsInto2bytes(dest, even, odd, j) \\\n    d##j = deinterleaveTable[((even >> (j*8)) & 0xFF) ^ (((odd >> (j*8)) & 0xFF) << 8)]; \\\n    ((UINT16*)dest)[j] = d##j;\n\n#else // (PLATFORM_BYTE_ORDER == IS_BIG_ENDIAN)\n\n#define xor2bytesIntoInterleavedWords(even, odd, source, j) \\\n    i##j = interleaveTable[source[2*j] ^ ((UINT16)source[2*j+1] << 8)]; \\\n    *even ^= (i##j & 0xFF) << (j*8); \\\n    *odd ^= ((i##j >> 8) & 0xFF) << (j*8);\n\n#define setInterleavedWordsInto2bytes(dest, even, odd, j) \\\n    d##j = deinterleaveTable[((even >> (j*8)) & 0xFF) ^ (((odd >> (j*8)) & 0xFF) << 8)]; \\\n    dest[2*j] = d##j & 0xFF; \\\n    dest[2*j+1] = d##j >> 8;\n\n#endif // Endianness\n\nvoid xor8bytesIntoInterleavedWords(UINT32 *even, UINT32 *odd, const UINT8* source)\n{\n    UINT16 i0, i1, i2, i3;\n\n    xor2bytesIntoInterleavedWords(even, odd, source, 0)\n    xor2bytesIntoInterleavedWords(even, odd, source, 1)\n    xor2bytesIntoInterleavedWords(even, odd, source, 2)\n    xor2bytesIntoInterleavedWords(even, odd, source, 3)\n}\n\n#define xorLanesIntoState(laneCount, state, input) \\\n    { \\\n        int i; \\\n        for(i=0; i<(laneCount); i++) \\\n            xor8bytesIntoInterleavedWords(state+i*2, state+i*2+1, input+i*8); \\\n    }\n\nvoid setInterleavedWordsInto8bytes(UINT8* dest, UINT32 even, UINT32 odd)\n{\n    UINT16 d0, d1, d2, d3;\n\n    setInterleavedWordsInto2bytes(dest, even, odd, 0)\n    setInterleavedWordsInto2bytes(dest, even, odd, 1)\n    setInterleavedWordsInto2bytes(dest, even, odd, 2)\n    setInterleavedWordsInto2bytes(dest, even, odd, 3)\n}\n\n#define extractLanes(laneCount, state, data) \\\n    { \\\n        int i; \\\n        for(i=0; i<(laneCount); i++) \\\n            setInterleavedWordsInto8bytes(data+i*8, ((UINT32*)state)[i*2], ((UINT32*)state)[i*2+1]); \\\n    }\n\n#else // No interleaving tables\n\n#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)\n\n// Credit: Henry S. Warren, Hacker's Delight, Addison-Wesley, 2002\n#define xorInterleavedLE(rateInLanes, state, input) \\\n\t{ \\\n\t\tconst UINT32 * pI = (const UINT32 *)input; \\\n\t\tUINT32 * pS = state; \\\n\t\tUINT32 t, x0, x1; \\\n\t    int i; \\\n\t    for (i = (rateInLanes)-1; i >= 0; --i) \\\n\t\t{ \\\n\t\t\tx0 = *(pI++); \\\n\t\t\tt = (x0 ^ (x0 >>  1)) & 0x22222222UL;  x0 = x0 ^ t ^ (t <<  1); \\\n\t\t\tt = (x0 ^ (x0 >>  2)) & 0x0C0C0C0CUL;  x0 = x0 ^ t ^ (t <<  2); \\\n\t\t\tt = (x0 ^ (x0 >>  4)) & 0x00F000F0UL;  x0 = x0 ^ t ^ (t <<  4); \\\n\t\t\tt = (x0 ^ (x0 >>  8)) & 0x0000FF00UL;  x0 = x0 ^ t ^ (t <<  8); \\\n \t\t\tx1 = *(pI++); \\\n\t\t\tt = (x1 ^ (x1 >>  1)) & 0x22222222UL;  x1 = x1 ^ t ^ (t <<  1); \\\n\t\t\tt = (x1 ^ (x1 >>  2)) & 0x0C0C0C0CUL;  x1 = x1 ^ t ^ (t <<  2); \\\n\t\t\tt = (x1 ^ (x1 >>  4)) & 0x00F000F0UL;  x1 = x1 ^ t ^ (t <<  4); \\\n\t\t\tt = (x1 ^ (x1 >>  8)) & 0x0000FF00UL;  x1 = x1 ^ t ^ (t <<  8); \\\n\t\t\t*(pS++) ^= (UINT16)x0 | (x1 << 16); \\\n\t\t\t*(pS++) ^= (x0 >> 16) | (x1 & 0xFFFF0000); \\\n\t\t} \\\n\t}\n\n#define xorLanesIntoState(laneCount, state, input) \\\n    xorInterleavedLE(laneCount, state, input)\n\n#else // (PLATFORM_BYTE_ORDER == IS_BIG_ENDIAN)\n\n// Credit: Henry S. Warren, Hacker's Delight, Addison-Wesley, 2002\nUINT64 toInterleaving(UINT64 x) \n{\n   UINT64 t;\n\n   t = (x ^ (x >>  1)) & 0x2222222222222222ULL;  x = x ^ t ^ (t <<  1);\n   t = (x ^ (x >>  2)) & 0x0C0C0C0C0C0C0C0CULL;  x = x ^ t ^ (t <<  2);\n   t = (x ^ (x >>  4)) & 0x00F000F000F000F0ULL;  x = x ^ t ^ (t <<  4);\n   t = (x ^ (x >>  8)) & 0x0000FF000000FF00ULL;  x = x ^ t ^ (t <<  8);\n   t = (x ^ (x >> 16)) & 0x00000000FFFF0000ULL;  x = x ^ t ^ (t << 16);\n\n   return x;\n}\n\nvoid xor8bytesIntoInterleavedWords(UINT32* evenAndOdd, const UINT8* source)\n{\n    // This can be optimized\n    UINT64 sourceWord =\n        (UINT64)source[0]\n        ^ (((UINT64)source[1]) <<  8)\n        ^ (((UINT64)source[2]) << 16)\n        ^ (((UINT64)source[3]) << 24)\n        ^ (((UINT64)source[4]) << 32)\n        ^ (((UINT64)source[5]) << 40)\n        ^ (((UINT64)source[6]) << 48)\n        ^ (((UINT64)source[7]) << 56);\n    UINT64 evenAndOddWord = toInterleaving(sourceWord);\n    evenAndOdd[0] ^= (UINT32)evenAndOddWord;\n    evenAndOdd[1] ^= (UINT32)(evenAndOddWord >> 32);\n}\n\n#define xorLanesIntoState(laneCount, state, input) \\\n    { \\\n        int i; \\\n        for(i=0; i<(laneCount); i++) \\\n            xor8bytesIntoInterleavedWords(state+i*2, input+i*8); \\\n    }\n\n#endif // Endianness\n\n// Credit: Henry S. Warren, Hacker's Delight, Addison-Wesley, 2002\nUINT64 fromInterleaving(UINT64 x)\n{\n   UINT64 t;\n\n   t = (x ^ (x >> 16)) & 0x00000000FFFF0000ULL;  x = x ^ t ^ (t << 16);\n   t = (x ^ (x >>  8)) & 0x0000FF000000FF00ULL;  x = x ^ t ^ (t <<  8);\n   t = (x ^ (x >>  4)) & 0x00F000F000F000F0ULL;  x = x ^ t ^ (t <<  4);\n   t = (x ^ (x >>  2)) & 0x0C0C0C0C0C0C0C0CULL;  x = x ^ t ^ (t <<  2);\n   t = (x ^ (x >>  1)) & 0x2222222222222222ULL;  x = x ^ t ^ (t <<  1);\n\n   return x;\n}\n\nvoid setInterleavedWordsInto8bytes(UINT8* dest, UINT32* evenAndOdd)\n{\n#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)\n    ((UINT64*)dest)[0] = fromInterleaving(*(UINT64*)evenAndOdd);\n#else // (PLATFORM_BYTE_ORDER == IS_BIG_ENDIAN)\n    // This can be optimized\n    UINT64 evenAndOddWord = (UINT64)evenAndOdd[0] ^ ((UINT64)evenAndOdd[1] << 32);\n    UINT64 destWord = fromInterleaving(evenAndOddWord);\n    dest[0] = destWord & 0xFF;\n    dest[1] = (destWord >> 8) & 0xFF;\n    dest[2] = (destWord >> 16) & 0xFF;\n    dest[3] = (destWord >> 24) & 0xFF;\n    dest[4] = (destWord >> 32) & 0xFF;\n    dest[5] = (destWord >> 40) & 0xFF;\n    dest[6] = (destWord >> 48) & 0xFF;\n    dest[7] = (destWord >> 56) & 0xFF;\n#endif // Endianness\n}\n\n#define extractLanes(laneCount, state, data) \\\n    { \\\n        int i; \\\n        for(i=0; i<(laneCount); i++) \\\n            setInterleavedWordsInto8bytes(data+i*8, (UINT32*)state+i*2); \\\n    }\n\n#endif // With or without interleaving tables\n\n#if defined(_MSC_VER)\n#define ROL32(a, offset) _rotl(a, offset)\n#elif (defined (__arm__) && defined(__ARMCC_VERSION))\n#define ROL32(a, offset) __ror(a, 32-(offset))\n#else\n#define ROL32(a, offset) ((((UINT32)a) << (offset)) ^ (((UINT32)a) >> (32-(offset))))\n#endif\n\n#include \"KeccakF-1600-unrolling.macros\"\n#include \"KeccakF-1600-32.macros\"\n\n#if (UseSchedule == 3)\n\n#ifdef UseBebigokimisa\n#error \"No lane complementing with schedule 3.\"\n#endif\n\n#if (Unrolling != 2)\n#error \"Only unrolling 2 is supported by schedule 3.\"\n#endif\n\nvoid KeccakPermutationOnWords(UINT32 *state)\n{\n    rounds\n}\n\nvoid KeccakPermutationOnWordsAfterXoring(UINT32 *state, const UINT8 *input, unsigned int laneCount)\n{\n    xorLanesIntoState(laneCount, state, input)\n    rounds\n}\n\n#ifdef ProvideFast576\nvoid KeccakPermutationOnWordsAfterXoring576bits(UINT32 *state, const UINT8 *input)\n{\n    xorLanesIntoState(9, state, input)\n    rounds\n}\n#endif\n\n#ifdef ProvideFast832\nvoid KeccakPermutationOnWordsAfterXoring832bits(UINT32 *state, const UINT8 *input)\n{\n    xorLanesIntoState(13, state, input)\n    rounds\n}\n#endif\n\n#ifdef ProvideFast1024\nvoid KeccakPermutationOnWordsAfterXoring1024bits(UINT32 *state, const UINT8 *input)\n{\n    xorLanesIntoState(16, state, input)\n    rounds\n}\n#endif\n\n#ifdef ProvideFast1088\nvoid KeccakPermutationOnWordsAfterXoring1088bits(UINT32 *state, const UINT8 *input)\n{\n    xorLanesIntoState(17, state, input)\n    rounds\n}\n#endif\n\n#ifdef ProvideFast1152\nvoid KeccakPermutationOnWordsAfterXoring1152bits(UINT32 *state, const UINT8 *input)\n{\n    xorLanesIntoState(18, state, input)\n    rounds\n}\n#endif\n\n#ifdef ProvideFast1344\nvoid KeccakPermutationOnWordsAfterXoring1344bits(UINT32 *state, const UINT8 *input)\n{\n    xorLanesIntoState(21, state, input)\n    rounds\n}\n#endif\n\n#else // (Schedule != 3)\n\nvoid KeccakPermutationOnWords(UINT32 *state)\n{\n    declareABCDE\n#if (Unrolling != 24)\n    unsigned int i;\n#endif\n\n    copyFromState(A, state)\n    rounds\n}\n\nvoid KeccakPermutationOnWordsAfterXoring(UINT32 *state, const UINT8 *input, unsigned int laneCount)\n{\n    declareABCDE\n    unsigned int i;\n\n    xorLanesIntoState(laneCount, state, input)\n    copyFromState(A, state)\n    rounds\n}\n\n#ifdef ProvideFast576\nvoid KeccakPermutationOnWordsAfterXoring576bits(UINT32 *state, const UINT8 *input)\n{\n    declareABCDE\n    unsigned int i;\n\n    xorLanesIntoState(9, state, input)\n    copyFromState(A, state)\n    rounds\n}\n#endif\n\n#ifdef ProvideFast832\nvoid KeccakPermutationOnWordsAfterXoring832bits(UINT32 *state, const UINT8 *input)\n{\n    declareABCDE\n    unsigned int i;\n\n    xorLanesIntoState(13, state, input)\n    copyFromState(A, state)\n    rounds\n}\n#endif\n\n#ifdef ProvideFast1024\nvoid KeccakPermutationOnWordsAfterXoring1024bits(UINT32 *state, const UINT8 *input)\n{\n    declareABCDE\n    unsigned int i;\n\n    xorLanesIntoState(16, state, input)\n    copyFromState(A, state)\n    rounds\n}\n#endif\n\n#ifdef ProvideFast1088\nvoid KeccakPermutationOnWordsAfterXoring1088bits(UINT32 *state, const UINT8 *input)\n{\n    declareABCDE\n    unsigned int i;\n\n    xorLanesIntoState(17, state, input)\n    copyFromState(A, state)\n    rounds\n}\n#endif\n\n#ifdef ProvideFast1152\nvoid KeccakPermutationOnWordsAfterXoring1152bits(UINT32 *state, const UINT8 *input)\n{\n    declareABCDE\n    unsigned int i;\n\n    xorLanesIntoState(18, state, input)\n    copyFromState(A, state)\n    rounds\n}\n#endif\n\n#ifdef ProvideFast1344\nvoid KeccakPermutationOnWordsAfterXoring1344bits(UINT32 *state, const UINT8 *input)\n{\n    declareABCDE\n    unsigned int i;\n\n    xorLanesIntoState(21, state, input)\n    copyFromState(A, state)\n    rounds\n}\n#endif\n\n#endif\n\nvoid KeccakInitialize()\n{\n#ifdef UseInterleaveTables\n    buildInterleaveTables();\n#endif\n}\n\nvoid KeccakInitializeState(unsigned char *state)\n{\n    memset(state, 0, 200);\n#ifdef UseBebigokimisa\n    ((UINT32*)state)[ 2] = ~(UINT32)0;\n    ((UINT32*)state)[ 3] = ~(UINT32)0;\n    ((UINT32*)state)[ 4] = ~(UINT32)0;\n    ((UINT32*)state)[ 5] = ~(UINT32)0;\n    ((UINT32*)state)[16] = ~(UINT32)0;\n    ((UINT32*)state)[17] = ~(UINT32)0;\n    ((UINT32*)state)[24] = ~(UINT32)0;\n    ((UINT32*)state)[25] = ~(UINT32)0;\n    ((UINT32*)state)[34] = ~(UINT32)0;\n    ((UINT32*)state)[35] = ~(UINT32)0;\n    ((UINT32*)state)[40] = ~(UINT32)0;\n    ((UINT32*)state)[41] = ~(UINT32)0;\n#endif\n}\n\nvoid KeccakPermutation(unsigned char *state)\n{\n    // We assume the state is always stored as interleaved 32-bit words\n    KeccakPermutationOnWords((UINT32*)state);\n}\n\n#ifdef ProvideFast576\nvoid KeccakAbsorb576bits(unsigned char *state, const unsigned char *data)\n{\n    KeccakPermutationOnWordsAfterXoring576bits((UINT32*)state, data);\n}\n#endif\n\n#ifdef ProvideFast832\nvoid KeccakAbsorb832bits(unsigned char *state, const unsigned char *data)\n{\n    KeccakPermutationOnWordsAfterXoring832bits((UINT32*)state, data);\n}\n#endif\n\n#ifdef ProvideFast1024\nvoid KeccakAbsorb1024bits(unsigned char *state, const unsigned char *data)\n{\n    KeccakPermutationOnWordsAfterXoring1024bits((UINT32*)state, data);\n}\n#endif\n\n#ifdef ProvideFast1088\nvoid KeccakAbsorb1088bits(unsigned char *state, const unsigned char *data)\n{\n    KeccakPermutationOnWordsAfterXoring1088bits((UINT32*)state, data);\n}\n#endif\n\n#ifdef ProvideFast1152\nvoid KeccakAbsorb1152bits(unsigned char *state, const unsigned char *data)\n{\n    KeccakPermutationOnWordsAfterXoring1152bits((UINT32*)state, data);\n}\n#endif\n\n#ifdef ProvideFast1344\nvoid KeccakAbsorb1344bits(unsigned char *state, const unsigned char *data)\n{\n    KeccakPermutationOnWordsAfterXoring1344bits((UINT32*)state, data);\n}\n#endif\n\nvoid KeccakAbsorb(unsigned char *state, const unsigned char *data, unsigned int laneCount)\n{\n    KeccakPermutationOnWordsAfterXoring((UINT32*)state, data, laneCount);\n}\n\n#ifdef ProvideFast1024\nvoid KeccakExtract1024bits(const unsigned char *state, unsigned char *data)\n{\n    extractLanes(16, state, data)\n#ifdef UseBebigokimisa\n    ((UINT32*)data)[ 2] = ~((UINT32*)data)[ 2];\n    ((UINT32*)data)[ 3] = ~((UINT32*)data)[ 3];\n    ((UINT32*)data)[ 4] = ~((UINT32*)data)[ 4];\n    ((UINT32*)data)[ 5] = ~((UINT32*)data)[ 5];\n    ((UINT32*)data)[16] = ~((UINT32*)data)[16];\n    ((UINT32*)data)[17] = ~((UINT32*)data)[17];\n    ((UINT32*)data)[24] = ~((UINT32*)data)[24];\n    ((UINT32*)data)[25] = ~((UINT32*)data)[25];\n#endif\n}\n#endif\n\nvoid KeccakExtract(const unsigned char *state, unsigned char *data, unsigned int laneCount)\n{\n    extractLanes(laneCount, state, data)\n#ifdef UseBebigokimisa\n    if (laneCount > 1) {\n        ((UINT32*)data)[ 2] = ~((UINT32*)data)[ 2];\n        ((UINT32*)data)[ 3] = ~((UINT32*)data)[ 3];\n        if (laneCount > 2) {\n            ((UINT32*)data)[ 4] = ~((UINT32*)data)[ 4];\n            ((UINT32*)data)[ 5] = ~((UINT32*)data)[ 5];\n            if (laneCount > 8) {\n                ((UINT32*)data)[16] = ~((UINT32*)data)[16];\n                ((UINT32*)data)[17] = ~((UINT32*)data)[17];\n                if (laneCount > 12) {\n                    ((UINT32*)data)[24] = ~((UINT32*)data)[24];\n                    ((UINT32*)data)[25] = ~((UINT32*)data)[25];\n                    if (laneCount > 17) {\n                        ((UINT32*)data)[34] = ~((UINT32*)data)[34];\n                        ((UINT32*)data)[35] = ~((UINT32*)data)[35];\n                        if (laneCount > 20) {\n                            ((UINT32*)data)[40] = ~((UINT32*)data)[40];\n                            ((UINT32*)data)[41] = ~((UINT32*)data)[41];\n                        }\n                    }\n                }\n            }\n        }\n    }\n#endif\n}\n"
        },
        {
            "file_name": "KeccakF-1600-opt64.c",
            "content": "/*\nThe Keccak sponge function, designed by Guido Bertoni, Joan Daemen,\nMicha\u00c3\u00abl Peeters and Gilles Van Assche. For more information, feedback or\nquestions, please refer to our website: http://keccak.noekeon.org/\n\nImplementation by the designers,\nhereby denoted as \"the implementer\".\n\nTo the extent possible under law, the implementer has waived all copyright\nand related or neighboring rights to the source code in this file.\nhttp://creativecommons.org/publicdomain/zero/1.0/\n*/\n\n#include <string.h>\n#include \"brg_endian.h\"\n#include \"KeccakF-1600-opt64-settings.h\"\n#include \"KeccakF-1600-interface.h\"\n\ntypedef unsigned char UINT8;\ntypedef unsigned long long int UINT64;\n\n#if defined(__GNUC__)\n#define ALIGN __attribute__ ((aligned(32)))\n#elif defined(_MSC_VER)\n#define ALIGN __declspec(align(32))\n#else\n#define ALIGN\n#endif\n\n#if defined(UseSSE)\n    #include <x86intrin.h>\n    typedef __m128i V64;\n    typedef __m128i V128;\n    typedef union {\n        V128 v128;\n        UINT64 v64[2];\n    } V6464;\n\n    #define ANDnu64(a, b)       _mm_andnot_si128(a, b)\n    #define LOAD64(a)           _mm_loadl_epi64((const V64 *)&(a))\n    #define CONST64(a)          _mm_loadl_epi64((const V64 *)&(a))\n    #define ROL64(a, o)         _mm_or_si128(_mm_slli_epi64(a, o), _mm_srli_epi64(a, 64-(o)))\n    #define STORE64(a, b)       _mm_storel_epi64((V64 *)&(a), b)\n    #define XOR64(a, b)         _mm_xor_si128(a, b)\n    #define XOReq64(a, b)       a = _mm_xor_si128(a, b)\n    #define SHUFFLEBYTES128(a, b)   _mm_shuffle_epi8(a, b)\n\n    #define ANDnu128(a, b)      _mm_andnot_si128(a, b)\n    #define LOAD6464(a, b)      _mm_set_epi64((__m64)(a), (__m64)(b))\n    #define CONST128(a)         _mm_load_si128((const V128 *)&(a))\n    #define LOAD128(a)          _mm_load_si128((const V128 *)&(a))\n    #define LOAD128u(a)         _mm_loadu_si128((const V128 *)&(a))\n    #define ROL64in128(a, o)    _mm_or_si128(_mm_slli_epi64(a, o), _mm_srli_epi64(a, 64-(o)))\n    #define STORE128(a, b)      _mm_store_si128((V128 *)&(a), b)\n    #define XOR128(a, b)        _mm_xor_si128(a, b)\n    #define XOReq128(a, b)      a = _mm_xor_si128(a, b)\n    #define GET64LOLO(a, b)     _mm_unpacklo_epi64(a, b)\n    #define GET64HIHI(a, b)     _mm_unpackhi_epi64(a, b)\n    #define COPY64HI2LO(a)      _mm_shuffle_epi32(a, 0xEE)\n    #define COPY64LO2HI(a)      _mm_shuffle_epi32(a, 0x44)\n    #define ZERO128()           _mm_setzero_si128()\n\n    #ifdef UseOnlySIMD64\n    #include \"KeccakF-1600-simd64.macros\"\n    #else\nALIGN const UINT64 rho8_56[2] = {0x0605040302010007, 0x080F0E0D0C0B0A09};\n    #include \"KeccakF-1600-simd128.macros\"\n    #endif\n\n    #ifdef UseBebigokimisa\n    #error \"UseBebigokimisa cannot be used in combination with UseSSE\"\n    #endif\n#elif defined(UseXOP)\n    #include <x86intrin.h>\n    typedef __m128i V64;\n    typedef __m128i V128;\n   \n    #define LOAD64(a)           _mm_loadl_epi64((const V64 *)&(a))\n    #define CONST64(a)          _mm_loadl_epi64((const V64 *)&(a))\n    #define STORE64(a, b)       _mm_storel_epi64((V64 *)&(a), b)\n    #define XOR64(a, b)         _mm_xor_si128(a, b)\n    #define XOReq64(a, b)       a = _mm_xor_si128(a, b)\n\n    #define ANDnu128(a, b)      _mm_andnot_si128(a, b)\n    #define LOAD6464(a, b)      _mm_set_epi64((__m64)(a), (__m64)(b))\n    #define CONST128(a)         _mm_load_si128((const V128 *)&(a))\n    #define LOAD128(a)          _mm_load_si128((const V128 *)&(a))\n    #define LOAD128u(a)         _mm_loadu_si128((const V128 *)&(a))\n    #define STORE128(a, b)      _mm_store_si128((V128 *)&(a), b)\n    #define XOR128(a, b)        _mm_xor_si128(a, b)\n    #define XOReq128(a, b)      a = _mm_xor_si128(a, b)\n    #define ZERO128()           _mm_setzero_si128()\n\n    #define SWAP64(a)           _mm_shuffle_epi32(a, 0x4E)\n    #define GET64LOLO(a, b)     _mm_unpacklo_epi64(a, b)\n    #define GET64HIHI(a, b)     _mm_unpackhi_epi64(a, b)\n    #define GET64LOHI(a, b)     ((__m128i)_mm_blend_pd((__m128d)a, (__m128d)b, 2))\n    #define GET64HILO(a, b)     SWAP64(GET64LOHI(b, a))\n    #define COPY64HI2LO(a)      _mm_shuffle_epi32(a, 0xEE)\n    #define COPY64LO2HI(a)      _mm_shuffle_epi32(a, 0x44)\n \n    #define ROL6464same(a, o)   _mm_roti_epi64(a, o)\n    #define ROL6464(a, r1, r2)  _mm_rot_epi64(a, CONST128( rot_##r1##_##r2 ))\nALIGN const UINT64 rot_0_20[2]  = { 0, 20};\nALIGN const UINT64 rot_44_3[2]  = {44,  3};\nALIGN const UINT64 rot_43_45[2] = {43, 45};\nALIGN const UINT64 rot_21_61[2] = {21, 61};\nALIGN const UINT64 rot_14_28[2] = {14, 28};\nALIGN const UINT64 rot_1_36[2]  = { 1, 36};\nALIGN const UINT64 rot_6_10[2]  = { 6, 10};\nALIGN const UINT64 rot_25_15[2] = {25, 15};\nALIGN const UINT64 rot_8_56[2]  = { 8, 56};\nALIGN const UINT64 rot_18_27[2] = {18, 27};\nALIGN const UINT64 rot_62_55[2] = {62, 55};\nALIGN const UINT64 rot_39_41[2] = {39, 41};\n\n#if defined(UseSimulatedXOP)\n    // For debugging purposes, when XOP is not available\n    #undef ROL6464\n    #undef ROL6464same\n    #define ROL6464same(a, o)   _mm_or_si128(_mm_slli_epi64(a, o), _mm_srli_epi64(a, 64-(o)))\n    V128 ROL6464(V128 a, int r0, int r1)\n    {\n        V128 a0 = ROL64(a, r0);\n        V128 a1 = COPY64HI2LO(ROL64(a, r1));\n        return GET64LOLO(a0, a1);\n    }\n#endif\n    \n    #include \"KeccakF-1600-xop.macros\"\n\n    #ifdef UseBebigokimisa\n    #error \"UseBebigokimisa cannot be used in combination with UseXOP\"\n    #endif\n#elif defined(UseMMX)\n    #include <mmintrin.h>\n    typedef __m64 V64;\n    #define ANDnu64(a, b)       _mm_andnot_si64(a, b)\n\n    #if (defined(_MSC_VER) || defined (__INTEL_COMPILER))\n        #define LOAD64(a)       *(V64*)&(a)\n        #define CONST64(a)      *(V64*)&(a)\n        #define STORE64(a, b)   *(V64*)&(a) = b\n    #else\n        #define LOAD64(a)       (V64)a\n        #define CONST64(a)      (V64)a\n        #define STORE64(a, b)   a = (UINT64)b\n    #endif\n    #define ROL64(a, o)         _mm_or_si64(_mm_slli_si64(a, o), _mm_srli_si64(a, 64-(o)))\n    #define XOR64(a, b)         _mm_xor_si64(a, b)\n    #define XOReq64(a, b)       a = _mm_xor_si64(a, b)\n\n    #include \"KeccakF-1600-simd64.macros\"\n\n    #ifdef UseBebigokimisa\n    #error \"UseBebigokimisa cannot be used in combination with UseMMX\"\n    #endif\n#else\n    #if defined(_MSC_VER)\n    #define ROL64(a, offset) _rotl64(a, offset)\n    #elif defined(UseSHLD)\n      #define ROL64(x,N) ({ \\\n        register UINT64 __out; \\\n        register UINT64 __in = x; \\\n        __asm__ (\"shld %2,%0,%0\" : \"=r\"(__out) : \"0\"(__in), \"i\"(N)); \\\n        __out; \\\n      })\n    #else\n    #define ROL64(a, offset) ((((UINT64)a) << offset) ^ (((UINT64)a) >> (64-offset)))\n    #endif\n\n    #include \"KeccakF-1600-64.macros\"\n#endif\n\n#include \"KeccakF-1600-unrolling.macros\"\n\nvoid KeccakPermutationOnWords(UINT64 *state)\n{\n    declareABCDE\n#if (Unrolling != 24)\n    unsigned int i;\n#endif\n\n    copyFromState(A, state)\n    rounds\n#if defined(UseMMX)\n    _mm_empty();\n#endif\n}\n\nvoid KeccakPermutationOnWordsAfterXoring(UINT64 *state, const UINT64 *input, unsigned int laneCount)\n{\n    declareABCDE\n#if (Unrolling != 24)\n    unsigned int i;\n#endif\n\tunsigned int j;\n\n    for(j=0; j<laneCount; j++)\n        state[j] ^= input[j];\t\n    copyFromState(A, state)\n    rounds\n#if defined(UseMMX)\n    _mm_empty();\n#endif\n}\n\n#ifdef ProvideFast576\nvoid KeccakPermutationOnWordsAfterXoring576bits(UINT64 *state, const UINT64 *input)\n{\n    declareABCDE\n#if (Unrolling != 24)\n    unsigned int i;\n#endif\n\n    copyFromStateAndXor576bits(A, state, input)\n    rounds\n#if defined(UseMMX)\n    _mm_empty();\n#endif\n}\n#endif\n\n#ifdef ProvideFast832\nvoid KeccakPermutationOnWordsAfterXoring832bits(UINT64 *state, const UINT64 *input)\n{\n    declareABCDE\n#if (Unrolling != 24)\n    unsigned int i;\n#endif\n\n    copyFromStateAndXor832bits(A, state, input)\n    rounds\n#if defined(UseMMX)\n    _mm_empty();\n#endif\n}\n#endif\n\n#ifdef ProvideFast1024\nvoid KeccakPermutationOnWordsAfterXoring1024bits(UINT64 *state, const UINT64 *input)\n{\n    declareABCDE\n#if (Unrolling != 24)\n    unsigned int i;\n#endif\n\n    copyFromStateAndXor1024bits(A, state, input)\n    rounds\n#if defined(UseMMX)\n    _mm_empty();\n#endif\n}\n#endif\n\n#ifdef ProvideFast1088\nvoid KeccakPermutationOnWordsAfterXoring1088bits(UINT64 *state, const UINT64 *input)\n{\n    declareABCDE\n#if (Unrolling != 24)\n    unsigned int i;\n#endif\n\n    copyFromStateAndXor1088bits(A, state, input)\n    rounds\n#if defined(UseMMX)\n    _mm_empty();\n#endif\n}\n#endif\n\n#ifdef ProvideFast1152\nvoid KeccakPermutationOnWordsAfterXoring1152bits(UINT64 *state, const UINT64 *input)\n{\n    declareABCDE\n#if (Unrolling != 24)\n    unsigned int i;\n#endif\n\n    copyFromStateAndXor1152bits(A, state, input)\n    rounds\n#if defined(UseMMX)\n    _mm_empty();\n#endif\n}\n#endif\n\n#ifdef ProvideFast1344\nvoid KeccakPermutationOnWordsAfterXoring1344bits(UINT64 *state, const UINT64 *input)\n{\n    declareABCDE\n#if (Unrolling != 24)\n    unsigned int i;\n#endif\n\n    copyFromStateAndXor1344bits(A, state, input)\n    rounds\n#if defined(UseMMX)\n    _mm_empty();\n#endif\n}\n#endif\n\nvoid KeccakInitialize()\n{\n}\n\nvoid KeccakInitializeState(unsigned char *state)\n{\n    memset(state, 0, 200);\n#ifdef UseBebigokimisa\n    ((UINT64*)state)[ 1] = ~(UINT64)0;\n    ((UINT64*)state)[ 2] = ~(UINT64)0;\n    ((UINT64*)state)[ 8] = ~(UINT64)0;\n    ((UINT64*)state)[12] = ~(UINT64)0;\n    ((UINT64*)state)[17] = ~(UINT64)0;\n    ((UINT64*)state)[20] = ~(UINT64)0;\n#endif\n}\n\nvoid KeccakPermutation(unsigned char *state)\n{\n    // We assume the state is always stored as words\n    KeccakPermutationOnWords((UINT64*)state);\n}\n\nvoid fromBytesToWord(UINT64 *word, const UINT8 *bytes)\n{\n    unsigned int i;\n\n    *word = 0;\n    for(i=0; i<(64/8); i++)\n        *word |= (UINT64)(bytes[i]) << (8*i);\n}\n\n#ifdef ProvideFast576\nvoid KeccakAbsorb576bits(unsigned char *state, const unsigned char *data)\n{\n#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)\n    KeccakPermutationOnWordsAfterXoring576bits((UINT64*)state, (const UINT64*)data);\n#else\n    UINT64 dataAsWords[9];\n    unsigned int i;\n\n    for(i=0; i<9; i++)\n        fromBytesToWord(dataAsWords+i, data+(i*8));\n    KeccakPermutationOnWordsAfterXoring576bits((UINT64*)state, dataAsWords);\n#endif\n}\n#endif\n\n#ifdef ProvideFast832\nvoid KeccakAbsorb832bits(unsigned char *state, const unsigned char *data)\n{\n#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)\n    KeccakPermutationOnWordsAfterXoring832bits((UINT64*)state, (const UINT64*)data);\n#else\n    UINT64 dataAsWords[13];\n    unsigned int i;\n\n    for(i=0; i<13; i++)\n        fromBytesToWord(dataAsWords+i, data+(i*8));\n    KeccakPermutationOnWordsAfterXoring832bits((UINT64*)state, dataAsWords);\n#endif\n}\n#endif\n\n#ifdef ProvideFast1024\nvoid KeccakAbsorb1024bits(unsigned char *state, const unsigned char *data)\n{\n#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)\n    KeccakPermutationOnWordsAfterXoring1024bits((UINT64*)state, (const UINT64*)data);\n#else\n    UINT64 dataAsWords[16];\n    unsigned int i;\n\n    for(i=0; i<16; i++)\n        fromBytesToWord(dataAsWords+i, data+(i*8));\n    KeccakPermutationOnWordsAfterXoring1024bits((UINT64*)state, dataAsWords);\n#endif\n}\n#endif\n\n#ifdef ProvideFast1088\nvoid KeccakAbsorb1088bits(unsigned char *state, const unsigned char *data)\n{\n#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)\n    KeccakPermutationOnWordsAfterXoring1088bits((UINT64*)state, (const UINT64*)data);\n#else\n    UINT64 dataAsWords[17];\n    unsigned int i;\n\n    for(i=0; i<17; i++)\n        fromBytesToWord(dataAsWords+i, data+(i*8));\n    KeccakPermutationOnWordsAfterXoring1088bits((UINT64*)state, dataAsWords);\n#endif\n}\n#endif\n\n#ifdef ProvideFast1152\nvoid KeccakAbsorb1152bits(unsigned char *state, const unsigned char *data)\n{\n#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)\n    KeccakPermutationOnWordsAfterXoring1152bits((UINT64*)state, (const UINT64*)data);\n#else\n    UINT64 dataAsWords[18];\n    unsigned int i;\n\n    for(i=0; i<18; i++)\n        fromBytesToWord(dataAsWords+i, data+(i*8));\n    KeccakPermutationOnWordsAfterXoring1152bits((UINT64*)state, dataAsWords);\n#endif\n}\n#endif\n\n#ifdef ProvideFast1344\nvoid KeccakAbsorb1344bits(unsigned char *state, const unsigned char *data)\n{\n#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)\n    KeccakPermutationOnWordsAfterXoring1344bits((UINT64*)state, (const UINT64*)data);\n#else\n    UINT64 dataAsWords[21];\n    unsigned int i;\n\n    for(i=0; i<21; i++)\n        fromBytesToWord(dataAsWords+i, data+(i*8));\n    KeccakPermutationOnWordsAfterXoring1344bits((UINT64*)state, dataAsWords);\n#endif\n}\n#endif\n\nvoid KeccakAbsorb(unsigned char *state, const unsigned char *data, unsigned int laneCount)\n{\n#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)\n    KeccakPermutationOnWordsAfterXoring((UINT64*)state, (const UINT64*)data, laneCount);\n#else\n    UINT64 dataAsWords[25];\n    unsigned int i;\n\n    for(i=0; i<laneCount; i++)\n        fromBytesToWord(dataAsWords+i, data+(i*8));\n    KeccakPermutationOnWordsAfterXoring((UINT64*)state, dataAsWords, laneCount);\n#endif\n}\n\nvoid fromWordToBytes(UINT8 *bytes, const UINT64 word)\n{\n    unsigned int i;\n\n    for(i=0; i<(64/8); i++)\n        bytes[i] = (word >> (8*i)) & 0xFF;\n}\n\n#ifdef ProvideFast1024\nvoid KeccakExtract1024bits(const unsigned char *state, unsigned char *data)\n{\n#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)\n    memcpy(data, state, 128);\n#else\n    unsigned int i;\n\n    for(i=0; i<16; i++)\n        fromWordToBytes(data+(i*8), ((const UINT64*)state)[i]);\n#endif\n#ifdef UseBebigokimisa\n    ((UINT64*)data)[ 1] = ~((UINT64*)data)[ 1];\n    ((UINT64*)data)[ 2] = ~((UINT64*)data)[ 2];\n    ((UINT64*)data)[ 8] = ~((UINT64*)data)[ 8];\n    ((UINT64*)data)[12] = ~((UINT64*)data)[12];\n#endif\n}\n#endif\n\nvoid KeccakExtract(const unsigned char *state, unsigned char *data, unsigned int laneCount)\n{\n#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)\n    memcpy(data, state, laneCount*8);\n#else\n    unsigned int i;\n\n    for(i=0; i<laneCount; i++)\n        fromWordToBytes(data+(i*8), ((const UINT64*)state)[i]);\n#endif\n#ifdef UseBebigokimisa\n    if (laneCount > 1) {\n        ((UINT64*)data)[ 1] = ~((UINT64*)data)[ 1];\n        if (laneCount > 2) {\n            ((UINT64*)data)[ 2] = ~((UINT64*)data)[ 2];\n            if (laneCount > 8) {\n                ((UINT64*)data)[ 8] = ~((UINT64*)data)[ 8];\n                if (laneCount > 12) {\n                    ((UINT64*)data)[12] = ~((UINT64*)data)[12];\n                    if (laneCount > 17) {\n                        ((UINT64*)data)[17] = ~((UINT64*)data)[17];\n                        if (laneCount > 20) {\n                            ((UINT64*)data)[20] = ~((UINT64*)data)[20];\n                        }\n                    }\n                }\n            }\n        }\n    }\n#endif\n}\n"
        },
        {
            "file_name": "KeccakNISTInterface.c",
            "content": "/*\nThe Keccak sponge function, designed by Guido Bertoni, Joan Daemen,\nMicha\u00c3\u00abl Peeters and Gilles Van Assche. For more information, feedback or\nquestions, please refer to our website: http://keccak.noekeon.org/\n\nImplementation by the designers,\nhereby denoted as \"the implementer\".\n\nTo the extent possible under law, the implementer has waived all copyright\nand related or neighboring rights to the source code in this file.\nhttp://creativecommons.org/publicdomain/zero/1.0/\n*/\n\n#include <string.h>\n#include \"KeccakNISTInterface.h\"\n#include \"KeccakF-1600-interface.h\"\n\nHashReturn Init(hashState *state, int hashbitlen)\n{\n    switch(hashbitlen) {\n        case 0: // Default parameters, arbitrary length output\n            InitSponge((spongeState*)state, 1024, 576);\n            break;\n        case 224:\n            InitSponge((spongeState*)state, 1152, 448);\n            break;\n        case 256:\n            InitSponge((spongeState*)state, 1088, 512);\n            break;\n        case 384:\n            InitSponge((spongeState*)state, 832, 768);\n            break;\n        case 512:\n            InitSponge((spongeState*)state, 576, 1024);\n            break;\n        default:\n            return BAD_HASHLEN;\n    }\n    state->fixedOutputLength = hashbitlen;\n    return SUCCESS;\n}\n\nHashReturn Update(hashState *state, const BitSequence *data, DataLength databitlen)\n{\n    if ((databitlen % 8) == 0)\n        return Absorb((spongeState*)state, data, databitlen);\n    else {\n        HashReturn ret = Absorb((spongeState*)state, data, databitlen - (databitlen % 8));\n        if (ret == SUCCESS) {\n            unsigned char lastByte; \n            // Align the last partial byte to the least significant bits\n            lastByte = data[databitlen/8] >> (8 - (databitlen % 8));\n            return Absorb((spongeState*)state, &lastByte, databitlen % 8);\n        }\n        else\n            return ret;\n    }\n}\n\nHashReturn Final(hashState *state, BitSequence *hashval)\n{\n    return Squeeze(state, hashval, state->fixedOutputLength);\n}\n\nHashReturn Hash(int hashbitlen, const BitSequence *data, DataLength databitlen, BitSequence *hashval)\n{\n    hashState state;\n    HashReturn result;\n\n    if ((hashbitlen != 224) && (hashbitlen != 256) && (hashbitlen != 384) && (hashbitlen != 512))\n        return BAD_HASHLEN; // Only the four fixed output lengths available through this API\n    result = Init(&state, hashbitlen);\n    if (result != SUCCESS)\n        return result;\n    result = Update(&state, data, databitlen);\n    if (result != SUCCESS)\n        return result;\n    result = Final(&state, hashval);\n    return result;\n}\n\n"
        },
        {
            "file_name": "KeccakSponge.c",
            "content": "/*\nThe Keccak sponge function, designed by Guido Bertoni, Joan Daemen,\nMicha\u00c3\u00abl Peeters and Gilles Van Assche. For more information, feedback or\nquestions, please refer to our website: http://keccak.noekeon.org/\n\nImplementation by the designers,\nhereby denoted as \"the implementer\".\n\nTo the extent possible under law, the implementer has waived all copyright\nand related or neighboring rights to the source code in this file.\nhttp://creativecommons.org/publicdomain/zero/1.0/\n*/\n\n#include <string.h>\n#include \"KeccakSponge.h\"\n#include \"KeccakF-1600-interface.h\"\n#ifdef KeccakReference\n#include \"displayIntermediateValues.h\"\n#endif\n\nint InitSponge(spongeState *state, unsigned int rate, unsigned int capacity)\n{\n    if (rate+capacity != 1600)\n        return 1;\n    if ((rate <= 0) || (rate >= 1600) || ((rate % 64) != 0))\n        return 1;\n    KeccakInitialize();\n    state->rate = rate;\n    state->capacity = capacity;\n    state->fixedOutputLength = 0;\n    KeccakInitializeState(state->state);\n    memset(state->dataQueue, 0, KeccakMaximumRateInBytes);\n    state->bitsInQueue = 0;\n    state->squeezing = 0;\n    state->bitsAvailableForSqueezing = 0;\n\n    return 0;\n}\n\nvoid AbsorbQueue(spongeState *state)\n{\n    // state->bitsInQueue is assumed to be equal to state->rate\n    #ifdef KeccakReference\n    displayBytes(1, \"Block to be absorbed\", state->dataQueue, state->rate/8);\n    #endif\n#ifdef ProvideFast576\n    if (state->rate == 576)\n        KeccakAbsorb576bits(state->state, state->dataQueue);\n    else \n#endif\n#ifdef ProvideFast832\n    if (state->rate == 832)\n        KeccakAbsorb832bits(state->state, state->dataQueue);\n    else \n#endif\n#ifdef ProvideFast1024\n    if (state->rate == 1024)\n        KeccakAbsorb1024bits(state->state, state->dataQueue);\n    else \n#endif\n#ifdef ProvideFast1088\n    if (state->rate == 1088)\n        KeccakAbsorb1088bits(state->state, state->dataQueue);\n    else\n#endif\n#ifdef ProvideFast1152\n    if (state->rate == 1152)\n        KeccakAbsorb1152bits(state->state, state->dataQueue);\n    else \n#endif\n#ifdef ProvideFast1344\n    if (state->rate == 1344)\n        KeccakAbsorb1344bits(state->state, state->dataQueue);\n    else \n#endif\n        KeccakAbsorb(state->state, state->dataQueue, state->rate/64);\n    state->bitsInQueue = 0;\n}\n\nint Absorb(spongeState *state, const unsigned char *data, unsigned long long databitlen)\n{\n    unsigned long long i, j, wholeBlocks;\n    unsigned int partialBlock, partialByte;\n    const unsigned char *curData;\n\n    if ((state->bitsInQueue % 8) != 0)\n        return 1; // Only the last call may contain a partial byte\n    if (state->squeezing)\n        return 1; // Too late for additional input\n\n    i = 0;\n    while(i < databitlen) {\n        if ((state->bitsInQueue == 0) && (databitlen >= state->rate) && (i <= (databitlen-state->rate))) {\n            wholeBlocks = (databitlen-i)/state->rate;\n            curData = data+i/8;\n#ifdef ProvideFast576\n            if (state->rate == 576) {\n                for(j=0; j<wholeBlocks; j++, curData+=576/8) {\n                    #ifdef KeccakReference\n                    displayBytes(1, \"Block to be absorbed\", curData, state->rate/8);\n                    #endif\n                    KeccakAbsorb576bits(state->state, curData);\n                }\n            }\n            else\n#endif\n#ifdef ProvideFast832\n            if (state->rate == 832) {\n                for(j=0; j<wholeBlocks; j++, curData+=832/8) {\n                    #ifdef KeccakReference\n                    displayBytes(1, \"Block to be absorbed\", curData, state->rate/8);\n                    #endif\n                    KeccakAbsorb832bits(state->state, curData);\n                }\n            }\n            else\n#endif\n#ifdef ProvideFast1024\n            if (state->rate == 1024) {\n                for(j=0; j<wholeBlocks; j++, curData+=1024/8) {\n                    #ifdef KeccakReference\n                    displayBytes(1, \"Block to be absorbed\", curData, state->rate/8);\n                    #endif\n                    KeccakAbsorb1024bits(state->state, curData);\n                }\n            }\n            else\n#endif\n#ifdef ProvideFast1088\n            if (state->rate == 1088) {\n                for(j=0; j<wholeBlocks; j++, curData+=1088/8) {\n                    #ifdef KeccakReference\n                    displayBytes(1, \"Block to be absorbed\", curData, state->rate/8);\n                    #endif\n                    KeccakAbsorb1088bits(state->state, curData);\n                }\n            }\n            else\n#endif\n#ifdef ProvideFast1152\n            if (state->rate == 1152) {\n                for(j=0; j<wholeBlocks; j++, curData+=1152/8) {\n                    #ifdef KeccakReference\n                    displayBytes(1, \"Block to be absorbed\", curData, state->rate/8);\n                    #endif\n                    KeccakAbsorb1152bits(state->state, curData);\n                }\n            }\n            else\n#endif\n#ifdef ProvideFast1344\n            if (state->rate == 1344) {\n                for(j=0; j<wholeBlocks; j++, curData+=1344/8) {\n                    #ifdef KeccakReference\n                    displayBytes(1, \"Block to be absorbed\", curData, state->rate/8);\n                    #endif\n                    KeccakAbsorb1344bits(state->state, curData);\n                }\n            }\n            else\n#endif\n            {\n                for(j=0; j<wholeBlocks; j++, curData+=state->rate/8) {\n                    #ifdef KeccakReference\n                    displayBytes(1, \"Block to be absorbed\", curData, state->rate/8);\n                    #endif\n                    KeccakAbsorb(state->state, curData, state->rate/64);\n                }\n            }\n            i += wholeBlocks*state->rate;\n        }\n        else {\n            partialBlock = (unsigned int)(databitlen - i);\n            if (partialBlock+state->bitsInQueue > state->rate)\n                partialBlock = state->rate-state->bitsInQueue;\n            partialByte = partialBlock % 8;\n            partialBlock -= partialByte;\n            memcpy(state->dataQueue+state->bitsInQueue/8, data+i/8, partialBlock/8);\n            state->bitsInQueue += partialBlock;\n            i += partialBlock;\n            if (state->bitsInQueue == state->rate)\n                AbsorbQueue(state);\n            if (partialByte > 0) {\n                unsigned char mask = (1 << partialByte)-1;\n                state->dataQueue[state->bitsInQueue/8] = data[i/8] & mask;\n                state->bitsInQueue += partialByte;\n                i += partialByte;\n            }\n        }\n    }\n    return 0;\n}\n\nvoid PadAndSwitchToSqueezingPhase(spongeState *state)\n{\n    // Note: the bits are numbered from 0=LSB to 7=MSB\n    if (state->bitsInQueue + 1 == state->rate) {\n        state->dataQueue[state->bitsInQueue/8 ] |= 1 << (state->bitsInQueue % 8);\n        AbsorbQueue(state);\n        memset(state->dataQueue, 0, state->rate/8);\n    }\n    else {\n        memset(state->dataQueue + (state->bitsInQueue+7)/8, 0, state->rate/8 - (state->bitsInQueue+7)/8);\n        state->dataQueue[state->bitsInQueue/8 ] |= 1 << (state->bitsInQueue % 8);\n    }\n    state->dataQueue[(state->rate-1)/8] |= 1 << ((state->rate-1) % 8);\n    AbsorbQueue(state);\n\n    #ifdef KeccakReference\n    displayText(1, \"--- Switching to squeezing phase ---\");\n    #endif\n#ifdef ProvideFast1024\n    if (state->rate == 1024) {\n        KeccakExtract1024bits(state->state, state->dataQueue);\n        state->bitsAvailableForSqueezing = 1024;\n    }\n    else\n#endif\n    {\n        KeccakExtract(state->state, state->dataQueue, state->rate/64);\n        state->bitsAvailableForSqueezing = state->rate;\n    }\n    #ifdef KeccakReference\n    displayBytes(1, \"Block available for squeezing\", state->dataQueue, state->bitsAvailableForSqueezing/8);\n    #endif\n    state->squeezing = 1;\n}\n\nint Squeeze(spongeState *state, unsigned char *output, unsigned long long outputLength)\n{\n    unsigned long long i;\n    unsigned int partialBlock;\n\n    if (!state->squeezing)\n        PadAndSwitchToSqueezingPhase(state);\n    if ((outputLength % 8) != 0)\n        return 1; // Only multiple of 8 bits are allowed, truncation can be done at user level\n\n    i = 0;\n    while(i < outputLength) {\n        if (state->bitsAvailableForSqueezing == 0) {\n            KeccakPermutation(state->state);\n#ifdef ProvideFast1024\n            if (state->rate == 1024) {\n                KeccakExtract1024bits(state->state, state->dataQueue);\n                state->bitsAvailableForSqueezing = 1024;\n            }\n            else\n#endif\n            {\n                KeccakExtract(state->state, state->dataQueue, state->rate/64);\n                state->bitsAvailableForSqueezing = state->rate;\n            }\n            #ifdef KeccakReference\n            displayBytes(1, \"Block available for squeezing\", state->dataQueue, state->bitsAvailableForSqueezing/8);\n            #endif\n        }\n        partialBlock = state->bitsAvailableForSqueezing;\n        if ((unsigned long long)partialBlock > outputLength - i)\n            partialBlock = (unsigned int)(outputLength - i);\n        memcpy(output+i/8, state->dataQueue+(state->rate-state->bitsAvailableForSqueezing)/8, partialBlock/8);\n        state->bitsAvailableForSqueezing -= partialBlock;\n        i += partialBlock;\n    }\n    return 0;\n}\n"
        },
        {
            "file_name": "kiasuneq128v1_kiasu.cpp",
            "content": "/*\n * Kiasu=/=-128 Reference C Implementation\n * \n * Copyright 2014:\n *     Jeremy Jean <JJean@ntu.edu.sg>\n *     Ivica Nikolic <INikolic@ntu.edu.sg>\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n * \n */\n\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include \"kiasuneq128v1_kiasu.h\"\n#include \"kiasuneq128v1_tweakable_aes.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Kiasuneq128v1_raw {\n\n/* Define the three MSB of the tweak (that depend on the stage) */\n#define MSB_AD \t\t\t      (0x2<<5)\n#define MSB_AD_LAST\t\t      (0x6<<5)\n#define MSB_M\t\t\t      (0x0<<5)\n#define MSB_M_LAST_ZERO\t\t  (0x1<<5)\n#define MSB_M_LAST_NONZERO\t  (0x4<<5)\n#define MSB_PAD\t\t\t      (0x4<<5)\n#define MSB_CHKSUM\t\t      (0x5<<5)\n\n/**********************************************************************************\n*** In Kiasu=/=-128, the tweak is on 64 bits:\n***     tweak = <stage> || <nonce> || <blockNumber>\n***  where we use:\n***      3 bits for stage\n***     32 bits for nonce\n***     29 bits for blockNumber\n***********************************************************************************/\n\n/*\n** Modifiy the nonce part in the tweak value\n*/\nstatic void set_nonce_in_tweak(uint8_t *tweak, const uint8_t *nonce) {\n    tweak[0]= (tweak[0]&0xe0)  ^ (nonce[0] >> 3);\n    tweak[1]=(nonce[0]&7) << 5 ^ (nonce[1] >> 3);\n    tweak[2]=(nonce[1]&7) << 5 ^ (nonce[2] >> 3);\n    tweak[3]=(nonce[2]&7) << 5 ^ (nonce[3] >> 3);\n    tweak[4]=(nonce[3]&7) << 5;\n}\n\n/*\n** Modifiy the block number in the tweak value\n*/\nstatic void set_block_number_in_tweak(uint8_t *tweak, const uint32_t block_no) {\n    tweak[4]=((block_no >> 24) & 0x1f) ^ (tweak[4] & 0xe0);\n    tweak[5]=((block_no >> 16) & 0xff);\n    tweak[6]=((block_no >>  8) & 0xff);\n    tweak[7]=((block_no >>  0) & 0xff);\n}\n\n/*\n** Modifiy the stage value in the tweak value\n*/\nstatic void set_stage_in_tweak(uint8_t *tweak, const uint8_t value) {\n    tweak[0]=(tweak[0] & 0x1f) ^ value ;\n}\n\n/*\n** XOR an input block to another input block\n*/\nstatic void xor_values(uint8_t *v1, const uint8_t *v2) {\n    int i;\n    for (i=0; i<16; i++) v1[i] ^= v2[i];\n}\n\n/*\n** Kiasu encryption function\n*/\nvoid kiasu_aead_encrypt(const uint8_t *ass_data, size_t ass_data_len,\n                        const uint8_t *message, size_t m_len,\n                        const uint8_t *key,\n                        const uint8_t *nonce,\n                        uint8_t *ciphertext, size_t *c_len)\n{\n\n    uint32_t i;\n    uint32_t j;\n    uint8_t tweak[8];\n    uint8_t Auth[16];\n    uint8_t last_block[16];\n    uint8_t Checksum[16];\n    uint8_t Final[16];\n    uint8_t zero_block[16];\n    uint8_t Pad[16];\n    uint8_t temp[16];\n\n    /* Fill the tweak from nonce */\n    memset(tweak, 0, sizeof(tweak));\n    set_nonce_in_tweak(tweak, nonce);\n\n    /* Associated data */\n    memset(Auth, 0, 16);\n    set_stage_in_tweak(tweak, MSB_AD);\n\n    /* For each full input blocks */\n    i=1;\n    while (16*i <= ass_data_len) {\n\n        /* Encrypt the current block */\n        set_block_number_in_tweak(tweak, i);\n        aesTweakEncrypt(ass_data+16*(i-1), key, tweak, temp);\n\n        /* Update Auth value */\n        xor_values(Auth, temp);\n\n        /* Go on with the next block */\n        i++;\n    }\n    i--;\n\n    /* Last block if incomplete */\n    if ( (ass_data_len==0) || (ass_data_len > 16*i) ) {\n\n        /* Prepare the last padded block */\n        memset(last_block, 0, 16);\n        memcpy(last_block, ass_data+16*i, ass_data_len-16*i);\n        last_block[ass_data_len-16*i]=0x80;\n\n        /* Encrypt the last block */\n        set_stage_in_tweak(tweak, MSB_AD_LAST);\n        set_block_number_in_tweak(tweak, i);\n\n        aesTweakEncrypt(last_block, key, tweak, temp);\n\n        /* Update the Auth value */\n        xor_values(Auth, temp);\n    }\n\n    /* Message */\n    memset(Checksum, 0, 16);\n    set_stage_in_tweak(tweak, MSB_M);\n    i=1;\n    while (16*i <= m_len) {\n        xor_values(Checksum, message+16*(i-1));\n        set_block_number_in_tweak(tweak, i);\n        aesTweakEncrypt(message+16*(i-1), key, tweak, ciphertext+16*(i-1));\n        i++;\n    }\n    i--;\n\n    /* Process last block */\n    /* If the block is full, i.e. M_last=epsilon */\n    if (m_len == 16*i) {\n        set_stage_in_tweak(tweak, MSB_M_LAST_ZERO);\n        set_block_number_in_tweak(tweak, i);\n        aesTweakEncrypt(Checksum, key, tweak, Final);\n\n    } else { /* If the block is partial and requires padding */\n        memset(last_block, 0, 16);\n        memcpy(last_block, message +16*i, m_len-16*i);\n        last_block[m_len-16*i]=0x80;\n        xor_values(Checksum, last_block);\n\n        set_stage_in_tweak(tweak, MSB_M_LAST_NONZERO);\n        set_block_number_in_tweak(tweak, i);\n        memset(zero_block, 0, 16);\n        aesTweakEncrypt(zero_block, key, tweak, Pad);\n\n        for (j=0; j<m_len-16*i; j++) {\n            ciphertext[16*i+j]=last_block[j] ^ Pad[j];\n        }\n        set_stage_in_tweak(tweak, MSB_CHKSUM);\n        aesTweakEncrypt(Checksum, key, tweak, Final);\n    }\n\n    /* Append the authentication tag to the ciphertext */\n    for (i=0; i<16; i++) {\n        ciphertext[m_len+i]=Final[i] ^ Auth[i];\n    }\n\n    /* The authentication tag is one block long, i.e. 16 bytes */\n    *c_len=m_len+16;\n\n}\n\n/*\n** Kiasu decryption function\n*/\nint kiasu_aead_decrypt(const uint8_t *ass_data, size_t ass_data_len,\n                       uint8_t *message, size_t *m_len,\n                       const uint8_t *key,\n                       const uint8_t *nonce,\n                       const uint8_t *ciphertext, size_t c_len)\n{\n\n    uint32_t i;\n    uint32_t j;\n    uint8_t tweak[8];\n    uint8_t Auth[16];\n    uint8_t last_block[16];\n    uint8_t Checksum[16];\n    uint8_t Final[16];\n    uint8_t zero_block[16];\n    uint8_t Pad[16];\n    uint8_t Tag[16];\n    uint8_t temp[16];\n\n    /* Get the tag from the last 16 bytes of the ciphertext */\n    memcpy(Tag, ciphertext+c_len-16, 16);\n\n    /* Update c_len to the actual size of the ciphertext (i.e., without the tag) */\n    c_len-=16;\n\n    /* Fill the tweak from nonce */\n    set_nonce_in_tweak(tweak, nonce);\n\n    /* Associated data */\n    memset(Auth, 0, 16);\n    set_stage_in_tweak(tweak, MSB_AD);\n    i=1;\n    while (16*i <= ass_data_len) {\n        set_block_number_in_tweak(tweak, i);\n        aesTweakEncrypt(ass_data+16*(i-1), key, tweak, temp);\n        xor_values(Auth, temp);\n        i++;\n    }\n    i--;\n\n    /* Last block if incomplete */\n    if ((ass_data_len==0) || (ass_data_len > 16*i) ) {\n        memset(last_block, 0, 16);\n        memcpy(last_block, ass_data+16*i, ass_data_len-16*i);\n        last_block[ass_data_len-16*i]=0x80;\n        set_stage_in_tweak(tweak, MSB_AD_LAST);\n        set_block_number_in_tweak(tweak, i);\n        aesTweakEncrypt(last_block, key, tweak, temp);\n        xor_values(Auth, temp);\n    }\n\n    /* Ciphertext */\n    memset(Checksum, 0, 16);\n    set_stage_in_tweak(tweak, MSB_M);\n    i=1;\n    while(16*i<=c_len) {\n        set_block_number_in_tweak(tweak, i);\n        aesTweakDecrypt(ciphertext+16*(i-1), key, tweak, message+16*(i-1));\n        xor_values(Checksum, message+16*(i-1));\n        i++;\n    }\n    i--;\n\n    /* Last block */\n    /* If the block is full, i.e. M_last=epsilon */\n    if (c_len == 16*i) {\n        set_stage_in_tweak(tweak, MSB_M_LAST_ZERO);\n        set_block_number_in_tweak(tweak, i);\n        aesTweakEncrypt(Checksum, key, tweak, Final);\n        xor_values(Final, Auth);\n\n        /* If the tags does not match, return error -1 */\n        if( 0 != memcmp(Final, Tag, sizeof(Tag)) ) {\n            return -1;\n        }\n\n    } else { /* If the block is partial and has been padded */\n\n        /* Prepare the full-zero block */\n        memset(zero_block, 0, 16);\n\n        /* Prepare the tweak */\n        set_stage_in_tweak(tweak, MSB_M_LAST_NONZERO);\n        set_block_number_in_tweak(tweak, i);\n\n        /* Encrypt */\n        aesTweakEncrypt(zero_block, key, tweak, Pad);\n\n        /* XOR the partial ciphertext */\n        memset(last_block, 0, 16);\n        memcpy(last_block, ciphertext+16*i, c_len-16*i);\n        memset(Pad+c_len-16*i, 0, 16-(c_len-16*i));\n        xor_values(last_block, Pad);\n        last_block[c_len-16*i]=0x80;\n\n        for (j=0; j<c_len-16*i; j++) {\n            message[16*i+j]=last_block[j];\n        }\n\n        /* Update checksum */\n        xor_values(Checksum, last_block);\n\n        /* Verify the tag */\n        set_stage_in_tweak(tweak, MSB_CHKSUM);\n        aesTweakEncrypt(Checksum, key, tweak, Final);\n        xor_values(Final, Auth);\n\n        /* If the tags does not match, return error -1 */\n        if( 0 != memcmp(Final, Tag, sizeof(Tag)) ) {\n            return -1;\n        }\n    }\n\n    *m_len=c_len;\n    return 0;\n}\n\n} // namespace Kiasuneq128v1_raw\n"
        },
        {
            "file_name": "kiasuneq128v1_tweakable_aes.cpp",
            "content": "/*\n * Kiasu=/=-128 Reference C Implementation\n * \n * Copyright 2014:\n *     Jeremy Jean <JJean@ntu.edu.sg>\n *     Ivica Nikolic <INikolic@ntu.edu.sg>\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n * \n */\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n// CHANGE namespace moved due to includes\nnamespace Kiasuneq128v1_raw {\n\nstatic const uint32_t Te0[256] = {\n    0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,\n    0xfff2f20dU, 0xd66b6bbdU, 0xde6f6fb1U, 0x91c5c554U,\n    0x60303050U, 0x02010103U, 0xce6767a9U, 0x562b2b7dU,\n    0xe7fefe19U, 0xb5d7d762U, 0x4dababe6U, 0xec76769aU,\n    0x8fcaca45U, 0x1f82829dU, 0x89c9c940U, 0xfa7d7d87U,\n    0xeffafa15U, 0xb25959ebU, 0x8e4747c9U, 0xfbf0f00bU,\n    0x41adadecU, 0xb3d4d467U, 0x5fa2a2fdU, 0x45afafeaU,\n    0x239c9cbfU, 0x53a4a4f7U, 0xe4727296U, 0x9bc0c05bU,\n    0x75b7b7c2U, 0xe1fdfd1cU, 0x3d9393aeU, 0x4c26266aU,\n    0x6c36365aU, 0x7e3f3f41U, 0xf5f7f702U, 0x83cccc4fU,\n    0x6834345cU, 0x51a5a5f4U, 0xd1e5e534U, 0xf9f1f108U,\n    0xe2717193U, 0xabd8d873U, 0x62313153U, 0x2a15153fU,\n    0x0804040cU, 0x95c7c752U, 0x46232365U, 0x9dc3c35eU,\n    0x30181828U, 0x379696a1U, 0x0a05050fU, 0x2f9a9ab5U,\n    0x0e070709U, 0x24121236U, 0x1b80809bU, 0xdfe2e23dU,\n    0xcdebeb26U, 0x4e272769U, 0x7fb2b2cdU, 0xea75759fU,\n    0x1209091bU, 0x1d83839eU, 0x582c2c74U, 0x341a1a2eU,\n    0x361b1b2dU, 0xdc6e6eb2U, 0xb45a5aeeU, 0x5ba0a0fbU,\n    0xa45252f6U, 0x763b3b4dU, 0xb7d6d661U, 0x7db3b3ceU,\n    0x5229297bU, 0xdde3e33eU, 0x5e2f2f71U, 0x13848497U,\n    0xa65353f5U, 0xb9d1d168U, 0x00000000U, 0xc1eded2cU,\n    0x40202060U, 0xe3fcfc1fU, 0x79b1b1c8U, 0xb65b5bedU,\n    0xd46a6abeU, 0x8dcbcb46U, 0x67bebed9U, 0x7239394bU,\n    0x944a4adeU, 0x984c4cd4U, 0xb05858e8U, 0x85cfcf4aU,\n    0xbbd0d06bU, 0xc5efef2aU, 0x4faaaae5U, 0xedfbfb16U,\n    0x864343c5U, 0x9a4d4dd7U, 0x66333355U, 0x11858594U,\n    0x8a4545cfU, 0xe9f9f910U, 0x04020206U, 0xfe7f7f81U,\n    0xa05050f0U, 0x783c3c44U, 0x259f9fbaU, 0x4ba8a8e3U,\n    0xa25151f3U, 0x5da3a3feU, 0x804040c0U, 0x058f8f8aU,\n    0x3f9292adU, 0x219d9dbcU, 0x70383848U, 0xf1f5f504U,\n    0x63bcbcdfU, 0x77b6b6c1U, 0xafdada75U, 0x42212163U,\n    0x20101030U, 0xe5ffff1aU, 0xfdf3f30eU, 0xbfd2d26dU,\n    0x81cdcd4cU, 0x180c0c14U, 0x26131335U, 0xc3ecec2fU,\n    0xbe5f5fe1U, 0x359797a2U, 0x884444ccU, 0x2e171739U,\n    0x93c4c457U, 0x55a7a7f2U, 0xfc7e7e82U, 0x7a3d3d47U,\n    0xc86464acU, 0xba5d5de7U, 0x3219192bU, 0xe6737395U,\n    0xc06060a0U, 0x19818198U, 0x9e4f4fd1U, 0xa3dcdc7fU,\n    0x44222266U, 0x542a2a7eU, 0x3b9090abU, 0x0b888883U,\n    0x8c4646caU, 0xc7eeee29U, 0x6bb8b8d3U, 0x2814143cU,\n    0xa7dede79U, 0xbc5e5ee2U, 0x160b0b1dU, 0xaddbdb76U,\n    0xdbe0e03bU, 0x64323256U, 0x743a3a4eU, 0x140a0a1eU,\n    0x924949dbU, 0x0c06060aU, 0x4824246cU, 0xb85c5ce4U,\n    0x9fc2c25dU, 0xbdd3d36eU, 0x43acacefU, 0xc46262a6U,\n    0x399191a8U, 0x319595a4U, 0xd3e4e437U, 0xf279798bU,\n    0xd5e7e732U, 0x8bc8c843U, 0x6e373759U, 0xda6d6db7U,\n    0x018d8d8cU, 0xb1d5d564U, 0x9c4e4ed2U, 0x49a9a9e0U,\n    0xd86c6cb4U, 0xac5656faU, 0xf3f4f407U, 0xcfeaea25U,\n    0xca6565afU, 0xf47a7a8eU, 0x47aeaee9U, 0x10080818U,\n    0x6fbabad5U, 0xf0787888U, 0x4a25256fU, 0x5c2e2e72U,\n    0x381c1c24U, 0x57a6a6f1U, 0x73b4b4c7U, 0x97c6c651U,\n    0xcbe8e823U, 0xa1dddd7cU, 0xe874749cU, 0x3e1f1f21U,\n    0x964b4bddU, 0x61bdbddcU, 0x0d8b8b86U, 0x0f8a8a85U,\n    0xe0707090U, 0x7c3e3e42U, 0x71b5b5c4U, 0xcc6666aaU,\n    0x904848d8U, 0x06030305U, 0xf7f6f601U, 0x1c0e0e12U,\n    0xc26161a3U, 0x6a35355fU, 0xae5757f9U, 0x69b9b9d0U,\n    0x17868691U, 0x99c1c158U, 0x3a1d1d27U, 0x279e9eb9U,\n    0xd9e1e138U, 0xebf8f813U, 0x2b9898b3U, 0x22111133U,\n    0xd26969bbU, 0xa9d9d970U, 0x078e8e89U, 0x339494a7U,\n    0x2d9b9bb6U, 0x3c1e1e22U, 0x15878792U, 0xc9e9e920U,\n    0x87cece49U, 0xaa5555ffU, 0x50282878U, 0xa5dfdf7aU,\n    0x038c8c8fU, 0x59a1a1f8U, 0x09898980U, 0x1a0d0d17U,\n    0x65bfbfdaU, 0xd7e6e631U, 0x844242c6U, 0xd06868b8U,\n    0x824141c3U, 0x299999b0U, 0x5a2d2d77U, 0x1e0f0f11U,\n    0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,\n};\nstatic const uint32_t Te1[256] = {\n    0xa5c66363U, 0x84f87c7cU, 0x99ee7777U, 0x8df67b7bU,\n    0x0dfff2f2U, 0xbdd66b6bU, 0xb1de6f6fU, 0x5491c5c5U,\n    0x50603030U, 0x03020101U, 0xa9ce6767U, 0x7d562b2bU,\n    0x19e7fefeU, 0x62b5d7d7U, 0xe64dababU, 0x9aec7676U,\n    0x458fcacaU, 0x9d1f8282U, 0x4089c9c9U, 0x87fa7d7dU,\n    0x15effafaU, 0xebb25959U, 0xc98e4747U, 0x0bfbf0f0U,\n    0xec41adadU, 0x67b3d4d4U, 0xfd5fa2a2U, 0xea45afafU,\n    0xbf239c9cU, 0xf753a4a4U, 0x96e47272U, 0x5b9bc0c0U,\n    0xc275b7b7U, 0x1ce1fdfdU, 0xae3d9393U, 0x6a4c2626U,\n    0x5a6c3636U, 0x417e3f3fU, 0x02f5f7f7U, 0x4f83ccccU,\n    0x5c683434U, 0xf451a5a5U, 0x34d1e5e5U, 0x08f9f1f1U,\n    0x93e27171U, 0x73abd8d8U, 0x53623131U, 0x3f2a1515U,\n    0x0c080404U, 0x5295c7c7U, 0x65462323U, 0x5e9dc3c3U,\n    0x28301818U, 0xa1379696U, 0x0f0a0505U, 0xb52f9a9aU,\n    0x090e0707U, 0x36241212U, 0x9b1b8080U, 0x3ddfe2e2U,\n    0x26cdebebU, 0x694e2727U, 0xcd7fb2b2U, 0x9fea7575U,\n    0x1b120909U, 0x9e1d8383U, 0x74582c2cU, 0x2e341a1aU,\n    0x2d361b1bU, 0xb2dc6e6eU, 0xeeb45a5aU, 0xfb5ba0a0U,\n    0xf6a45252U, 0x4d763b3bU, 0x61b7d6d6U, 0xce7db3b3U,\n    0x7b522929U, 0x3edde3e3U, 0x715e2f2fU, 0x97138484U,\n    0xf5a65353U, 0x68b9d1d1U, 0x00000000U, 0x2cc1ededU,\n    0x60402020U, 0x1fe3fcfcU, 0xc879b1b1U, 0xedb65b5bU,\n    0xbed46a6aU, 0x468dcbcbU, 0xd967bebeU, 0x4b723939U,\n    0xde944a4aU, 0xd4984c4cU, 0xe8b05858U, 0x4a85cfcfU,\n    0x6bbbd0d0U, 0x2ac5efefU, 0xe54faaaaU, 0x16edfbfbU,\n    0xc5864343U, 0xd79a4d4dU, 0x55663333U, 0x94118585U,\n    0xcf8a4545U, 0x10e9f9f9U, 0x06040202U, 0x81fe7f7fU,\n    0xf0a05050U, 0x44783c3cU, 0xba259f9fU, 0xe34ba8a8U,\n    0xf3a25151U, 0xfe5da3a3U, 0xc0804040U, 0x8a058f8fU,\n    0xad3f9292U, 0xbc219d9dU, 0x48703838U, 0x04f1f5f5U,\n    0xdf63bcbcU, 0xc177b6b6U, 0x75afdadaU, 0x63422121U,\n    0x30201010U, 0x1ae5ffffU, 0x0efdf3f3U, 0x6dbfd2d2U,\n    0x4c81cdcdU, 0x14180c0cU, 0x35261313U, 0x2fc3ececU,\n    0xe1be5f5fU, 0xa2359797U, 0xcc884444U, 0x392e1717U,\n    0x5793c4c4U, 0xf255a7a7U, 0x82fc7e7eU, 0x477a3d3dU,\n    0xacc86464U, 0xe7ba5d5dU, 0x2b321919U, 0x95e67373U,\n    0xa0c06060U, 0x98198181U, 0xd19e4f4fU, 0x7fa3dcdcU,\n    0x66442222U, 0x7e542a2aU, 0xab3b9090U, 0x830b8888U,\n    0xca8c4646U, 0x29c7eeeeU, 0xd36bb8b8U, 0x3c281414U,\n    0x79a7dedeU, 0xe2bc5e5eU, 0x1d160b0bU, 0x76addbdbU,\n    0x3bdbe0e0U, 0x56643232U, 0x4e743a3aU, 0x1e140a0aU,\n    0xdb924949U, 0x0a0c0606U, 0x6c482424U, 0xe4b85c5cU,\n    0x5d9fc2c2U, 0x6ebdd3d3U, 0xef43acacU, 0xa6c46262U,\n    0xa8399191U, 0xa4319595U, 0x37d3e4e4U, 0x8bf27979U,\n    0x32d5e7e7U, 0x438bc8c8U, 0x596e3737U, 0xb7da6d6dU,\n    0x8c018d8dU, 0x64b1d5d5U, 0xd29c4e4eU, 0xe049a9a9U,\n    0xb4d86c6cU, 0xfaac5656U, 0x07f3f4f4U, 0x25cfeaeaU,\n    0xafca6565U, 0x8ef47a7aU, 0xe947aeaeU, 0x18100808U,\n    0xd56fbabaU, 0x88f07878U, 0x6f4a2525U, 0x725c2e2eU,\n    0x24381c1cU, 0xf157a6a6U, 0xc773b4b4U, 0x5197c6c6U,\n    0x23cbe8e8U, 0x7ca1ddddU, 0x9ce87474U, 0x213e1f1fU,\n    0xdd964b4bU, 0xdc61bdbdU, 0x860d8b8bU, 0x850f8a8aU,\n    0x90e07070U, 0x427c3e3eU, 0xc471b5b5U, 0xaacc6666U,\n    0xd8904848U, 0x05060303U, 0x01f7f6f6U, 0x121c0e0eU,\n    0xa3c26161U, 0x5f6a3535U, 0xf9ae5757U, 0xd069b9b9U,\n    0x91178686U, 0x5899c1c1U, 0x273a1d1dU, 0xb9279e9eU,\n    0x38d9e1e1U, 0x13ebf8f8U, 0xb32b9898U, 0x33221111U,\n    0xbbd26969U, 0x70a9d9d9U, 0x89078e8eU, 0xa7339494U,\n    0xb62d9b9bU, 0x223c1e1eU, 0x92158787U, 0x20c9e9e9U,\n    0x4987ceceU, 0xffaa5555U, 0x78502828U, 0x7aa5dfdfU,\n    0x8f038c8cU, 0xf859a1a1U, 0x80098989U, 0x171a0d0dU,\n    0xda65bfbfU, 0x31d7e6e6U, 0xc6844242U, 0xb8d06868U,\n    0xc3824141U, 0xb0299999U, 0x775a2d2dU, 0x111e0f0fU,\n    0xcb7bb0b0U, 0xfca85454U, 0xd66dbbbbU, 0x3a2c1616U,\n};\nstatic const uint32_t Te2[256] = {\n    0x63a5c663U, 0x7c84f87cU, 0x7799ee77U, 0x7b8df67bU,\n    0xf20dfff2U, 0x6bbdd66bU, 0x6fb1de6fU, 0xc55491c5U,\n    0x30506030U, 0x01030201U, 0x67a9ce67U, 0x2b7d562bU,\n    0xfe19e7feU, 0xd762b5d7U, 0xabe64dabU, 0x769aec76U,\n    0xca458fcaU, 0x829d1f82U, 0xc94089c9U, 0x7d87fa7dU,\n    0xfa15effaU, 0x59ebb259U, 0x47c98e47U, 0xf00bfbf0U,\n    0xadec41adU, 0xd467b3d4U, 0xa2fd5fa2U, 0xafea45afU,\n    0x9cbf239cU, 0xa4f753a4U, 0x7296e472U, 0xc05b9bc0U,\n    0xb7c275b7U, 0xfd1ce1fdU, 0x93ae3d93U, 0x266a4c26U,\n    0x365a6c36U, 0x3f417e3fU, 0xf702f5f7U, 0xcc4f83ccU,\n    0x345c6834U, 0xa5f451a5U, 0xe534d1e5U, 0xf108f9f1U,\n    0x7193e271U, 0xd873abd8U, 0x31536231U, 0x153f2a15U,\n    0x040c0804U, 0xc75295c7U, 0x23654623U, 0xc35e9dc3U,\n    0x18283018U, 0x96a13796U, 0x050f0a05U, 0x9ab52f9aU,\n    0x07090e07U, 0x12362412U, 0x809b1b80U, 0xe23ddfe2U,\n    0xeb26cdebU, 0x27694e27U, 0xb2cd7fb2U, 0x759fea75U,\n    0x091b1209U, 0x839e1d83U, 0x2c74582cU, 0x1a2e341aU,\n    0x1b2d361bU, 0x6eb2dc6eU, 0x5aeeb45aU, 0xa0fb5ba0U,\n    0x52f6a452U, 0x3b4d763bU, 0xd661b7d6U, 0xb3ce7db3U,\n    0x297b5229U, 0xe33edde3U, 0x2f715e2fU, 0x84971384U,\n    0x53f5a653U, 0xd168b9d1U, 0x00000000U, 0xed2cc1edU,\n    0x20604020U, 0xfc1fe3fcU, 0xb1c879b1U, 0x5bedb65bU,\n    0x6abed46aU, 0xcb468dcbU, 0xbed967beU, 0x394b7239U,\n    0x4ade944aU, 0x4cd4984cU, 0x58e8b058U, 0xcf4a85cfU,\n    0xd06bbbd0U, 0xef2ac5efU, 0xaae54faaU, 0xfb16edfbU,\n    0x43c58643U, 0x4dd79a4dU, 0x33556633U, 0x85941185U,\n    0x45cf8a45U, 0xf910e9f9U, 0x02060402U, 0x7f81fe7fU,\n    0x50f0a050U, 0x3c44783cU, 0x9fba259fU, 0xa8e34ba8U,\n    0x51f3a251U, 0xa3fe5da3U, 0x40c08040U, 0x8f8a058fU,\n    0x92ad3f92U, 0x9dbc219dU, 0x38487038U, 0xf504f1f5U,\n    0xbcdf63bcU, 0xb6c177b6U, 0xda75afdaU, 0x21634221U,\n    0x10302010U, 0xff1ae5ffU, 0xf30efdf3U, 0xd26dbfd2U,\n    0xcd4c81cdU, 0x0c14180cU, 0x13352613U, 0xec2fc3ecU,\n    0x5fe1be5fU, 0x97a23597U, 0x44cc8844U, 0x17392e17U,\n    0xc45793c4U, 0xa7f255a7U, 0x7e82fc7eU, 0x3d477a3dU,\n    0x64acc864U, 0x5de7ba5dU, 0x192b3219U, 0x7395e673U,\n    0x60a0c060U, 0x81981981U, 0x4fd19e4fU, 0xdc7fa3dcU,\n    0x22664422U, 0x2a7e542aU, 0x90ab3b90U, 0x88830b88U,\n    0x46ca8c46U, 0xee29c7eeU, 0xb8d36bb8U, 0x143c2814U,\n    0xde79a7deU, 0x5ee2bc5eU, 0x0b1d160bU, 0xdb76addbU,\n    0xe03bdbe0U, 0x32566432U, 0x3a4e743aU, 0x0a1e140aU,\n    0x49db9249U, 0x060a0c06U, 0x246c4824U, 0x5ce4b85cU,\n    0xc25d9fc2U, 0xd36ebdd3U, 0xacef43acU, 0x62a6c462U,\n    0x91a83991U, 0x95a43195U, 0xe437d3e4U, 0x798bf279U,\n    0xe732d5e7U, 0xc8438bc8U, 0x37596e37U, 0x6db7da6dU,\n    0x8d8c018dU, 0xd564b1d5U, 0x4ed29c4eU, 0xa9e049a9U,\n    0x6cb4d86cU, 0x56faac56U, 0xf407f3f4U, 0xea25cfeaU,\n    0x65afca65U, 0x7a8ef47aU, 0xaee947aeU, 0x08181008U,\n    0xbad56fbaU, 0x7888f078U, 0x256f4a25U, 0x2e725c2eU,\n    0x1c24381cU, 0xa6f157a6U, 0xb4c773b4U, 0xc65197c6U,\n    0xe823cbe8U, 0xdd7ca1ddU, 0x749ce874U, 0x1f213e1fU,\n    0x4bdd964bU, 0xbddc61bdU, 0x8b860d8bU, 0x8a850f8aU,\n    0x7090e070U, 0x3e427c3eU, 0xb5c471b5U, 0x66aacc66U,\n    0x48d89048U, 0x03050603U, 0xf601f7f6U, 0x0e121c0eU,\n    0x61a3c261U, 0x355f6a35U, 0x57f9ae57U, 0xb9d069b9U,\n    0x86911786U, 0xc15899c1U, 0x1d273a1dU, 0x9eb9279eU,\n    0xe138d9e1U, 0xf813ebf8U, 0x98b32b98U, 0x11332211U,\n    0x69bbd269U, 0xd970a9d9U, 0x8e89078eU, 0x94a73394U,\n    0x9bb62d9bU, 0x1e223c1eU, 0x87921587U, 0xe920c9e9U,\n    0xce4987ceU, 0x55ffaa55U, 0x28785028U, 0xdf7aa5dfU,\n    0x8c8f038cU, 0xa1f859a1U, 0x89800989U, 0x0d171a0dU,\n    0xbfda65bfU, 0xe631d7e6U, 0x42c68442U, 0x68b8d068U,\n    0x41c38241U, 0x99b02999U, 0x2d775a2dU, 0x0f111e0fU,\n    0xb0cb7bb0U, 0x54fca854U, 0xbbd66dbbU, 0x163a2c16U,\n};\nstatic const uint32_t Te3[256] = {\n\n    0x6363a5c6U, 0x7c7c84f8U, 0x777799eeU, 0x7b7b8df6U,\n    0xf2f20dffU, 0x6b6bbdd6U, 0x6f6fb1deU, 0xc5c55491U,\n    0x30305060U, 0x01010302U, 0x6767a9ceU, 0x2b2b7d56U,\n    0xfefe19e7U, 0xd7d762b5U, 0xababe64dU, 0x76769aecU,\n    0xcaca458fU, 0x82829d1fU, 0xc9c94089U, 0x7d7d87faU,\n    0xfafa15efU, 0x5959ebb2U, 0x4747c98eU, 0xf0f00bfbU,\n    0xadadec41U, 0xd4d467b3U, 0xa2a2fd5fU, 0xafafea45U,\n    0x9c9cbf23U, 0xa4a4f753U, 0x727296e4U, 0xc0c05b9bU,\n    0xb7b7c275U, 0xfdfd1ce1U, 0x9393ae3dU, 0x26266a4cU,\n    0x36365a6cU, 0x3f3f417eU, 0xf7f702f5U, 0xcccc4f83U,\n    0x34345c68U, 0xa5a5f451U, 0xe5e534d1U, 0xf1f108f9U,\n    0x717193e2U, 0xd8d873abU, 0x31315362U, 0x15153f2aU,\n    0x04040c08U, 0xc7c75295U, 0x23236546U, 0xc3c35e9dU,\n    0x18182830U, 0x9696a137U, 0x05050f0aU, 0x9a9ab52fU,\n    0x0707090eU, 0x12123624U, 0x80809b1bU, 0xe2e23ddfU,\n    0xebeb26cdU, 0x2727694eU, 0xb2b2cd7fU, 0x75759feaU,\n    0x09091b12U, 0x83839e1dU, 0x2c2c7458U, 0x1a1a2e34U,\n    0x1b1b2d36U, 0x6e6eb2dcU, 0x5a5aeeb4U, 0xa0a0fb5bU,\n    0x5252f6a4U, 0x3b3b4d76U, 0xd6d661b7U, 0xb3b3ce7dU,\n    0x29297b52U, 0xe3e33eddU, 0x2f2f715eU, 0x84849713U,\n    0x5353f5a6U, 0xd1d168b9U, 0x00000000U, 0xeded2cc1U,\n    0x20206040U, 0xfcfc1fe3U, 0xb1b1c879U, 0x5b5bedb6U,\n    0x6a6abed4U, 0xcbcb468dU, 0xbebed967U, 0x39394b72U,\n    0x4a4ade94U, 0x4c4cd498U, 0x5858e8b0U, 0xcfcf4a85U,\n    0xd0d06bbbU, 0xefef2ac5U, 0xaaaae54fU, 0xfbfb16edU,\n    0x4343c586U, 0x4d4dd79aU, 0x33335566U, 0x85859411U,\n    0x4545cf8aU, 0xf9f910e9U, 0x02020604U, 0x7f7f81feU,\n    0x5050f0a0U, 0x3c3c4478U, 0x9f9fba25U, 0xa8a8e34bU,\n    0x5151f3a2U, 0xa3a3fe5dU, 0x4040c080U, 0x8f8f8a05U,\n    0x9292ad3fU, 0x9d9dbc21U, 0x38384870U, 0xf5f504f1U,\n    0xbcbcdf63U, 0xb6b6c177U, 0xdada75afU, 0x21216342U,\n    0x10103020U, 0xffff1ae5U, 0xf3f30efdU, 0xd2d26dbfU,\n    0xcdcd4c81U, 0x0c0c1418U, 0x13133526U, 0xecec2fc3U,\n    0x5f5fe1beU, 0x9797a235U, 0x4444cc88U, 0x1717392eU,\n    0xc4c45793U, 0xa7a7f255U, 0x7e7e82fcU, 0x3d3d477aU,\n    0x6464acc8U, 0x5d5de7baU, 0x19192b32U, 0x737395e6U,\n    0x6060a0c0U, 0x81819819U, 0x4f4fd19eU, 0xdcdc7fa3U,\n    0x22226644U, 0x2a2a7e54U, 0x9090ab3bU, 0x8888830bU,\n    0x4646ca8cU, 0xeeee29c7U, 0xb8b8d36bU, 0x14143c28U,\n    0xdede79a7U, 0x5e5ee2bcU, 0x0b0b1d16U, 0xdbdb76adU,\n    0xe0e03bdbU, 0x32325664U, 0x3a3a4e74U, 0x0a0a1e14U,\n    0x4949db92U, 0x06060a0cU, 0x24246c48U, 0x5c5ce4b8U,\n    0xc2c25d9fU, 0xd3d36ebdU, 0xacacef43U, 0x6262a6c4U,\n    0x9191a839U, 0x9595a431U, 0xe4e437d3U, 0x79798bf2U,\n    0xe7e732d5U, 0xc8c8438bU, 0x3737596eU, 0x6d6db7daU,\n    0x8d8d8c01U, 0xd5d564b1U, 0x4e4ed29cU, 0xa9a9e049U,\n    0x6c6cb4d8U, 0x5656faacU, 0xf4f407f3U, 0xeaea25cfU,\n    0x6565afcaU, 0x7a7a8ef4U, 0xaeaee947U, 0x08081810U,\n    0xbabad56fU, 0x787888f0U, 0x25256f4aU, 0x2e2e725cU,\n    0x1c1c2438U, 0xa6a6f157U, 0xb4b4c773U, 0xc6c65197U,\n    0xe8e823cbU, 0xdddd7ca1U, 0x74749ce8U, 0x1f1f213eU,\n    0x4b4bdd96U, 0xbdbddc61U, 0x8b8b860dU, 0x8a8a850fU,\n    0x707090e0U, 0x3e3e427cU, 0xb5b5c471U, 0x6666aaccU,\n    0x4848d890U, 0x03030506U, 0xf6f601f7U, 0x0e0e121cU,\n    0x6161a3c2U, 0x35355f6aU, 0x5757f9aeU, 0xb9b9d069U,\n    0x86869117U, 0xc1c15899U, 0x1d1d273aU, 0x9e9eb927U,\n    0xe1e138d9U, 0xf8f813ebU, 0x9898b32bU, 0x11113322U,\n    0x6969bbd2U, 0xd9d970a9U, 0x8e8e8907U, 0x9494a733U,\n    0x9b9bb62dU, 0x1e1e223cU, 0x87879215U, 0xe9e920c9U,\n    0xcece4987U, 0x5555ffaaU, 0x28287850U, 0xdfdf7aa5U,\n    0x8c8c8f03U, 0xa1a1f859U, 0x89898009U, 0x0d0d171aU,\n    0xbfbfda65U, 0xe6e631d7U, 0x4242c684U, 0x6868b8d0U,\n    0x4141c382U, 0x9999b029U, 0x2d2d775aU, 0x0f0f111eU,\n    0xb0b0cb7bU, 0x5454fca8U, 0xbbbbd66dU, 0x16163a2cU,\n};\nstatic const uint32_t Te4[256] = {\n    0x63636363U, 0x7c7c7c7cU, 0x77777777U, 0x7b7b7b7bU,\n    0xf2f2f2f2U, 0x6b6b6b6bU, 0x6f6f6f6fU, 0xc5c5c5c5U,\n    0x30303030U, 0x01010101U, 0x67676767U, 0x2b2b2b2bU,\n    0xfefefefeU, 0xd7d7d7d7U, 0xababababU, 0x76767676U,\n    0xcacacacaU, 0x82828282U, 0xc9c9c9c9U, 0x7d7d7d7dU,\n    0xfafafafaU, 0x59595959U, 0x47474747U, 0xf0f0f0f0U,\n    0xadadadadU, 0xd4d4d4d4U, 0xa2a2a2a2U, 0xafafafafU,\n    0x9c9c9c9cU, 0xa4a4a4a4U, 0x72727272U, 0xc0c0c0c0U,\n    0xb7b7b7b7U, 0xfdfdfdfdU, 0x93939393U, 0x26262626U,\n    0x36363636U, 0x3f3f3f3fU, 0xf7f7f7f7U, 0xccccccccU,\n    0x34343434U, 0xa5a5a5a5U, 0xe5e5e5e5U, 0xf1f1f1f1U,\n    0x71717171U, 0xd8d8d8d8U, 0x31313131U, 0x15151515U,\n    0x04040404U, 0xc7c7c7c7U, 0x23232323U, 0xc3c3c3c3U,\n    0x18181818U, 0x96969696U, 0x05050505U, 0x9a9a9a9aU,\n    0x07070707U, 0x12121212U, 0x80808080U, 0xe2e2e2e2U,\n    0xebebebebU, 0x27272727U, 0xb2b2b2b2U, 0x75757575U,\n    0x09090909U, 0x83838383U, 0x2c2c2c2cU, 0x1a1a1a1aU,\n    0x1b1b1b1bU, 0x6e6e6e6eU, 0x5a5a5a5aU, 0xa0a0a0a0U,\n    0x52525252U, 0x3b3b3b3bU, 0xd6d6d6d6U, 0xb3b3b3b3U,\n    0x29292929U, 0xe3e3e3e3U, 0x2f2f2f2fU, 0x84848484U,\n    0x53535353U, 0xd1d1d1d1U, 0x00000000U, 0xededededU,\n    0x20202020U, 0xfcfcfcfcU, 0xb1b1b1b1U, 0x5b5b5b5bU,\n    0x6a6a6a6aU, 0xcbcbcbcbU, 0xbebebebeU, 0x39393939U,\n    0x4a4a4a4aU, 0x4c4c4c4cU, 0x58585858U, 0xcfcfcfcfU,\n    0xd0d0d0d0U, 0xefefefefU, 0xaaaaaaaaU, 0xfbfbfbfbU,\n    0x43434343U, 0x4d4d4d4dU, 0x33333333U, 0x85858585U,\n    0x45454545U, 0xf9f9f9f9U, 0x02020202U, 0x7f7f7f7fU,\n    0x50505050U, 0x3c3c3c3cU, 0x9f9f9f9fU, 0xa8a8a8a8U,\n    0x51515151U, 0xa3a3a3a3U, 0x40404040U, 0x8f8f8f8fU,\n    0x92929292U, 0x9d9d9d9dU, 0x38383838U, 0xf5f5f5f5U,\n    0xbcbcbcbcU, 0xb6b6b6b6U, 0xdadadadaU, 0x21212121U,\n    0x10101010U, 0xffffffffU, 0xf3f3f3f3U, 0xd2d2d2d2U,\n    0xcdcdcdcdU, 0x0c0c0c0cU, 0x13131313U, 0xececececU,\n    0x5f5f5f5fU, 0x97979797U, 0x44444444U, 0x17171717U,\n    0xc4c4c4c4U, 0xa7a7a7a7U, 0x7e7e7e7eU, 0x3d3d3d3dU,\n    0x64646464U, 0x5d5d5d5dU, 0x19191919U, 0x73737373U,\n    0x60606060U, 0x81818181U, 0x4f4f4f4fU, 0xdcdcdcdcU,\n    0x22222222U, 0x2a2a2a2aU, 0x90909090U, 0x88888888U,\n    0x46464646U, 0xeeeeeeeeU, 0xb8b8b8b8U, 0x14141414U,\n    0xdedededeU, 0x5e5e5e5eU, 0x0b0b0b0bU, 0xdbdbdbdbU,\n    0xe0e0e0e0U, 0x32323232U, 0x3a3a3a3aU, 0x0a0a0a0aU,\n    0x49494949U, 0x06060606U, 0x24242424U, 0x5c5c5c5cU,\n    0xc2c2c2c2U, 0xd3d3d3d3U, 0xacacacacU, 0x62626262U,\n    0x91919191U, 0x95959595U, 0xe4e4e4e4U, 0x79797979U,\n    0xe7e7e7e7U, 0xc8c8c8c8U, 0x37373737U, 0x6d6d6d6dU,\n    0x8d8d8d8dU, 0xd5d5d5d5U, 0x4e4e4e4eU, 0xa9a9a9a9U,\n    0x6c6c6c6cU, 0x56565656U, 0xf4f4f4f4U, 0xeaeaeaeaU,\n    0x65656565U, 0x7a7a7a7aU, 0xaeaeaeaeU, 0x08080808U,\n    0xbabababaU, 0x78787878U, 0x25252525U, 0x2e2e2e2eU,\n    0x1c1c1c1cU, 0xa6a6a6a6U, 0xb4b4b4b4U, 0xc6c6c6c6U,\n    0xe8e8e8e8U, 0xddddddddU, 0x74747474U, 0x1f1f1f1fU,\n    0x4b4b4b4bU, 0xbdbdbdbdU, 0x8b8b8b8bU, 0x8a8a8a8aU,\n    0x70707070U, 0x3e3e3e3eU, 0xb5b5b5b5U, 0x66666666U,\n    0x48484848U, 0x03030303U, 0xf6f6f6f6U, 0x0e0e0e0eU,\n    0x61616161U, 0x35353535U, 0x57575757U, 0xb9b9b9b9U,\n    0x86868686U, 0xc1c1c1c1U, 0x1d1d1d1dU, 0x9e9e9e9eU,\n    0xe1e1e1e1U, 0xf8f8f8f8U, 0x98989898U, 0x11111111U,\n    0x69696969U, 0xd9d9d9d9U, 0x8e8e8e8eU, 0x94949494U,\n    0x9b9b9b9bU, 0x1e1e1e1eU, 0x87878787U, 0xe9e9e9e9U,\n    0xcecececeU, 0x55555555U, 0x28282828U, 0xdfdfdfdfU,\n    0x8c8c8c8cU, 0xa1a1a1a1U, 0x89898989U, 0x0d0d0d0dU,\n    0xbfbfbfbfU, 0xe6e6e6e6U, 0x42424242U, 0x68686868U,\n    0x41414141U, 0x99999999U, 0x2d2d2d2dU, 0x0f0f0f0fU,\n    0xb0b0b0b0U, 0x54545454U, 0xbbbbbbbbU, 0x16161616U,\n};\nstatic const uint32_t Td0[256] = {\n    0x51f4a750U, 0x7e416553U, 0x1a17a4c3U, 0x3a275e96U,\n    0x3bab6bcbU, 0x1f9d45f1U, 0xacfa58abU, 0x4be30393U,\n    0x2030fa55U, 0xad766df6U, 0x88cc7691U, 0xf5024c25U,\n    0x4fe5d7fcU, 0xc52acbd7U, 0x26354480U, 0xb562a38fU,\n    0xdeb15a49U, 0x25ba1b67U, 0x45ea0e98U, 0x5dfec0e1U,\n    0xc32f7502U, 0x814cf012U, 0x8d4697a3U, 0x6bd3f9c6U,\n    0x038f5fe7U, 0x15929c95U, 0xbf6d7aebU, 0x955259daU,\n    0xd4be832dU, 0x587421d3U, 0x49e06929U, 0x8ec9c844U,\n    0x75c2896aU, 0xf48e7978U, 0x99583e6bU, 0x27b971ddU,\n    0xbee14fb6U, 0xf088ad17U, 0xc920ac66U, 0x7dce3ab4U,\n    0x63df4a18U, 0xe51a3182U, 0x97513360U, 0x62537f45U,\n    0xb16477e0U, 0xbb6bae84U, 0xfe81a01cU, 0xf9082b94U,\n    0x70486858U, 0x8f45fd19U, 0x94de6c87U, 0x527bf8b7U,\n    0xab73d323U, 0x724b02e2U, 0xe31f8f57U, 0x6655ab2aU,\n    0xb2eb2807U, 0x2fb5c203U, 0x86c57b9aU, 0xd33708a5U,\n    0x302887f2U, 0x23bfa5b2U, 0x02036abaU, 0xed16825cU,\n    0x8acf1c2bU, 0xa779b492U, 0xf307f2f0U, 0x4e69e2a1U,\n    0x65daf4cdU, 0x0605bed5U, 0xd134621fU, 0xc4a6fe8aU,\n    0x342e539dU, 0xa2f355a0U, 0x058ae132U, 0xa4f6eb75U,\n    0x0b83ec39U, 0x4060efaaU, 0x5e719f06U, 0xbd6e1051U,\n    0x3e218af9U, 0x96dd063dU, 0xdd3e05aeU, 0x4de6bd46U,\n    0x91548db5U, 0x71c45d05U, 0x0406d46fU, 0x605015ffU,\n    0x1998fb24U, 0xd6bde997U, 0x894043ccU, 0x67d99e77U,\n    0xb0e842bdU, 0x07898b88U, 0xe7195b38U, 0x79c8eedbU,\n    0xa17c0a47U, 0x7c420fe9U, 0xf8841ec9U, 0x00000000U,\n    0x09808683U, 0x322bed48U, 0x1e1170acU, 0x6c5a724eU,\n    0xfd0efffbU, 0x0f853856U, 0x3daed51eU, 0x362d3927U,\n    0x0a0fd964U, 0x685ca621U, 0x9b5b54d1U, 0x24362e3aU,\n    0x0c0a67b1U, 0x9357e70fU, 0xb4ee96d2U, 0x1b9b919eU,\n    0x80c0c54fU, 0x61dc20a2U, 0x5a774b69U, 0x1c121a16U,\n    0xe293ba0aU, 0xc0a02ae5U, 0x3c22e043U, 0x121b171dU,\n    0x0e090d0bU, 0xf28bc7adU, 0x2db6a8b9U, 0x141ea9c8U,\n    0x57f11985U, 0xaf75074cU, 0xee99ddbbU, 0xa37f60fdU,\n    0xf701269fU, 0x5c72f5bcU, 0x44663bc5U, 0x5bfb7e34U,\n    0x8b432976U, 0xcb23c6dcU, 0xb6edfc68U, 0xb8e4f163U,\n    0xd731dccaU, 0x42638510U, 0x13972240U, 0x84c61120U,\n    0x854a247dU, 0xd2bb3df8U, 0xaef93211U, 0xc729a16dU,\n    0x1d9e2f4bU, 0xdcb230f3U, 0x0d8652ecU, 0x77c1e3d0U,\n    0x2bb3166cU, 0xa970b999U, 0x119448faU, 0x47e96422U,\n    0xa8fc8cc4U, 0xa0f03f1aU, 0x567d2cd8U, 0x223390efU,\n    0x87494ec7U, 0xd938d1c1U, 0x8ccaa2feU, 0x98d40b36U,\n    0xa6f581cfU, 0xa57ade28U, 0xdab78e26U, 0x3fadbfa4U,\n    0x2c3a9de4U, 0x5078920dU, 0x6a5fcc9bU, 0x547e4662U,\n    0xf68d13c2U, 0x90d8b8e8U, 0x2e39f75eU, 0x82c3aff5U,\n    0x9f5d80beU, 0x69d0937cU, 0x6fd52da9U, 0xcf2512b3U,\n    0xc8ac993bU, 0x10187da7U, 0xe89c636eU, 0xdb3bbb7bU,\n    0xcd267809U, 0x6e5918f4U, 0xec9ab701U, 0x834f9aa8U,\n    0xe6956e65U, 0xaaffe67eU, 0x21bccf08U, 0xef15e8e6U,\n    0xbae79bd9U, 0x4a6f36ceU, 0xea9f09d4U, 0x29b07cd6U,\n    0x31a4b2afU, 0x2a3f2331U, 0xc6a59430U, 0x35a266c0U,\n    0x744ebc37U, 0xfc82caa6U, 0xe090d0b0U, 0x33a7d815U,\n    0xf104984aU, 0x41ecdaf7U, 0x7fcd500eU, 0x1791f62fU,\n    0x764dd68dU, 0x43efb04dU, 0xccaa4d54U, 0xe49604dfU,\n    0x9ed1b5e3U, 0x4c6a881bU, 0xc12c1fb8U, 0x4665517fU,\n    0x9d5eea04U, 0x018c355dU, 0xfa877473U, 0xfb0b412eU,\n    0xb3671d5aU, 0x92dbd252U, 0xe9105633U, 0x6dd64713U,\n    0x9ad7618cU, 0x37a10c7aU, 0x59f8148eU, 0xeb133c89U,\n    0xcea927eeU, 0xb761c935U, 0xe11ce5edU, 0x7a47b13cU,\n    0x9cd2df59U, 0x55f2733fU, 0x1814ce79U, 0x73c737bfU,\n    0x53f7cdeaU, 0x5ffdaa5bU, 0xdf3d6f14U, 0x7844db86U,\n    0xcaaff381U, 0xb968c43eU, 0x3824342cU, 0xc2a3405fU,\n    0x161dc372U, 0xbce2250cU, 0x283c498bU, 0xff0d9541U,\n    0x39a80171U, 0x080cb3deU, 0xd8b4e49cU, 0x6456c190U,\n    0x7bcb8461U, 0xd532b670U, 0x486c5c74U, 0xd0b85742U,\n};\nstatic const uint32_t Td1[256] = {\n    0x5051f4a7U, 0x537e4165U, 0xc31a17a4U, 0x963a275eU,\n    0xcb3bab6bU, 0xf11f9d45U, 0xabacfa58U, 0x934be303U,\n    0x552030faU, 0xf6ad766dU, 0x9188cc76U, 0x25f5024cU,\n    0xfc4fe5d7U, 0xd7c52acbU, 0x80263544U, 0x8fb562a3U,\n    0x49deb15aU, 0x6725ba1bU, 0x9845ea0eU, 0xe15dfec0U,\n    0x02c32f75U, 0x12814cf0U, 0xa38d4697U, 0xc66bd3f9U,\n    0xe7038f5fU, 0x9515929cU, 0xebbf6d7aU, 0xda955259U,\n    0x2dd4be83U, 0xd3587421U, 0x2949e069U, 0x448ec9c8U,\n    0x6a75c289U, 0x78f48e79U, 0x6b99583eU, 0xdd27b971U,\n    0xb6bee14fU, 0x17f088adU, 0x66c920acU, 0xb47dce3aU,\n    0x1863df4aU, 0x82e51a31U, 0x60975133U, 0x4562537fU,\n    0xe0b16477U, 0x84bb6baeU, 0x1cfe81a0U, 0x94f9082bU,\n    0x58704868U, 0x198f45fdU, 0x8794de6cU, 0xb7527bf8U,\n    0x23ab73d3U, 0xe2724b02U, 0x57e31f8fU, 0x2a6655abU,\n    0x07b2eb28U, 0x032fb5c2U, 0x9a86c57bU, 0xa5d33708U,\n    0xf2302887U, 0xb223bfa5U, 0xba02036aU, 0x5ced1682U,\n    0x2b8acf1cU, 0x92a779b4U, 0xf0f307f2U, 0xa14e69e2U,\n    0xcd65daf4U, 0xd50605beU, 0x1fd13462U, 0x8ac4a6feU,\n    0x9d342e53U, 0xa0a2f355U, 0x32058ae1U, 0x75a4f6ebU,\n    0x390b83ecU, 0xaa4060efU, 0x065e719fU, 0x51bd6e10U,\n    0xf93e218aU, 0x3d96dd06U, 0xaedd3e05U, 0x464de6bdU,\n    0xb591548dU, 0x0571c45dU, 0x6f0406d4U, 0xff605015U,\n    0x241998fbU, 0x97d6bde9U, 0xcc894043U, 0x7767d99eU,\n    0xbdb0e842U, 0x8807898bU, 0x38e7195bU, 0xdb79c8eeU,\n    0x47a17c0aU, 0xe97c420fU, 0xc9f8841eU, 0x00000000U,\n    0x83098086U, 0x48322bedU, 0xac1e1170U, 0x4e6c5a72U,\n    0xfbfd0effU, 0x560f8538U, 0x1e3daed5U, 0x27362d39U,\n    0x640a0fd9U, 0x21685ca6U, 0xd19b5b54U, 0x3a24362eU,\n    0xb10c0a67U, 0x0f9357e7U, 0xd2b4ee96U, 0x9e1b9b91U,\n    0x4f80c0c5U, 0xa261dc20U, 0x695a774bU, 0x161c121aU,\n    0x0ae293baU, 0xe5c0a02aU, 0x433c22e0U, 0x1d121b17U,\n    0x0b0e090dU, 0xadf28bc7U, 0xb92db6a8U, 0xc8141ea9U,\n    0x8557f119U, 0x4caf7507U, 0xbbee99ddU, 0xfda37f60U,\n    0x9ff70126U, 0xbc5c72f5U, 0xc544663bU, 0x345bfb7eU,\n    0x768b4329U, 0xdccb23c6U, 0x68b6edfcU, 0x63b8e4f1U,\n    0xcad731dcU, 0x10426385U, 0x40139722U, 0x2084c611U,\n    0x7d854a24U, 0xf8d2bb3dU, 0x11aef932U, 0x6dc729a1U,\n    0x4b1d9e2fU, 0xf3dcb230U, 0xec0d8652U, 0xd077c1e3U,\n    0x6c2bb316U, 0x99a970b9U, 0xfa119448U, 0x2247e964U,\n    0xc4a8fc8cU, 0x1aa0f03fU, 0xd8567d2cU, 0xef223390U,\n    0xc787494eU, 0xc1d938d1U, 0xfe8ccaa2U, 0x3698d40bU,\n    0xcfa6f581U, 0x28a57adeU, 0x26dab78eU, 0xa43fadbfU,\n    0xe42c3a9dU, 0x0d507892U, 0x9b6a5fccU, 0x62547e46U,\n    0xc2f68d13U, 0xe890d8b8U, 0x5e2e39f7U, 0xf582c3afU,\n    0xbe9f5d80U, 0x7c69d093U, 0xa96fd52dU, 0xb3cf2512U,\n    0x3bc8ac99U, 0xa710187dU, 0x6ee89c63U, 0x7bdb3bbbU,\n    0x09cd2678U, 0xf46e5918U, 0x01ec9ab7U, 0xa8834f9aU,\n    0x65e6956eU, 0x7eaaffe6U, 0x0821bccfU, 0xe6ef15e8U,\n    0xd9bae79bU, 0xce4a6f36U, 0xd4ea9f09U, 0xd629b07cU,\n    0xaf31a4b2U, 0x312a3f23U, 0x30c6a594U, 0xc035a266U,\n    0x37744ebcU, 0xa6fc82caU, 0xb0e090d0U, 0x1533a7d8U,\n    0x4af10498U, 0xf741ecdaU, 0x0e7fcd50U, 0x2f1791f6U,\n    0x8d764dd6U, 0x4d43efb0U, 0x54ccaa4dU, 0xdfe49604U,\n    0xe39ed1b5U, 0x1b4c6a88U, 0xb8c12c1fU, 0x7f466551U,\n    0x049d5eeaU, 0x5d018c35U, 0x73fa8774U, 0x2efb0b41U,\n    0x5ab3671dU, 0x5292dbd2U, 0x33e91056U, 0x136dd647U,\n    0x8c9ad761U, 0x7a37a10cU, 0x8e59f814U, 0x89eb133cU,\n    0xeecea927U, 0x35b761c9U, 0xede11ce5U, 0x3c7a47b1U,\n    0x599cd2dfU, 0x3f55f273U, 0x791814ceU, 0xbf73c737U,\n    0xea53f7cdU, 0x5b5ffdaaU, 0x14df3d6fU, 0x867844dbU,\n    0x81caaff3U, 0x3eb968c4U, 0x2c382434U, 0x5fc2a340U,\n    0x72161dc3U, 0x0cbce225U, 0x8b283c49U, 0x41ff0d95U,\n    0x7139a801U, 0xde080cb3U, 0x9cd8b4e4U, 0x906456c1U,\n    0x617bcb84U, 0x70d532b6U, 0x74486c5cU, 0x42d0b857U,\n};\nstatic const uint32_t Td2[256] = {\n    0xa75051f4U, 0x65537e41U, 0xa4c31a17U, 0x5e963a27U,\n    0x6bcb3babU, 0x45f11f9dU, 0x58abacfaU, 0x03934be3U,\n    0xfa552030U, 0x6df6ad76U, 0x769188ccU, 0x4c25f502U,\n    0xd7fc4fe5U, 0xcbd7c52aU, 0x44802635U, 0xa38fb562U,\n    0x5a49deb1U, 0x1b6725baU, 0x0e9845eaU, 0xc0e15dfeU,\n    0x7502c32fU, 0xf012814cU, 0x97a38d46U, 0xf9c66bd3U,\n    0x5fe7038fU, 0x9c951592U, 0x7aebbf6dU, 0x59da9552U,\n    0x832dd4beU, 0x21d35874U, 0x692949e0U, 0xc8448ec9U,\n    0x896a75c2U, 0x7978f48eU, 0x3e6b9958U, 0x71dd27b9U,\n    0x4fb6bee1U, 0xad17f088U, 0xac66c920U, 0x3ab47dceU,\n    0x4a1863dfU, 0x3182e51aU, 0x33609751U, 0x7f456253U,\n    0x77e0b164U, 0xae84bb6bU, 0xa01cfe81U, 0x2b94f908U,\n    0x68587048U, 0xfd198f45U, 0x6c8794deU, 0xf8b7527bU,\n    0xd323ab73U, 0x02e2724bU, 0x8f57e31fU, 0xab2a6655U,\n    0x2807b2ebU, 0xc2032fb5U, 0x7b9a86c5U, 0x08a5d337U,\n    0x87f23028U, 0xa5b223bfU, 0x6aba0203U, 0x825ced16U,\n    0x1c2b8acfU, 0xb492a779U, 0xf2f0f307U, 0xe2a14e69U,\n    0xf4cd65daU, 0xbed50605U, 0x621fd134U, 0xfe8ac4a6U,\n    0x539d342eU, 0x55a0a2f3U, 0xe132058aU, 0xeb75a4f6U,\n    0xec390b83U, 0xefaa4060U, 0x9f065e71U, 0x1051bd6eU,\n\n    0x8af93e21U, 0x063d96ddU, 0x05aedd3eU, 0xbd464de6U,\n    0x8db59154U, 0x5d0571c4U, 0xd46f0406U, 0x15ff6050U,\n    0xfb241998U, 0xe997d6bdU, 0x43cc8940U, 0x9e7767d9U,\n    0x42bdb0e8U, 0x8b880789U, 0x5b38e719U, 0xeedb79c8U,\n    0x0a47a17cU, 0x0fe97c42U, 0x1ec9f884U, 0x00000000U,\n    0x86830980U, 0xed48322bU, 0x70ac1e11U, 0x724e6c5aU,\n    0xfffbfd0eU, 0x38560f85U, 0xd51e3daeU, 0x3927362dU,\n    0xd9640a0fU, 0xa621685cU, 0x54d19b5bU, 0x2e3a2436U,\n    0x67b10c0aU, 0xe70f9357U, 0x96d2b4eeU, 0x919e1b9bU,\n    0xc54f80c0U, 0x20a261dcU, 0x4b695a77U, 0x1a161c12U,\n    0xba0ae293U, 0x2ae5c0a0U, 0xe0433c22U, 0x171d121bU,\n    0x0d0b0e09U, 0xc7adf28bU, 0xa8b92db6U, 0xa9c8141eU,\n    0x198557f1U, 0x074caf75U, 0xddbbee99U, 0x60fda37fU,\n    0x269ff701U, 0xf5bc5c72U, 0x3bc54466U, 0x7e345bfbU,\n    0x29768b43U, 0xc6dccb23U, 0xfc68b6edU, 0xf163b8e4U,\n    0xdccad731U, 0x85104263U, 0x22401397U, 0x112084c6U,\n    0x247d854aU, 0x3df8d2bbU, 0x3211aef9U, 0xa16dc729U,\n    0x2f4b1d9eU, 0x30f3dcb2U, 0x52ec0d86U, 0xe3d077c1U,\n    0x166c2bb3U, 0xb999a970U, 0x48fa1194U, 0x642247e9U,\n    0x8cc4a8fcU, 0x3f1aa0f0U, 0x2cd8567dU, 0x90ef2233U,\n    0x4ec78749U, 0xd1c1d938U, 0xa2fe8ccaU, 0x0b3698d4U,\n    0x81cfa6f5U, 0xde28a57aU, 0x8e26dab7U, 0xbfa43fadU,\n    0x9de42c3aU, 0x920d5078U, 0xcc9b6a5fU, 0x4662547eU,\n    0x13c2f68dU, 0xb8e890d8U, 0xf75e2e39U, 0xaff582c3U,\n    0x80be9f5dU, 0x937c69d0U, 0x2da96fd5U, 0x12b3cf25U,\n    0x993bc8acU, 0x7da71018U, 0x636ee89cU, 0xbb7bdb3bU,\n    0x7809cd26U, 0x18f46e59U, 0xb701ec9aU, 0x9aa8834fU,\n    0x6e65e695U, 0xe67eaaffU, 0xcf0821bcU, 0xe8e6ef15U,\n    0x9bd9bae7U, 0x36ce4a6fU, 0x09d4ea9fU, 0x7cd629b0U,\n    0xb2af31a4U, 0x23312a3fU, 0x9430c6a5U, 0x66c035a2U,\n    0xbc37744eU, 0xcaa6fc82U, 0xd0b0e090U, 0xd81533a7U,\n    0x984af104U, 0xdaf741ecU, 0x500e7fcdU, 0xf62f1791U,\n    0xd68d764dU, 0xb04d43efU, 0x4d54ccaaU, 0x04dfe496U,\n    0xb5e39ed1U, 0x881b4c6aU, 0x1fb8c12cU, 0x517f4665U,\n    0xea049d5eU, 0x355d018cU, 0x7473fa87U, 0x412efb0bU,\n    0x1d5ab367U, 0xd25292dbU, 0x5633e910U, 0x47136dd6U,\n    0x618c9ad7U, 0x0c7a37a1U, 0x148e59f8U, 0x3c89eb13U,\n    0x27eecea9U, 0xc935b761U, 0xe5ede11cU, 0xb13c7a47U,\n    0xdf599cd2U, 0x733f55f2U, 0xce791814U, 0x37bf73c7U,\n    0xcdea53f7U, 0xaa5b5ffdU, 0x6f14df3dU, 0xdb867844U,\n    0xf381caafU, 0xc43eb968U, 0x342c3824U, 0x405fc2a3U,\n    0xc372161dU, 0x250cbce2U, 0x498b283cU, 0x9541ff0dU,\n    0x017139a8U, 0xb3de080cU, 0xe49cd8b4U, 0xc1906456U,\n    0x84617bcbU, 0xb670d532U, 0x5c74486cU, 0x5742d0b8U,\n};\nstatic const uint32_t Td3[256] = {\n    0xf4a75051U, 0x4165537eU, 0x17a4c31aU, 0x275e963aU,\n    0xab6bcb3bU, 0x9d45f11fU, 0xfa58abacU, 0xe303934bU,\n    0x30fa5520U, 0x766df6adU, 0xcc769188U, 0x024c25f5U,\n    0xe5d7fc4fU, 0x2acbd7c5U, 0x35448026U, 0x62a38fb5U,\n    0xb15a49deU, 0xba1b6725U, 0xea0e9845U, 0xfec0e15dU,\n    0x2f7502c3U, 0x4cf01281U, 0x4697a38dU, 0xd3f9c66bU,\n    0x8f5fe703U, 0x929c9515U, 0x6d7aebbfU, 0x5259da95U,\n    0xbe832dd4U, 0x7421d358U, 0xe0692949U, 0xc9c8448eU,\n    0xc2896a75U, 0x8e7978f4U, 0x583e6b99U, 0xb971dd27U,\n    0xe14fb6beU, 0x88ad17f0U, 0x20ac66c9U, 0xce3ab47dU,\n    0xdf4a1863U, 0x1a3182e5U, 0x51336097U, 0x537f4562U,\n    0x6477e0b1U, 0x6bae84bbU, 0x81a01cfeU, 0x082b94f9U,\n    0x48685870U, 0x45fd198fU, 0xde6c8794U, 0x7bf8b752U,\n    0x73d323abU, 0x4b02e272U, 0x1f8f57e3U, 0x55ab2a66U,\n    0xeb2807b2U, 0xb5c2032fU, 0xc57b9a86U, 0x3708a5d3U,\n    0x2887f230U, 0xbfa5b223U, 0x036aba02U, 0x16825cedU,\n    0xcf1c2b8aU, 0x79b492a7U, 0x07f2f0f3U, 0x69e2a14eU,\n    0xdaf4cd65U, 0x05bed506U, 0x34621fd1U, 0xa6fe8ac4U,\n    0x2e539d34U, 0xf355a0a2U, 0x8ae13205U, 0xf6eb75a4U,\n    0x83ec390bU, 0x60efaa40U, 0x719f065eU, 0x6e1051bdU,\n    0x218af93eU, 0xdd063d96U, 0x3e05aeddU, 0xe6bd464dU,\n    0x548db591U, 0xc45d0571U, 0x06d46f04U, 0x5015ff60U,\n    0x98fb2419U, 0xbde997d6U, 0x4043cc89U, 0xd99e7767U,\n    0xe842bdb0U, 0x898b8807U, 0x195b38e7U, 0xc8eedb79U,\n    0x7c0a47a1U, 0x420fe97cU, 0x841ec9f8U, 0x00000000U,\n    0x80868309U, 0x2bed4832U, 0x1170ac1eU, 0x5a724e6cU,\n    0x0efffbfdU, 0x8538560fU, 0xaed51e3dU, 0x2d392736U,\n    0x0fd9640aU, 0x5ca62168U, 0x5b54d19bU, 0x362e3a24U,\n    0x0a67b10cU, 0x57e70f93U, 0xee96d2b4U, 0x9b919e1bU,\n    0xc0c54f80U, 0xdc20a261U, 0x774b695aU, 0x121a161cU,\n    0x93ba0ae2U, 0xa02ae5c0U, 0x22e0433cU, 0x1b171d12U,\n    0x090d0b0eU, 0x8bc7adf2U, 0xb6a8b92dU, 0x1ea9c814U,\n    0xf1198557U, 0x75074cafU, 0x99ddbbeeU, 0x7f60fda3U,\n    0x01269ff7U, 0x72f5bc5cU, 0x663bc544U, 0xfb7e345bU,\n    0x4329768bU, 0x23c6dccbU, 0xedfc68b6U, 0xe4f163b8U,\n    0x31dccad7U, 0x63851042U, 0x97224013U, 0xc6112084U,\n    0x4a247d85U, 0xbb3df8d2U, 0xf93211aeU, 0x29a16dc7U,\n    0x9e2f4b1dU, 0xb230f3dcU, 0x8652ec0dU, 0xc1e3d077U,\n    0xb3166c2bU, 0x70b999a9U, 0x9448fa11U, 0xe9642247U,\n    0xfc8cc4a8U, 0xf03f1aa0U, 0x7d2cd856U, 0x3390ef22U,\n    0x494ec787U, 0x38d1c1d9U, 0xcaa2fe8cU, 0xd40b3698U,\n    0xf581cfa6U, 0x7ade28a5U, 0xb78e26daU, 0xadbfa43fU,\n    0x3a9de42cU, 0x78920d50U, 0x5fcc9b6aU, 0x7e466254U,\n    0x8d13c2f6U, 0xd8b8e890U, 0x39f75e2eU, 0xc3aff582U,\n    0x5d80be9fU, 0xd0937c69U, 0xd52da96fU, 0x2512b3cfU,\n    0xac993bc8U, 0x187da710U, 0x9c636ee8U, 0x3bbb7bdbU,\n    0x267809cdU, 0x5918f46eU, 0x9ab701ecU, 0x4f9aa883U,\n    0x956e65e6U, 0xffe67eaaU, 0xbccf0821U, 0x15e8e6efU,\n    0xe79bd9baU, 0x6f36ce4aU, 0x9f09d4eaU, 0xb07cd629U,\n    0xa4b2af31U, 0x3f23312aU, 0xa59430c6U, 0xa266c035U,\n    0x4ebc3774U, 0x82caa6fcU, 0x90d0b0e0U, 0xa7d81533U,\n    0x04984af1U, 0xecdaf741U, 0xcd500e7fU, 0x91f62f17U,\n    0x4dd68d76U, 0xefb04d43U, 0xaa4d54ccU, 0x9604dfe4U,\n    0xd1b5e39eU, 0x6a881b4cU, 0x2c1fb8c1U, 0x65517f46U,\n    0x5eea049dU, 0x8c355d01U, 0x877473faU, 0x0b412efbU,\n    0x671d5ab3U, 0xdbd25292U, 0x105633e9U, 0xd647136dU,\n    0xd7618c9aU, 0xa10c7a37U, 0xf8148e59U, 0x133c89ebU,\n    0xa927eeceU, 0x61c935b7U, 0x1ce5ede1U, 0x47b13c7aU,\n    0xd2df599cU, 0xf2733f55U, 0x14ce7918U, 0xc737bf73U,\n    0xf7cdea53U, 0xfdaa5b5fU, 0x3d6f14dfU, 0x44db8678U,\n    0xaff381caU, 0x68c43eb9U, 0x24342c38U, 0xa3405fc2U,\n    0x1dc37216U, 0xe2250cbcU, 0x3c498b28U, 0x0d9541ffU,\n    0xa8017139U, 0x0cb3de08U, 0xb4e49cd8U, 0x56c19064U,\n    0xcb84617bU, 0x32b670d5U, 0x6c5c7448U, 0xb85742d0U,\n};\nstatic const uint32_t Td4[256] = {\n    0x52525252U, 0x09090909U, 0x6a6a6a6aU, 0xd5d5d5d5U,\n    0x30303030U, 0x36363636U, 0xa5a5a5a5U, 0x38383838U,\n    0xbfbfbfbfU, 0x40404040U, 0xa3a3a3a3U, 0x9e9e9e9eU,\n    0x81818181U, 0xf3f3f3f3U, 0xd7d7d7d7U, 0xfbfbfbfbU,\n    0x7c7c7c7cU, 0xe3e3e3e3U, 0x39393939U, 0x82828282U,\n    0x9b9b9b9bU, 0x2f2f2f2fU, 0xffffffffU, 0x87878787U,\n    0x34343434U, 0x8e8e8e8eU, 0x43434343U, 0x44444444U,\n    0xc4c4c4c4U, 0xdedededeU, 0xe9e9e9e9U, 0xcbcbcbcbU,\n    0x54545454U, 0x7b7b7b7bU, 0x94949494U, 0x32323232U,\n    0xa6a6a6a6U, 0xc2c2c2c2U, 0x23232323U, 0x3d3d3d3dU,\n    0xeeeeeeeeU, 0x4c4c4c4cU, 0x95959595U, 0x0b0b0b0bU,\n    0x42424242U, 0xfafafafaU, 0xc3c3c3c3U, 0x4e4e4e4eU,\n    0x08080808U, 0x2e2e2e2eU, 0xa1a1a1a1U, 0x66666666U,\n    0x28282828U, 0xd9d9d9d9U, 0x24242424U, 0xb2b2b2b2U,\n    0x76767676U, 0x5b5b5b5bU, 0xa2a2a2a2U, 0x49494949U,\n    0x6d6d6d6dU, 0x8b8b8b8bU, 0xd1d1d1d1U, 0x25252525U,\n    0x72727272U, 0xf8f8f8f8U, 0xf6f6f6f6U, 0x64646464U,\n    0x86868686U, 0x68686868U, 0x98989898U, 0x16161616U,\n    0xd4d4d4d4U, 0xa4a4a4a4U, 0x5c5c5c5cU, 0xccccccccU,\n    0x5d5d5d5dU, 0x65656565U, 0xb6b6b6b6U, 0x92929292U,\n    0x6c6c6c6cU, 0x70707070U, 0x48484848U, 0x50505050U,\n    0xfdfdfdfdU, 0xededededU, 0xb9b9b9b9U, 0xdadadadaU,\n    0x5e5e5e5eU, 0x15151515U, 0x46464646U, 0x57575757U,\n    0xa7a7a7a7U, 0x8d8d8d8dU, 0x9d9d9d9dU, 0x84848484U,\n    0x90909090U, 0xd8d8d8d8U, 0xababababU, 0x00000000U,\n    0x8c8c8c8cU, 0xbcbcbcbcU, 0xd3d3d3d3U, 0x0a0a0a0aU,\n    0xf7f7f7f7U, 0xe4e4e4e4U, 0x58585858U, 0x05050505U,\n    0xb8b8b8b8U, 0xb3b3b3b3U, 0x45454545U, 0x06060606U,\n    0xd0d0d0d0U, 0x2c2c2c2cU, 0x1e1e1e1eU, 0x8f8f8f8fU,\n    0xcacacacaU, 0x3f3f3f3fU, 0x0f0f0f0fU, 0x02020202U,\n    0xc1c1c1c1U, 0xafafafafU, 0xbdbdbdbdU, 0x03030303U,\n    0x01010101U, 0x13131313U, 0x8a8a8a8aU, 0x6b6b6b6bU,\n    0x3a3a3a3aU, 0x91919191U, 0x11111111U, 0x41414141U,\n    0x4f4f4f4fU, 0x67676767U, 0xdcdcdcdcU, 0xeaeaeaeaU,\n    0x97979797U, 0xf2f2f2f2U, 0xcfcfcfcfU, 0xcecececeU,\n    0xf0f0f0f0U, 0xb4b4b4b4U, 0xe6e6e6e6U, 0x73737373U,\n    0x96969696U, 0xacacacacU, 0x74747474U, 0x22222222U,\n    0xe7e7e7e7U, 0xadadadadU, 0x35353535U, 0x85858585U,\n    0xe2e2e2e2U, 0xf9f9f9f9U, 0x37373737U, 0xe8e8e8e8U,\n    0x1c1c1c1cU, 0x75757575U, 0xdfdfdfdfU, 0x6e6e6e6eU,\n    0x47474747U, 0xf1f1f1f1U, 0x1a1a1a1aU, 0x71717171U,\n    0x1d1d1d1dU, 0x29292929U, 0xc5c5c5c5U, 0x89898989U,\n    0x6f6f6f6fU, 0xb7b7b7b7U, 0x62626262U, 0x0e0e0e0eU,\n    0xaaaaaaaaU, 0x18181818U, 0xbebebebeU, 0x1b1b1b1bU,\n    0xfcfcfcfcU, 0x56565656U, 0x3e3e3e3eU, 0x4b4b4b4bU,\n    0xc6c6c6c6U, 0xd2d2d2d2U, 0x79797979U, 0x20202020U,\n    0x9a9a9a9aU, 0xdbdbdbdbU, 0xc0c0c0c0U, 0xfefefefeU,\n    0x78787878U, 0xcdcdcdcdU, 0x5a5a5a5aU, 0xf4f4f4f4U,\n    0x1f1f1f1fU, 0xddddddddU, 0xa8a8a8a8U, 0x33333333U,\n    0x88888888U, 0x07070707U, 0xc7c7c7c7U, 0x31313131U,\n    0xb1b1b1b1U, 0x12121212U, 0x10101010U, 0x59595959U,\n    0x27272727U, 0x80808080U, 0xececececU, 0x5f5f5f5fU,\n    0x60606060U, 0x51515151U, 0x7f7f7f7fU, 0xa9a9a9a9U,\n    0x19191919U, 0xb5b5b5b5U, 0x4a4a4a4aU, 0x0d0d0d0dU,\n    0x2d2d2d2dU, 0xe5e5e5e5U, 0x7a7a7a7aU, 0x9f9f9f9fU,\n    0x93939393U, 0xc9c9c9c9U, 0x9c9c9c9cU, 0xefefefefU,\n    0xa0a0a0a0U, 0xe0e0e0e0U, 0x3b3b3b3bU, 0x4d4d4d4dU,\n    0xaeaeaeaeU, 0x2a2a2a2aU, 0xf5f5f5f5U, 0xb0b0b0b0U,\n    0xc8c8c8c8U, 0xebebebebU, 0xbbbbbbbbU, 0x3c3c3c3cU,\n    0x83838383U, 0x53535353U, 0x99999999U, 0x61616161U,\n    0x17171717U, 0x2b2b2b2bU, 0x04040404U, 0x7e7e7e7eU,\n    0xbabababaU, 0x77777777U, 0xd6d6d6d6U, 0x26262626U,\n    0xe1e1e1e1U, 0x69696969U, 0x14141414U, 0x63636363U,\n    0x55555555U, 0x21212121U, 0x0c0c0c0cU, 0x7d7d7d7dU,\n};\nstatic const uint32_t rcon[] = {\n\t0x01000000, 0x02000000, 0x04000000, 0x08000000,\n\t0x10000000, 0x20000000, 0x40000000, 0x80000000,\n\t0x1B000000, 0x36000000, /* for 128-bit key, Rijndael never uses more than 10 rcon values */\n};\n\n#define GETU32(pt) (((uint32_t)(pt)[0] << 24) ^ ((uint32_t)(pt)[1] << 16) ^ ((uint32_t)(pt)[2] <<  8) ^ ((uint32_t)(pt)[3]))\n#define PUTU32(ct, st) { (ct)[0] = (uint8_t)((st) >> 24); (ct)[1] = (uint8_t)((st) >> 16); (ct)[2] = (uint8_t)((st) >>  8); (ct)[3] = (uint8_t)(st); }\n\n/*\n** Prepare the subkeys for encryption using the aes128 key schedule\n*/\nstatic int aesKeySetupEnc(uint32_t rk[], const uint8_t cipherKey[]) {\n\n   \tint i = 0;\n\tuint32_t temp;\n\n\trk[0] = GETU32(cipherKey     );\n\trk[1] = GETU32(cipherKey +  4);\n\trk[2] = GETU32(cipherKey +  8);\n\trk[3] = GETU32(cipherKey + 12);\n\t\n\tfor (;;) {\n\t\ttemp  = rk[3];\n\t\trk[4] = rk[0] ^\n\t\t\t(Te4[(temp >> 16) & 0xff] & 0xff000000) ^\n\t\t\t(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^\n\t\t\t(Te4[(temp      ) & 0xff] & 0x0000ff00) ^\n\t\t\t(Te4[(temp >> 24)       ] & 0x000000ff) ^\n\t\t\trcon[i];\n\t\trk[5] = rk[1] ^ rk[4];\n\t\trk[6] = rk[2] ^ rk[5];\n\t\trk[7] = rk[3] ^ rk[6];\n\t\tif (++i == 10) {\n\t\t\treturn 10;\n\t\t}\n\t\trk += 4;\n\t}\n}\n\n\n/*\n** Prepare the subkeys for decryption using the aes128 key schedule\n*/\nstatic int aesKeySetupDec(uint32_t rk[], const uint8_t cipherKey[]) {\n\n    int Nr;\n    int i;\n    int j;\n    uint32_t temp;\n\n    /* expand the cipher key: */\n    Nr = aesKeySetupEnc(rk, cipherKey);\n\n    /* invert the order of the round keys: */\n    for (i = 0, j = 4*Nr; i < j; i += 4, j -= 4) {\n        temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;\n        temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\n        temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\n        temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\n    }\n    /* apply the inverse MixColumn transform to all round keys but the first and the last: */\n    for (i = 1; i < Nr; i++) {\n        rk += 4;\n        rk[0] =\n            Td0[Te4[(rk[0] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[0] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[0]      ) & 0xff] & 0xff];\n        rk[1] =\n            Td0[Te4[(rk[1] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[1] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[1]      ) & 0xff] & 0xff];\n        rk[2] =\n            Td0[Te4[(rk[2] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[2] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[2]      ) & 0xff] & 0xff];\n        rk[3] =\n            Td0[Te4[(rk[3] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[3] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[3]      ) & 0xff] & 0xff];\n    }\n    return Nr;\n}\n\n/*\n** Tweakable AES block encryption\n*/\nvoid aesTweakEncrypt(const uint8_t pt[16], \n                     const uint8_t key[16], \n                     const uint8_t tweak[8], \n                     uint8_t ct[16]) {\n\n\tuint32_t s0;\n    uint32_t s1;\n    uint32_t s2;\n    uint32_t s3;\n    uint32_t t0;\n    uint32_t t1;\n    uint32_t t2;\n    uint32_t t3;\n\tuint32_t rk[44];\n\tuint32_t tweaks[4];\n\t\t\n\t/* Produce the subkeys */\n\taesKeySetupEnc(rk, key);\n\t\n\t/* Get the tweak */\n\ttweaks[0] = (uint32_t)tweak[0]<<24 ^ (uint32_t)tweak[1]<<16;\n\ttweaks[1] = (uint32_t)tweak[2]<<24 ^ (uint32_t)tweak[3]<<16;\n\ttweaks[2] = (uint32_t)tweak[4]<<24 ^ (uint32_t)tweak[5]<<16;\n\ttweaks[3] = (uint32_t)tweak[6]<<24 ^ (uint32_t)tweak[7]<<16;\n\t\n\t/* Get the plaintext + key/tweak prewhitening */\n    s0 = GETU32(pt     ) ^ rk[0] ^ tweaks[0];\n\ts1 = GETU32(pt +  4) ^ rk[1] ^ tweaks[1];\n\ts2 = GETU32(pt +  8) ^ rk[2] ^ tweaks[2];\n\ts3 = GETU32(pt + 12) ^ rk[3] ^ tweaks[3];\n\t\n\t/* round 1: */\n   \tt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 4] ^ tweaks[0];\n   \tt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 5] ^ tweaks[1];\n   \tt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 6] ^ tweaks[2];\n   \tt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 7] ^ tweaks[3];\n   \t/* round 2: */\n   \ts0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 8] ^ tweaks[0];\n   \ts1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 9] ^ tweaks[1];\n   \ts2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10] ^ tweaks[2];\n   \ts3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11] ^ tweaks[3];\n\t/* round 3: */\n   \tt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[12] ^ tweaks[0];\n   \tt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[13] ^ tweaks[1];\n   \tt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[14] ^ tweaks[2];\n   \tt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[15] ^ tweaks[3];\n   \t/* round 4: */\n   \ts0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[16] ^ tweaks[0];\n   \ts1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[17] ^ tweaks[1];\n   \ts2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[18] ^ tweaks[2];\n   \ts3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[19] ^ tweaks[3];\n\t/* round 5: */\n   \tt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[20] ^ tweaks[0];\n   \tt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[21] ^ tweaks[1];\n   \tt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[22] ^ tweaks[2];\n   \tt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[23] ^ tweaks[3];\n   \t/* round 6: */\n   \ts0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[24] ^ tweaks[0];\n   \ts1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[25] ^ tweaks[1];\n   \ts2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[26] ^ tweaks[2];\n   \ts3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[27] ^ tweaks[3];\n\t/* round 7: */\n   \tt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[28] ^ tweaks[0];\n   \tt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[29] ^ tweaks[1];\n   \tt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[30] ^ tweaks[2];\n   \tt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[31] ^ tweaks[3];\n   \t/* round 8: */\n   \ts0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[32] ^ tweaks[0];\n   \ts1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[33] ^ tweaks[1];\n   \ts2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[34] ^ tweaks[2];\n   \ts3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[35] ^ tweaks[3];\n\t/* round 9: */\n   \tt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[36] ^ tweaks[0];\n   \tt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[37] ^ tweaks[1];\n   \tt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[38] ^ tweaks[2];\n   \tt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[39] ^ tweaks[3];\n\t\n\t/* Apply last round and map cipher state to byte array block */\n\ts0 =\n\t\t(Te4[(t0 >> 24)       ] & 0xff000000) ^\n\t\t(Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n\t\t(Te4[(t2 >>  8) & 0xff] & 0x0000ff00) ^\n\t\t(Te4[(t3      ) & 0xff] & 0x000000ff) ^\n\t\trk[40] ^ tweaks[0];\n\tPUTU32(ct     , s0);\n\ts1 =\n\t\t(Te4[(t1 >> 24)       ] & 0xff000000) ^\n\t\t(Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n\t\t(Te4[(t3 >>  8) & 0xff] & 0x0000ff00) ^\n\t\t(Te4[(t0      ) & 0xff] & 0x000000ff) ^\n\t\trk[41] ^ tweaks[1];\n\tPUTU32(ct +  4, s1);\n\ts2 =\n\t\t(Te4[(t2 >> 24)       ] & 0xff000000) ^\n\t\t(Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n\t\t(Te4[(t0 >>  8) & 0xff] & 0x0000ff00) ^\n\t\t(Te4[(t1      ) & 0xff] & 0x000000ff) ^\n\t\trk[42] ^ tweaks[2];\n\tPUTU32(ct +  8, s2);\n\ts3 =\n\t\t(Te4[(t3 >> 24)       ] & 0xff000000) ^\n\t\t(Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n\t\t(Te4[(t1 >>  8) & 0xff] & 0x0000ff00) ^\n\t\t(Te4[(t2      ) & 0xff] & 0x000000ff) ^\n\t\trk[43] ^ tweaks[3];\n\tPUTU32(ct + 12, s3);\n}\n\n/*\n** Tweakable AES block decryption\n*/\nvoid aesTweakDecrypt(const uint8_t ct[16],\n                     const uint8_t key[16],\n                     const uint8_t tweak[8],\n                     uint8_t pt[16])\n{\n    uint32_t s0;\n    uint32_t s1;\n    uint32_t s2;\n    uint32_t s3;\n    uint32_t t0;\n    uint32_t t1;\n    uint32_t t2;\n    uint32_t t3;\n    uint32_t rk[44];\n    uint32_t tweaks[4];\n    uint32_t tweaksInvMC[4];\n        \n    /* Produce the subkeys */\n    aesKeySetupDec(rk, key);\n    \n    /* Get the tweak */\n    tweaks[0] = (uint32_t)tweak[0]<<24 ^ (uint32_t)tweak[1]<<16 ;\n    tweaks[1] = (uint32_t)tweak[2]<<24 ^ (uint32_t)tweak[3]<<16 ;\n    tweaks[2] = (uint32_t)tweak[4]<<24 ^ (uint32_t)tweak[5]<<16 ;\n    tweaks[3] = (uint32_t)tweak[6]<<24 ^ (uint32_t)tweak[7]<<16 ;     \n\n    /* apply the inverse MixColumn transform to the tweak for the middle rounds */\n    tweaksInvMC[0] =\n        Td0[Te4[(tweaks[0] >> 24)       ] & 0xff] ^\n        Td1[Te4[(tweaks[0] >> 16) & 0xff] & 0xff] ^\n        Td2[Te4[(tweaks[0] >>  8) & 0xff] & 0xff] ^\n        Td3[Te4[(tweaks[0]      ) & 0xff] & 0xff];\n    tweaksInvMC[1] =\n        Td0[Te4[(tweaks[1] >> 24)       ] & 0xff] ^\n        Td1[Te4[(tweaks[1] >> 16) & 0xff] & 0xff] ^\n        Td2[Te4[(tweaks[1] >>  8) & 0xff] & 0xff] ^\n        Td3[Te4[(tweaks[1]      ) & 0xff] & 0xff];\n    tweaksInvMC[2] =\n        Td0[Te4[(tweaks[2] >> 24)       ] & 0xff] ^\n        Td1[Te4[(tweaks[2] >> 16) & 0xff] & 0xff] ^\n        Td2[Te4[(tweaks[2] >>  8) & 0xff] & 0xff] ^\n        Td3[Te4[(tweaks[2]      ) & 0xff] & 0xff];\n    tweaksInvMC[3] =\n        Td0[Te4[(tweaks[3] >> 24)       ] & 0xff] ^\n        Td1[Te4[(tweaks[3] >> 16) & 0xff] & 0xff] ^\n        Td2[Te4[(tweaks[3] >>  8) & 0xff] & 0xff] ^\n        Td3[Te4[(tweaks[3]      ) & 0xff] & 0xff];\n\n    /* Get the cipher + key/tweak prewhitening */\n    s0 = GETU32(ct     ) ^ rk[0] ^ tweaks[0];\n    s1 = GETU32(ct +  4) ^ rk[1] ^ tweaks[1];\n    s2 = GETU32(ct +  8) ^ rk[2] ^ tweaks[2];\n    s3 = GETU32(ct + 12) ^ rk[3] ^ tweaks[3];\n\n    /* round 1: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[ 4] ^ tweaksInvMC[0];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[ 5] ^ tweaksInvMC[1];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[ 6] ^ tweaksInvMC[2];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[ 7] ^ tweaksInvMC[3];\n    /* round 2: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[ 8] ^ tweaksInvMC[0];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[ 9] ^ tweaksInvMC[1];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[10] ^ tweaksInvMC[2];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[11] ^ tweaksInvMC[3];\n    /* round 3: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[12] ^ tweaksInvMC[0];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[13] ^ tweaksInvMC[1];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[14] ^ tweaksInvMC[2];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[15] ^ tweaksInvMC[3];\n    /* round 4: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[16] ^ tweaksInvMC[0];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[17] ^ tweaksInvMC[1];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[18] ^ tweaksInvMC[2];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[19] ^ tweaksInvMC[3];\n    /* round 5: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[20] ^ tweaksInvMC[0];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[21] ^ tweaksInvMC[1];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[22] ^ tweaksInvMC[2];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[23] ^ tweaksInvMC[3];\n    /* round 6: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[24] ^ tweaksInvMC[0];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[25] ^ tweaksInvMC[1];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[26] ^ tweaksInvMC[2];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[27] ^ tweaksInvMC[3];\n    /* round 7: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[28] ^ tweaksInvMC[0];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[29] ^ tweaksInvMC[1];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[30] ^ tweaksInvMC[2];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[31] ^ tweaksInvMC[3];\n    /* round 8: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[32] ^ tweaksInvMC[0];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[33] ^ tweaksInvMC[1];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[34] ^ tweaksInvMC[2];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[35] ^ tweaksInvMC[3];\n    /* round 9: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[36] ^ tweaksInvMC[0];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[37] ^ tweaksInvMC[1];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[38] ^ tweaksInvMC[2];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[39] ^ tweaksInvMC[3];\n\n    /* Apply last round and map cipher state to byte array block */\n    s0 =\n        (Td4[(t0 >> 24)       ] & 0xff000000) ^\n        (Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t2 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t1      ) & 0xff] & 0x000000ff) ^\n        rk[40] ^ tweaks[0];\n    PUTU32(pt     , s0);\n    s1 =\n        (Td4[(t1 >> 24)       ] & 0xff000000) ^\n        (Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t3 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t2      ) & 0xff] & 0x000000ff) ^\n        rk[41] ^ tweaks[1];\n    PUTU32(pt +  4, s1);\n    s2 =\n        (Td4[(t2 >> 24)       ] & 0xff000000) ^\n        (Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t0 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t3      ) & 0xff] & 0x000000ff) ^\n        rk[42] ^ tweaks[2];\n    PUTU32(pt +  8, s2);\n    s3 =\n        (Td4[(t3 >> 24)       ] & 0xff000000) ^\n        (Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t1 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t0      ) & 0xff] & 0x000000ff) ^\n        rk[43] ^ tweaks[3];\n    PUTU32(pt + 12, s3);\n}\n\n} // namespace Kiasuneq128v1_raw\n"
        },
        {
            "file_name": "lacv1_encrypt.cpp",
            "content": "#include \"lacv1_encrypt.h\"\n#include <stdio.h>\n#if defined(__APPLE__)\t\t\t// EACIRC: manual edit: apple compatibility\n#  include <malloc/malloc.h>\n#  include <stdlib.h>\n#else\n#  include <malloc.h>\n#endif\n\n// CHANGE namespace moved due to includes\nnamespace Lacv1_raw {\nint numRounds = -1;\n\n//contents of the 4-bit sbox used in LBlock-s\nunsigned char S[16] = {14,9,15,0,13,4,10,11,1,2,8,3,7,6,12,5};\t\n\n//padding procedure: string x(xlen bytes) is padded to string xpad(xpadlen bytes)\n void padding(\n   const unsigned char *x,unsigned long long xlen,\n   unsigned char *xpad,unsigned long long xpadlen\n )\n {\n\t int i;\n\n\t for(i = 0; i < xlen; i++)\n\t {\n\t\t xpad[i] = x[i];\n\t }\n\t for(i = xlen; i < xpadlen; i++)\n\t {\n\t\txpad[i] = 0;\n\t }\n \t xpad[xpadlen - 5] = ((xlen * 8) >> 32) & 0xff;\t\n \t xpad[xpadlen - 4] = ((xlen * 8) >> 24) & 0xff;\t\t\n \t xpad[xpadlen - 3] = ((xlen * 8) >> 16) & 0xff;\t\t\n \t xpad[xpadlen - 2] = ((xlen * 8) >>  8) & 0xff;\t\t\n \t xpad[xpadlen - 1] = ((xlen * 8) >>  0) & 0xff;\t\n\t /* the last 40-bit of xpad is padded with the length of string x(in bits) */\n\n\t return;\n }\n\n//key schedule algorithm of the full 32-round LBlock-s   \n void key_sched_LBlocks(\n   const unsigned char *keystate,\n   unsigned char *subkey\n )\n {\t\n\tint i, j, r;\n\tunsigned char temp[10], ttemp[10], temp1;\n\n\t//copy the master key stored in keystate(10 bytes)\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tttemp[i] = keystate[i];\n\t}\n\n\t//output the first round subkey(4 bytes)\n\tfor(j = 0; j < 4; j++)\n\t{\n\t\tsubkey[j] = ttemp[j];\n\t}\n\n\tfor (r = 1; r < 32; r++)\n\t{\t\n\t\t//update the key register with operation <<< 24\n\t\tfor (i = 0; i < 10; i++)\n\t\t{\n\t\t\ttemp[i] = ttemp[(i + 3) % 10];\n\t\t}\n\t\ttemp1 = (S[temp[0] >> 4] << 4) ^ (S[temp[0] & 0xf]);\t//update the key register with two 4-bit sbox operations\n\t\ttemp[3] ^= (temp1 & 0xf0) ^ (temp[8] & 0xf);\n\t\ttemp[6] ^= temp1 << 4;\n\t\ttemp[1] ^= temp[1] >> 4;\n\t\ttemp[3] ^= r << 2;\t\t\t\t//update the key register with round constant xor operation\n\n\t\tfor (i = 0; i < 10; i++)\n\t\t{\n\t\t\tttemp[i] = temp[i];\n\t\t}\n\t\tfor (j = 0; j < 4; j++)\n\t\t{\n\t\t\tsubkey[r * 4 + j] = ttemp[j];\t//output the (r + 1)-th round subkey(4 bytes)\n\t\t}\t\n\t}\n\n\treturn;\n }\n\n //encryption algorithm of the full 32-round LBlock-s\n void E(\n   const unsigned char *input,\n   const unsigned char *key,\n   unsigned char *output\n )\n {\n\tint i, r;\n\tunsigned char subkey[32 * 4];\n\tunsigned char left[4], right[4];\n\tunsigned char temp[4], nibble[8];\n\n\tkey_sched_LBlocks(key, subkey);\t\t//obtain the subkeys used in 32 rounds, each subkey is 4 bytes\n\n\tfor(i = 0; i < 4; i++)\n\t{\n\t\tleft[i] = input[i];\n\t\tright[i] = input[i + 4];\n\t}\n\n\t//32-round encryption\n\tfor(r = 0; r < 32; r++)\n\t{\n\t\t//finish the operation of <<< 8 in right half branch\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\ttemp[i] = right[(i + 1) % 4];\n\t\t}\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tright[i] = temp[i];\n\t\t}\n\n\t\t//round subkey xor operation\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\ttemp[i] = left[i] ^ subkey[r * 4 + i];\n\t\t}\n\n\t\t//4-bit sbox operation, the results are stored in 8 nibbles, each nibble is 4-bit long\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tnibble[2 * i] = S[temp[i] >> 4];\n\t\t\tnibble[2 * i + 1] = S[temp[i] & 0xf];\n\t\t}\n\t\t\n\t\t//nibble-wise permutation, the results are stored in 4 bytes\n\t\ttemp[0] = (nibble[1] << 4) ^ nibble[3];\n\t\ttemp[1] = (nibble[0] << 4) ^ nibble[2];\n\t\ttemp[2] = (nibble[5] << 4) ^ nibble[7];\n\t\ttemp[3] = (nibble[4] << 4) ^ nibble[6];\n\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\ttemp[i] ^= right[i];\n\t\t}\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tright[i] = left[i];\n\t\t\tleft[i] = temp[i];\n\t\t}\n\t}\n\n\t//the ciphertext is stored in output(8 bytes)\n\tfor(i = 0; i < 4; i++)\n\t{\n\t\toutput[i] = left[i];\n\t\toutput[i + 4] = right[i];\n\t}\n }\n\n //key schedule algorithm of the reduced 16-round LBlock-s   \n void KS(\n   unsigned char *keystate,\n   unsigned char *subkey\n )\n {\t\n\tint i, j, r;\n\tunsigned char temp[10], ttemp[10], temp1;\n\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tttemp[i] = keystate[i];\n\t}\n\n\tfor(j = 0; j < 4; j++)\n\t{\n\t\tsubkey[j] = ttemp[j];\n\t}\n\n\tfor (r = 1; r < 16; r++)\n\t{\t\n\t\tfor (i = 0; i < 10; i++)\n\t\t{\n\t\t\ttemp[i] = ttemp[(i + 3) % 10];\n\t\t}\n\t\ttemp1 = (S[temp[0] >> 4] << 4) ^ (S[temp[0] & 0xf]);\n\t\ttemp[3] ^= (temp1 & 0xf0) ^ (temp[8] & 0xf);\n\t\ttemp[6] ^= temp1 << 4;\n\t\ttemp[1] ^= temp[1] >> 4;\n\t\ttemp[3] ^= r << 2;\n\n\t\tfor (i = 0; i < 10; i++)\n\t\t{\n\t\t\tttemp[i] = temp[i];\n\t\t}\n\t\tfor (j = 0; j < 4; j++)\n\t\t{\n\t\t\tsubkey[r * 4 + j] = ttemp[j];\t\n\t\t}\n\t}\n\n\t//after outputing 16 round subkeys, update the key register one more time, the round constant used is 0x15\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\ttemp[i] = ttemp[(i + 3) % 10];\n\t}\n\ttemp1 = (S[temp[0] >> 4] << 4) ^ (S[temp[0] & 0xf]);\n\ttemp[3] ^= (temp1 & 0xf0) ^ (temp[8] & 0xf);\n\ttemp[6] ^= temp1 << 4;\n\ttemp[1] ^= temp[1] >> 4;\n\ttemp[3] ^= 0x15 << 2;\n\n\t//output the final state of key register\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tkeystate[i] = temp[i];\n\t}\n\n\treturn;\n }\n\n  //encryption algorithm of the reduced 16-round LBlock-s\n  void G(\n   unsigned char *input,\n   unsigned char *subkey,\n   unsigned char *output\n )\n {\n\tint i, r;\n\tunsigned char left[4], right[4];\n\tunsigned char temp[4], nibble[8];\n\n\tfor(i = 0; i < 4; i++)\n\t{\n\t\tleft[i] = input[i];\n\t\tright[i] = input[i + 4];\n\t}\n\n\tfor(r = 0; r < 16; r++)\n\t{\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\ttemp[i] = right[(i + 1) % 4];\n\t\t}\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tright[i] = temp[i];\n\t\t}\n\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\ttemp[i] = left[i] ^ subkey[r * 4 + i];\n\t\t}\n\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tnibble[2 * i] = S[temp[i] >> 4];\n\t\t\tnibble[2 * i + 1] = S[temp[i] & 0xf];\n\t\t}\n\t\t\n\t\ttemp[0] = (nibble[1] << 4) ^ nibble[3];\n\t\ttemp[1] = (nibble[0] << 4) ^ nibble[2];\n\t\ttemp[2] = (nibble[5] << 4) ^ nibble[7];\n\t\ttemp[3] = (nibble[4] << 4) ^ nibble[6];\n\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\ttemp[i] ^= right[i];\n\t\t}\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tright[i] = left[i];\n\t\t\tleft[i] = temp[i];\n\t\t}\n\t}\n\n\tfor(i = 0; i < 4; i++)\n\t{\n\t\toutput[i] = left[i];\n\t\toutput[i + 4] = right[i];\n\t}\t\n\n\treturn;\n }\n\n  //encryption algorithm of the reduced 16-round LBlock-s with 48-bit leak data\n  void Gleak(\n   unsigned char *input,\n   unsigned char *subkey,\n   unsigned char *output,\n   unsigned char *leak\n )\n {\n\tint i, r;\n\tunsigned char left[4], right[4];\n\tunsigned char temp[4], nibble[8];\n\n\tfor(i = 0; i < 4; i++)\n\t{\n\t\tleft[i] = input[i];\n\t\tright[i] = input[i + 4];\n\t}\n\n\tfor(r = 0; r < 8; r++)\n\t{\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\ttemp[i] = right[(i + 1) % 4];\n\t\t}\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tright[i] = temp[i];\n\t\t}\n\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\ttemp[i] = left[i] ^ subkey[r * 4 + i];\n\t\t}\n\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tnibble[2 * i] = S[temp[i] >> 4];\n\t\t\tnibble[2 * i + 1] = S[temp[i] & 0xf];\n\t\t}\n\t\t\n\t\ttemp[0] = (nibble[1] << 4) ^ nibble[3];\n\t\ttemp[1] = (nibble[0] << 4) ^ nibble[2];\n\t\ttemp[2] = (nibble[5] << 4) ^ nibble[7];\n\t\ttemp[3] = (nibble[4] << 4) ^ nibble[6];\n\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\ttemp[i] ^= right[i];\n\t\t}\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tright[i] = left[i];\n\t\t\tleft[i] = temp[i];\n\t\t}\n\t}\n\n\t//the higher 24-bit output of 8-round LBlock-s is used as the first 24-bit leak data\n\tleak[0] = left[0];\n\tleak[1] = left[1];\n\tleak[2] = left[2];\n\n\tfor(r = 8; r < 16; r++)\n\t{\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\ttemp[i] = right[(i + 1) % 4];\n\t\t}\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tright[i] = temp[i];\n\t\t}\n\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\ttemp[i] = left[i] ^ subkey[r * 4 + i];\n\t\t}\n\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tnibble[2 * i] = S[temp[i] >> 4];\n\t\t\tnibble[2 * i + 1] = S[temp[i] & 0xf];\n\t\t}\n\t\t\n\t\ttemp[0] = (nibble[1] << 4) ^ nibble[3];\n\t\ttemp[1] = (nibble[0] << 4) ^ nibble[2];\n\t\ttemp[2] = (nibble[5] << 4) ^ nibble[7];\n\t\ttemp[3] = (nibble[4] << 4) ^ nibble[6];\n\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\ttemp[i] ^= right[i];\n\t\t}\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tright[i] = left[i];\n\t\t\tleft[i] = temp[i];\n\t\t}\n\t}\n\n\t//the higher 24-bit output of 16-round LBlock-s is used as the last 24-bit leak data\n\tleak[3] = left[0];\n\tleak[4] = left[1];\n\tleak[5] = left[2];\n\n\tfor(i = 0; i < 4; i++)\n\t{\n\t\toutput[i] = left[i];\n\t\toutput[i + 4] = right[i];\n\t}\t\n\n\treturn;\n }\n\n int crypto_aead_encrypt(\n   unsigned char *c,unsigned long long *clen,\n   const unsigned char *m,unsigned long long mlen,\n   const unsigned char *ad,unsigned long long adlen,\n   const unsigned char *nsec,\n   const unsigned char *npub,\n   const unsigned char *k\n )\n {\n\tunsigned char *mpad; \n\tunsigned long long mpadlen;\n\tunsigned char *adpad = NULL; \n\tunsigned long long adpadlen;\n\tunsigned char ukey[16];\n\tunsigned char datastate[8] = {0}, keystate[10], leak[6];\n\tunsigned char subkey[16 * 4];\n\tunsigned char tag[8];\n\tint i, j;\n\n\t/*\t//1 message should not be null\n\tif(mlen == 0)\n\t{\n\t\treturn -2;\t\n\t}\n\t//2 at most 2^40 bits data (including associate data and message are allowed to be processed with the same key)\n\tif((mlen + adlen) > ((unsigned long)0x1 << 37))\n\t{\n\t\treturn -3;\t\n\t}\n*/\n\n\tif(mlen == 0) //if the message is null, the result is expected to be computed as follows \n\t{\n\t\tmpadlen = 0;\n\t\tmpad = (unsigned char *)malloc(mpadlen);\t//the array to store padded message(mpad bytes)\n\t\tpadding(m, mlen, mpad, mpadlen);\n\t}\n\telse\n\t{\n\t\t//compute the length of padded message(in bytes)\n\t\tif((mlen + 5) % 6 == 0)\n\t\t{\n\t\t\tmpadlen = mlen + 5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmpadlen = ((mlen + 5) / 6 + 1) * 6;\n\t\t}\n\t\tmpad = (unsigned char *)malloc(mpadlen);\t//the array to store padded message(mpad bytes)\n\t\tpadding(m, mlen, mpad, mpadlen);\t//message padding procedure\n\t}\n\t\n\n\tif(adlen == 0)\t\t//associate data can be null\n\t{\n\t\tadpadlen = 0;\t\n\t}\n\telse\t//associate data padding procedure\n\t{\n\t\tif((adlen + 5) % 6 == 0)\n\t\t{\n\t\t\tadpadlen = adlen + 5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tadpadlen = ((adlen + 5) / 6 + 1) * 6;\n\t\t}\n\t\tadpad = (unsigned char *)malloc(adpadlen);\n\t\tpadding(ad, adlen, adpad, adpadlen);\n\t}\n\n\t//initialize to generate 128-bit ukey\n\tE(npub, k, ukey);\n\tE(ukey, k, ukey + 8);\n\n\t//update the key register of KS with lower 80-bit ukey\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tkeystate[i] = ukey[i + 6];\n\t}\n\n\t//encrypting 64-bit 0 with higher 80-bit ukey to obtain the beginning of data state \n\tE(datastate, ukey, datastate);\n\n\t//processing associate data\n\tfor(i = 0; i < adpadlen; i += 6)\n\t{\n\t\tKS(keystate, subkey);\n\t\tG(datastate, subkey, datastate);\n\t\tfor(j = 0; j < 6; j++)\n\t\t{\n\t\t\tdatastate[j + 2] ^= adpad[i + j];\n\t\t}\n\t}\n\n\t//processing message\n\tfor(i = 0; i < mpadlen; i += 6)\n\t{\n\t\tKS(keystate, subkey);\n\t\tGleak(datastate, subkey, datastate, leak);\n\t\tfor(j = 0; j < 6; j++)\n\t\t{\n\t\t\tdatastate[j + 2] ^= mpad[i + j];\t//xor the padded message block to the lower 48-bit of data state \n\t\t\tif((i + j) < mlen)\n\t\t\t{\n\t\t\t\tc[i + j] = m[i + j] ^ leak[j];\t//xor the message block with the 48-bit leak data to get the cipher block\n\t\t\t}\n\t\t}\n\t}\n\n\t//generate the tag\n\tE(datastate, k, tag);\n\n\t//the last 8 bytes of cipher are the tag\n\tfor(i = 0; i < 8; i++)\n\t{\n\t\tc[mlen + i] = tag[i];\n\t}\n\n\t*clen = mlen + 8;\t//length of cipher, the first mlen bytes are ciphertext corresponding to the message, and the last 8 bytes are the tag\n\n\treturn 0;\n }\n\n int crypto_aead_decrypt(\n   unsigned char *m,unsigned long long *mlen,\n   unsigned char *nsec,\n   const unsigned char *c,unsigned long long clen,\n   const unsigned char *ad,unsigned long long adlen,\n   const unsigned char *npub,\n   const unsigned char *k\n )\n {\n   \tunsigned char *mpad; \n\tunsigned long long mpadlen;\n\tunsigned char *adpad = NULL; \n\tunsigned long long adpadlen;\n\tunsigned char ukey[16];\n\tunsigned char datastate[8] = {0}, keystate[10], leak[6];\n\tunsigned char subkey[16 * 4];\n\tunsigned char tag[8];\n\n\tint i, j;\n\n\t*mlen = clen - 8;\t//length of message \n\n\t/*1 message should not be null\n\tif(*mlen == 0)\n\t{\n\t\treturn -2;\t\n\t}\n\t//2 at most 2^40 bits data (including associate data and message are allowed to be processed with the same key)\n\tif((*mlen + adlen) > ((unsigned long)0x1 << 37))\n\t{\n\t\treturn -3;\t\n\t}*/\n\n\tif(*mlen == 0) //if the message is null, the result is expected to be computed as follows \n\t{\n\t\tmpadlen = 0;\t\n\t}\n\telse\n\t{\n\t\t//compute the length of padded message(in bytes), and store the padding data in the array mpad\n\t\tif((*mlen + 5) % 6 == 0)\n\t\t{\n\t\t\tmpadlen = *mlen + 5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmpadlen = ((*mlen + 5) / 6 + 1) * 6;\n\t\t}\n\t\tmpad = (unsigned char *)malloc(mpadlen);\n\t\tpadding(m, *mlen, mpad, mpadlen);\n\t}\n\t\n\n\tif(adlen == 0)\t\t//associate data can be null\n\t{\n\t\tadpadlen = 0;\t\n\t}\n\telse\t//associate data padding procedure\n\t{\n\t\tif((adlen + 5) % 6 == 0)\n\t\t{\n\t\t\tadpadlen = adlen + 5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tadpadlen = ((adlen + 5) / 6 + 1) * 6;\n\t\t}\n\t\tadpad = (unsigned char *)malloc(adpadlen);\n\t\tpadding(ad, adlen, adpad, adpadlen);\n\t}\n\n\tE(npub, k, ukey);\n\tE(ukey, k, ukey + 8);\n\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tkeystate[i] = ukey[i + 6];\n\t}\n\n\tE(datastate, ukey, datastate);\n\n\tfor(i = 0; i < adpadlen; i += 6)\n\t{\n\t\tKS(keystate, subkey);\n\t\tG(datastate, subkey, datastate);\n\t\tfor(j = 0; j < 6; j++)\n\t\t{\n\t\t\tdatastate[j + 2] ^= adpad[i + j];\n\t\t}\n\t}\n\n\tfor(i = 0; i < mpadlen; i += 6)\n\t{\n\t\tKS(keystate, subkey);\n\t\tGleak(datastate, subkey, datastate, leak);\n\t\tfor(j = 0; j < 6; j++)\n\t\t{\n\t\t\tif((i + j) < *mlen)\n\t\t\t{\n\t\t\t\tm[i + j] = c[i + j] ^ leak[j];\t//xor the cipher block with 48-bit leak data to get the message block\n\t\t\t\tdatastate[j + 2] ^= m[i + j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdatastate[j + 2] ^= mpad[i + j];\n\t\t\t}\n\t\t}\n\t}\n\n\tE(datastate, k, tag);\n\n\t//verifying procedure\n\tfor(i = 0; i < 8; i++)\n\t{\n\t\tif(tag[i] != c[*mlen + i])\n\t\t{\n\t\t\treturn -1;\t\t//if the tag computed is not equal to the tag stored in the last 8 bytes of cipher, reture -1 to denote the failure of verifying and output no message\n\t\t}\n\t}\n\n\treturn 0;\t//denotes the success of verifying and output the decrypted message\n }\n\n} // namespace Lacv1_raw\n"
        },
        {
            "file_name": "lanarea.c",
            "content": "#include \"lanarea.h\"\n\n#define ROL(value, shift) (value << (shift % sizeof(value))) | (value >> (sizeof(value) * 8 - (shift % sizeof(value))))\n#define ROR(value, shift) (value >> (shift % sizeof(value))) | (value << (sizeof(value) * 8 - (shift % sizeof(value))))\n\nstatic inline ssize_t diagonal_ur (ssize_t i, ssize_t w);\nstatic inline ssize_t diagonal_dr (ssize_t i, ssize_t w, ssize_t h);\n\nconst uint8_t pi[] =\t{\n\t\t\t0x32, 0x43, 0xF6, 0xA8, 0x88, 0x5A, 0x30, 0x8D,\n\t\t\t0x31, 0x31, 0x98, 0xA2, 0xE0, 0x37, 0x07, 0x34,\n\t\t\t0x4A, 0x40, 0x93, 0x82, 0x22, 0x99, 0xF3, 0x1D,\n\t\t\t0x00, 0x82, 0xEF, 0xA9, 0x8E, 0xC4, 0xE6, 0xC8,\n\t\t\t0x94, 0x52, 0x82, 0x1E, 0x63, 0x8D, 0x01, 0x37,\n\t\t\t0x7B, 0xE5, 0x46, 0x6C, 0xF3, 0x4E, 0x90, 0xC6,\n\t\t\t0xCC, 0x0A, 0xC2, 0x9B, 0x7C, 0x97, 0xC5, 0x0D,\n\t\t\t0xD3, 0xF8, 0x4D, 0x5B, 0x5B, 0x54, 0x70, 0x91,\n\t\t\t0x79, 0x21, 0x6D, 0x5D, 0x98, 0x97, 0x9F, 0xB1,\n\t\t\t0xBD, 0x13, 0x10, 0xBA, 0x69, 0x8D, 0xFB, 0x5A,\n\t\t\t0xC2, 0xFF, 0xD7, 0x2D, 0xBD, 0x01, 0xAD, 0xFB,\n\t\t\t0x7B, 0x8E, 0x1A, 0xFE, 0xD6, 0xA2, 0x67, 0xE9,\n\t\t\t0x6B, 0xA7, 0xC9, 0x04, 0x5F, 0x12, 0xC7, 0xF9,\n\t\t\t0x92, 0x4A, 0x19, 0x94, 0x7B, 0x39, 0x16, 0xCF,\n\t\t\t0x70, 0x80, 0x1F, 0x2E, 0x28, 0x58, 0xEF, 0xC1,\n\t\t\t0x66, 0x36, 0x92, 0x0D, 0x87, 0x15, 0x74, 0xE6\n\t\t\t};\n\nconst uint8_t e[] =\t{\n\t\t\t0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,\n\t\t\t0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C,\n\t\t\t0x76, 0x2E, 0x71, 0x60, 0xF3, 0x8B, 0x4D, 0xA5,\n\t\t\t0x6A, 0x78, 0x4D, 0x90, 0x45, 0x19, 0x0C, 0xFE,\n\t\t\t0xF3, 0x24, 0xE7, 0x73, 0x89, 0x26, 0xCF, 0xBE,\n\t\t\t0x5F, 0x4B, 0xF8, 0xD8, 0xD8, 0xC3, 0x1D, 0x76,\n\t\t\t0x3D, 0xA0, 0x6C, 0x80, 0xAB, 0xB1, 0x18, 0x5E,\n\t\t\t0xB4, 0xF7, 0xC7, 0xB5, 0x75, 0x7F, 0x59, 0x58,\n\t\t\t0x49, 0x0C, 0xFD, 0x47, 0xD7, 0xC1, 0x9B, 0xB4,\n\t\t\t0x21, 0x58, 0xD9, 0x55, 0x4F, 0x7B, 0x46, 0xBC,\n\t\t\t0xED, 0x55, 0xC4, 0xD7, 0x9F, 0xD5, 0xF2, 0x4D,\n\t\t\t0x66, 0x13, 0xC3, 0x1C, 0x38, 0x39, 0xA2, 0xDD,\n\t\t\t0xF8, 0xA9, 0xA2, 0x76, 0xBC, 0xFB, 0xFA, 0x1C,\n\t\t\t0x87, 0x7C, 0x56, 0x28, 0x4D, 0xAB, 0x79, 0xCD,\n\t\t\t0x4C, 0x2B, 0x32, 0x93, 0xD2, 0x0E, 0x9E, 0x5E,\n\t\t\t0xAF, 0x02, 0xAC, 0x60, 0xAC, 0xC9, 0x3E, 0xD8\n\t\t\t};\n\nint lanarea (\nvoid *out,\t\t// pointer to large enough dest\nsize_t outlen,\t\t// must be a multiple of 32\nconst void *in,\t\t// source password\nsize_t inlen,\t\t// length of source password\nconst void *salt,\t// cryptographic salt\nsize_t saltlen,\t\t// length of salt\nsize_t t_cost,\t\t// abstract amount of time to waste\nsize_t m_cost\t\t// abstract amount of memory to waste\n) {\n\t// check that directions were followed and that pointers are valid\n\tif (!out || !outlen || (outlen % 32) || !in || !inlen || !salt || !saltlen) {\n\t\treturn 2;\n\t}\n\n\t// check for idiocy\n\tif (!m_cost || !t_cost) {\n\t\tmemset (out, 0x00, outlen);\t// contrary to popular belief, there are stupid\n\t\treturn 1;\t\t\t// queries, and they deserve stupid answers\n\t}\n\n\t// initialization\n\tm_cost = m_cost * 16;\n\tssize_t x, y;\n\tuint8_t **matrix = malloc (m_cost * sizeof (uint8_t *));\n\n\t// matrix size parameters\n\tconst size_t columnSize\t\t= m_cost;\n\tconst size_t rowSize\t\t= 16;\n\tconst size_t matrixSize\t\t= columnSize * rowSize;\n\n\t// memory allocation\n\tfor (x = 0; x < m_cost; x++) {\n\t\tmatrix[x] = malloc (rowSize * sizeof (uint8_t));\n\t}\n\n\t// allocate additional important memory\n\tuint8_t *hash\t= malloc (32 * sizeof (uint8_t));\n\tuint8_t *line\t= malloc (rowSize * sizeof (uint8_t));\n\tuint8_t *row\t= malloc (rowSize * sizeof (uint8_t));\n\tuint8_t *column\t= malloc (columnSize * sizeof (uint8_t));\n\tuint8_t *chain\t= malloc (matrixSize * sizeof (uint8_t));\n\n\tconst size_t initialSize = (sizeof pi) + (sizeof e) + 32;\n\n\tuint8_t *initial\t= malloc (initialSize * sizeof (uint8_t));\n\n\t// copy constants over\n\tsize_t offset = 0;\n\tmemcpy (initial + offset, pi, sizeof pi);\n\toffset += sizeof pi;\n\tmemcpy (initial + offset,  e, sizeof  e);\n\toffset += sizeof  e;\n\n\tmemset (initial + offset, 0, 32);\t// pad until sizeof BLAKE2b 256bit output\n\n\t// initialize the matrix\n\tfor (x = 0; x < columnSize; x++) {\n\t\tfor (y = 0; y < rowSize; y++) {\n\t\t\tblake2b (\n\t\t\t\thash,\n\t\t\t\tinitial,\n\t\t\t\tNULL,\t// we don't need a key here\n\t\t\t\t32,\t// give a 256 bit output\n\t\t\t\tinitialSize,\n\t\t\t\t0\n\t\t\t\t);\n\n\t\t\t// append last hash after [e ++ pi]\n\t\t\tmemcpy (initial + offset, hash, 32);\n\n\t\t\t// set the matrix byte\n\t\t\tmatrix[x][y] = hash[y];\n\t\t}\n\t}\n\n\t// compute the initial line\n\tblake2b (\n\t\thash,\n\t\tin,\n\t\tsalt,\n\t\t32,\n\t\tinlen,\n\t\tsaltlen\n\t\t);\n\n\t// actual processing\n\tt_cost = t_cost * 4;\t\t\t// run the loop at least 4 times\n\tm_cost = m_cost * rowSize;\t\t// (block count * block height) * block width = total bytes\n\tsize_t z, r, c;\n\tfor (x = 0; x < t_cost; x++) {\n\t\tfor (y = 0; y < columnSize; y++) {\n\t\t\t// apply line to matrix\n\t\t\tfor (z = 0; z < rowSize; z++) {\n\t\t\t\t// cause cache misses\n\t\t\t\tr = (y + hash[z]) % columnSize;\t// prevent cache read hits\n\t\t\t\tc = (r + matrix[y][z]) % columnSize;\t// ^^^^^^^^^^^^^^^^^^^^^^^\n\t\t\t\tr = (r + matrix[r][z]) % columnSize;\t// ^^^^^^^^^^^^^^^^^^^^^^^\n\t\t\t\tc = matrix[c][z];\n\n\t\t\t\t// rotate right or left ...\n\t\t\t\t// ... although it really only\n\t\t\t\t// matters for one or two cases\n\t\t\t\tswitch (c % 2) {\n\t\t\t\t\tcase 0x00:\n\t\t\t\t\t\tc = ROL (c, r);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x01:\n\t\t\t\t\t\tc = ROR (c, r);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// mix mixing instructions\n\t\t\t\tswitch (c % 4) {\n\t\t\t\t\tcase 0x00:\t// ADD\n\t\t\t\t\t\tmatrix[y][z] = matrix[y][z] + hash[z];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x01:\t// XOR\n\t\t\t\t\t\tmatrix[y][z] = matrix[y][z] ^ hash[z];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x02:\t// SUB\n\t\t\t\t\t\tmatrix[y][z] = matrix[y][z] - hash[z];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x03:\t// XNOR\n\t\t\t\t\t\tmatrix[y][z] = matrix[y][z] ^ ~hash[z];\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// build a chain using the up-right diagonal full matrix\n\t\t\tfor (z = 0; z < m_cost; z++) {\n\t\t\t\tc = z % rowSize;\n\t\t\t\tr = diagonal_ur (z, rowSize);\n\t\t\t\tchain[z] = matrix[r][c];\n\t\t\t}\n\n\t\t\t// hash the chain\n\t\t\tblake2b (hash, chain, NULL, 32, matrixSize, 0);\n\n\t\t// rinse and repeat - minus the rinsing :)\n\t\t}\n\t// do this as many times as is necessary to waste compute time\n\t}\n\n\t// create and dump the output\n\toutlen = outlen / 32;\n\tfor (x = 0; x < outlen; x++) {\n\t\ty = x * 32;\t// offset for output\n\t\tblake2b (((uint8_t *) out) + y, chain, hash, 32, matrixSize, 32);\t// hash the matrix using the last hash as a key\n\t\tmemcpy (hash, ((uint8_t *) out) + y, 32);\t// copy the output back to prevent a WAR data hazard\n\t}\n\n\t// cleanup all of our memory allocations\n\tm_cost = m_cost / rowSize;\t// undo earlier multiply\n\tfor (x = 0; x < m_cost; x++) {\n\t\tfree (matrix[x]);\n\t}\n\tfree (matrix);\n\tfree (hash);\n\tfree (line);\n\tfree (row);\n\tfree (column);\n\tfree (chain);\n\tfree (initial);\n\n\treturn 0;\n}\n\n// Creates the up-right diagonal pattern\nstatic inline ssize_t diagonal_ur (ssize_t i, ssize_t w) {\n\t// http://stackoverflow.com/questions/22647907/multidimensional-array-patterned-access/22648975#22648975\n\n\t// Simplification is left as an exercise for the compiler.\n\treturn (((w - i % w) % w) + (i / w)) % w  + (w * (i / (w * w)));\n}\n"
        },
        {
            "file_name": "libpolypasshash.c",
            "content": "/*\n * This file is Copyright Santiago Torres Arias <torresariass@gmail.com> 2014\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n#include \"config.h\"\n#include \"libgfshare.h\"\n#include \"libpolypasshash.h\"\n\n\n\n\n/*******************************************************************\n* NAME :            pph_init_context\n*\n* DESCRIPTION :     Initialize a poly pass hash structure with everything\n*                   we need in order to work. \n*\n*                   This is the layout of the generated structure:\n*\n*                   typedef struct _pph_context{\n*                     gfshare_ctx* share_context      = new share context\n*                     uint8 threshold                 = threshold\n*                     uint8 available_shares;         = MAX_NUMBER_OF_SHARES\n*                     uint8 next_entry;               = 1\n*                     bool is_unlocked;               = true   \n*                     uint8 *AES_key;                 = will point to secret       \n*                     uint8 *secret;                  = generated secret\n*                     uint8 partial_bytes;            = partial_bytes\n*                     pph_account_node* account_data; = NULL\n*                   } pph_context;\n*                \n*\n* INPUTS :\n*   PARAMETERS:\n*     uint8 threshold:            The threshold for this specific\n*                                 password storage. This is, the minimum\n*                                 number of shares needed to unlock the \n*                                 upon reloading. The valid ranges for the \n*                                 threshold go from 1 to MAX_NUMBER_OF_SHARES;\n*                                 however, a value of 1 is a bad idea.\n*\n*     uint8 partial_bytes:        The number of hashed-bytes to leak in order \n*                                 to perform partial verification. If \n*                                 partial_bytes = 0, partial verification is \n*                                 disabled. Partial bytes should range from 0\n*                                 to DIGEST_LENGTH\n* OUTPUTS :\n*   PARAMETERS:\n*     None\n*     \n*   GLOBALS :\n*     None\n*   \n*   RETURN :\n*     Type:   pph_context         the resulting context or NULL when either\n*                                 allocation fails or the input given is not\n*                                 within the valid ranges.\n*\n* PROCESS :\n*   1) verify arguments\n*   2) allocate data structures\n*   3) generate a custom random secret\n*   4) initialize the rest of the values\n*   5) initialize the secret generator.\n*   7) return \n*\n* CHANGES :\n*     21/04/2014: secret is no longer a parameter\n*/\n\npph_context* pph_init_context(uint8 threshold, uint8 partial_bytes) {\n\n\n  pph_context *context;\n\n  // this is a specific initialization constant\n  unsigned char share_numbers[MAX_NUMBER_OF_SHARES];\n  unsigned int i;\n  \n  \n\n  // 1) CHECK ARGUMENT SANITY\n  // threshold\n  if(threshold == 0 || threshold > MAX_NUMBER_OF_SHARES) {\n    \n    return NULL;\n\n  }\n\n  if(partial_bytes > DIGEST_LENGTH) {\n    \n    return NULL;\n    \n  }\n\n\n  // 2)INITIALIZE DATA STRUCTURES\n  context = malloc(sizeof(*context));\n  if(context == NULL) {\n    \n    return NULL;\n    \n  }\n\n  context->threshold=threshold;\n  \n  // initialize the partial bytes offset, this will be used to limit the\n  // length of the shares, and the length of the digest to xor/encrypt.\n  context->partial_bytes=partial_bytes;\n\n\n\n  // 3) generate random secret, we generate a random byte stream and append\n  // half of the 16 byte hash to the end of it, we have chosen to use\n  // only four hash bytes in order to have more random bytes. \n  context->secret = generate_pph_secret(\n      SIGNATURE_RANDOM_BYTE_LENGTH-partial_bytes,\n      SIGNATURE_HASH_BYTE_LENGTH);\n  if(context->secret == NULL) {\n    free(context);\n    \n    return NULL;\n    \n  }\n\n\n\n  // 4) Initialize the rest of the values.\n  context->available_shares = (uint8)MAX_NUMBER_OF_SHARES;\n\n  // since this is a new context, it should be unlocked.\n  context->is_unlocked = true; \n\n  // We are using the secret to encrypt thresholdless accounts, so we set the \n  // AES key to be the same as the secret. \n  context->AES_key = context->secret;\n\n  // initialize the rest\n  context->next_entry=1;\n  context->account_data=NULL;\n\n\n\n  // 5) Initialize share context\n  for(i=0;i<MAX_NUMBER_OF_SHARES;i++) {\n    share_numbers[i]=(unsigned char)i+1;\n  }\n\n  // Update the share context, the size of the shares is reduced by the number\n  // or partial bytes.\n  context->share_context = NULL;\n  context->share_context = gfshare_ctx_init_enc( share_numbers,\n                                                 MAX_NUMBER_OF_SHARES-1,\n                                                 context->threshold,\n                                                 SHARE_LENGTH-partial_bytes);\n  if(context->share_context == NULL) {\n    free(context->secret);\n    free(context);\n    \n    return NULL;\n    \n  }\n  \n  \n  gfshare_ctx_enc_setsecret(context->share_context, context->secret);\n  \n  // finish, return our product\n  return context;\n    \n}\n\n\n\n\n\n/*******************************************************************\n* NAME :            pph_destroy_context\n*\n* DESCRIPTION :     Destroy an existing instance of pph_context, securely \n*                   destroying its resources.\n*\n*                   The structure will have to free the following elements \n*                   before it can be safely freed:\n*\n*                   typedef struct _pph_context{\n*                     gfshare_ctx* share_context      = needs freeing\n*                     uint8 threshold                 = \n*                     uint8 available_shares;         = \n*                     uint8 next_entry;               = \n*                     bool is_unlocked;               = \n*                     uint8 *AES_key;                 = needs freeing      \n*                     uint8 *secret;                  = needs freeing\n*                     uint8 partial_bytes;            = \n*                     pph_account_node* account_data; = needs freeing\n*                   } pph_context;\n*\n*\n* INPUTS :\n*   PARAMETERS:\n*     pph_context *context: the context to destroy\n*\n* OUTPUTS :\n*   PARAMETERS:\n*     pph_context *context: the context to free/destroy.    \n*     \n*   GLOBALS :\n*     None\n*   \n*   RETURN :\n*     Type:   PPH_ERROR     \n*                    value:                     when:\n*                   PPH_ERROR_OK                  the free process worked\n*\n*                   PPH_ERROR_BAD_PTR             if the pointer given is NULL \n* PROCESS :\n*     Basically destroy pointers in the structure and then free the structure\n*     itself, doing sanity checks in between child and parent structure \n*     destruction. \n*\n* CHANGES :\n*     (03/17/14): Account freeing is done now. \n*/\n\nPPH_ERROR pph_destroy_context(pph_context *context){\n\n\n  pph_account_node *current,*next;\n\n\n  // check that we are given a valid pointer\n  if(context == NULL){\n    \n    return PPH_BAD_PTR;\n    \n  }\n  \n  \n  // do child freeing.\n  if(context->secret !=NULL){\n    free(context->secret);\n  }\n\n\n  if(context->account_data != NULL){\n    next = context->account_data;\n    while(next!=NULL){\n      current=next;\n      next=next->next;\n      // free their entry list\n      _destroy_entry_list(current->account.entries);\n      free(current); \n    }\n  }\n\n\n  if(context->share_context!=NULL){\n    gfshare_ctx_free(context->share_context);\n  }\n  \n  \n  // now it is safe to free the context\n  free(context);\n\n  return PPH_ERROR_OK;\n    \n}\n\n\n\n\n/*******************************************************************\n* NAME :            pph_create_account\n*\n* DESCRIPTION :     given a context and some other data, create a user\n*                   entry in the polypasshash context with the desired \n*                   information.\n*\n* INPUTS :\n*   PARAMETERS:\n*     pph_context *ctx:                   This is the context in which the\n*                                         account will be created\n*     \n*     const uint8 *username:              This is the desired username for the\n*                                         new entry\n*\n*     const unsigned int username_length: the length of the username field,\n*                                         this value should not exceed \n*                                         MAX_USERNAME_LENGTH.\n*\n*     const uint8 *password:              This is the password for the new entry\n*\n*     const unsgned int password_length:  The length of the password field, this\n*                                         value should not exceed \n*                                         MAX_PASSWORD_LENGTH\n*\n*     uint8 shares:                       This is the amount of shares we decide \n*                                         to allocate to this new account. \n* OUTPUTS :\n*   PARAMETERS:\n*     None\n*     \n*   GLOBALS :\n*     None\n*   \n*   RETURN :\n*     Type: int PPH_ERROR     \n*           Values:                       When:\n*             PPH_ERROR_OK                 The credentials provided are correct\n*             \n*             PPH_BAD_PTR                  One of the fields is unallocated\n*\n*             PPH_ERROR_UNKNOWN            When something unexpected happens.\n*\n*             PPH_NO_MEM                   If malloc, calloc fails.\n*\n*             PPH_USERNAME_IS_TOO_LONG     When the value for username_length is\n*                                          larger than MAX_USERNAME_LENGTH.\n*\n*             PPH_PASSWORD_IS_TOO_LONG     When the value for password_length is\n*                                          larger than MAX_PASSWORD_LENGTH.\n*\n*             PPH_CONTEXT_IS_LOCKED        When the context is locked and, hence\n*                                          he cannot create accounts\n*\n*             PPH_ACCOUNT_EXISTS          If the username provided already \n*                                          exists\n*\n* PROCESS :\n*     1) Check for data sanity, and return errors\n*     2) Check the type of account requested\n*     3) Allocate a share/digest entry for the account\n*     4) Initialize the account data with the information provided\n*     5) Update the context information regarding the new account\n*     6) return\n*\n* CHANGES :\n*   Added support for different length accounts\n*/\n\nPPH_ERROR pph_create_account(pph_context *ctx, const uint8 *username,\n                        const unsigned int username_length, \n                        const uint8 *password, \n                        const unsigned int password_length, uint8 shares){\n\n\n  pph_account_node *node,*next;\n  unsigned int length;\n  unsigned int i;\n  pph_entry *entry_node,*last_entry;\n  uint8 current_entry;\n  uint8 share_data[SHARE_LENGTH];\n  uint8 resulting_hash[DIGEST_LENGTH];\n  uint8 salt_buffer[MAX_SALT_LENGTH];\n\n  \n  \n  // 1) SANITIZE INFORMATION\n  // check password length\n  if(password_length > MAX_PASSWORD_LENGTH-1){\n    \n    return PPH_PASSWORD_IS_TOO_LONG;\n    \n  }\n\n  // check username length\n  if(username_length > MAX_USERNAME_LENGTH-1){\n    \n    return PPH_USERNAME_IS_TOO_LONG;\n    \n  }\n\n  // check share numbers, we don't check for 0 since that means thresholdless\n  // accounts\n  if(shares>MAX_NUMBER_OF_SHARES){\n    \n    return PPH_WRONG_SHARE_COUNT;\n    \n  }\n  \n  // check correct context pointer\n  if(ctx == NULL){\n    \n    return PPH_BAD_PTR;\n    \n  }\n\n  // check if we are able to get shares from the context vault\n  if(ctx->is_unlocked != true || ctx->AES_key == NULL){\n    \n    return PPH_CONTEXT_IS_LOCKED;\n    \n  }\n\n  // This while loop will traverse our accounts and check if the username is \n  // already taken.\n  next = ctx->account_data;\n  while(next!=NULL){\n    node=next;\n    next=next->next;\n    // only compare them if their lengths match\n    if(username_length==node->account.username_length && \n        !memcmp(node->account.username,username,username_length)){\n    \n      return PPH_ACCOUNT_EXISTS; \n    \n    }\n  }\n\n\n  // 2) check for the type of account requested.\n  \n  // this will generate a share list for threshold accounts, we won't \n  // fall inside this loop for thresholdless accounts since shares is 0.\n  last_entry = NULL;\n\n  for(i=0;i<shares;i++){\n    \n    // 3) Allocate entries for each account\n    // get a new share value\n    gfshare_ctx_enc_getshare( ctx->share_context, ctx->next_entry,\n        share_data);\n\n    // get a salt for the password\n    get_random_bytes(MAX_SALT_LENGTH, salt_buffer);\n\n    // Try to get a new entry.\n    entry_node=create_polyhashed_entry(password, password_length, salt_buffer,\n        MAX_SALT_LENGTH, share_data, SHARE_LENGTH, ctx->partial_bytes);\n    if(entry_node == NULL){\n      _destroy_entry_list(last_entry);\n    \n      return PPH_NO_MEM;\n    \n    }\n    \n    // update the share number for this entry, and update the next available\n    // share in a round robin fashion\n    entry_node->share_number = ctx->next_entry;\n    ctx->next_entry++;\n    if(ctx->next_entry==0 || ctx->next_entry>=MAX_NUMBER_OF_SHARES){\n      ctx->next_entry=1;\n    }   \n\n    // add the node to the list\n    entry_node->next = last_entry;\n    last_entry=entry_node;\n  }\n\n  // This if will check for thresholdless accounts, and will build a single \n  // entry for them.\n  if(shares == 0){\n  \n    // 3) allocate an entry for each account\n    // get a salt for the password\n    get_random_bytes(MAX_SALT_LENGTH, salt_buffer); \n \n    // generate the entry\n    entry_node = create_thresholdless_entry(password, password_length,\n        salt_buffer, MAX_SALT_LENGTH, ctx->AES_key, DIGEST_LENGTH,\n        ctx->partial_bytes);\n\n    if(entry_node == NULL){\n    \n      return PPH_NO_MEM;\n    \n    }\n\n    // we now have one share entry under this list, so we increment this\n    // parameter.\n    shares++;\n  }\n  \n  // 4) Allocate the information for the account\n  // allocate the account information, check for memory issues and return.\n  node=malloc(sizeof(*node));\n  if(node==NULL){\n    // we should destroy the list we created now to avoid memory leaks\n    _destroy_entry_list(entry_node);\n    \n    return PPH_NO_MEM;\n    \n  }\n\n  // fill with the user entry with the rest of the account information.\n  memcpy(node->account.username,username,username_length);\n  node->account.number_of_entries = shares;\n  node->account.username_length = username_length;\n  node->account.entries = entry_node;\n\n  // 5) add the resulting account to the current context.\n  // append it to the context list, with the rest of thee users\n  node->next = ctx->account_data;\n  ctx->account_data = node;\n\n  // 6) return.\n  // everything is set!\n    \n  return PPH_ERROR_OK;\n    \n}\n\n\n\n\n/*******************************************************************\n* NAME :          pph_check_login  \n*\n* DESCRIPTION :   Check whether a username and password combination exists \n*                 inside the loaded PPH context.\n*\n* INPUTS :\n*   PARAMETERS:\n*     pph_context *ctx:     The context in which we are working\n*\n*     const char *username: The username attempt\n*\n*     unsigned int username_length: The length of the username field\n*\n*     const char *password: The password attempt\n*\n*     unsigned int password_length: the length of the password field\n*\n* OUTPUTS :\n*   PARAMETERS:\n*     None\n*     \n*   GLOBALS :\n*     None\n*   \n*   RETURN :\n*     Type: int PPH_ERROR     \n*           Values:                         When:\n*           PPH_ACCOUNT_IS_INVALID            The combination does not exist\n*           \n*           PPH_USERNAME_IS_TOO_LONG          The username won't fit in the \n*                                             buffer\n*\n*           PPH_PASSWORD_IS_TOO_LONG          The password won't fit in the \n*                                             buffer associated to it. \n*\n*           PPH_BAD_PTR                       When pointers are null or out\n*                                             of range\n*\n*           PPH_ERROR_UNKNOWN                 any time else\n*           \n* PROCESS :\n*     1) Sanitize data and return errors\n*     2) try to find username in the context\n*     3) if found, decide how to verify his information based on the status\n*         of the context (thresholdless, partial verif, etc.)\n*     4) Do the corresponding check and return the proper error\n*\n* CHANGES :\n*  (21/04/2014): Added support for non-null-terminated usernames and passwords.\n*/\n\nPPH_ERROR pph_check_login(pph_context *ctx, const char *username, \n                          unsigned int username_length, uint8 *password,\n                          unsigned int password_length){\n \n\n  // this will be used to iterate all the users \n  pph_account_node *search;\n  pph_account_node *target = NULL; \n  \n  // we will store the current share in this buffer for xor'ing   \n  uint8 share_data[SHARE_LENGTH];  \n  \n  // we will calculate a \"proposed hash\" in this buffer  \n  uint8 resulting_hash[DIGEST_LENGTH];\n  uint8 salted_password[MAX_SALT_LENGTH+MAX_PASSWORD_LENGTH]; \n                                                      \n  uint8 xored_hash[SHARE_LENGTH];\n\n  // these are value holders to improve readability\n  uint8 sharenumber;\n  pph_entry *current_entry;\n  unsigned int i;\n\n  // this will hold an offset value for partial verification.\n  unsigned int partial_bytes_offset;\n\n  // openSSL managers.\n  EVP_CIPHER_CTX de_ctx;\n  int p_len,f_len;\n\n\n  // 1) Sanitize data and return errors.\n  // check for any improper pointers\n  if(ctx == NULL || username == NULL || password == NULL){\n    \n    return PPH_BAD_PTR;\n    \n  }\n\n  // if the length is too long for either field, return proper error.\n  if(username_length > MAX_USERNAME_LENGTH){\n    \n    return PPH_USERNAME_IS_TOO_LONG;\n    \n  }\n  \n  // do the same for the password\n  if(password_length > MAX_PASSWORD_LENGTH){\n    \n    return PPH_PASSWORD_IS_TOO_LONG;\n    \n  }\n\n  // check if the context is locked and we lack partial bytes to check. If we\n  // do not have enough partial bytes (at least one), we cannot do partial\n  // verification\n  if(ctx->is_unlocked != true && ctx->partial_bytes == 0){\n    \n    return PPH_CONTEXT_IS_LOCKED;\n    \n  }\n\n  // check we have a thresholdless key\n  if(ctx->AES_key == NULL && ctx->partial_bytes == 0){\n    \n    return PPH_CONTEXT_IS_LOCKED;\n    \n  }\n\n\n  // 2) Try to find the user in our context.\n  // search for our user, we search the entries with the same username length \n  // first, and then we check if the contents are the same. \n  search = ctx->account_data;\n  while(search!=NULL){\n    // we check lengths first and then compare what's in it. \n    if(username_length == search->account.username_length && \n        !memcmp(search->account.username,username,username_length)){\n      target = search;\n    }\n    search=search->next;\n  } \n\n  //i.e. we found no one\n  if(target == NULL){ \n    \n    return PPH_ACCOUNT_IS_INVALID;\n    \n  }\n\n  \n  // if we reach here, we should have enough resources to provide a login\n  // functionality to the user.\n  \n\n  // 3) Try to verify the proper password for him.\n  // first, check what type of account is this\n  \n  // this probably happens if data is inconsistent, but let's avoid\n  // segmentation faults. \n  if(target->account.entries == NULL){\n    \n    return PPH_ERROR_UNKNOWN; \n    \n  }\n\n\n  // we get the first entry to check if this is a valid login, we could be \n  // thorough and check for each, but it looks like an overkill\n  current_entry = target->account.entries;\n  sharenumber = current_entry->share_number;\n  partial_bytes_offset = DIGEST_LENGTH - ctx->partial_bytes;\n  \n  \n  // if the context is not unlocked, we can only provide partial verification  \n  if(ctx->is_unlocked != true){\n\n    // partial bytes check\n    // calculate the proposed digest, this means, calculate the hash with\n    // the information just provided about the user. \n    memcpy(salted_password,current_entry->salt,current_entry->salt_length);\n    memcpy(salted_password+current_entry->salt_length, password,\n        current_entry->password_length);\n    _calculate_digest(resulting_hash, salted_password, \n       current_entry->salt_length + password_length);\n   \n    // only compare the bytes that are not obscured by either AES or the \n    // share, we start from share_length-partial_bytes to share_length. \n    if(memcmp(resulting_hash+partial_bytes_offset,\n          target->account.entries->polyhashed_value+partial_bytes_offset,\n          ctx->partial_bytes)){\n    \n      return PPH_ACCOUNT_IS_INVALID;\n    \n    }\n    \n    return PPH_ERROR_OK;\n    \n  }\n\n  // we are unlocked and hence we can provide full verification.\n  else{ \n    // first, check if the account is a threshold or thresholdless account.\n    if(sharenumber == 0){\n      \n      // if the sharenumber is 0 then we have a thresholdless account\n      \n      // now we should calculate the expected hash by deciphering the\n      // information inside the context.\n      EVP_CIPHER_CTX_init(&de_ctx);\n      EVP_DecryptInit_ex(&de_ctx, EVP_aes_256_ctr(), NULL, ctx->AES_key, NULL);\n      EVP_DecryptUpdate(&de_ctx, xored_hash, &p_len, \n          current_entry->polyhashed_value, partial_bytes_offset);\n      EVP_DecryptFinal_ex(&de_ctx, xored_hash+p_len, &f_len);\n      EVP_CIPHER_CTX_cleanup(&de_ctx);\n\n      // append the unencrypted bytes if we have partial bytes. \n      for(i=p_len+f_len;i<DIGEST_LENGTH;i++){\n        xored_hash[i] = current_entry->polyhashed_value[i];\n      }\n\n      // calculate the proposed digest with the parameters provided in\n      // this function.\n      memcpy(salted_password,current_entry->salt, current_entry->salt_length);\n      memcpy(salted_password+current_entry->salt_length, password, \n          password_length); \n      _calculate_digest(resulting_hash, salted_password, \n          current_entry->salt_length + password_length);\n\n      \n      // 3) compare both, and they should match.\n      if(memcmp(resulting_hash, xored_hash, DIGEST_LENGTH)){\n    \n        return PPH_ACCOUNT_IS_INVALID;\n    \n      }\n    \n      return PPH_ERROR_OK;\n    \n    }else{\n    \n      // we have a non thresholdless account instead, since the sharenumber is \n      // not 0\n      gfshare_ctx_enc_getshare(ctx->share_context, sharenumber, share_data);\n\n      // calculate the proposed digest with the salt from the account and\n      // the password in the argument.\n      memcpy(salted_password,current_entry->salt, current_entry->salt_length);\n      memcpy(salted_password+current_entry->salt_length, password, \n          password_length); \n      _calculate_digest(resulting_hash, salted_password, \n          current_entry->salt_length + password_length);\n      \n      // xor the thing back to normal\n      _xor_share_with_digest(xored_hash,current_entry->polyhashed_value,\n          share_data, partial_bytes_offset);\n      \n      // add the partial bytes to the end of the digest.\n      for(i=DIGEST_LENGTH-ctx->partial_bytes;i<DIGEST_LENGTH;i++){\n        xored_hash[i] = target->account.entries->polyhashed_value[i];\n      }\n      \n      // compare both.\n      if(memcmp(resulting_hash, xored_hash, DIGEST_LENGTH)){\n    \n        return PPH_ACCOUNT_IS_INVALID;\n    \n      }\n    \n      return PPH_ERROR_OK; // this means, the login does match\n    \n    } \n  }\n\n  // if we get to reach here, we where diverged from usual flow. \n    \n  return PPH_ERROR_UNKNOWN;\n    \n}\n\n\n\n\n/*******************************************************************\n* NAME :          pph_unlock_password_data \n*\n* DESCRIPTION :   given a context and pairs of usernames and passwords,\n*                 unlock the password secret. \n*\n* INPUTS :\n*   PARAMETERS:\n*     pph_context *ctx:                The context in which we are working\n*\n*     unsigned int username_count:     The length of the username/password arrays\n*\n*     const char *usernames:           The username attempts\n*\n*     unsigned int username_lengths[]: The length of the username fields,\n*                                      in the same order as the usernames.\n*\n*     const char *passwords:           The password attempts\n*\n* OUTPUTS :\n*   PARAMETERS:\n*     type: pph_context             The context provided will be activated and\n*                                   pointed to the secret if combination was \n*                                   successful\n*     \n*   GLOBALS :\n*     None\n*   \n*   RETURN :\n*     Type: int PPH_ERROR     \n*           Values:                         When:\n*           PPH_ACCOUNT_IS_INVALID            We couldn't recombine with the \n*                                             information given\n*           \n*           PPH_USERNAME_IS_TOO_LONG          The username won't fit in the\n*                                             buffer allocated to it.\n*\n*           PPH_PASSOWRD_IS_TOO_LONG          The password won't fit in it's\n*                                             assigned buffer\n*\n*           PPH_BAD_PTR                       When pointers are null or out\n*                                             of range\n*\n*           PPH_ERROR_UNKNOWN                 any time else\n*           \n* PROCESS :\n*     1) Verify input sanity\n*     2) traverse user accounts searching for proposed username\n*     3) produce shares out of the password digest\n*     4) give shares to the recombination context\n*     5) attempt recombination\n*     6) verify correct recombination.\n*     7) if successful, unlock the store\n*     8) return error code\n*\n* CHANGES :\n*     (03/25/14): Secret consistency check was added. \n*/\n\nPPH_ERROR pph_unlock_password_data(pph_context *ctx,unsigned int username_count,\n                          const uint8 *usernames[], \n                          unsigned int username_lengths[],\n                          const uint8 *passwords[]){\n  \n  \n  uint8 share_numbers[MAX_NUMBER_OF_SHARES];\n  gfshare_ctx *G;\n  unsigned int i;\n  uint8 secret[SHARE_LENGTH];\n  uint8 salted_password[MAX_USERNAME_LENGTH+MAX_SALT_LENGTH];\n  uint8 estimated_digest[DIGEST_LENGTH];\n  uint8 estimated_share[SHARE_LENGTH];\n  pph_entry *entry; \n  pph_account_node *current_user;\n  \n\n  //sanitize the data.\n  if(ctx == NULL || usernames == NULL || passwords == NULL || \n      username_lengths == NULL){\n    \n    return PPH_BAD_PTR;\n    \n  }\n\n  if(username_count < ctx->threshold){\n    \n    return PPH_ACCOUNT_IS_INVALID;\n    \n  }\n\n\n  // initialize the share numbers\n  for(i=0;i<MAX_NUMBER_OF_SHARES;i++){\n    share_numbers[i] = 0;\n  }\n  \n  // initialize a recombination context\n  G = gfshare_ctx_init_dec( share_numbers, MAX_NUMBER_OF_SHARES-1,\n     SHARE_LENGTH-ctx->partial_bytes);\n\n\n  // traverse our possible users\n  current_user=ctx->account_data;\n  while(current_user!=NULL){\n    // check if each of the provided users is inside the context. We traverse\n    // our user list inside the while, and compare against the provided users \n    // inside this for loop.\n    for(i = 0; i<username_count;i++){\n\n      //compare the proposed against existing users.\n      if(username_lengths[i] == current_user->account.username_length &&\n          (!memcmp(usernames[i],current_user->account.username,\n            current_user->account.username_length))){\n\n        // this is an existing user\n        entry = current_user->account.entries;\n        \n        // check if he is a threshold account.\n        if(entry->share_number != 0){\n        \n          // if he is a threshold account, we must attempt to reconstruct the\n          // shares using their information, traverse his entries\n          while(entry!=NULL){\n\n            // calulate the digest given the password.\n            memcpy(salted_password,entry->salt,entry->salt_length);\n            memcpy(salted_password+entry->salt_length, passwords[i],\n                entry->password_length);\n            _calculate_digest(estimated_digest,salted_password,\n             MAX_SALT_LENGTH + current_user->account.entries->password_length);\n\n            // xor the obtained digest with the polyhashed value to obtain\n            // our share.\n            _xor_share_with_digest(estimated_share,entry->polyhashed_value,\n                estimated_digest,SHARE_LENGTH-ctx->partial_bytes);\n         \n            // give share to the recombinator. \n            share_numbers[entry->share_number] = entry->share_number+1;\n            gfshare_ctx_dec_giveshare(G, entry->share_number,estimated_share);\n\n            // move to the next entry.\n            entry = entry->next;\n          }\n        } \n      }\n    } \n    current_user = current_user->next;\n  }\n\n\n  // now we attempt to recombine the secret, we have given him all of the \n  // obtained shares.\n  gfshare_ctx_dec_newshares(G, share_numbers);\n  gfshare_ctx_dec_extract(G, secret);\n\n  // verify that we got a proper secret back.\n  if(check_pph_secret(secret, SIGNATURE_RANDOM_BYTE_LENGTH-ctx->partial_bytes,\n        SIGNATURE_HASH_BYTE_LENGTH) != PPH_ERROR_OK){\n    \n    return PPH_ACCOUNT_IS_INVALID;\n    \n  }\n\n  // else, we have a correct secret and we will copy it back to the provided\n  // context.\n  if(ctx->secret == NULL){\n    ctx->secret = calloc(sizeof(ctx->secret),SHARE_LENGTH-ctx->partial_bytes);\n  }\n  memcpy(ctx->secret,secret,SHARE_LENGTH-ctx->partial_bytes);\n\n  // if the share context is not initialized, initialize one with the\n  // information we have about our context. \n  if(ctx->share_context == NULL){\n    for(i=0;i<MAX_NUMBER_OF_SHARES;i++){\n      share_numbers[i]=(unsigned char)i+1;\n    }\n    ctx->share_context = gfshare_ctx_init_enc( share_numbers,\n                                               MAX_NUMBER_OF_SHARES-1,\n                                               ctx->threshold,\n                                               SHARE_LENGTH-ctx->partial_bytes);\n  }\n  \n  // we have an initialized share context, we set the recombined secret to it \n  // and set the unlock flag to one so it is ready to use.\n  gfshare_ctx_enc_setsecret(ctx->share_context, ctx->secret);\n  ctx->is_unlocked = true;\n  ctx->AES_key = ctx->secret;\n  \n  return PPH_ERROR_OK;\n    \n}\n\n\n\n\n\n/*******************************************************************\n* NAME :          pph_store_context\n*\n* DESCRIPTION :   store the information of the working context into a file. \n*                 Elements as the secret and the share context are not stored.\n*                 \n*\n* INPUTS :\n*   PARAMETERS:\n*     pph_context *ctx:              The context in which we are working\n*\n*     const unsigned char* filename: The filename of the datastore to use\n* OUTPUTS :\n*   PARAMETERS:\n*     None\n*     \n*   GLOBALS :\n*     None\n*   \n*   RETURN :\n*     Type: int PPH_ERROR     \n*           Values:                         When:\n*           PPH_ERROR_OK                      When the file was stored \n*                                             successfully.\n*\n*           PPH_BAD_PTR                       When pointers are null or out\n*                                             of range\n*           \n*           PPH_FILE_ERR                      when the file selected is non-\n*                                             writable. \n*\n*           PPH_ERROR_UNKNOWN                 any time else\n*           \n* PROCESS :\n*     * Sanitize the data (unset flags, point secret to NULL)\n*     * open the selected file.\n*     * traverse the dynamic linked lists storing everything\n*     * close the file, return appropriate error\n*\n* CHANGES :\n*     None as of this version\n*/\n\nPPH_ERROR pph_store_context(pph_context *ctx, const unsigned char *filename){\n  \n  \n  FILE *fp;\n  pph_account_node *current_node;\n\n  // we use a hard copy so we can mess with it without damaging the one from the\n  // user, he might want to keep using it and we need to set some values before\n  // writing. \n  pph_context context_to_store; \n  pph_entry *current_entry;  \n\n\n  // 1) sanitize the data\n  if(ctx == NULL || filename == NULL){\n    \n    return PPH_BAD_PTR;\n    \n  }\n \n\n  // we backup the context so we can mess with it without breaking anything. \n  memcpy(&context_to_store,ctx,sizeof(*ctx));\n\n  // NULL out the pointers, we won't store that, not even where it used to point\n  context_to_store.share_context = NULL;\n  context_to_store.AES_key = NULL;\n  context_to_store.secret = NULL;\n  context_to_store.account_data = NULL;\n\n  // set this context's information to locked.\n  context_to_store.is_unlocked = false; \n\n\n  // 2) open selected file\n  fp=fopen(filename,\"wb\");\n  if(fp==NULL){\n    \n    return PPH_FILE_ERR;\n    \n  }\n\n\n  // 3) write the context\n  fwrite(&context_to_store,sizeof(context_to_store),1,fp); \n\n  // traverse the list and write it too.\n  current_node = ctx->account_data;\n  while(current_node!=NULL){\n    \n    // write current node...\n    fwrite(current_node,sizeof(*current_node),1,fp);\n    \n    current_entry = current_node->account.entries;\n    while(current_entry != NULL){\n      \n      // write its entries\n      fwrite(current_entry,sizeof(*current_entry),1,fp);\n      current_entry = current_entry->next;\n    }\n    current_node = current_node->next;\n  }\n\n\n  // 4) close the file, return appropriate error\n  fclose(fp);\n    \n  return PPH_ERROR_OK;\n    \n}\n\n\n\n\n\n/*******************************************************************\n* NAME :          pph_reload_context\n*\n* DESCRIPTION :   Reload a pph_context stored in a file, the secret is\n*                 unknown and the structure is locked by default.\n*                 pph_unlock_password_data should be called after this returns\n*                 a valid pointer \n*\n* INPUTS :\n*   PARAMETERS:\n*     const unsigned char* filename: The filename of the datastore to use\n*\n* OUTPUTS :\n*   PARAMETERS:\n*     None\n*     \n*   GLOBALS :\n*     None\n*   \n*   RETURN :\n*     Type: pph_context * \n*\n*           Values:                         When:\n*            NULL                             The file is not loadable\n*                                             or data looks corrupted\n*           \n*            A valid pointer                  if everything went fine\n* \n* PROCESS :\n*     * Sanitize the data (check the string is a good string) \n*     * open the selected file.\n*     * Build a dynamic list by traversing the file's contents\n*     * close the file, return appropriate structure\n*\n* CHANGES :\n*     None as of this version\n*/\n\npph_context *pph_reload_context(const unsigned char *filename){\n\n\n  FILE *fp;\n  pph_context *loaded_context;\n  pph_account_node *accounts,*last,account_buffer;\n  pph_entry *entries, *last_entry, entry_buffer;\n  unsigned int i;\n\n\n  // 1) sanitize data\n  if(filename == NULL){\n    \n    return NULL;\n    \n  }\n\n\n  // 2) open selected file\n  fp= fopen(filename,\"rb\");\n  if(fp == NULL){\n    \n    return NULL;\n    \n  }\n  \n\n  // 3) load the context structure from the file. \n  loaded_context = malloc(sizeof(*loaded_context));\n  if(loaded_context == NULL){\n    \n    return NULL;\n    \n  }\n\n  fread(loaded_context,sizeof(*loaded_context),1,fp);\n  \n  // build the account and entry list out of the information from the file. \n  accounts = NULL;\n  while(fread(&account_buffer,sizeof(account_buffer),1,fp) != 0){\n    \n    // read an account\n    last = accounts;\n    accounts = malloc(sizeof(account_buffer));\n    memcpy(accounts,&account_buffer,sizeof(account_buffer));\n    last_entry = NULL;\n    for(i=0;i<account_buffer.account.number_of_entries;i++){\n      \n      // allocate the entry list for this account\n      entries = malloc(sizeof(*entries));\n      fread(entries,sizeof(*entries),1,fp);\n      entries->next = last_entry;\n      last_entry = entries;\n    }\n    accounts->account.entries = entries;\n    accounts->next = last;\n    last = accounts; \n  }\n  loaded_context->account_data = accounts;\n  \n\n  // 4) close the file.\n  fclose(fp);\n    \n  return loaded_context;\n    \n}\n\n\n\n\n\n/*******************************************************************\n* NAME :          PHS \n*\n* DESCRIPTION :   Generate a password hash, given the password, and salt. \n*                 This is a \"virtual\" interface and functions as a proof of\n*                 context for the password hashing competition. A context will\n*                 be initialized upon calling, and will be destroyed upon\n*                 return. No persistent setup is done in this function, and no\n*                 accounts are created. \n*\n* INPUTS :\n*   PARAMETERS:\n*     void *out:          The resulting hash buffer. The resulting hash will be\n*                         copied here. \n*\n*     size_t outlen:      The size of the hash to produce, this version only\n*                         supports 32 byte-length outputs. \n*\n*     const void *in:     The input password to hash.\n*\n*     size_t inlen:       The length of the input, the maximum supported length\n*                         is 128.\n*\n*     const void *salt:   The salt to use with the password\n*\n*     size_t saltlen:     The length of the salt to use. The maximum supported\n*                         length is 16\n*\n*     int tcost:          Time cost for this function. This parameter \n*                         translates directly to the threshold of the\n*                         generated context. With a bigger threshold, the time\n*                         to initialize a context rises. This value can't be 0.\n*\n*     int mcost:          Memory cost (unusable this time)\n*\n* OUTPUTS :\n*   PARAMETERS:\n*     None\n*     \n*   GLOBALS :\n*     None\n*   \n*   RETURN :\n*     Type: int\n*\n*           Values:                         When:\n*            0                                On error ok. \n*\n*            !=0                              In case of error.\n* \n* PROCESS :\n*     1) verify the input. \n*     2) Generate a pph_context if there is none in memory\n*     3) Generate a polyhashed entry\n*     4) Copy the polyhashed value to the output buffer\n*     5) Return.\n*\n* CHANGES :\n*     None as of this version\n*/\n\nint PHS(void *out, size_t outlen, const void *in, size_t inlen,\n   const void* salt, size_t saltlen, int tcost, int mcost){\n  \n\n  static pph_context *context = NULL;\n  pph_entry *generated_entry; \n  uint8 share[DIGEST_LENGTH];\n\n\n  // check we are given proper pointers\n  if(out == NULL || in == NULL || salt == NULL){\n    \n    return -1;\n    \n  }\n\n  // we only support 32 byte digests at the moment.\n  if(outlen != DIGEST_LENGTH){\n    \n    return -1;\n    \n  }\n\n  // check the input length\n  if(inlen < 1 || inlen > MAX_PASSWORD_LENGTH){\n    \n    return -1;\n    \n  }\n\n  // check the salt length\n  if(saltlen < 1 || saltlen > MAX_SALT_LENGTH){\n    \n    return -1;\n    \n  }\n\n  if(tcost < 1 || tcost > MAX_NUMBER_OF_SHARES){\n    \n    return -1;\n    \n  }\n\n  // remember, in our case, tcost maps directly to the threshold value, we also\n  // decided to leave no partial bytes to have the whole hash protected by the\n  // shares \n  context = pph_init_context(tcost,0);\n\n  // get a share to xor it with the password\n  gfshare_ctx_enc_getshare(context->share_context, context->next_entry, share);\n  context->next_entry++;\n  if(context->next_entry > MAX_NUMBER_OF_SHARES){\n    context->next_entry = 0;\n  }\n\n  // generate an entry.\n  generated_entry = create_polyhashed_entry( in, inlen, salt, saltlen,\n      share, DIGEST_LENGTH, context->partial_bytes);\n\n  // copy the resulting polyhash to the output\n  memcpy(out, generated_entry->polyhashed_value, outlen);\n\n  // free the generated entry\n  free(generated_entry);\n  pph_destroy_context(context);\n\n  return 0;\n    \n}\n\n\n\n\n\n\n\n// helper functions ///////////////////////\n\n\n// this generates a random secret of the form [stream][streamhash], the \n// parameters are the length of each section of the secret\n\nuint8 *generate_pph_secret(unsigned int stream_length,\n    unsigned int hash_length){\n  \n\n  uint8 *secret;\n  uint8 stream_digest[DIGEST_LENGTH];\n\n  // sanitize data\n  if(stream_length > DIGEST_LENGTH || stream_length < 1){\n    \n    return NULL;\n    \n  }\n\n  if(hash_length > DIGEST_LENGTH || hash_length < 1){\n    \n    return NULL;\n    \n  }\n\n  if(hash_length + stream_length > DIGEST_LENGTH){\n    \n    return NULL;\n    \n  }\n\n  // allocate memory\n  secret=malloc(sizeof(*secret)*DIGEST_LENGTH);\n  if(secret == NULL){\n    \n    return NULL;\n    \n  }\n\n  // generate a random stream\n  get_random_bytes(stream_length, secret);\n \n  // hash the rest of the \n  _calculate_digest(stream_digest, secret, stream_length);\n  memcpy(secret + stream_length, stream_digest, hash_length);\n\n  return secret;\n    \n}\n\n\n\n\n\n// this checks whether a given secret complies with the pph_secret prototype\n// ([stream][streamhash])\n\nPPH_ERROR check_pph_secret(uint8 *secret, unsigned int stream_length, \n    unsigned int hash_bytes){\n  \n  uint8 stream_digest[DIGEST_LENGTH];\n\n\n  // sanitize data\n  if(stream_length > DIGEST_LENGTH || stream_length < 1){\n    \n    return PPH_VALUE_OUT_OF_RANGE;\n    \n  }\n\n  if(hash_bytes > DIGEST_LENGTH || hash_bytes < 1){\n    \n    return PPH_VALUE_OUT_OF_RANGE;\n    \n  }\n\n  if(hash_bytes + stream_length > DIGEST_LENGTH){\n    \n    return PPH_VALUE_OUT_OF_RANGE;\n    \n  }\n\n  if(secret == NULL){\n    \n    return PPH_BAD_PTR;\n    \n  }\n\n\n  // generate the digest for the stream.\n  _calculate_digest(stream_digest, secret, stream_length);\n  \n  // compare both digests\n  if(memcmp(stream_digest, secret+stream_length, hash_bytes) == 0){\n    \n    return PPH_ERROR_OK;\n    \n  }\n\n  return PPH_SECRET_IS_INVALID;\n    \n}\n\n\n\n\n\n// this function provides a polyhashed entry given the input\n\npph_entry *create_polyhashed_entry(uint8 *password, unsigned int\n    password_length, uint8 *salt, unsigned int salt_length, uint8 *share,\n    unsigned int share_length, unsigned int partial_bytes){\n\n\n  pph_entry *entry_node = NULL;\n  \n  // we hold a buffer for the salted password.\n  uint8 salted_password[MAX_SALT_LENGTH+MAX_PASSWORD_LENGTH]; \n\n  // check input pointers are correct\n  if(password == NULL || salt == NULL || share == NULL){\n    \n    return NULL;\n    \n  }\n\n  // check for valid lengths\n  if(password_length > MAX_PASSWORD_LENGTH || salt_length > MAX_SALT_LENGTH){\n    \n    return NULL;\n    \n  }\n\n  // check for valid lengths on the share information\n  if(share_length > SHARE_LENGTH || partial_bytes > SHARE_LENGTH){\n    \n    return NULL;\n    \n  }\n\n  entry_node = malloc(sizeof(*entry_node));\n  if(entry_node==NULL){\n    \n    return NULL;\n\n  }\n    \n\n  // update the salt value in the entry\n  memcpy(entry_node->salt,salt, salt_length);\n  entry_node->salt_length = salt_length;\n  entry_node->password_length = password_length;\n\n  // prepend the salt to the password\n  memcpy(salted_password,salt,salt_length);\n  memcpy(salted_password+salt_length, password, password_length);\n\n  // hash the salted password\n  _calculate_digest(entry_node->polyhashed_value, salted_password,\n        salt_length + password_length);\n  \n  // xor the whole thing, with the share, we are doing operations in-place\n  // to make everything faster\n  _xor_share_with_digest(entry_node->polyhashed_value, share,\n        entry_node->polyhashed_value, share_length-partial_bytes);\n    \n  return entry_node;\n    \n}\n\n\n\n\n\n// this other function is the equivalent to the one in the top, but for\n// thresholdless accounts.\n\npph_entry *create_thresholdless_entry(uint8 *password, unsigned int\n    password_length, uint8* salt, unsigned int salt_length, uint8* AES_key,\n    unsigned int key_length, unsigned int partial_bytes){\n\n\n  pph_entry *entry_node = NULL;\n  uint8 salted_password[MAX_SALT_LENGTH + MAX_PASSWORD_LENGTH];\n\n  // openssl encryption contexts\n  EVP_CIPHER_CTX en_ctx;\n  int c_len,f_len;\n\n\n\n  // check everything makes sense, nothing should point to null\n  if(password == NULL || salt == NULL || AES_key == NULL){\n    \n    return NULL;\n    \n  }\n\n  // check for password and pass lengths\n  if(password_length > MAX_PASSWORD_LENGTH || salt_length > MAX_SALT_LENGTH){\n    \n    return NULL;\n    \n  }\n\n  // we check that the key is shorter than the digest we are using for\n  // ctr mode, but we could omit this, partial bytes should be shorter\n  // than the digest length since we cannot reveal more bytes than the ones\n  // we have.\n  if(key_length > DIGEST_LENGTH || partial_bytes > DIGEST_LENGTH){\n    \n    return NULL;\n    \n  }\n\n  // allocate memory and fail if there is not memory available.\n  entry_node = malloc(sizeof(*entry_node));\n  if(entry_node==NULL){\n    \n    return NULL;\n    \n  }\n\n  // copy the salt into the pph_entry\n  memcpy(entry_node->salt, salt, salt_length);\n  entry_node->salt_length = salt_length;\n  \n  // prepend the salt to the password and generate a digest\n  memcpy(salted_password,entry_node->salt,salt_length);\n  memcpy(salted_password+MAX_SALT_LENGTH, password, password_length); \n  _calculate_digest(entry_node->polyhashed_value,salted_password, \n      salt_length + password_length); \n\n  // encrypt the generated digest\n  EVP_CIPHER_CTX_init(&en_ctx);\n  EVP_EncryptInit_ex(&en_ctx, EVP_aes_256_ctr(), NULL, AES_key, NULL);\n  EVP_EncryptUpdate(&en_ctx, entry_node->polyhashed_value, &c_len,\n      entry_node->polyhashed_value, DIGEST_LENGTH-partial_bytes);\n  EVP_EncryptFinal_ex(&en_ctx, entry_node->polyhashed_value+c_len, &f_len);\n  EVP_CIPHER_CTX_cleanup(&en_ctx);\n\n\n  // thresholdless accounts have this value defaulted to 0;\n  entry_node->share_number = 0;\n\n  // thresholdless accounts should have only one entry\n  entry_node->next = NULL;\n\n  return entry_node;  \n\n}\n\n\n\n\n\n\n// This is a private helper that produces a salt string,\n\nvoid get_random_bytes(unsigned int length, uint8 *dest){\n    \n    \n  unsigned int i=0;\n  int fp;\n\n    \n  fp = open(\"/dev/urandom\",O_RDONLY);\n  while(i<length){\n    i += read(fp,dest,length);\n  }\n  close(fp);\n\n}\n\n\n"
        },
        {
            "file_name": "Lyra2.c",
            "content": "/**\n * Implementation of the Lyra2 Password Hashing Scheme (PHS).\n *\n * Author: The Lyra PHC team (http://www.lyra-kdf.net/) -- 2014.\n *\n * This software is hereby placed in the public domain.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"Lyra2.h\"\n#include \"Sponge.h\"\n\n/**\n * Executes Lyra2 based on the G function from Blake2b. The number of columns of the memory matrix is set to nCols = 64.\n * This version supports salts and passwords whose combined length is smaller than the size of the memory matrix,\n * (i.e., (nRows x nCols x b) bits, where \"b\" is the underlying sponge's bitrate). In this implementation, the \"basil\" \n * is composed by all integer parameters in the order they are provided, plus the value of nCols, \n * (i.e., basil = kLen || pwdlen || saltlen || timeCost || nRows || nCols).\n *\n * @param out The derived key to be output by the algorithm\n * @param outlen Desired key length\n * @param in User password\n * @param inlen Password length\n * @param salt Salt\n * @param saltlen Salt length\n * @param t_cost Parameter to determine the processing time (T)\n * @param m_cost Memory cost parameter (defines the number of rows of the memory matrix, R)\n *\n * @return 0 if the key is generated correctly; -1 if there is an error (usually due to lack of memory for allocation)\n */\nint PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost) {\n    return LYRA2(out, outlen, in, inlen, salt, saltlen, t_cost, m_cost, N_COLS);\n}\n\ninline void print64(uint64_t *v) {\n    int i;\n    for (i = 0; i < 16; i++) {\n\tprintf(\"%ld|\", v[i]);\n    }\n    printf(\"\\n\");\n}\n\n/**\n * Executes Lyra2 based on the G function from Blake2b. This version supports salts and passwords\n * whose combined length is smaller than the size of the memory matrix, (i.e., (nRows x nCols x b) bits,\n * where \"b\" is the underlying sponge's bitrate). In this implementation, the \"basil\" is composed by all \n * integer parameters, in the order they are provided (i.e., basil = kLen || pwdlen || saltlen || timeCost || nRows || nCols).\n *\n * @param K The derived key to be output by the algorithm\n * @param kLen Desired key length\n * @param pwd User password\n * @param pwdlen Password length\n * @param salt Salt\n * @param saltlen Salt length\n * @param timeCost Parameter to determine the processing time (T)\n * @param nRows Number or rows of the memory matrix (R)\n * @param nCols Number of columns of the memory matrix (C)\n *\n * @return 0 if the key is generated correctly; -1 if there is an error (usually due to lack of memory for allocation)\n */\nint LYRA2(unsigned char *K, int kLen, const unsigned char *pwd, int pwdlen, const unsigned char *salt, int saltlen, int timeCost, int nRows, int nCols) {\n\n    //============================= Basic variables ============================//\n    int row = 2; //index of row to be processed\n    int prev = 1; //index of prev (last row ever computed/modified)\n    int rowa = 0; //index of row* (a previous row, deterministically picked during Setup and randomly picked during Wandering)\n    int tau; //Time Loop iterator\n    int i; //auxiliary iteration counter\n    //==========================================================================/\n\n\n    //========== Initializing the Memory Matrix and pointers to it =============//\n    //Allocates enough space for the whole memory matrix\n    uint64_t *wholeMatrix = malloc(nRows * ROW_LEN_BYTES);\n    if (wholeMatrix == NULL) {\n\treturn -1;\n    }\n    //Allocates pointers to each row of the matrix\n    uint64_t **memMatrix = malloc(nRows * sizeof (uint64_t*));\n    if (memMatrix == NULL) {\n\treturn -1;\n    }\n    //Places the pointers in the correct positions\n    uint64_t *ptrWord = wholeMatrix;\n    for (i = 0; i < nRows; i++) {\n\tmemMatrix[i] = ptrWord;\n\tptrWord += ROW_LEN_INT64;\n    }\n    //==========================================================================/\n\n    //============= Getting the password + salt + basil padded with 10*1 ===============//\n\n    //OBS.:The memory matrix will temporarily hold the password: not for saving memory,\n    //but this ensures that the password copied locally will be overwritten as soon as possible\n\n    //First, we clean enough blocks for the password, salt, basil and padding\n    int nBlocksInput = ((saltlen + pwdlen + 6*sizeof(int)) / BLOCK_LEN_BYTES) + 1;\n    byte *ptrByte = (byte*) wholeMatrix;\n    memset(ptrByte, 0, nBlocksInput * BLOCK_LEN_BYTES);\n\n    //Prepends the password\n    memcpy(ptrByte, pwd, pwdlen);\n    ptrByte += pwdlen;\n    \n    //Concatenates the salt\n    memcpy(ptrByte, salt, saltlen);\n    ptrByte += saltlen;\n    \n    //Concatenates the basil: every integer passed as parameter, in the order they are provided by the interface\n    memcpy(ptrByte, &kLen, sizeof(int));\n    ptrByte += sizeof(int);\n    memcpy(ptrByte, &pwdlen, sizeof(int));\n    ptrByte += sizeof(int);\n    memcpy(ptrByte, &saltlen, sizeof(int));\n    ptrByte += sizeof(int);\n    memcpy(ptrByte, &timeCost, sizeof(int));\n    ptrByte += sizeof(int);\n    memcpy(ptrByte, &nRows, sizeof(int));\n    ptrByte += sizeof(int);\n    memcpy(ptrByte, &nCols, sizeof(int));\n    ptrByte += sizeof(int);\n    \n\n    //Now comes the padding\n    *ptrByte = 0x80; //first byte of padding: right after the password\n    ptrByte = (byte*) wholeMatrix; //resets the pointer to the start of the memory matrix\n    ptrByte += nBlocksInput * BLOCK_LEN_BYTES - 1; //sets the pointer to the correct position: end of incomplete block\n    *ptrByte ^= 0x01; //last byte of padding: at the end of the last incomplete block\n\n    //==========================================================================/\n\n    //======================= Initializing the Sponge State ====================//\n    //Sponge state: 16 uint64_t, BLOCK_LEN_INT64 words of them for the bitrate (b) and the remainder for the capacity (c)\n    uint64_t *state = malloc(16 * sizeof (uint64_t));\n    if (state == NULL) {\n\treturn -1;\n    }\n    initState(state);\n    //==========================================================================/\n\n    //================================ Setup Phase =============================//\n\n    //Absorbing salt, password and basil\n    ptrWord = wholeMatrix;\n    for (i = 0; i < nBlocksInput; i++) {\n\tabsorbBlock(state, ptrWord); //absorbs each block of pad(pwd || salt || basil)\n\tptrWord += BLOCK_LEN_INT64; //goes to next block of pad(pwd || salt || basil)\n    }\n\n    //Initializes M[0] and M[1]\n    reducedSqueezeRow(state, memMatrix[0]); //The locally copied password is most likely overwritten here\n    reducedSqueezeRow(state, memMatrix[1]);\n\n    do {\n\t//M[row] = rand; //M[row*] = M[row*] XOR rotW(rand)\n\treducedDuplexRowSetup(state, memMatrix[prev], memMatrix[rowa], memMatrix[row]);\n\n\t//updates the value of row* (deterministically picked during Setup))\n\trowa--;\n\tif (rowa < 0) {\n\t    rowa = prev;\n\t}\n\t//update prev: it now points to the last row ever computed\n\tprev = row;\n\t//updates row: does to the next row to be computed\n\trow++;\n    } while (row < nRows);\n    //==========================================================================/\n\n    //============================ Wandering Phase =============================//\n    int maxIndex = nRows - 1;\n    for (tau = 1; tau <= timeCost; tau++) {\n\t//========= Iterations for an odd tau ==========\n\trow = maxIndex; //Odd iterations of the Wandering phase start with the last row ever computed\n\tprev = 0; //The companion \"prev\" is 0\n\tdo {\n\t    //Selects a pseudorandom index row*\n\t    //rowa = ((unsigned int)state[0] ^ prev) & maxIndex; //(USE THIS IF nRows IS A POWER OF 2)\n\t    rowa = ((unsigned int) (state[0] ^ prev)) % nRows; //(USE THIS FOR THE \"GENERIC\" CASE)\n\n\t    //Performs a reduced-round duplexing operation over M[row*] XOR M[prev], updating both M[row*] and M[row]\n\t    reducedDuplexRow(state, memMatrix[prev], memMatrix[rowa], memMatrix[row]);\n\n\t    //Goes to the next row (inverse order)\n\t    prev = row;\n\t    row--;\n\t} while (row >= 0);\n\n\tif (++tau > timeCost) {\n\t    break; //end of the Wandering phase\n\t}\n\n\t//========= Iterations for an even tau ==========\n\trow = 0; //Even iterations of the Wandering phase start with row = 0\n\tprev = maxIndex; //The companion \"prev\" is the last row in the memory matrix\n\tdo {\n\t    //rowa = ((unsigned int)state[0] ^ prev) & maxIndex; //(USE THIS IF nRows IS A POWER OF 2)\n\t    rowa = ((unsigned int) (state[0] ^ prev)) % nRows; //(USE THIS FOR THE \"GENERIC\" CASE)\n\n\t    //Performs a reduced-round duplexing operation over M[row*] XOR M[prev], updating both M[row*] and M[row]\n\t    reducedDuplexRow(state, memMatrix[prev], memMatrix[rowa], memMatrix[row]);\n\n\t    //Goes to the next row (direct order)\n\t    prev = row;\n\t    row++;\n\t} while (row <= maxIndex);\n    }\n    //==========================================================================/\n\n    //============================ Wrap-up Phase ===============================//\n    //Absorbs the last block of the memory matrix\n    absorbBlock(state, memMatrix[rowa]);\n\n    //Squeezes the key\n    squeeze(state, K, kLen);\n    //==========================================================================/\n\n    //========================= Freeing the memory =============================//\n    free(memMatrix);\n    free(wholeMatrix);\n    \n    //Wiping out the sponge's internal state before freeing it\n    memset(state, 0, 16 * sizeof (uint64_t));\n    free(state);\n    //==========================================================================/\n\n    return 0;\n}"
        },
        {
            "file_name": "m3lcrypt.c",
            "content": "/********************************************************************\n *\n *      FILE \t   :m3l_crypt.c\n *\n *      DATE\t   :18/03/14\n *      VERSION\t   :1.0\n *\n *      CONTENTS   :The M3l_crypt PBKDF reference implementation\n *\tREFERENCES :Makwakwa, I., \"The M3l_crypt_H PBKDF\",\n * \t\t    PHC Competition Submission, March 2014 \n *\n\\********************************************************************/\n\n\n#include \"m3lcrypt.h\" \n\n#if defined(__cplusplus)\nextern \"C\"\n{\n#endif\n\nvoid PHS\n(\n\tvoid *out,\t\t\t/* output buffer\t*/\n\tsize_t outlen,\t\t\t/* output length\t*/\n\tconst void *in,\t\t\t/* secret key\t \t*/\n\tsize_t inlen,\t\t\t/* key length\t \t*/\n\tvoid *salt,\t\t\t/* salt\t\t \t*/\n\tsize_t saltlen,\t\t\t/* salt length\t \t*/\n\tunsigned int t_cost,\t\t/* time cost\t \t*/\n\tunsigned int m_cost\t\t/* memory cost\t \t*/\n)\n{\n#if defined(_64BIT)\n\tuint64_t digest[DIGEST_SIZE >> 3];\n\tuint64_t shash[DIGEST_SIZE >> 3];\n\tuint64_t h[2*(DIGEST_SIZE >> 3)];\n\tuint64_t X[m_cost][DIGEST_SIZE >> 3];\n\tuint64_t V[_VSIZE][DIGEST_SIZE >> 3];\n\tint hlen = (DIGEST_SIZE >> 3);\n#else\n\tuint32_t digest[DIGEST_SIZE >> 2];\n\tuint32_t shash[DIGEST_SIZE >> 2];\n\tuint32_t h[2*(DIGEST_SIZE >> 2)];\n\tuint32_t X[m_cost][DIGEST_SIZE >> 2];\n\tuint32_t V[_VSIZE][DIGEST_SIZE >> 2];\n\tint hlen = (DIGEST_SIZE >> 2);\n#endif\n\tunsigned int k,i = 0,mask0 = m_cost-1,mask1 = _VSIZE-1;\n\tint pos;\n\n\t/* obtain H(in ^ ipad) and H(in ^ opad) */\n\n\tPRF_init((unsigned char *)h,(const unsigned char *)in,inlen);\n\n\thash_ctx\tctx;\n\n\tctx_reinit(&ctx,(unsigned char *)h);\n\t(*f_hash)((const unsigned char *)salt,saltlen,&ctx); \n\t(*f_hash)((const unsigned char *)&t_cost,4,&ctx);\n\t(*f_hash)((const unsigned char *)&i,4,&ctx);\n\t(*f_end)((void *)digest,&ctx);\n\n\tctx_reinit(&ctx,(unsigned char *)&h[hlen]);\n\t(*f_hash)((const unsigned char *)digest,DIGEST_SIZE,&ctx);\n\t(*f_end)((void *)X[0],&ctx);\n\n\tfor (i=1;i<m_cost;i++){\n\n\t\tctx_reinit(&ctx,(unsigned char *)h);\n\t\t(*f_hash)((const unsigned char *)X[i-1],DIGEST_SIZE,&ctx);\n\t\t(*f_hash)((const unsigned char *)&t_cost,4,&ctx);\n\t\t(*f_hash)((const unsigned char *)&i,4,&ctx);\n\t\t(*f_end)((void *)digest,&ctx);\n\n\t\tctx_reinit(&ctx,(unsigned char *)&h[hlen]);\n\t\t(*f_hash)((const unsigned char *)digest,DIGEST_SIZE,&ctx);\n\t\t(*f_end)((void *)X[i],&ctx);\n\t}\n\n\t/* obtain H(salt ^ ipad) and H(salt ^ opad) */\n\n\tPRF_init((unsigned char *)h,(const unsigned char *)salt,saltlen);\n\n\tctx_reinit(&ctx,(unsigned char *)h);\n\t(*f_hash)((const unsigned char *)in,inlen,&ctx);\n\t(*f_hash)((const unsigned char *)X[m_cost-1],DIGEST_SIZE,&ctx);\n\t(*f_end)((void *)shash,&ctx);\n\n\tctx_reinit(&ctx,(unsigned char *)&h[hlen]);\n\t(*f_hash)((const unsigned char *)shash,DIGEST_SIZE,&ctx);\n\t(*f_end)((void *)shash,&ctx);\n\n\t/* obtain H(shash ^ ipad) and H(shash ^ opad) */\n\n\tPRF_init((unsigned char *)h,(const unsigned char *)shash,DIGEST_SIZE);\n\n#if defined(_64BIT)\n\tuint64_t *dp = (uint64_t *)X[m_cost-1];\n#else\n\tuint32_t *dp = (uint32_t *)X[m_cost-1];\n#endif\n\n\tfor (i=0;i<t_cost;i++){\n\n\t\tk   = dp[0] & mask0;\n\t\tpos = i & mask1;\n\n\t\tctx_reinit(&ctx,(unsigned char *)h);\n\t\t(*f_hash)((const unsigned char *)X[k],DIGEST_SIZE,&ctx);\n\t\t(*f_hash)((const unsigned char *)dp,DIGEST_SIZE,&ctx);\n\t\t(*f_hash)((const unsigned char *)&i,4,&ctx);\n\t\t(*f_end)((void *)digest,&ctx);\n\n\t\tctx_reinit(&ctx,(unsigned char *)&h[hlen]);\n\t\t(*f_hash)((const unsigned char *)digest,DIGEST_SIZE,&ctx);\n\t\t(*f_end)((void *)V[pos],&ctx);\n\t\t\n#if defined(_64BIT)\n\t\tdp = (uint64_t *)V[pos];\n#else\n\t\tdp = (uint32_t *)V[pos];\n#endif\n\t}\n\t\n\tctx_reinit(&ctx,(unsigned char *)h);\n\t(*f_hash)((const unsigned char *)in,inlen,&ctx);\n\t(*f_hash)((const unsigned char *)salt,saltlen,&ctx);\n\t(*f_hash)((const unsigned char *)dp,DIGEST_SIZE,&ctx);\n\t(*f_hash)((const unsigned char *)&t_cost,4,&ctx);\n\t(*f_end)((void *)shash,&ctx);\n\n\tctx_reinit(&ctx,(unsigned char *)&h[hlen]);\n\t(*f_hash)((const unsigned char *)shash,DIGEST_SIZE,&ctx);\n\t(*f_end)((void *)shash,&ctx);\n\t\t\n\tint r = (outlen % DIGEST_SIZE);\n\tunsigned int l = (unsigned int)(outlen / DIGEST_SIZE);\n\tl = ((r) ? (l+1) : l);\n\t\n\t/* obtain H(shash ^ ipad) and H(shash ^ opad) */\n\n\tPRF_init((unsigned char *)h,(const unsigned char *)shash,DIGEST_SIZE);\n\n\tunsigned char *tp = (unsigned char *)out;\n\n\tfor (i=0;i<l;i++){\n\n\t\tctx_reinit(&ctx,(unsigned char *)h);\n\t\t(*f_hash)((const unsigned char *)in,inlen,&ctx);\n\t\t(*f_hash)((const unsigned char *)dp,DIGEST_SIZE,&ctx);\n\t\t\n\t\tint j;\n\t\tfor (j=0;j<_VSIZE;j++)\n\t\t\t(*f_hash)((const unsigned char *)V[j],DIGEST_SIZE,&ctx);\n\t\t(*f_end)((void *)digest,&ctx);\n\n\t\tctx_reinit(&ctx,(unsigned char *)&h[hlen]);\n\t\t(*f_hash)((const unsigned char *)digest,DIGEST_SIZE,&ctx);\n\n\t\tif ((i == (l-1)) && (r)){\n\t\t\t(*f_end)((void *)digest,&ctx);\n\t\t\tmemcpy(tp,digest,r);\n\t\t}else{\n\t\t\t(*f_end)((void *)tp,&ctx);\n#if defined(_64BIT)\n\t\t\tdp = (uint64_t *)tp;\n#else\n\t\t\tdp = (uint32_t *)tp;\n#endif\n\t\t\tif (i < (l-1))\n\t\t\t\ttp += DIGEST_SIZE;\n\t\t}\t\n\t}\n\t\n\tmemset(digest,0,DIGEST_SIZE);\n\tmemset(shash,0,DIGEST_SIZE);\n\tmemset(h,0,2*DIGEST_SIZE);\n\tmemset(X,0,m_cost*DIGEST_SIZE);\n\tmemset(V,0,_VSIZE*DIGEST_SIZE);\n\tmemset(&ctx,0,sizeof(ctx));\n}\n\nvoid PRF_init\n(\n\tunsigned char *h,\t\t/* output buffer */\n\tconst unsigned char *key,\t/* secret key\t */\n\tunsigned long int klen\t\t/* key length\t */\n)\n{\n\thash_ctx\tctx;\n\n\t/* alignment functions below due to Ulrich Drepper - as in SHA2crypt */\n#if defined(_64BIT)\n\tunsigned char\tk[BLOCK_SIZE]\n\t__attribute__((__aligned__(__alignof__(uint64_t))));\n#else\n\tunsigned char\tk[BLOCK_SIZE]\n\t__attribute__((__aligned__(__alignof__(uint32_t))));\n#endif\n\tunsigned char *s = (unsigned char *)key;\n\tint i;\n\n\tif (klen > BLOCK_SIZE){\n\n\t\t(*f_begin)(&ctx);\n\t\t(*f_hash)(key,klen,&ctx);\n\t\t(*f_end)((void *)k,&ctx);\n\n\t\ts = k;\n\t\tklen = DIGEST_SIZE;\n\t}\n\t\n\t/*** inner key ***/\n\n\tfor (i=0;i<klen;i++)\n\t\tk[i] = s[i]^0x36;\n\tfor (i=klen;i<BLOCK_SIZE;i++)\n\t\tk[i] = 0x36;\n\n\t(*f_begin)(&ctx);\n\t(*f_hash)((const unsigned char *)k,BLOCK_SIZE,&ctx);\n\t(*f_end)((void *)&h[0],&ctx);\n\n\t/*** outer key ***/\n\n\t/* \n\t   note that k[i] = key[i] ^ 0x36 and\n\t   0x36 ^ 0x5c = 0x6a \t\t\t\n\t*/\n\n\tfor (i=0;i<BLOCK_SIZE;i++)\n\t\tk[i] ^= 0x6a;\n\n\t(*f_begin)(&ctx);\n\t(*f_hash)((const unsigned char *)k,BLOCK_SIZE,&ctx);\n\t(*f_end)((void *)&h[DIGEST_SIZE],&ctx);\n\n\t/*** clear buffers ***/\n\n\tmemset(k,0,BLOCK_SIZE);\n\tmemset(&ctx,0,sizeof(ctx));\n}\n\n/* adopted from Brian Gladman in his SHA*_begin functions for the SHA2 hash family */\n\nvoid ctx_reinit(hash_ctx *ctx,unsigned char *hkey)\n{\n\t/* initialise context */\n\n\tctx->count[0] = ctx->count[1] = 0;\n\tmemcpy((unsigned char *)ctx->hash,hkey,DIGEST_SIZE);\n}\n\n#if defined(__cplusplus)\n}\n#endif\n"
        },
        {
            "file_name": "main.c",
            "content": "#include <stdio.h>\n#include <string.h>\n\nvoid icepole_main();\n\nint main() {\n\n\n\tvolatile uint32_t count;\n\t// addresses of registers\n\tvolatile uint32_t *DWT_CONTROL = (uint32_t *)0xE0001000;\n\tvolatile uint32_t *DWT_CYCCNT = (uint32_t *)0xE0001004;\n\tvolatile uint32_t *DEMCR = (uint32_t *)0xE000EDFC;\n\t     // enable the use DWT\n\t     *DEMCR = *DEMCR | 0x01000000;\n\t     count=0;\n\t     // Reset cycle counter\n\t     *DWT_CYCCNT = 0;\n\t     // enable cycle counter\n\t     *DWT_CONTROL = *DWT_CONTROL | 1 ;\n\n\n\n\n/*----------------------------------------- USER INPUT -----------------------------------------------------*/\n\t     char message[] = \"This is a test message for ICEPOLE testing\";\n\n\n\t     // Copy paste the cipher text below if already having the cipher text and change executionMode = 1 (i.e. Decryption only)\n\t     //Else it the encrypted text of the plain message will be used as a cipher text automatically.\n\t     char cipherText[] = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";\n\n\t     char key[] = \"\\x41\\x4e\\x45\\x57\\x4b\\x45\\x59\\x46\\x4f\\x52\\x54\\x45\\x53\\x54\\x49\\x4e\";\n\t     char nonce[] = \"\\x63\\x73\\x6f\\x6d\\x65\\x67\\x68\\x65\\x78\\x0d\\x0a\\x69\\x5A\\x4B\\x1E\\x0F\";\n\t\t char secret[] = \"\\x74\\x65\\x73\\x74\\x69\\x6e\\x67\\x63\\x69\\x70\\x68\\x65\\x72\\xB4\\x86\\x57\";\n\t\t char ad[] = \"\\xbb\\x70\\x50\\x86\\x3b\\x50\\x40\\x89\\xAB\\xCD\\xEF\\xF0\\xE1\\xD2\\xC3\\xC5\";\n\t\t int adlen = strlen(ad)+1;\n\t\t int mlen = strlen(message);\n\t\t int clen = 0;\n\n\t\t int executionMode = 2;\t\t\t // 0 : Encryption only\n\t\t \t \t \t \t \t // 1 : Decryption only\n\t\t \t \t \t \t \t // 2 : Both Encryption and Decryption\n\n/*----------------------------------------- USER INPUT -----------------------------------------------------*/\n\n\n\n\n\t\tchar decryptedMessage[] = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";\n \t\tchar tag[] = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";\n\n\n\n\t\t if (executionMode==0) {\n\t\t\t   \tchar *encryptionParameters[] = {key, message, nonce,\tad, secret, mlen, adlen};\n\t\t\t    icepole_main(encryptionParameters, cipherText, 0);\n\t\t\t }\n\t\t else if (executionMode==1) {\n\t\t\t    clen = strlen(cipherText);\n\t\t\t    char *decryptionParameters[] = {key, cipherText, nonce, ad, secret, clen, adlen};\n\t\t\t   \ticepole_main(decryptionParameters, decryptedMessage, 1, tag);\n\t\t}\n\t\telse if (executionMode==2) {\n\t\t\t\tchar *encryptionParameters[] = {key, message, nonce,\tad, secret, mlen, adlen};\n\t\t\t\ticepole_main(encryptionParameters, cipherText, 0);\n\t\t\t\tclen = strlen(cipherText);\n\t\t\t\tchar *decryptionParameters[] = {key, cipherText, nonce, ad, secret, clen, adlen};\n\t\t\t\ticepole_main(decryptionParameters, decryptedMessage, 1, tag);\n\t\t}\n\n\n\n\t     // number of cycles stored in count variable\n\t     count = *DWT_CYCCNT;\n\t     //you can view the count variable while debugging by selecting\n\t     //View Menu -> \"variables\" tab\n\nreturn 0;\n}\n\n\n\n\n"
        },
        {
            "file_name": "main.cpp",
            "content": "#include <string.h>\n#include <iostream>\n#include \"keccak.h\"\n#include \"gambit.h\"\n\n/* DISCLAIMER\n * This is NOT a reference implementation!\n * This is a quick and dirty implementation. The software is not thoroughly\n * tested, and not at all tested on platforms other than Intel x86,\n * Windows OS, and CodeBlocks/GNU compiler. Once tested and verified, the\n * purpose of this program is to print test vectors to stdout that can\n * be compared to the output of another implementation.\n */\n\nusing namespace std;\nusing namespace keccak;\nusing namespace gambit;\n\nvoid coutarray(uint8_t *buf, int len)\n{\n    for (int i=0; i < len; i++)\n        cout << std::hex << (int)(buf[i]/16) << (int)(buf[i]%16) << std::dec;\n}\n\nvoid test256(salt &salt, const char *pwd, unsigned int pwd_len,\n             const uint64_t* ROM, unsigned int ROM_len,\n             unsigned int t, unsigned int m)\n{\n    seed256 sd;\n    gambit256(salt, pwd, pwd_len, ROM, ROM_len, t, m, sd);\n    cout << \"  sd256: \";\n    coutarray(sd, 32);\n    cout << endl;\n}\n\nvoid test512(salt &salt, const char *pwd, unsigned int pwd_len,\n             const uint64_t* ROM, unsigned int ROM_len,\n             unsigned int t, unsigned int m)\n{\n    seed512 sd;\n    gambit512(salt, pwd, pwd_len, ROM, ROM_len, t, m, sd);\n    cout << \"  sd512: \";\n    coutarray(sd, 32);\n    cout << endl << \"         \";\n    coutarray(sd+32, 32);\n    cout << endl;\n}\n\nint main()\n{\n    cout << \"state size: \" << sizeof(keccak_state) << endl;\n\n    keccak_state A;\n    cout << std::hex;\n    cout << \"state after init: \" << A.word_read(0) << \",\"\n                                 << A.word_read(1) << \", ...\" << endl;\n    A.f();\n    cout << \"state after f(): \" << A.word_read(0) << \",\"\n                                << A.word_read(1) << \", ...\" << endl;\n\n    salt salt;\n    char pwd[151];\n    unsigned int pwd_len = 0;\n    unsigned int t = 128;\n    unsigned int m = 511;\n    uint64_t ROM[128] = {0};\n    unsigned int ROM_len = 1;\n\n    cout << endl << \"SALT\" << endl;\n    for (int i = 1; i <= 128; i*=2)\n    {\n        memset(salt, 0, sizeof(salt));\n        salt[15 - ((i-1) / 8)] = (1 << ((i-1) % 8));\n        cout << \"salt: \";\n        coutarray(salt, 16);\n        cout << endl;\n        test256(salt, pwd, pwd_len, ROM, ROM_len, t, m);\n        test512(salt, pwd, pwd_len, ROM, ROM_len, t, m);\n    }\n    memset(salt, 0, sizeof(salt));\n\n    cout << endl << \"PASSWORD\" << endl;\n    for (int i = 2; i > -3; i--)\n    {\n        memset(pwd, 0x00, 152);\n        cout << \"pwd: \" << std::dec << (i+152)%152 << \" * 0x00\" << endl;\n        test256(salt, pwd, (i+152)%152, ROM, ROM_len, t, m);\n        cout << \"pwd: \" << std::dec << (i+120)%120 << \" * 0x00\" << endl;\n        test512(salt, pwd, (i+120)%120, ROM, ROM_len, t, m);\n        if (i != 0)\n        {\n            memset(pwd, 0x01, 152);\n            cout << \"pwd: \" << std::dec << (i+152)%152 << \" * 0x01\" << endl;\n            test256(salt, pwd, (i+152)%152, ROM, ROM_len, t, m);\n            cout << \"pwd: \" << std::dec << (i+120)%120 << \" * 0x01\" << endl;\n            test512(salt, pwd, (i+120)%120, ROM, ROM_len, t, m);\n\n            memset(pwd, 0x4A, 152);\n            cout << \"pwd: \" << std::dec << (i+152)%152 << \" * 0x4A\" << endl;\n            test256(salt, pwd, (i+152)%152, ROM, ROM_len, t, m);\n            cout << \"pwd: \" << std::dec << (i+120)%120 << \" * 0x4A\" << endl;\n            test512(salt, pwd, (i+120)%120, ROM, ROM_len, t, m);\n\n            memset(pwd, 0xFF, 152);\n            cout << \"pwd: \" << std::dec << (i+152)%152 << \" * 0xFF\" << endl;\n            test256(salt, pwd, (i+152)%152, ROM, ROM_len, t, m);\n            cout << \"pwd: \" << std::dec << (i+120)%120 << \" * 0xFF\" << endl;\n            test512(salt, pwd, (i+120)%120, ROM, ROM_len, t, m);\n        }\n    }\n\n    cout << endl << \"T/M\" << endl;\n    for (t = 1; t < 40000; t = t*9/4)\n    {\n        for (m = (t * 21 / 2 - 1) | 1; m > 0; m = (m==1)? 0 : (m / 3) | 1)\n        {\n            cout << std::dec << \"t: \" << t << \" m: \" << m << endl;\n            test256(salt, pwd, pwd_len, ROM, ROM_len, t, m);\n        }\n        for (m = (t * 17 / 2 - 1) | 1; m > 0; m = (m==1)? 0 : (m / 3) | 1)\n        {\n            cout << std::dec << \"t: \" << t << \" m: \" << m << endl;\n            test512(salt, pwd, pwd_len, ROM, ROM_len, t, m);\n        }\n    }\n\n    cout << endl << \"DERIVATION\" << endl;\n    pwd_len = 0;\n    t = 16;\n    m = 25;\n\n    {\n        seed256 sd;\n        dkid256 dkid;\n        uint8_t key[16];\n\n        gambit256(salt, pwd, pwd_len, ROM, ROM_len, t, m, sd);\n        for (int i = 1; i <= 1024; i*=2)\n        {\n            memset(dkid, 0, sizeof(dkid));\n            dkid[((i-1) / 8)] = (1 << ((i-1) % 8));\n            gambit256(sd, dkid, key, 16);\n            cout << \"256 dkid: bit\" << i-1 << \" set\" << endl << \"  key: \";\n            coutarray(key, 16);\n            cout << endl;\n        }\n    }\n\n    {\n        seed512 sd;\n        dkid512 dkid;\n        uint8_t key[16];\n\n        gambit512(salt, pwd, pwd_len, ROM, ROM_len, t, m, sd);\n        for (int i = 1; i <= 1024; i*=2)\n        {\n            memset(dkid, 0, sizeof(dkid));\n            dkid[((i-1) / 8)] = (1 << ((i-1) % 8));\n            gambit512(sd, dkid, key, 16);\n            cout << \"512 dkid: bit\" << i-1 << \" set\" << endl << \"  key: \";\n            coutarray(key, 16);\n            cout << endl;\n        }\n    }\n\n    return 0;\n}\n"
        },
        {
            "file_name": "makeKAT.c",
            "content": "/*\n * -----------------------------------------------------------------------\n * (c) Thomas Pornin 2014. This software is provided 'as-is', without\n * any express or implied warranty. In no event will the author be held\n * liable for any damages arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to no restriction.\n *\n * Technical remarks and questions can be addressed to:\n * <pornin@bolet.org>\n * -----------------------------------------------------------------------\n */\n\n/*\n * This command-line tool generates known-answer test values, to be\n * compared with the reference file.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * We use OpenSSL's SHA-256 implementation to compute an aggregate hash\n * of all KAT outputs.\n */\n#include <openssl/sha.h>\n\n#include \"makwa.h\"\n\n/*\n * A conventional Makwa modulus (2048 bits).\n */\nstatic const unsigned char PUB2048[] = {\n\t0x55, 0x41, 0x4d, 0x30, 0x01, 0x00, 0xc2, 0x2c,\n\t0x40, 0xbb, 0xd0, 0x56, 0xbb, 0x21, 0x3a, 0xad,\n\t0x7c, 0x83, 0x05, 0x19, 0x10, 0x1a, 0xb9, 0x26,\n\t0xae, 0x18, 0xe3, 0xe9, 0xfc, 0x96, 0x99, 0xc8,\n\t0x06, 0xe0, 0xae, 0x5c, 0x25, 0x94, 0x14, 0xa0,\n\t0x1a, 0xc1, 0xd5, 0x2e, 0x87, 0x3e, 0xc0, 0x80,\n\t0x46, 0xa6, 0x8e, 0x34, 0x4c, 0x8d, 0x74, 0xa5,\n\t0x08, 0x95, 0x28, 0x42, 0xef, 0x0f, 0x03, 0xf7,\n\t0x1a, 0x6e, 0xdc, 0x07, 0x7f, 0xaa, 0x14, 0x89,\n\t0x9a, 0x79, 0xf8, 0x3c, 0x3a, 0xe1, 0x36, 0xf7,\n\t0x74, 0xfa, 0x6e, 0xb8, 0x8f, 0x1d, 0x1a, 0xea,\n\t0x5e, 0xa0, 0x2f, 0xc0, 0xcc, 0xaf, 0x96, 0xe2,\n\t0xce, 0x86, 0xf3, 0x49, 0x0f, 0x49, 0x93, 0xb4,\n\t0xb5, 0x66, 0xc0, 0x07, 0x96, 0x41, 0x47, 0x2d,\n\t0xef, 0xc1, 0x4b, 0xec, 0xcf, 0x48, 0x98, 0x4a,\n\t0x79, 0x46, 0xf1, 0x44, 0x1e, 0xa1, 0x44, 0xea,\n\t0x4c, 0x80, 0x2a, 0x45, 0x75, 0x50, 0xba, 0x3d,\n\t0xf0, 0xf1, 0x4c, 0x09, 0x0a, 0x75, 0xfe, 0x9e,\n\t0x6a, 0x77, 0xcf, 0x0b, 0xe9, 0x8b, 0x71, 0xd5,\n\t0x62, 0x51, 0xa8, 0x69, 0x43, 0xe7, 0x19, 0xd2,\n\t0x78, 0x65, 0xa4, 0x89, 0x56, 0x6c, 0x1d, 0xc5,\n\t0x7f, 0xcd, 0xef, 0xac, 0xa6, 0xab, 0x04, 0x3f,\n\t0x8e, 0x13, 0xf6, 0xc0, 0xbe, 0x7b, 0x39, 0xc9,\n\t0x2d, 0xa8, 0x6e, 0x1d, 0x87, 0x47, 0x7a, 0x18,\n\t0x9e, 0x73, 0xce, 0x8e, 0x31, 0x1d, 0x3d, 0x51,\n\t0x36, 0x1f, 0x8b, 0x00, 0x24, 0x9f, 0xb3, 0xd8,\n\t0x43, 0x56, 0x07, 0xb1, 0x4a, 0x1e, 0x70, 0x17,\n\t0x0f, 0x9a, 0xf3, 0x67, 0x84, 0x11, 0x0a, 0x3f,\n\t0x2e, 0x67, 0x42, 0x8f, 0xc1, 0x8f, 0xb0, 0x13,\n\t0xb3, 0x0f, 0xe6, 0x78, 0x2a, 0xec, 0xb4, 0x42,\n\t0x8d, 0x7c, 0x8e, 0x35, 0x4a, 0x0f, 0xbd, 0x06,\n\t0x1b, 0x01, 0x91, 0x7c, 0x72, 0x7a, 0xbe, 0xe0,\n\t0xfe, 0x3f, 0xd3, 0xce, 0xf7, 0x61\n};\n\n/*\n * The private key for the modulus in PUB2048[].\n */\nstatic const unsigned char PRIV2048[] = {\n\t0x55, 0x41, 0x4d, 0x31, 0x00, 0x80, 0xea, 0x43,\n\t0xd7, 0x9d, 0xf0, 0xb8, 0x74, 0x14, 0x0a, 0x55,\n\t0xec, 0xd1, 0x44, 0x73, 0x2e, 0xaf, 0x49, 0xd9,\n\t0xc8, 0xf0, 0xe4, 0x37, 0x6f, 0x5d, 0x72, 0x97,\n\t0x2a, 0x14, 0x66, 0x79, 0xe3, 0x82, 0x44, 0xf5,\n\t0xa9, 0x6e, 0xf5, 0xce, 0x92, 0x8a, 0x54, 0x25,\n\t0x12, 0x40, 0x47, 0x5f, 0xd1, 0xdd, 0x96, 0x8b,\n\t0x9a, 0x77, 0xad, 0xd1, 0x65, 0x50, 0x56, 0x4c,\n\t0x1d, 0xd2, 0x42, 0x40, 0x08, 0xea, 0x83, 0xc2,\n\t0x59, 0xd5, 0x3b, 0x88, 0x61, 0xc5, 0xe9, 0x4f,\n\t0x22, 0x8f, 0x03, 0xc4, 0x98, 0xdd, 0x3c, 0x8c,\n\t0x69, 0x49, 0xe3, 0x66, 0x02, 0xfe, 0x74, 0x6d,\n\t0x64, 0xd5, 0x14, 0x89, 0xc7, 0x6c, 0x74, 0xdb,\n\t0xc2, 0x44, 0x7e, 0x22, 0x2e, 0xcf, 0x28, 0xfa,\n\t0x9b, 0xd4, 0x4e, 0x81, 0x41, 0x07, 0x55, 0x87,\n\t0x9e, 0x71, 0xbd, 0xf8, 0xfb, 0x4a, 0x61, 0xd8,\n\t0xad, 0x3d, 0xf4, 0x4f, 0xfc, 0x9b, 0x00, 0x80,\n\t0xd4, 0x30, 0x28, 0xee, 0x37, 0x4f, 0xeb, 0xb9,\n\t0x3b, 0x5d, 0xf8, 0xdc, 0x1c, 0x68, 0x37, 0x13,\n\t0xab, 0x05, 0x10, 0xaf, 0x7e, 0xeb, 0xe6, 0x3d,\n\t0x33, 0xf9, 0x0a, 0xf7, 0x63, 0xfa, 0x22, 0x64,\n\t0xb6, 0x8b, 0x09, 0x21, 0x94, 0x90, 0xa5, 0xa5,\n\t0x64, 0x4d, 0x63, 0x56, 0x85, 0x9c, 0x27, 0xcd,\n\t0xf9, 0x76, 0x71, 0x12, 0x2e, 0x4d, 0x9a, 0x13,\n\t0xd9, 0x16, 0x09, 0x60, 0x9c, 0x46, 0x90, 0x14,\n\t0xda, 0xe3, 0x0f, 0x9a, 0xe6, 0xbc, 0x93, 0x78,\n\t0xe7, 0x97, 0x47, 0x60, 0x1e, 0xee, 0xa8, 0x18,\n\t0x46, 0x98, 0x42, 0x72, 0x08, 0x9c, 0x08, 0x53,\n\t0x49, 0x7f, 0xc5, 0x3a, 0x51, 0xd4, 0x5d, 0x37,\n\t0xf0, 0xcb, 0x4e, 0x67, 0xd8, 0xb9, 0x59, 0x21,\n\t0xb7, 0xd2, 0x93, 0xd7, 0x55, 0xb4, 0x9d, 0xda,\n\t0x55, 0xb8, 0x15, 0x29, 0xa7, 0x06, 0xcd, 0x67,\n\t0xee, 0x3b, 0xfe, 0xfe, 0xc4, 0xf3, 0xf5, 0xb3\n};\n\n/*\n * Some pre-generated salt values. These 16 salts, of 16 bytes each,\n * actually use all byte values from 0 to 255; they were generated as\n * a random permutation of the 0..255 range.\n */\nstatic const unsigned char SALTS[][16] = {\n\t{ /* 0 */\n\t\t0xb8, 0x2c, 0xb4, 0x2e, 0x3a, 0x2d, 0xfc, 0x2a,\n\t\t0xd6, 0x0b, 0x8b, 0x76, 0xc6, 0x66, 0xb0, 0x15\n\t},\n\t{ /* 1 */\n\t\t0xa8, 0x67, 0xf0, 0x36, 0xcc, 0x97, 0x43, 0x41,\n\t\t0x5a, 0x7c, 0xf8, 0xe7, 0x6f, 0x3d, 0x79, 0xc3\n\t},\n\t{ /* 2 */\n\t\t0x07, 0x96, 0x09, 0x03, 0x6d, 0xd1, 0x89, 0x4c,\n\t\t0xe3, 0x7d, 0x08, 0xab, 0x20, 0x21, 0xa3, 0x02\n\t},\n\t{ /* 3 */\n\t\t0x1a, 0xdb, 0xc1, 0xe6, 0xa9, 0xdd, 0x48, 0x1f,\n\t\t0xff, 0x00, 0xeb, 0x93, 0xb2, 0x8e, 0x9a, 0xce\n\t},\n\t{ /* 4 */\n\t\t0xd8, 0x8f, 0x1d, 0x9b, 0x71, 0xd0, 0xa1, 0x59,\n\t\t0xf1, 0x1b, 0x28, 0x84, 0x78, 0x18, 0x29, 0x16\n\t},\n\t{ /* 5 */\n\t\t0x1c, 0x37, 0x22, 0x64, 0x42, 0x19, 0xb5, 0xcd,\n\t\t0x55, 0xf3, 0x68, 0xcf, 0xcb, 0xe5, 0x4e, 0xd7\n\t},\n\t{ /* 6 */\n\t\t0x82, 0xef, 0x58, 0x8d, 0xd5, 0xc5, 0x52, 0xdf,\n\t\t0xa2, 0xf6, 0x46, 0x99, 0x87, 0x91, 0xa5, 0x75\n\t},\n\t{ /* 7 */\n\t\t0x4b, 0x9f, 0x85, 0x74, 0x2f, 0x0c, 0xfb, 0xda,\n\t\t0xde, 0x12, 0xb7, 0x3e, 0x54, 0xb9, 0x95, 0x10\n\t},\n\t{ /* 8 */\n\t\t0xaf, 0xa6, 0xa0, 0x92, 0xf2, 0x35, 0x4a, 0x8a,\n\t\t0xaa, 0x0e, 0x80, 0x23, 0x56, 0xe4, 0x7e, 0x01\n\t},\n\t{ /* 9 */\n\t\t0x60, 0xf4, 0x8c, 0xdc, 0x69, 0x3f, 0x2b, 0x7b,\n\t\t0xc0, 0x6b, 0xc9, 0x13, 0x53, 0x86, 0x30, 0xbc\n\t},\n\t{ /* 10 */\n\t\t0x06, 0xbe, 0xfd, 0x62, 0xea, 0xc8, 0xe0, 0x5d,\n\t\t0x4d, 0x65, 0x39, 0xa4, 0xe9, 0xf5, 0xba, 0xfa\n\t},\n\t{ /* 11 */\n\t\t0x73, 0x9c, 0x40, 0x51, 0xf7, 0x04, 0x6c, 0x33,\n\t\t0xad, 0x11, 0x1e, 0x7f, 0xed, 0x3c, 0x9d, 0x34\n\t},\n\t{ /* 12 */\n\t\t0x31, 0x24, 0x44, 0xb6, 0x83, 0x88, 0x9e, 0x94,\n\t\t0x5e, 0xd4, 0x47, 0x26, 0x49, 0xe1, 0x6a, 0x0d\n\t},\n\t{ /* 13 */\n\t\t0xbf, 0xfe, 0xbb, 0x98, 0x5b, 0xc4, 0xc7, 0x5f,\n\t\t0x77, 0xa7, 0x81, 0xd3, 0x0f, 0xe8, 0x7a, 0xee\n\t},\n\t{ /* 14 */\n\t\t0x63, 0xf9, 0xc2, 0x27, 0xd2, 0x5c, 0xae, 0x3b,\n\t\t0xd9, 0x45, 0x4f, 0x61, 0x05, 0x0a, 0x90, 0xbd\n\t},\n\t{ /* 15 */\n\t\t0xe2, 0x38, 0x17, 0x25, 0x14, 0xca, 0xb3, 0x57,\n\t\t0xb1, 0x50, 0xec, 0x32, 0x72, 0x6e, 0x70, 0xac\n\t}\n};\n\n/*\n * The \"small\" work factor is below the threshold for use of the\n * \"fast path\", while the \"large\" work factor is above. Threshold is\n * 34% of the modulus size (in bits), i.e. 696 for a 2048-bit modulus.\n */\n#define WF_SMALL   384\n#define WF_LARGE  4096\n\n/*\n * The salt for the \"detailed test vector\" from the specification.\n */\nstatic const unsigned char SALT_D[] = {\n\t0xC7, 0x27, 0x03, 0xC2, 0x2A, 0x96, 0xD9, 0x99,\n\t0x2F, 0x3D, 0xEA, 0x87, 0x64, 0x97, 0xE3, 0x92\n};\n\n/*\n * The expected binary output for the \"detailed test vector\" from the\n * specification.\n */\nstatic const unsigned char REF_D[] = {\n\t0xC9, 0xCE, 0xA0, 0xE6, 0xEF, 0x09, 0x39, 0x3A,\n\t0xB1, 0x71, 0x0A, 0x08\n};\n\n/*\n * Successive hash outputs are concatenated and hashed together with\n * SHA-256, thus producing an aggregate checksum of all KAT.\n */\nstatic SHA256_CTX sha256;\n\nstatic void\nprint_blob(char *name, const void *data, size_t len)\n{\n\tconst unsigned char *buf;\n\n\tbuf = data;\n\tprintf(\"%s: \", name);\n\twhile (len -- > 0) {\n\t\tprintf(\"%02x\", *buf ++);\n\t}\n\tprintf(\"\\n\");\n}\n\nstatic void\nprintKDF(char *banner, int hf,\n\tunsigned char *input, size_t input_len, size_t output_len)\n{\n\tunsigned char output[4096];\n\n\tif (output_len > sizeof output) {\n\t\tabort();\n\t}\n\tmakwa_kdf(hf, input, input_len, output, output_len);\n\tprintf(\"%s\\n\", banner);\n\tprint_blob(\"input\", input, input_len);\n\tprint_blob(\"output\", output, output_len);\n\tprintf(\"\\n\");\n\tSHA256_Update(&sha256, output, output_len);\n}\n\nstatic void\nprintKAT4(char *banner, makwa_context *mcpub, makwa_context *mcpriv,\n\tconst unsigned char *input, size_t input_len,\n\tconst unsigned char *salt, size_t salt_len,\n\tint pre_hash, size_t post_hash_len)\n{\n\tunsigned char outs1[300], outs2[300], outb1[300], outb2[300];\n\tsize_t outs1_len, outs2_len, outb1_len, outb2_len;\n\tchar tmp[30];\n\tchar *outs1_str, *outb1_str;\n\tsize_t outs1_str_len, outb1_str_len;\n\n\tmemset(outs1, 0x00, sizeof outs1);\n\tmemset(outs2, 0xFF, sizeof outs2);\n\tmemset(outb1, 0x00, sizeof outb1);\n\tmemset(outb2, 0xFF, sizeof outb2);\n\touts1_len = sizeof outs1;\n\touts2_len = sizeof outs2;\n\tif (makwa_hash(mcpub, input, input_len, salt, salt_len,\n\t\tpre_hash, post_hash_len, WF_SMALL, outs1, &outs1_len) < 0)\n\t{\n\t\tabort();\n\t}\n\tif (makwa_hash(mcpriv, input, input_len, salt, salt_len,\n\t\tpre_hash, post_hash_len, WF_SMALL, outs2, &outs2_len) < 0)\n\t{\n\t\tabort();\n\t}\n\tif (outs1_len != outs2_len || memcmp(outs1, outs2, outs1_len) != 0) {\n\t\tabort();\n\t}\n\toutb1_len = sizeof outb1;\n\toutb2_len = sizeof outb2;\n\tif (makwa_hash(mcpub, input, input_len, salt, salt_len,\n\t\tpre_hash, post_hash_len, WF_LARGE, outb1, &outb1_len) < 0)\n\t{\n\t\tabort();\n\t}\n\tif (makwa_hash(mcpriv, input, input_len, salt, salt_len,\n\t\tpre_hash, post_hash_len, WF_LARGE, outb2, &outb2_len) < 0)\n\t{\n\t\tabort();\n\t}\n\tif (outb1_len != outb2_len || memcmp(outb1, outb2, outb1_len) != 0) {\n\t\tabort();\n\t}\n\n\tprintf(\"%s\\n\", banner);\n\tprint_blob(\"input\", input, input_len);\n\tprint_blob(\"salt\", salt, salt_len);\n\tprintf(\"pre-hashing: %s\\n\", pre_hash ? \"true\" : \"false\");\n\tif (post_hash_len == 0) {\n\t\tprintf(\"post-hashing: false\\n\");\n\t} else {\n\t\tprintf(\"post-hashing: %lu\\n\", (unsigned long)post_hash_len);\n\t}\n\tsprintf(tmp, \"bin%d\", WF_SMALL);\n\tprint_blob(tmp, outs1, outs1_len);\n\tsprintf(tmp, \"bin%d\", WF_LARGE);\n\tprint_blob(tmp, outb1, outb1_len);\n\n\tif (makwa_encode_string(mcpriv, salt, salt_len, pre_hash,\n\t\tpost_hash_len, WF_SMALL, outs1, NULL, &outs1_str_len) < 0)\n\t{\n\t\tabort();\n\t}\n\touts1_str = malloc(outs1_str_len);\n\tif (outs1_str == NULL) {\n\t\tabort();\n\t}\n\tif (makwa_encode_string(mcpriv, salt, salt_len, pre_hash,\n\t\tpost_hash_len, WF_SMALL, outs1, outs1_str, &outs1_str_len) < 0)\n\t{\n\t\tabort();\n\t}\n\tif (makwa_encode_string(mcpriv, salt, salt_len, pre_hash,\n\t\tpost_hash_len, WF_LARGE, outb1, NULL, &outb1_str_len) < 0)\n\t{\n\t\tabort();\n\t}\n\toutb1_str = malloc(outb1_str_len);\n\tif (outb1_str == NULL) {\n\t\tabort();\n\t}\n\tif (makwa_encode_string(mcpriv, salt, salt_len, pre_hash,\n\t\tpost_hash_len, WF_LARGE, outb1, outb1_str, &outb1_str_len) < 0)\n\t{\n\t\tabort();\n\t}\n\n\tprintf(\"str%d: %s\\n\", WF_SMALL, outs1_str);\n\tprintf(\"str%d: %s\\n\", WF_LARGE, outb1_str);\n\tprintf(\"\\n\");\n\n\tSHA256_Update(&sha256, outs1, outs1_len);\n\tSHA256_Update(&sha256, outb1, outb1_len);\n\tSHA256_Update(&sha256, outs1_str, strlen(outs1_str));\n\tSHA256_Update(&sha256, outb1_str, strlen(outb1_str));\n\n\tfree(outs1_str);\n\tfree(outb1_str);\n}\n\nstatic void\nprintKAT3(char *banner, makwa_context *mcpub, makwa_context *mcpriv,\n\tconst unsigned char *input, size_t input_len,\n\tconst unsigned char *salt, size_t salt_len,\n\tsize_t ph_len)\n{\n\tprintKAT4(banner, mcpub, mcpriv,\n\t\tinput, input_len, salt, salt_len, 0, 0);\n\tprintKAT4(banner, mcpub, mcpriv,\n\t\tinput, input_len, salt, salt_len, 0, ph_len);\n\tprintKAT4(banner, mcpub, mcpriv,\n\t\tinput, input_len, salt, salt_len, 1, 0);\n\tprintKAT4(banner, mcpub, mcpriv,\n\t\tinput, input_len, salt, salt_len, 1, ph_len);\n}\n\nstatic void\nprintKAT2(char *banner, makwa_context *mcpub, makwa_context *mcpriv,\n\tconst unsigned char *input, size_t input_len)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i ++) {\n\t\tprintKAT3(banner, mcpub, mcpriv,\n\t\t\tinput, input_len, SALTS[i], 16, 10 + i);\n\t}\n}\n\nstatic void\nprintKAT(char *banner, makwa_context *mcpub, makwa_context *mcpriv)\n{\n\tunsigned char input[150];\n\tint i, j;\n\n\tfor (i = 0; i < 150; i ++) {\n\t\tinput[i] = (17 + 73 * i) & 0xFF;\n\t}\n\tprintKAT2(banner, mcpub, mcpriv, input, 150);\n\n\tfor (i = 0; i < 22; i ++) {\n\t\tfor (j = 0; j < 13; j ++) {\n\t\t\tinput[j] = (13 * i + j + 8) & 0xFF;\n\t\t}\n\t\tprintKAT2(banner, mcpub, mcpriv, input, 13);\n\t}\n}\n\nint\nmain(void)\n{\n\tmakwa_context *mcpub, *mcpriv;\n\tint i, j;\n\tchar *pwd;\n\tunsigned char tmp[32];\n\tsize_t tmp_len;\n\tchar detailed_string[1024];\n\n\tSHA256_Init(&sha256);\n\n\tfor (i = 0; i < 200; i ++) {\n\t\tunsigned char input[200];\n\n\t\tfor (j = 0; j < i; j ++) {\n\t\t\tinput[j] = (7 * i + 83 * j) & 0xFF;\n\t\t}\n\t\tprintKDF(\"KDF/SHA-256\", MAKWA_SHA256, input, i, 100);\n\t\tprintKDF(\"KDF/SHA-512\", MAKWA_SHA512, input, i, 100);\n\t}\n\n\tmcpub = makwa_new();\n\tmcpriv = makwa_new();\n\n\tif (makwa_init(mcpub, PUB2048, sizeof PUB2048, MAKWA_SHA256) < 0) {\n\t\tabort();\n\t}\n\tif (makwa_init(mcpriv, PRIV2048, sizeof PRIV2048, MAKWA_SHA256) < 0) {\n\t\tabort();\n\t}\n\tpwd = \"Gego beshwaji'aaken awe makwa; onzaam naniizaanizi.\";\n\ttmp_len = sizeof tmp;\n\tif (makwa_hash(mcpub, pwd, strlen(pwd), SALT_D, sizeof SALT_D,\n\t\t0, 12, 4096, tmp, &tmp_len) < 0)\n\t{\n\t\tabort();\n\t}\n\tif (tmp_len != sizeof REF_D || memcmp(tmp, REF_D, tmp_len) != 0) {\n\t\tabort();\n\t}\n\tmemset(tmp, 0, sizeof tmp);\n\tif (makwa_hash(mcpriv, pwd, strlen(pwd), SALT_D, sizeof SALT_D,\n\t\t0, 12, 4096, tmp, &tmp_len) < 0)\n\t{\n\t\tabort();\n\t}\n\tif (tmp_len != sizeof REF_D || memcmp(tmp, REF_D, tmp_len) != 0) {\n\t\tabort();\n\t}\n\tif (makwa_encode_string(mcpub, SALT_D, sizeof SALT_D,\n\t\t0, 12, 4096, REF_D, detailed_string, NULL) != 0)\n\t{\n\t\tabort();\n\t}\n\tprintf(\"2048-bit modulus, SHA-256\\n\");\n\tprint_blob(\"input\", pwd, strlen(pwd));\n\tprint_blob(\"salt\", SALT_D, sizeof SALT_D);\n\tprintf(\"pre-hashing: false\\n\");\n\tprintf(\"post-hashing: 12\\n\");\n\tprint_blob(\"bin4096\", tmp, sizeof REF_D);\n\tprintf(\"str4096: %s\\n\\n\", detailed_string);\n\n\tSHA256_Update(&sha256, tmp, sizeof REF_D);\n\tSHA256_Update(&sha256, detailed_string, strlen(detailed_string));\n\n\tprintKAT(\"2048-bit modulus, SHA-256\", mcpub, mcpriv);\n\tif (makwa_init(mcpub, PUB2048, sizeof PUB2048, MAKWA_SHA512) < 0) {\n\t\tabort();\n\t}\n\tif (makwa_init(mcpriv, PRIV2048, sizeof PRIV2048, MAKWA_SHA512) < 0) {\n\t\tabort();\n\t}\n\tprintKAT(\"2048-bit modulus, SHA-512\", mcpub, mcpriv);\n\n\tmakwa_free(mcpub);\n\tmakwa_free(mcpriv);\n\n\tSHA256_Final(tmp, &sha256);\n\tprint_blob(\"KAT digest\", tmp, 32);\n\treturn 0;\n}\n"
        },
        {
            "file_name": "makwa.c",
            "content": "/*\n * -----------------------------------------------------------------------\n * (c) Thomas Pornin 2014. This software is provided 'as-is', without\n * any express or implied warranty. In no event will the author be held\n * liable for any damages arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to no restriction.\n *\n * Technical remarks and questions can be addressed to:\n * <pornin@bolet.org>\n * -----------------------------------------------------------------------\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <limits.h>\n\n/*\n * We use SHA-256, SHA-512, HMAC and the big integer code from OpenSSL.\n */\n#include <openssl/bn.h>\n#include <openssl/hmac.h>\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n\n#include \"makwa.h\"\n\n/*\n * Each encoded format (modulus, private key, set of delegation\n * parameters, delegation request and delegation response) begins with a\n * four-byte header, which is the big-endian encoding of one of the\n * following values.\n */\n#define MAGIC_PUBKEY       0x55414D30\n#define MAGIC_PRIVKEY      0x55414D31\n#define MAGIC_DELEG_PARAM  0x55414D32\n#define MAGIC_DELEG_REQ    0x55414D33\n#define MAGIC_DELEG_ANS    0x55414D34\n\n/* see makwa.h */\nint\nmakwa_kdf(int hash_function,\n\tconst void *src, size_t src_len,\n\tvoid *dst, size_t dst_len)\n{\n\tHMAC_CTX hc;\n\tconst EVP_MD *mdf;\n\tsize_t r;\n\tunsigned char K[64], V[64], b;\n\tunsigned mlen;\n\n\tHMAC_CTX_init(&hc);\n\tswitch (hash_function) {\n\tcase MAKWA_SHA256:\n\t\tmdf = EVP_sha256();\n\t\tr = 32;\n\t\tbreak;\n\tcase MAKWA_SHA512:\n\t\tmdf = EVP_sha512();\n\t\tr = 64;\n\t\tbreak;\n\tdefault:\n\t\treturn MAKWA_BADPARAM;\n\t}\n\n\t/*\n\t * HMAC_Init_ex(), HMAC_Update() and HMAC_Final() return 'void'\n\t * before OpenSSL-1.0.0, and 'int' since that version. MacOS X\n\t * still uses a pre-1.0.0 version. Since we use the default\n\t * implementation which should be software-based, no failure is\n\t * actually expected.\n\t */\n\n\t/* 1. V <- 0x01 0x01 0x01 ... 0x01 */\n\tmemset(V, 0x01, r);\n\n\t/* 2. K <- 0x00 0x00 0x00 ... 0x00 */\n\tmemset(K, 0x00, r);\n\n\t/* 3. K <- HMAC_K(V || 0x00 || m) */\n\tHMAC_Init_ex(&hc, K, r, mdf, NULL);\n\tHMAC_Update(&hc, V, r);\n\tb = 0x00;\n\tHMAC_Update(&hc, &b, 1);\n\tHMAC_Update(&hc, src, src_len);\n\tHMAC_Final(&hc, K, &mlen);\n\tif (mlen != r) {\n\t\treturn MAKWA_HMAC_ERROR;\n\t}\n\n\t/* 4. V <- HMAC_K(V) */\n\tHMAC_Init_ex(&hc, K, r, NULL, NULL);\n\tHMAC_Update(&hc, V, r);\n\tHMAC_Final(&hc, V, &mlen);\n\tif (mlen != r) {\n\t\treturn MAKWA_HMAC_ERROR;\n\t}\n\n\t/* 5. K <- HMAC_K(V || 0x01 || m) */\n\tHMAC_Init_ex(&hc, K, r, NULL, NULL);\n\tHMAC_Update(&hc, V, r);\n\tb = 0x01;\n\tHMAC_Update(&hc, &b, 1);\n\tHMAC_Update(&hc, src, src_len);\n\tHMAC_Final(&hc, K, &mlen);\n\tif (mlen != r) {\n\t\treturn MAKWA_HMAC_ERROR;\n\t}\n\n\t/* 6. V <- HMAC_K(V) */\n\tHMAC_Init_ex(&hc, K, r, NULL, NULL);\n\tHMAC_Update(&hc, V, r);\n\tHMAC_Final(&hc, V, &mlen);\n\tif (mlen != r) {\n\t\treturn MAKWA_HMAC_ERROR;\n\t}\n\n\t/* 7. and 8. */\n\twhile (dst_len > 0) {\n\t\tsize_t clen;\n\n\t\tHMAC_Init_ex(&hc, K, r, NULL, NULL);\n\t\tHMAC_Update(&hc, V, r);\n\t\tHMAC_Final(&hc, V, &mlen);\n\t\tif (mlen != r) {\n\t\t\treturn MAKWA_HMAC_ERROR;\n\t\t}\n\t\tclen = dst_len;\n\t\tif (clen > r) {\n\t\t\tclen = r;\n\t\t}\n\t\tmemcpy(dst, V, clen);\n\t\tdst = (unsigned char *)dst + clen;\n\t\tdst_len -= clen;\n\t}\n\tHMAC_CTX_cleanup(&hc);\n\treturn MAKWA_OK;\n}\n\n/* see makwa.h */\nint\nmakwa_make_new_salt(void *salt, size_t salt_len)\n{\n\t/*\n\t * A cryptographically strong PRNG is kinda overkill for a salt,\n\t * but it does not hurt to use one.\n\t */\n\tif (RAND_bytes(salt, salt_len) < 0) {\n\t\treturn MAKWA_RAND_ERROR;\n\t}\n\treturn MAKWA_OK;\n}\n\n/*\n * Some helper macros.\n *\n * In most of the remaining functions, exit is done through a code\n * sequence at the end, where temporary variables are deallocated.\n * The code sequence is reached through a 'goto' (label is 'exit_err')\n * and the function return value is held in the variable 'err'.\n *\n * CZ(expr) evaluates 'expr'; if it returns a zero value (or NULL\n * pointer), then the function will exit with a MAKWA_NOMEM error code.\n *\n * CZX(expr, errcode) evaluates 'expr'; if it returns a non-zero value,\n * then the function will exit with 'errcode' as error code.\n *\n * RETURN(errcode) exits the function with 'errcode' as error code.\n *\n * CF(expr) evaluates 'expr' and stores the result (of type 'int') into\n * the 'err' variable. If it is negative, then the function exits and\n * returns that value.\n *\n * FREE(x) calls free() on x (a pointer) if x is not NULL.\n *\n * FREE_BN(x) calls BN_clear_free() on x (a BIGNUM*) if x is not NULL.\n *\n * FREE_BNCTX(c) calls BN_CTX_free() on c (a BN_CTX*) if c is not NULL.\n *\n * FREE_MCTX(m) calls BN_MONT_CTX_free() on m (a BN_MONT_CTX*) if m is\n * not NULL.\n *\n * DO_BUFFER(out, out_len, len) applies the \"output buffer semantics\"\n * (see makwa.h) on out/out_len, for a predicted output length of 'len'\n * bytes.\n *\n * FUNCTION_EXIT is a non-statement macro which sets 'err' to MAKWA_OK\n * (for a successful exit) and defines the 'exit_err' label. It introduces\n * the function exit sequence, which must terminate with: 'return err;'\n */\n\n#define CZ(x)   CZX(x, MAKWA_NOMEM)\n\n#define CZX(x, errcode)   do { \\\n\t\tif ((x) == 0) { \\\n\t\t\tRETURN(errcode); \\\n\t\t} \\\n\t} while (0)\n\n#define RETURN(errcode)   do { \\\n\t\terr = (errcode); \\\n\t\tgoto exit_err; \\\n\t} while (0)\n\n#define CF(x)   do { \\\n\t\terr = (x); \\\n\t\tif (err < 0) { \\\n\t\t\tgoto exit_err; \\\n\t\t} \\\n\t} while (0)\n\n#define FREE(x)   do { \\\n\t\tvoid *tmp_free = (x); \\\n\t\tif (tmp_free != NULL) { \\\n\t\t\tfree(tmp_free); \\\n\t\t} \\\n\t} while (0)\n\n#define FREE_BN(x)   do { \\\n\t\tBIGNUM *tmp_free = (x); \\\n\t\tif (tmp_free != NULL) { \\\n\t\t\tBN_clear_free(tmp_free); \\\n\t\t} \\\n\t} while (0)\n\n#define FREE_BNCTX(x)   do { \\\n\t\tBN_CTX *tmp_free = (x); \\\n\t\tif (tmp_free != NULL) { \\\n\t\t\tBN_CTX_free(tmp_free); \\\n\t\t} \\\n\t} while (0)\n\n#define FREE_MCTX(x)   do { \\\n\t\tBN_MONT_CTX *tmp_free = (x); \\\n\t\tif (tmp_free != NULL) { \\\n\t\t\tBN_MONT_CTX_free(tmp_free); \\\n\t\t} \\\n\t} while (0)\n\n#define DO_BUFFER(out, out_len, len)   do { \\\n\t\tvoid *macro_out = (out); \\\n\t\tsize_t *macro_out_len = (out_len); \\\n\t\tsize_t macro_len = (len); \\\n\t\tif (macro_out == NULL) { \\\n\t\t\tif (macro_out_len != NULL) { \\\n\t\t\t\t*macro_out_len = macro_len; \\\n\t\t\t} \\\n\t\t\tRETURN(MAKWA_OK); \\\n\t\t} else if (macro_out_len != NULL) { \\\n\t\t\tsize_t macro_pred_len = *macro_out_len; \\\n\t\t\t*macro_out_len = macro_len; \\\n\t\t\tif (macro_pred_len < macro_len) { \\\n\t\t\t\tRETURN(MAKWA_BUFFER_TOO_SMALL); \\\n\t\t\t} \\\n\t\t} \\\n\t} while (0)\n\n#define FUNCTION_EXIT   err = MAKWA_OK; exit_err\n\n/*\n * Decode a 16-bit integer (big-endian).\n */\nstatic unsigned\ndecode_16(const void *src, size_t off)\n{\n\tconst unsigned char *buf;\n\n\tbuf = src;\n\treturn ((unsigned)buf[off + 0] << 8)\n\t\t| (unsigned)buf[off + 1];\n}\n\n/*\n * Decode a 32-bit integer (big-endian).\n */\nstatic unsigned long\ndecode_32(const void *src, size_t off)\n{\n\tconst unsigned char *buf;\n\n\tbuf = src;\n\treturn ((unsigned long)buf[off + 0] << 24)\n\t\t| ((unsigned long)buf[off + 1] << 16)\n\t\t| ((unsigned long)buf[off + 2] << 8)\n\t\t| (unsigned long)buf[off + 3];\n}\n\n/*\n * Decode a big integer value, using the format described in the Makwa\n * specification, section A.5 (this is also the MPI format from OpenPGP;\n * warning: OpenSSL also has a format which it calls \"MPI\" but is\n * distinct from the one we use).\n *\n * The MPI is located at offset '*off' in the 'src' buffer (offest is\n * in bytes). The total length of 'src' is provided in 'len'. When the\n * integer has been decoded, '*off' is adjusted to point to the first\n * byte immediately following the MPI in the buffer. The big integer is\n * decoded into 'v'.\n */\nstatic int\ndecode_mpi(const void *src, size_t *off, size_t len, BIGNUM *v)\n{\n\tconst unsigned char *buf;\n\tsize_t mlen;\n\n\tbuf = src;\n\tif (*off + 2 > len) {\n\t\treturn MAKWA_BADPARAM;\n\t}\n\tmlen = decode_16(buf, *off);\n\tif (mlen > (len - *off - 2)) {\n\t\treturn MAKWA_BADPARAM;\n\t}\n\tif (BN_bin2bn(buf + *off + 2, mlen, v) == NULL) {\n\t\treturn MAKWA_NOMEM;\n\t}\n\t*off += 2 + mlen;\n\treturn MAKWA_OK;\n}\n\n/*\n * Encode a 16-bit integer (big-endian).\n */\nstatic void\nencode_16(void *out, unsigned x)\n{\n\tunsigned char *buf;\n\n\tbuf = out;\n\tbuf[0] = (x >> 8) & 0xFF;\n\tbuf[1] = x & 0xFF;\n}\n\n/*\n * Encode a 32-bit integer (big-endian).\n */\nstatic void\nencode_32(void *out, unsigned long x)\n{\n\tunsigned char *buf;\n\n\tbuf = out;\n\tbuf[0] = (x >> 24) & 0xFF;\n\tbuf[1] = (x >> 16) & 0xFF;\n\tbuf[2] = (x >> 8) & 0xFF;\n\tbuf[3] = x & 0xFF;\n}\n\n/*\n * Encode a big integer in MPI format. The out/out_len values use the\n * \"output buffer semantics\".\n */\nstatic int\nencode_mpi(BIGNUM *v, void *out, size_t *out_len)\n{\n\tunsigned char *buf;\n\tsize_t len;\n\tint err;\n\n\tif (BN_is_negative(v)) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tlen = BN_num_bytes(v);\n\tif (len > 65535) {\n\t\tRETURN(MAKWA_TOOLARGE);\n\t}\n\tDO_BUFFER(out, out_len, len + 2);\n\tbuf = out;\n\tencode_16(buf, len);\n\tBN_bn2bin(v, buf + 2);\n\nFUNCTION_EXIT:\n\treturn err;\n}\n\nstatic size_t\nmpi_length(BIGNUM *v)\n{\n\treturn BN_num_bytes(v) + 2;\n}\n\n/*\n * This function generates a random prime integer of the specified size\n * (in bits, between 2 ans 16384 bits). The top two bits of the prime\n * are equal to 1 (this is meant so that the product of two such primes\n * reliably reaches a given target size); moreover, the prime is equal to\n * 3 modulo 4 (this last property is what makes this function differ\n * from OpenSSL's BN_generate_prime()).\n */\nstatic int\nrand_prime(int size, BIGNUM *p)\n{\n\tint err;\n\tBN_CTX *bnctx;\n\n\tbnctx = NULL;\n\tif (size < 2 || size > 16384) {\n\t\tRETURN(MAKWA_TOOLARGE);\n\t}\n\tfor (;;) {\n\t\tint r;\n\n\t\tCZ(BN_rand(p, size, 1, 1));\n\t\tCZ(BN_set_bit(p, 1));\n\t\tr = BN_is_prime_fasttest(p, BN_prime_checks, 0, bnctx, 0, 1);\n\t\tif (r > 0) {\n\t\t\tRETURN(MAKWA_OK);\n\t\t} else if (r < 0) {\n\t\t\tRETURN(MAKWA_RAND_ERROR);\n\t\t}\n\t}\n\nFUNCTION_EXIT:\n\tFREE_BNCTX(bnctx);\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_generate_key(int size, void *key, size_t *key_len)\n{\n\tBIGNUM *p, *q; \n\tint sp, sq;\n\tsize_t len, u, off;\n\tunsigned char *buf;\n\tint err;\n\n\tp = NULL;\n\tq = NULL;\n\tif (size < 1273 || size > 32768) {\n\t\tRETURN(MAKWA_TOOLARGE);\n\t}\n\tsp = (size + 1) >> 1;\n\tsq = size - sp;\n\tlen = 8 + (((size_t)sp + 7) >> 3) + (((size_t)sq + 7) >> 3);\n\tDO_BUFFER(key, key_len, len);\n\n\tCZ(p = BN_new());\n\tCZ(q = BN_new());\n\tCF(rand_prime(sp, p));\n\tCF(rand_prime(sq, q));\n\n\tbuf = key;\n\tencode_32(buf, MAGIC_PRIVKEY);\n\toff = 4;\n\tu = len - off;\n\tCF(encode_mpi(p, buf + off, &u));\n\toff += u;\n\tCF(encode_mpi(q, buf + off, &u));\n\toff += u;\n\nFUNCTION_EXIT:\n\tFREE_BN(p);\n\tFREE_BN(q);\n\treturn err;\n}\n\n/*\n * Context internal contents.\n *\n * The BIGNUM fields are allocated in makwa_init_full(), and reused when\n * possible; they are finally released by makwa_free(). If\n * initialization fails, it is possible that the fields are only\n * partially initialized; this is supported (both makwa_init_full() and\n * makwa_free() can recover, without leaking memory).\n *\n * When using a private key, makwa_init_full() ensures that p is greater\n * than q (the factors are swapped if necessary).\n */\nstruct makwa_context_ {\n\t/* The modulus. */\n\tBIGNUM *modulus;\n\n\t/* The private key parameters; NULL if no private key is set. */\n\tBIGNUM *p, *q, *iq;\n\n\t/* The modulus length, in bytes. */\n\tsize_t mod_len;\n\n\t/* The modulus checksum, used for the first 11 characters of the\n\t   string encoding of Makwa output. */\n\tunsigned char modID[8];\n\n\t/* The underlying hash function. */\n\tint hash_function;\n\n\t/* Default pre-hashing flag (when using the simple API). */\n\tint default_pre_hash;\n\n\t/* Default post-hashing flag and length (when using the simple API). */\n\tsize_t default_post_hash_length;\n\n\t/* Default work factor (when using the simple API). */\n\tlong default_work_factor;\n};\n\n/* see makwa.h */\nmakwa_context *\nmakwa_new(void)\n{\n\tmakwa_context *ctx;\n\n\tctx = malloc(sizeof *ctx);\n\tif (ctx == NULL) {\n\t\treturn NULL;\n\t}\n\tctx->modulus = NULL;\n\tctx->p = NULL;\n\tctx->q = NULL;\n\tctx->iq = NULL;\n\treturn ctx;\n}\n\n/* see makwa.h */\nvoid\nmakwa_free(makwa_context *ctx)\n{\n\tif (ctx == NULL) {\n\t\treturn;\n\t}\n\tif (ctx->modulus != NULL) {\n\t\tBN_free(ctx->modulus);\n\t}\n\tif (ctx->p != NULL) {\n\t\tBN_clear_free(ctx->p);\n\t}\n\tif (ctx->q != NULL) {\n\t\tBN_clear_free(ctx->q);\n\t}\n\tif (ctx->iq != NULL) {\n\t\tBN_clear_free(ctx->iq);\n\t}\n\tfree(ctx);\n}\n\n/*\n * Split a work factor into its mantissa (2 or 3) and logarithm. For\n * instance, if 'wf' is 384, then mantissa is 3 and the logarithm is 7,\n * because 384 is equal to 3 times 128 (which is 2 to the power 7).\n * If 'mant' is not NULL, then the mantissa is written into '*mant'.\n * If the work factor cannot be split, then MAKWA_BADPARAM is returned.\n */\nstatic int\nwflog(long wf, int *mant)\n{\n\tint j;\n\n\tj = 0;\n\twhile (wf > 3 && (wf & 1) == 0) {\n\t\twf >>= 1;\n\t\tj ++;\n\t}\n\tif (wf != 2 && wf != 3) {\n\t\treturn MAKWA_BADPARAM;\n\t}\n\tif (j > 99) {\n\t\t/*\n\t\t * This one cannot happen with today's systems; it would\n\t\t * require a 'long' type of more than 102 bits.\n\t\t */\n\t\treturn MAKWA_BADPARAM;\n\t}\n\tif (mant != NULL) {\n\t\t*mant = (int)wf;\n\t}\n\treturn j;\n}\n\n/* see makwa.h */\nint\nmakwa_init(makwa_context *ctx,\n\tconst void *param, size_t param_len,\n\tint hash_function)\n{\n\treturn makwa_init_full(ctx, param, param_len, hash_function, 0, 0, 0);\n}\n\n/* see makwa.h */\nint\nmakwa_init_full(makwa_context *ctx,\n\tconst void *param, size_t param_len,\n\tint hash_function, int default_pre_hash,\n\tsize_t default_post_hash_length, long default_work_factor)\n{\n\tconst unsigned char *buf;\n\tsize_t off;\n\tint ret;\n\tunsigned long magic;\n\tunsigned char *tmp_mod;\n\tint deleg;\n\tBN_CTX *bnctx;\n\tint err;\n\n\tbnctx = NULL;\n\ttmp_mod = NULL;\n\tif (ctx->modulus == NULL) {\n\t\tCZ(ctx->modulus = BN_new());\n\t}\n\n\t/*\n\t * Decode parameters. They may be either a public modulus, or\n\t * a private key.\n\t */\n\tif (param_len < 4) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tmagic = decode_32(param, 0);\n\tbuf = param;\n\toff = 4;\n\tdeleg = 0;\n\tswitch (magic) {\n\tcase MAGIC_DELEG_PARAM:\n\t\tdeleg = 1;\n\t\t/* fall through */\n\tcase MAGIC_PUBKEY:\n\t\t/* Public modulus or delegation parameters. When decoding\n\t\t   delegation parameters, we just extract the modulus,\n\t\t   and ignore the rest. */\n\t\tCF(decode_mpi(buf, &off, param_len, ctx->modulus));\n\t\tif (!deleg && off != param_len) {\n\t\t\tRETURN(MAKWA_BADPARAM);\n\t\t}\n\t\tif (!BN_is_bit_set(ctx->modulus, 0)\n\t\t\t|| BN_is_bit_set(ctx->modulus, 1))\n\t\t{\n\t\t\tRETURN(MAKWA_BADPARAM);\n\t\t}\n\t\tFREE_BN(ctx->p);\n\t\tctx->p = NULL;\n\t\tFREE_BN(ctx->q);\n\t\tctx->q = NULL;\n\t\tFREE_BN(ctx->iq);\n\t\tctx->iq = NULL;\n\t\tbreak;\n\tcase MAGIC_PRIVKEY:\n\t\t/* Private key. */\n\t\tif (ctx->p == NULL) {\n\t\t\tCZ(ctx->p = BN_new());\n\t\t}\n\t\tif (ctx->q == NULL) {\n\t\t\tCZ(ctx->q = BN_new());\n\t\t}\n\t\tif (ctx->iq == NULL) {\n\t\t\tCZ(ctx->iq = BN_new());\n\t\t}\n\t\tCF(decode_mpi(buf, &off, param_len, ctx->p));\n\t\tCF(decode_mpi(buf, &off, param_len, ctx->q));\n\t\tif (off != param_len) {\n\t\t\tRETURN(MAKWA_BADPARAM);\n\t\t}\n\n\t\t/* We want p to be the greater of the two factors. */\n\t\tret = BN_cmp(ctx->p, ctx->q);\n\t\tif (ret < 0) {\n\t\t\tBIGNUM *t;\n\n\t\t\tt = ctx->p;\n\t\t\tctx->p = ctx->q;\n\t\t\tctx->q = t;\n\t\t} else if (ret == 0) {\n\t\t\tRETURN(MAKWA_BADPARAM);\n\t\t}\n\t\tif (!BN_is_bit_set(ctx->p, 0)\n\t\t\t|| !BN_is_bit_set(ctx->p, 1)\n\t\t\t|| !BN_is_bit_set(ctx->q, 0)\n\t\t\t|| !BN_is_bit_set(ctx->q, 1))\n\t\t{\n\t\t\tRETURN(MAKWA_BADPARAM);\n\t\t}\n\t\tCZ(bnctx = BN_CTX_new());\n\t\tCZ(BN_mul(ctx->modulus, ctx->p, ctx->q, bnctx));\n\t\tCZX(BN_mod_inverse(ctx->iq, ctx->q, ctx->p, bnctx),\n\t\t\tMAKWA_BADPARAM);\n\t\tbreak;\n\tdefault:\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tctx->mod_len = BN_num_bytes(ctx->modulus);\n\tif (ctx->mod_len < 160) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\n\t/*\n\t * Set/check hash function.\n\t */\n\tif (hash_function == 0) {\n\t\thash_function = MAKWA_SHA256;\n\t} else {\n\t\tswitch (hash_function) {\n\t\tcase MAKWA_SHA256:\n\t\tcase MAKWA_SHA512:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tRETURN(MAKWA_BADPARAM);\n\t\t}\n\t}\n\tctx->hash_function = hash_function;\n\n\t/*\n\t * Compute modulus ID.\n\t */\n\tCZ(tmp_mod = malloc(ctx->mod_len));\n\tBN_bn2bin(ctx->modulus, tmp_mod);\n\tCF(makwa_kdf(hash_function, tmp_mod,\n\t\tctx->mod_len, ctx->modID, sizeof ctx->modID));\n\n\t/*\n\t * Set extra parameters (default values for the \"simple API\").\n\t */\n\tctx->default_pre_hash = default_pre_hash;\n\tif (default_post_hash_length > 0 && default_post_hash_length < 10) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tctx->default_post_hash_length = default_post_hash_length;\n\tif (default_work_factor == 0) {\n\t\tdefault_work_factor = 4096;\n\t} else if (default_work_factor < 0) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t} else if (wflog(default_work_factor, NULL) < 0) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tctx->default_work_factor = default_work_factor;\n\nFUNCTION_EXIT:\n\tFREE_BNCTX(bnctx);\n\tFREE(tmp_mod);\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_export_public(const makwa_context *ctx, void *out, size_t *out_len)\n{\n\tint err;\n\n\tDO_BUFFER(out, out_len, ctx->mod_len + 6);\n\tencode_32(out, MAGIC_PUBKEY);\n\tCF(encode_mpi(ctx->modulus, (unsigned char *)out + 4, NULL));\n\nFUNCTION_EXIT:\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_compute_modulus(\n\tconst void *key, size_t key_len, void *mod, size_t *mod_len)\n{\n\tmakwa_context *mc;\n\tint err;\n\n\tmc = NULL;\n\tCZ(mc = makwa_new());\n\tCF(makwa_init(mc, key, key_len, 0));\n\tCF(makwa_export_public(mc, mod, mod_len));\n\nFUNCTION_EXIT:\n\tmakwa_free(mc);\n\treturn err;\n}\n\n/*\n * Convert an integer into a sequence of bytes. The resulting sequence\n * has the provided length k (nominally, the length of the modulus).\n */\nstatic int\nI2OSP_ex(size_t k, BIGNUM *v, void *dst)\n{\n\tunsigned char *buf;\n\tsize_t len;\n\n\tbuf = dst;\n\tlen = BN_num_bytes(v);\n\tif (len > k) {\n\t\treturn MAKWA_TOOLARGE;\n\t} else if (len < k) {\n\t\tmemset(buf, 0, k - len);\n\t\tbuf += k - len;\n\t}\n\tBN_bn2bin(v, buf);\n\treturn MAKWA_OK;\n}\n\n/*\n * Convert an integer into a sequence of bytes. The resulting sequence\n * has the same length as the modulus.\n */\nstatic int\nI2OSP(const makwa_context *ctx, BIGNUM *v, void *dst)\n{\n\treturn I2OSP_ex(ctx->mod_len, v, dst);\n}\n\n/*\n * Convert a sequence of bytes into an integer; the source sequence\n * has the same length as the modulus. The resulting integer is\n * verified to be in the 1..n-1 range.\n */\nstatic int\nOS2IP(const makwa_context *ctx, const void *src, BIGNUM *v)\n{\n\tsize_t k;\n\n\tk = ctx->mod_len;\n\tif (BN_bin2bn(src, k, v) == NULL) {\n\t\treturn MAKWA_NOMEM;\n\t}\n\tif (BN_is_zero(v) || BN_cmp(ctx->modulus, v) <= 0) {\n\t\treturn MAKWA_BADPARAM;\n\t}\n\treturn MAKWA_OK;\n}\n\n/*\n * Apply a sequence of squarings to a modular integer 'x'. The context\n * must contain a private key; the \"fast path\" is used. Beware that\n * this function only accepts positive 'w'.\n */\nstatic int\nmulti_square_CRT(const makwa_context *ctx, BIGNUM *x, long w)\n{\n\tBN_CTX *bnctx;\n\tBIGNUM *p, *q, *iq;\n\tBIGNUM *xp, *xq, *ep, *eq, *b2, *bw;\n\tBIGNUM *temps[6];\n\tint i, err;\n\n\tbnctx = NULL;\n\tp = ctx->p;\n\tq = ctx->q;\n\tiq = ctx->iq;\n\tfor (i = 0; i < 6; i ++) {\n\t\ttemps[i] = NULL;\n\t}\n\tfor (i = 0; i < 6; i ++) {\n\t\tCZ(temps[i] = BN_new());\n\t}\n\txp = temps[0];\n\txq = temps[1];\n\tep = temps[2];\n\teq = temps[3];\n\tb2 = temps[4];\n\tbw = temps[5];\n\tCZ(bnctx = BN_CTX_new());\n\n\tCZ(BN_set_word(b2, 2));\n\tCZ(BN_set_word(bw, w));\n\tCZ(BN_copy(xp, p));\n\tCZ(BN_sub_word(xp, 1));\n\tCZ(BN_mod_exp(ep, b2, bw, xp, bnctx));\n\tCZ(BN_copy(xq, q));\n\tCZ(BN_sub_word(xq, 1));\n\tCZ(BN_mod_exp(eq, b2, bw, xq, bnctx));\n\tCZ(BN_mod(xp, x, p, bnctx));\n\tCZ(BN_mod(xq, x, q, bnctx));\n\tCZ(BN_mod_exp(xp, xp, ep, p, bnctx));\n\tCZ(BN_mod_exp(xq, xq, eq, q, bnctx));\n\tCZ(BN_mod_sub(b2, xp, xq, p, bnctx));\n\tCZ(BN_mod_mul(b2, b2, iq, p, bnctx));\n\tCZ(BN_mul(b2, b2, q, bnctx));\n\tCZ(BN_add(x, xq, b2));\n\nFUNCTION_EXIT:\n\tfor (i = 0; i < 6; i ++) {\n\t\tFREE_BN(temps[i]);\n\t}\n\tFREE_BNCTX(bnctx);\n\treturn err;\n}\n\n/*\n * Revert a sequence of squarings on an integer 'x'. This function returns\n * the 'reverted' value modulo p and modulo q, in xp and xq. 'nw' contains\n * the number of squarings to revert (i.e. it is a nonnegative integer).\n */\nstatic int\nrevert_multi_square(const makwa_context *ctx,\n\tBIGNUM *x, long nw, BIGNUM *xp, BIGNUM *xq)\n{\n\tBN_CTX *bnctx;\n\tBIGNUM *p, *q;\n\tBIGNUM *ep, *eq, *bw;\n\tBIGNUM *temps[3];\n\tint i, err;\n\n\tbnctx = NULL;\n\tp = ctx->p;\n\tq = ctx->q;\n\tfor (i = 0; i < 3; i ++) {\n\t\ttemps[i] = NULL;\n\t}\n\tfor (i = 0; i < 3; i ++) {\n\t\tCZ(temps[i] = BN_new());\n\t}\n\tep = temps[0];\n\teq = temps[1];\n\tbw = temps[2];\n\tCZ(bnctx = BN_CTX_new());\n\n\tCZ(BN_set_word(bw, nw));\n\n\t/* Compute the e'_p exponent. */\n\tCZ(BN_copy(ep, p));\n\tCZ(BN_add_word(ep, 1));\n\tCZ(BN_rshift(ep, ep, 2));\n\tCZ(BN_copy(xp, p));\n\tCZ(BN_sub_word(xp, 1));\n\tCZ(BN_mod_exp(ep, ep, bw, xp, bnctx));\n\n\t/* Compute the e'_q exponent. */\n\tCZ(BN_copy(eq, q));\n\tCZ(BN_add_word(eq, 1));\n\tCZ(BN_rshift(eq, eq, 2));\n\tCZ(BN_copy(xq, q));\n\tCZ(BN_sub_word(xq, 1));\n\tCZ(BN_mod_exp(eq, eq, bw, xq, bnctx));\n\n\t/* Do the exponentiations. */\n\tCZ(BN_mod(xp, x, p, bnctx));\n\tCZ(BN_mod(xq, x, q, bnctx));\n\tCZ(BN_mod_exp(xp, xp, ep, p, bnctx));\n\tCZ(BN_mod_exp(xq, xq, eq, q, bnctx));\n\nFUNCTION_EXIT:\n\tfor (i = 0; i < 3; i ++) {\n\t\tFREE_BN(temps[i]);\n\t}\n\tFREE_BNCTX(bnctx);\n\treturn err;\n}\n\n/*\n * Apply the CRT.\n */\nstatic int\napply_CRT(const makwa_context *ctx, BIGNUM *xp, BIGNUM *xq, BIGNUM *x)\n{\n\tBN_CTX *bnctx;\n\tBIGNUM *p, *q, *iq, *t;\n\tint err;\n\n\tt = NULL;\n\tbnctx = NULL;\n\tCZ(t = BN_new());\n\tCZ(bnctx = BN_CTX_new());\n\tp = ctx->p;\n\tq = ctx->q;\n\tiq = ctx->iq;\n\tCZ(BN_mod_sub(t, xp, xq, p, bnctx));\n\tCZ(BN_mod_mul(t, t, iq, p, bnctx));\n\tCZ(BN_mul(t, t, q, bnctx));\n\tCZ(BN_add(x, xq, t));\n\nFUNCTION_EXIT:\n\tFREE_BN(t);\n\tFREE_BNCTX(bnctx);\n\treturn err;\n}\n\n/*\n * Apply a sequence of squarings to an integer 'x' modulo 'n'. This\n * function is context-free.\n *\n * Returned value is 0 (MAKWA_OK) on success, or a negative error code.\n */\nstatic int\nmulti_square_cf(BIGNUM *x, unsigned long w, BIGNUM *n)\n{\n\tBN_CTX *bnctx;\n\tBN_MONT_CTX *mctx;\n\tint err;\n\n\tbnctx = NULL;\n\tmctx = NULL;\n\tCZ(bnctx = BN_CTX_new());\n\tCZ(mctx = BN_MONT_CTX_new());\n\tCZ(BN_MONT_CTX_set(mctx, n, bnctx));\n\tCZ(BN_to_montgomery(x, x, mctx, bnctx));\n\twhile (w -- > 0) {\n\t\tCZ(BN_mod_mul_montgomery(x, x, x, mctx, bnctx));\n\t}\n\tCZ(BN_from_montgomery(x, x, mctx, bnctx));\n\nFUNCTION_EXIT:\n\tFREE_BNCTX(bnctx);\n\tFREE_MCTX(mctx);\n\treturn err;\n}\n\n/*\n * Apply a sequence of squarings to a modular integer 'x'. If the context\n * contains a private key and the number of squarings is large enough to\n * make it worth, the \"fast path\" is used. If the 'w' parameter is negative,\n * then a private key MUST be known.\n */\nstatic int\nmulti_square(const makwa_context *ctx, BIGNUM *x, long w)\n{\n\tBIGNUM *xp, *xq;\n\tint err;\n\tint has_private;\n\n\txp = NULL;\n\txq = NULL;\n\thas_private = ctx->p != NULL && ctx->q != NULL && ctx->iq != NULL;\n\n\t/*\n\t * For a negative count, we must apply the private key.\n\t */\n\tif (w < 0) {\n\t\t/*\n\t\t * We reject the case w == LONG_MIN because on most systems,\n\t\t * -LONG_MIN is an overflow and goes back to LONG_MIN, i.e.\n\t\t * negative. You cannot get such a difference from two\n\t\t * nonnegative work factors which fit in a 'long' value\n\t\t * anyway.\n\t\t */\n#if -LONG_MAX != LONG_MIN\n\t\tif (w == LONG_MIN) {\n\t\t\tRETURN(MAKWA_TOOLARGE);\n\t\t}\n#endif\n\t\tif (!has_private) {\n\t\t\tRETURN(MAKWA_NO_PRIVATE_KEY);\n\t\t}\n\t\tCZ(xp = BN_new());\n\t\tCZ(xq = BN_new());\n\t\tCF(revert_multi_square(ctx, x, -w, xp, xq));\n\t\tCF(apply_CRT(ctx, xp, xq, x));\n\t\tRETURN(MAKWA_OK);\n\t}\n\n\t/*\n\t * If there is a private key, and the square count is at least\n\t * equal to about 34% of the modulus length (in bits), then it\n\t * is worthwhile to switch to the \"fast path\".\n\t */\n\tif (has_private) {\n\t\tlong thr;\n\n\t\tthr = (((long)BN_num_bits(ctx->modulus) * 34) + 50) / 100;\n\t\tif (w > thr) {\n\t\t\tCF(multi_square_CRT(ctx, x, w));\n\t\t\tRETURN(MAKWA_OK);\n\t\t}\n\t}\n\n\t/*\n\t * Normal path. We convert the integer to Montgomery representation,\n\t * then square repeatedly with Montgomery multiplication.\n\t */\n\tCF(multi_square_cf(x, (unsigned long)w, ctx->modulus));\n\nFUNCTION_EXIT:\n\tFREE_BN(xp);\n\tFREE_BN(xq);\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_hash(const makwa_context *ctx,\n\tconst void *input, size_t input_len,\n\tconst void *salt, size_t salt_len,\n\tint pre_hash,\n\tsize_t post_hash_length,\n\tlong work_factor,\n\tvoid *out, size_t *out_len)\n{\n\tconst unsigned char *pi;\n\tsize_t k, u, blen;\n\tunsigned char tmp_pi[64];\n\tunsigned char *Xbuf, *tmp;\n\tBIGNUM *x;\n\tint err;\n\n\tXbuf = NULL;\n\ttmp = NULL;\n\tx = NULL;\n\n\t/* 1. Filter out error conditions on input parameters. */\n\tk = ctx->mod_len;\n\tif (!pre_hash && (input_len > (k - 32) || input_len > 255)) {\n\t\tRETURN(MAKWA_TOOLARGE);\n\t}\n\n\t/* 2. Check and/or return output buffer size. */\n\tblen = (post_hash_length > 0) ? post_hash_length : k;\n\tDO_BUFFER(out, out_len, blen);\n\n\t/* 3. Output buffer is present and large enough; compute the\n\t      hash value. */\n\t/* Pre-hashing (if applicable). */\n\tif (pre_hash) {\n\t\tCF(makwa_kdf(ctx->hash_function,\n\t\t\tinput, input_len, tmp_pi, 64));\n\t\tpi = tmp_pi;\n\t\tu = 64;\n\t} else {\n\t\tpi = input;\n\t\tu = input_len;\n\t}\n\n\t/* Allocate and fill Xbuf[] (padding computation). */\n\tCZ(Xbuf = malloc(k));\n\tmemset(Xbuf, 0, k);\n\tCZ(tmp = malloc(salt_len + u + 1));\n\tmemcpy(tmp, salt, salt_len);\n\tmemcpy(tmp + salt_len, pi, u);\n\ttmp[salt_len + u] = u;\n\tCF(makwa_kdf(ctx->hash_function, tmp, salt_len + u + 1,\n\t\tXbuf + 1, k - u - 2));\n\tfree(tmp);\n\ttmp = NULL;\n\tmemcpy(Xbuf + (k - u - 1), pi, u);\n\tXbuf[k - 1] = u;\n\n\t/* Decode X[] into integer x. */\n\tCZ(x = BN_new());\n\tCF(OS2IP(ctx, Xbuf, x));\n\n\t/* Compute all the squarings. There is a corner case in which\n\t   the \"+1\" makes the work factor overflow; we handle that case\n\t   by calling multi_square() twice in that case. */\n\tif (work_factor == LONG_MAX) {\n\t\tCF(multi_square(ctx, x, work_factor));\n\t\tCF(multi_square(ctx, x, 1));\n\t} else {\n\t\tCF(multi_square(ctx, x, work_factor + 1));\n\t}\n\n\t/* Encode the result back into XBuf[]; this is the primary output. */\n\tCF(I2OSP(ctx, x, Xbuf));\n\n\t/* Return the primary output, or apply post-hashing, depending on\n\t   the parameters. */\n\tif (post_hash_length == 0) {\n\t\tmemcpy(out, Xbuf, k);\n\t} else {\n\t\tCF(makwa_kdf(ctx->hash_function,\n\t\t\tXbuf, k, out, post_hash_length));\n\t}\n\nFUNCTION_EXIT:\n\tFREE(Xbuf);\n\tFREE(tmp);\n\tFREE_BN(x);\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_change_work_factor(const makwa_context *ctx,\n\tvoid *out, size_t out_len, long diff_wf)\n{\n\tBIGNUM *x;\n\tint err;\n\n\tx = NULL;\n\tif (out_len != ctx->mod_len) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tCZ(x = BN_new());\n\tCF(OS2IP(ctx, out, x));\n\tCF(multi_square(ctx, x, diff_wf));\n\tCF(I2OSP(ctx, x, out));\n\nFUNCTION_EXIT:\n\tFREE_BN(x);\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_unescrow(const makwa_context *ctx,\n\tconst void *salt, size_t salt_len,\n\tlong work_factor, void *out, size_t *out_len)\n{\n\tsize_t k;\n\tBN_CTX *bnctx;\n\tBIGNUM *x, *xp, *xq;\n\tBIGNUM *temp[7];\n\tint i, err;\n\tunsigned char *unesc;\n\tunsigned char *buf;\n\n\t/* Allocate temporaries. */\n\tbnctx = NULL;\n\tunesc = NULL;\n\tbuf = NULL;\n\tfor (i = 0; i < 7; i ++) {\n\t\ttemp[i] = NULL;\n\t}\n\tfor (i = 0; i < 7; i ++) {\n\t\tCZ(temp[i] = BN_new());\n\t}\n\tx = temp[4];\n\txp = temp[5];\n\txq = temp[6];\n\tCZ(bnctx = BN_CTX_new());\n\n\t/* Check input parameters and convert Makwa output to an integer. */\n\tk = ctx->mod_len;\n\tif (*out_len != k) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tif (work_factor < 0) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tif (work_factor == LONG_MAX) {\n\t\t/*\n\t\t * This work factor value would overflow the count (because\n\t\t * of the \"+1\") so we reject it. It does not make practical\n\t\t * sense anyway: it is too large to be used without the\n\t\t * \"fast path\".\n\t\t *\n\t\t * (If we really want to handle it, then we could copy\n\t\t * the value to a temporary buffer and apply a work factor\n\t\t * decrease on it).\n\t\t */\n\t\tRETURN(MAKWA_TOOLARGE);\n\t}\n\tCF(OS2IP(ctx, out, x));\n\n\t/* Revert the squarings, yielding candidates x_p and x_q. */\n\tCF(revert_multi_square(ctx, x, work_factor + 1, xp, xq));\n\n\t/*\n\t * Build all four candidates for x.\n\t */\n\tCF(apply_CRT(ctx, xp, xq, temp[0]));\n\tCZ(BN_mod_sub(xp, ctx->p, xp, ctx->p, bnctx));\n\tCF(apply_CRT(ctx, xp, xq, temp[1]));\n\tCZ(BN_mod_sub(xq, ctx->q, xq, ctx->q, bnctx));\n\tCF(apply_CRT(ctx, xp, xq, temp[2]));\n\tCZ(BN_mod_sub(xp, ctx->p, xp, ctx->p, bnctx));\n\tCF(apply_CRT(ctx, xp, xq, temp[3]));\n\n\t/* Check all candidates: for each of them, we extract and recompute\n\t   the padding. Checking for 30 bytes is sufficient. */\n\tCZ(unesc = malloc(k));\n\tfor (i = 0;; i ++) {\n\t\tsize_t u;\n\t\tunsigned char pad[30];\n\n\t\tif (i == 4) {\n\t\t\t/*\n\t\t\t * All four candidates were checked; neither has\n\t\t\t * the correct format.\n\t\t\t */\n\t\t\tRETURN(MAKWA_UNESCROW_ERROR);\n\t\t}\n\t\tCF(I2OSP(ctx, temp[i], unesc));\n\t\tif (unesc[0] != 0x00) {\n\t\t\tcontinue;\n\t\t}\n\t\tu = unesc[k - 1];\n\t\tif (u > (k - 32)) {\n\t\t\tcontinue;\n\t\t}\n\t\tCZ(buf = malloc(salt_len + u + 1));\n\t\tmemcpy(buf, salt, salt_len);\n\t\tmemcpy(buf + salt_len, unesc + k - 1 - u, u + 1);\n\t\tCF(makwa_kdf(ctx->hash_function,\n\t\t\tbuf, salt_len + u + 1, pad, sizeof pad));\n\t\tfree(buf);\n\t\tbuf = NULL;\n\t\tif (memcmp(unesc + 1, pad, sizeof pad) == 0) {\n\t\t\tmemcpy(out, unesc + k - 1 - u, u);\n\t\t\tmemset(out + u, 0, k - u);\n\t\t\t*out_len = u;\n\t\t\tbreak;\n\t\t}\n\t}\n\nFUNCTION_EXIT:\n\tfor (i = 0; i < 7; i ++) {\n\t\tFREE_BN(temp[i]);\n\t}\n\tFREE(unesc);\n\tFREE_BNCTX(bnctx);\n\tFREE(buf);\n\treturn err;\n}\n\n/*\n * NOTE: all the Base64 support code in this file is for the Base64\n * variant as specified by Makwa (annex A.4.1). Namely:\n * -- there is no embedded newline;\n * -- non-Base64 characters (e.g. spaces) are not ignored/tolerated;\n * -- the padding '=' signs are not used.\n */\n\n/*\n * Compute the length in characters for the Base64 encoding of a given\n * number of source bytes. WARNING: that length DOES NOT INCLUDE the\n * terminating zero.\n */\nstatic size_t\nb64_length(size_t data_len)\n{\n\tsize_t len, n;\n\n\tn = data_len / 3;\n\tlen = n << 2;\n\tswitch (data_len - 3 * n) {\n\tcase 1:\n\t\tlen += 2;\n\t\tbreak;\n\tcase 2:\n\t\tlen += 3;\n\t\tbreak;\n\t}\n\treturn len;\n}\n\nstatic size_t\nget_string_output_length(size_t salt_len, size_t out_len)\n{\n\t/*\n\t * Base64 of modulus ID: 11 chars.\n\t * Flags: 4 chars.\n\t * Separators: 3 chars.\n\t * Final zero: 1 char.\n\t */\n\treturn 19 + b64_length(salt_len) + b64_length(out_len);\n}\n\n/* see makwa.h */\nsize_t\nmakwa_get_string_output_length(\n\tconst makwa_context *ctx, size_t salt_len, size_t post_hash_length)\n{\n\tsize_t out_len;\n\n\tif (post_hash_length == 0) {\n\t\tout_len = ctx->mod_len;\n\t} else {\n\t\tout_len = post_hash_length;\n\t}\n\treturn get_string_output_length(salt_len, out_len);\n}\n\n/*\n * Base64-encode some bytes. The output buffer is assumed to be large\n * enough. The returned string is zero-terminated. The length of the\n * produced string is returned, EXCLUDING the terminating zero.\n */\nstatic size_t\nb64_encode(const void *src, size_t src_len, void *dst)\n{\n\tconst unsigned char *in;\n\tchar *out;\n\tsize_t out_len;\n\tunsigned v;\n\n\tstatic const char B64[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t\"abcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n\tin = src;\n\tout = dst;\n\tout_len = 0;\n\twhile (src_len >= 3) {\n\t\tv = *in ++;\n\t\t*out ++ = B64[v >> 2];\n\t\tv = (v << 8) | *in ++;\n\t\t*out ++ = B64[(v >> 4) & 0x3F];\n\t\tv = (v << 8) | *in ++;\n\t\t*out ++ = B64[(v >> 6) & 0x3F];\n\t\t*out ++ = B64[v & 0x3F];\n\t\tsrc_len -= 3;\n\t\tout_len += 4;\n\t}\n\tswitch (src_len) {\n\tcase 1:\n\t\tv = *in ++;\n\t\t*out ++ = B64[v >> 2];\n\t\t*out ++ = B64[(v << 4) & 0x3F];\n\t\tout_len += 2;\n\t\tbreak;\n\tcase 2:\n\t\tv = *in ++;\n\t\t*out ++ = B64[v >> 2];\n\t\tv = (v << 8) | *in ++;\n\t\t*out ++ = B64[(v >> 4) & 0x3F];\n\t\t*out ++ = B64[(v << 2) & 0x3F];\n\t\tout_len += 3;\n\t\tbreak;\n\t}\n\t*out = 0;\n\treturn out_len;\n}\n\n/*\n * Base64-decode some characters. Decoding stops at the first non-Base64\n * character, or when src_len characters have been processed, whichever\n * comes first. The number of decoded bytes is returned.\n *\n * This function does NOT check for pending non-zero bits.\n */\nstatic size_t\nb64_decode(const void *src, size_t src_len, void *dst)\n{\n\tconst char *in;\n\tunsigned char *out;\n\tsize_t out_len;\n\tunsigned acc, acc_num;\n\n\tin = src;\n\tout = dst;\n\tout_len = 0;\n\tacc = 0;\n\tacc_num = 0;\n\twhile (src_len > 0) {\n\t\tunsigned c;\n\n\t\tc = *in ++;\n\t\tsrc_len --;\n\t\tif (c >= 'A' && c <= 'Z') {\n\t\t\tc -= 'A';\n\t\t} else if (c >= 'a' && c <= 'z') {\n\t\t\tc -= ('a' - 26);\n\t\t} else if (c >= '0' && c <= '9') {\n\t\t\tc -= ('0' - 52);\n\t\t} else if (c == '+') {\n\t\t\tc = 62;\n\t\t} else if (c == '/') {\n\t\t\tc = 63;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tacc = (acc << 6) | c;\n\t\tacc_num += 6;\n\t\tif (acc_num >= 8) {\n\t\t\t*out ++ = (acc >> (acc_num - 8)) & 0xFF;\n\t\t\tout_len ++;\n\t\t\tacc_num -= 8;\n\t\t}\n\t}\n\treturn out_len;\n}\n\n/*\n * Mock decoding: this function is similar to b64_decode(), except that\n * it does not write the decoded bytes anywhere. It simply returns the\n * number of bytes that b64_decode() would decode.\n */\nstatic size_t\nb64_ahead(const void *src, size_t src_len)\n{\n\tconst char *in;\n\tsize_t zlen;\n\tunsigned low;\n\n\tin = src;\n\tzlen = 0;\n\tlow = 0;\n\twhile (src_len > 0) {\n\t\tint c;\n\n\t\tc = *in ++;\n\t\tsrc_len --;\n\t\tif ((c >= 'A' && c <= 'Z')\n\t\t\t|| (c >= 'a' && c <= 'z')\n\t\t\t|| (c >= '0' && c <= '9')\n\t\t\t|| c == '+' || c == '/')\n\t\t{\n\t\t\tlow += 6;\n\t\t\tif (low >= 8) {\n\t\t\t\tlow &= 7;\n\t\t\t\tzlen ++;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn zlen;\n}\n\nstatic int\nencode_string_inner(const unsigned char *modID, size_t mod_len,\n\tconst void *salt, size_t salt_len,\n\tint pre_hash,\n\tsize_t post_hash_length,\n\tlong work_factor,\n\tconst void *bin_out,\n\tchar *str_out, size_t *str_out_len)\n{\n\tsize_t u, clen, bin_out_len, off;\n\tint wfl, wfm;\n\tint err;\n\n\t/*\n\t * Verify input parameters. We also don't want our computations\n\t * to overflow, so we require that the salt and binary output\n\t * lengths remain no longer than half the maximum value in a size_t,\n\t * and we require the same for their sum.\n\t * \n\t * Make sure that the parameters don't make our integers overflow.\n\t */\n\tif (((salt_len << 1) >> 1) != salt_len\n\t\t|| ((post_hash_length << 1) >> 1) != post_hash_length)\n\t{\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tu = salt_len + post_hash_length;\n\tif (((u << 1) >> 1) != u) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tCF(wfl = wflog(work_factor, &wfm));\n\tif (post_hash_length > 0 && post_hash_length < 10) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\n\t/*\n\t * Compute string output length; check it or return it.\n\t */\n\tbin_out_len = (post_hash_length > 0) ? post_hash_length : mod_len;\n\tclen = get_string_output_length(salt_len, bin_out_len);\n\tDO_BUFFER(str_out, str_out_len, clen);\n\n\t/*\n\t * The buffer is present and large enough; let's encode.\n\t */\n\toff = 0;\n\toff += b64_encode(modID, 8, str_out + off);\n\tstr_out[off ++] = '_';\n\tif (pre_hash) {\n\t\tif (post_hash_length > 0) {\n\t\t\tstr_out[off ++] = 'b';\n\t\t} else {\n\t\t\tstr_out[off ++] = 'r';\n\t\t}\n\t} else {\n\t\tif (post_hash_length > 0) {\n\t\t\tstr_out[off ++] = 's';\n\t\t} else {\n\t\t\tstr_out[off ++] = 'n';\n\t\t}\n\t}\n\tstr_out[off ++] = wfm + '0';\n\tstr_out[off ++] = (wfl / 10) + '0';\n\tstr_out[off ++] = (wfl % 10) + '0';\n\tstr_out[off ++] = '_';\n\toff += b64_encode(salt, salt_len, str_out + off);\n\tstr_out[off ++] = '_';\n\toff += b64_encode(bin_out, bin_out_len, str_out + off);\n\tstr_out[off ++] = 0;\n\nFUNCTION_EXIT:\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_encode_string(const makwa_context *ctx,\n\tconst void *salt, size_t salt_len,\n\tint pre_hash,\n\tsize_t post_hash_length,\n\tlong work_factor,\n\tconst void *bin_out,\n\tchar *str_out, size_t *str_out_len)\n{\n\treturn encode_string_inner(ctx->modID, ctx->mod_len,\n\t\tsalt, salt_len, pre_hash, post_hash_length,\n\t\twork_factor, bin_out, str_out, str_out_len);\n}\n\n/* see makwa.h */\nint\nmakwa_decode_string(const makwa_context *ctx,\n\tconst char *str,\n\tvoid *salt, size_t *salt_len,\n\tint *pre_hash,\n\tsize_t *post_hash_length,\n\tlong *work_factor,\n\tvoid *out, size_t *out_len)\n{\n\tunsigned char tmp[8];\n\tint preH, post_hash;\n\tint wfl;\n\tlong wfm;\n\tint d;\n\tsize_t b_salt_len, s_salt_len;\n\tsize_t b_out_len, s_out_len;\n\tint err, delayed_err;\n\n\tdelayed_err = 0;\n\n\t/*\n\t * Decode modulus ID (8-byte checksum).\n\t */\n\tif (b64_decode(str, 11, tmp) != 8) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tstr += b64_length(8);\n\tif (memcmp(tmp, ctx->modID, sizeof tmp) != 0) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tif (*str ++ != '_') {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\n\t/*\n\t * The flags (pre-hashing, post-hashing, work factor).\n\t */\n\tswitch (*str ++) {\n\tcase 'n':\n\t\tpreH = 0;\n\t\tpost_hash = 0;\n\t\tbreak;\n\tcase 'r':\n\t\tpreH = 1;\n\t\tpost_hash = 0;\n\t\tbreak;\n\tcase 's':\n\t\tpreH = 0;\n\t\tpost_hash = 1;\n\t\tbreak;\n\tcase 'b':\n\t\tpreH = 1;\n\t\tpost_hash = 1;\n\t\tbreak;\n\tdefault:\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tif (pre_hash != NULL) {\n\t\t*pre_hash = preH;\n\t}\n\tswitch (*str ++) {\n\tcase '2':\n\t\twfm = 2;\n\t\tbreak;\n\tcase '3':\n\t\twfm = 3;\n\t\tbreak;\n\tdefault:\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\td = *str ++;\n\tif (d < '0' || d > '9') {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\twfl = d - '0';\n\td = *str ++;\n\tif (d < '0' || d > '9') {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\twfl = 10 * wfl + d - '0';\n\tif (*str ++ != '_') {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\n\t/*\n\t * We need to take care when computing the work factor: we may\n\t * overflow, and C language does not guarantee behaviour in those\n\t * cases.\n\t */\n\twhile (wfl > 0) {\n\t\tif (wfm > (LONG_MAX >> 1)) {\n\t\t\tRETURN(MAKWA_TOOLARGE);\n\t\t}\n\t\twfm <<= 1;\n\t\twfl --;\n\t}\n\tif (work_factor != NULL) {\n\t\t*work_factor = wfm;\n\t}\n\n\t/*\n\t * The salt. Behaviour depends on whether the caller wants to\n\t * retrieve the salt value or not. We do not use the DO_BUFFER\n\t * macro because this function has two output buffers, and we\n\t * want to be able to report both lengths.\n\t */\n\tb_salt_len = b64_ahead(str, strlen(str));\n\ts_salt_len = b64_length(b_salt_len);\n\tif (salt == NULL) {\n\t\tif (salt_len != NULL) {\n\t\t\t*salt_len = b_salt_len;\n\t\t}\n\t} else {\n\t\tif (salt_len != NULL && *salt_len < b_salt_len) {\n\t\t\t*salt_len = b_salt_len;\n\t\t\tdelayed_err = MAKWA_BUFFER_TOO_SMALL;\n\t\t\tsalt = NULL;\n\t\t\t/* The salt buffer was too small but we must\n\t\t\t   keep on, because the caller may also be\n\t\t\t   interested in the output buffer length. */\n\t\t} else {\n\t\t\tb64_decode(str, s_salt_len, salt);\n\t\t\tif (salt_len != NULL) {\n\t\t\t\t*salt_len = b_salt_len;\n\t\t\t}\n\t\t}\n\t}\n\tstr += s_salt_len;\n\tif (*str ++ != '_') {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\n\t/*\n\t * The output itself. If post-hashing is used, then the output\n\t * length must encode at least 10 bytes; otherwise, the output\n\t * must match that of the modulus.\n\t */\n\tb_out_len = b64_ahead(str, strlen(str));\n\ts_out_len = b64_length(b_out_len);\n\tif (post_hash) {\n\t\tif (b_out_len < 10) {\n\t\t\tRETURN(MAKWA_BADPARAM);\n\t\t}\n\t\tif (post_hash_length != NULL) {\n\t\t\t*post_hash_length = b_out_len;\n\t\t}\n\t} else {\n\t\tif (b_out_len != ctx->mod_len) {\n\t\t\tRETURN(MAKWA_BADPARAM);\n\t\t}\n\t\tif (post_hash_length != NULL) {\n\t\t\t*post_hash_length = 0;\n\t\t}\n\t}\n\tif (out != NULL) {\n\t\tif (*out_len < b_out_len) {\n\t\t\t*out_len = b_out_len;\n\t\t\tRETURN(MAKWA_BUFFER_TOO_SMALL);\n\t\t}\n\t\tb64_decode(str, s_out_len, out);\n\t}\n\tif (out_len != NULL) {\n\t\t*out_len = b_out_len;\n\t}\n\tstr += s_out_len;\n\tif (*str != 0) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\n\t/*\n\t * All decoding proceeded correctly, except possibly a \"too small\n\t * buffer\" error with the salt.\n\t */\nFUNCTION_EXIT:\n\tif (err == 0 && delayed_err < 0) {\n\t\terr = delayed_err;\n\t}\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_simple_hash_new(const makwa_context *ctx,\n\tconst char *password, char *str_out, size_t *str_out_len)\n{\n\tunsigned char salt[16], *tmp;\n\tsize_t zlen, tmp_len;\n\tint err;\n\n\ttmp = NULL;\n\n\t/*\n\t * We first check the output buffer length: an initial call with\n\t * no output buffer must be fast.\n\t */\n\tzlen = makwa_get_string_output_length(ctx,\n\t\tsizeof salt, ctx->default_post_hash_length);\n\tDO_BUFFER(str_out, str_out_len, zlen);\n\n\t/*\n\t * Generate a new random salt.\n\t */\n\tCF(makwa_make_new_salt(salt, sizeof salt));\n\n\t/*\n\t * Generate the output into a temporary buffer.\n\t */\n\tCF(makwa_hash(ctx, password, strlen(password),\n\t\tsalt, sizeof salt, ctx->default_pre_hash,\n\t\tctx->default_post_hash_length, ctx->default_work_factor,\n\t\tNULL, &tmp_len));\n\tCZ(tmp = malloc(tmp_len));\n\tCF(makwa_hash(ctx, password, strlen(password),\n\t\tsalt, sizeof salt, ctx->default_pre_hash,\n\t\tctx->default_post_hash_length, ctx->default_work_factor,\n\t\ttmp, &tmp_len));\n\n\t/*\n\t * Encode the string. We already checked the buffer length.\n\t */\n\tCF(makwa_encode_string(ctx,\n\t\tsalt, sizeof salt, ctx->default_pre_hash,\n\t\tctx->default_post_hash_length, ctx->default_work_factor,\n\t\ttmp, str_out, str_out_len));\n\nFUNCTION_EXIT:\n\tFREE(tmp);\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_simple_hash_verify(const makwa_context *ctx,\n\tconst char *password, const char *ref_str)\n{\n\tvoid *salt;\n\tsize_t salt_len;\n\tint pre_hash;\n\tsize_t post_hash_length;\n\tlong work_factor;\n\tvoid *ref, *out;\n\tsize_t ref_len, out_len;\n\tint err;\n\n\tsalt = NULL;\n\tref = NULL;\n\tout = NULL;\n\n\t/*\n\t * 1. Decode reference string, to obtain the binary output, and\n\t *    also the parameters needed to recompute that output.\n\t */\n\tCF(makwa_decode_string(ctx, ref_str, NULL, &salt_len,\n\t\t&pre_hash, &post_hash_length, &work_factor, NULL, &ref_len));\n\tif (salt_len > 0) {\n\t\tCZ(salt = malloc(salt_len));\n\t}\n\tCZ(ref = malloc(ref_len));\n\tCF(makwa_decode_string(ctx, ref_str, salt, &salt_len,\n\t\t&pre_hash, &post_hash_length, &work_factor, ref, &ref_len));\n\n\t/*\n\t * 2. Recompute the hash into a temporary buffer. The output ought\n\t *    to have the same length as the reference output length.\n\t */\n\tout_len = ref_len;\n\tCZ(out = malloc(ref_len));\n\tCF(makwa_hash(ctx, password, strlen(password),\n\t\tsalt, salt_len, pre_hash, post_hash_length, work_factor,\n\t\tout, &out_len));\n\tif (out_len != ref_len || memcmp(out, ref, ref_len) != 0) {\n\t\tRETURN(MAKWA_WRONG_PASSWORD);\n\t}\n\nFUNCTION_EXIT:\n\tFREE(salt);\n\tFREE(ref);\n\tFREE(out);\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_simple_reset_work_factor(const makwa_context *ctx,\n\tchar *str, long new_work_factor)\n{\n\tint err;\n\tsize_t post_hash_length;\n\tlong work_factor;\n\tsize_t salt_len, out_len;\n\tunsigned char *out;\n\tint has_private;\n\tint wfl, wfm;\n\n\tout = NULL;\n\tCF(makwa_decode_string(ctx, str, NULL, &salt_len,\n\t\tNULL, &post_hash_length, &work_factor, NULL, &out_len));\n\n\t/* We cannot change the work factor if post-hashing was applied. */\n\tif (post_hash_length != 0) {\n\t\tRETURN(MAKWA_POST_HASH);\n\t}\n\n\t/* If the work factor is not actually changed, then we are\n\t   finished. */\n\tif (new_work_factor == work_factor) {\n\t\tRETURN(MAKWA_OK);\n\t}\n\n\t/* New work factor must be encodable. */\n\tif (new_work_factor < 0) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tCF(wfl = wflog(new_work_factor, &wfm));\n\n\t/* If we are decreasing the work factor, then we need a private\n\t   key. */\n\thas_private = ctx->p != NULL && ctx->q != NULL && ctx->iq != NULL;\n\tif (new_work_factor < work_factor && !has_private) {\n\t\tRETURN(MAKWA_NO_PRIVATE_KEY);\n\t}\n\n\t/* Get the binary output. */\n\tCZ(out = malloc(out_len));\n\tCF(makwa_decode_string(ctx, str, NULL, NULL,\n\t\tNULL, NULL, NULL, out, &out_len));\n\n\t/*\n\t * Compute the work factor change. Since both work factors are\n\t * in the positive 'long' range, the difference does not overflow.\n\t */\n\tCF(makwa_change_work_factor(ctx, out, out_len,\n\t\tnew_work_factor - work_factor));\n\n\t/*\n\t * Now we just have to reencode the new work factor and output.\n\t * Since the salt has not changed, we can put things back\n\t * directly in the buffer at the \"right place\".\n\t */\n\tstr[13] = '0' + wfm;\n\tstr[14] = '0' + (wfl / 10);\n\tstr[15] = '0' + (wfl % 10);\n\tb64_encode(out, out_len, str + 18 + b64_length(salt_len));\n\nFUNCTION_EXIT:\n\tFREE(out);\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_simple_unescrow(const makwa_context *ctx, char *str)\n{\n\tunsigned char *salt, *out;\n\tsize_t salt_len, out_len;\n\tint pre_hash;\n\tsize_t post_hash_length;\n\tlong work_factor;\n\tint err;\n\tsize_t u;\n\n\tsalt = NULL;\n\tout = NULL;\n\tCF(makwa_decode_string(ctx, str, NULL, &salt_len, &pre_hash,\n\t\t&post_hash_length, &work_factor, NULL, &out_len));\n\tif (pre_hash) {\n\t\tRETURN(MAKWA_PRE_HASH);\n\t}\n\tif (post_hash_length > 0) {\n\t\tRETURN(MAKWA_POST_HASH);\n\t}\n\tCZ(salt = malloc(salt_len));\n\tCZ(out = malloc(out_len));\n\tCF(makwa_decode_string(ctx, str, salt, &salt_len, NULL,\n\t\tNULL, NULL, out, &out_len));\n\tCF(makwa_unescrow(ctx, salt, salt_len, work_factor, out, &out_len));\n\tfor (u = 0; u < out_len; u ++) {\n\t\tif (out[u] == 0) {\n\t\t\tRETURN(MAKWA_EMBEDDED_ZERO);\n\t\t}\n\t}\n\tmemcpy(str, out, out_len + 1);\n\nFUNCTION_EXIT:\n\tFREE(salt);\n\tFREE(out);\n\treturn err;\n}\n\n/* ====================================================================== */\n\nstruct makwa_delegation_parameters_ {\n\tBIGNUM *modulus;\n\tlong work_factor;\n\tsize_t num;\n\tBIGNUM **alpha;\n\tBIGNUM **beta;\n};\n\n/* see makwa.h */\nint\nmakwa_delegation_generate(const void *param, size_t param_len,\n\tlong work_factor, void *out, size_t *out_len)\n{\n\tBN_CTX *bnctx;\n\tmakwa_context *mc;\n\tunsigned char *buf;\n\tsize_t len, mlen, off, u, num;\n\tBIGNUM *z;\n\tint err;\n\n\tbnctx = NULL;\n\tmc = NULL;\n\tz = NULL;\n\tif (work_factor < 0) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\n\t/* As per the specification recommendations, we always generate\n\t   300 mask pairs. */\n\tnum = 300;\n\n\tCZ(mc = makwa_new());\n\tCF(makwa_init(mc, param, param_len, 0));\n\tmlen = mpi_length(mc->modulus);\n\tDO_BUFFER(out, out_len, 10 + (2 * num + 1) * mlen);\n\n\tCZ(bnctx = BN_CTX_new());\n\tCZ(z = BN_new());\n\n\tbuf = out;\n\tencode_32(buf, MAGIC_DELEG_PARAM);\n\toff = 4;\n\tlen = mlen;\n\tCF(encode_mpi(mc->modulus, buf + off, &len));\n\toff += len;\n\tencode_32(buf + off, work_factor);\n\toff += 4;\n\tencode_16(buf + off, num);\n\toff += 2;\n\tfor (u = 0; u < num; u ++) {\n\t\t/*\n\t\t * Each alpha value must be a quadratic residue, so we\n\t\t * apply an initial squaring on the selected random value.\n\t\t */\n\t\tdo {\n\t\t\tCZ(BN_rand_range(z, mc->modulus));\n\t\t} while (BN_is_zero(z));\n\t\tCZ(BN_mod_mul(z, z, z, mc->modulus, bnctx));\n\t\tlen = mlen;\n\t\tCF(encode_mpi(z, buf + off, &len));\n\t\toff += len;\n\t\tCF(multi_square(mc, z, work_factor));\n\t\tCZ(BN_mod_inverse(z, z, mc->modulus, bnctx));\n\t\tlen = mlen;\n\t\tCF(encode_mpi(z, buf + off, &len));\n\t\toff += len;\n\t}\n\tif (out_len != NULL) {\n\t\t*out_len = off;\n\t}\n\nFUNCTION_EXIT:\n\tFREE_BNCTX(bnctx);\n\tFREE_BN(z);\n\tmakwa_free(mc);\n\treturn err;\n}\n\n/* see makwa.h */\nmakwa_delegation_parameters *\nmakwa_delegation_new(void)\n{\n\tmakwa_delegation_parameters *mdp;\n\n\tmdp = malloc(sizeof *mdp);\n\tif (mdp == NULL) {\n\t\treturn NULL;\n\t}\n\tmdp->modulus = NULL;\n\tmdp->work_factor = 0;\n\tmdp->num = 0;\n\tmdp->alpha = NULL;\n\tmdp->beta = NULL;\n\treturn mdp;\n}\n\nstatic void\nmdp_clear(makwa_delegation_parameters *mdp)\n{\n\tFREE_BN(mdp->modulus);\n\tmdp->modulus = NULL;\n\tif (mdp->alpha != NULL) {\n\t\tsize_t u;\n\n\t\tfor (u = 0; u < mdp->num; u ++) {\n\t\t\tFREE_BN(mdp->alpha[u]);\n\t\t}\n\t\tfree(mdp->alpha);\n\t\tmdp->alpha = NULL;\n\t}\n\tif (mdp->beta != NULL) {\n\t\tsize_t u;\n\n\t\tfor (u = 0; u < mdp->num; u ++) {\n\t\t\tFREE_BN(mdp->beta[u]);\n\t\t}\n\t\tfree(mdp->beta);\n\t\tmdp->beta = NULL;\n\t}\n\tmdp->work_factor = 0;\n\tmdp->num = 0;\n}\n\n/* see makwa.h */\nvoid\nmakwa_delegation_free(makwa_delegation_parameters *mdp)\n{\n\tif (mdp == NULL) {\n\t\treturn;\n\t}\n\tmdp_clear(mdp);\n\tfree(mdp);\n}\n\n/* see makwa.h */\nint\nmakwa_delegation_init(makwa_delegation_parameters *mdp,\n\tconst void *param, size_t param_len)\n{\n\tBN_CTX *bnctx;\n\tBN_MONT_CTX *mctx;\n\tsize_t off;\n\tint err;\n\tunsigned long wf;\n\tsize_t u;\n\n\tbnctx = NULL;\n\tmctx = NULL;\n\tCZ(bnctx = BN_CTX_new());\n\tCZ(mctx = BN_MONT_CTX_new());\n\tmdp_clear(mdp);\n\tif (param_len < 4 || decode_32(param, 0) != MAGIC_DELEG_PARAM) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\toff = 4;\n\tCZ(mdp->modulus = BN_new());\n\tCF(decode_mpi(param, &off, param_len, mdp->modulus));\n\tif (BN_num_bytes(mdp->modulus) < 160\n\t\t|| !BN_is_bit_set(mdp->modulus, 0)\n\t\t|| BN_is_bit_set(mdp->modulus, 1))\n\t{\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tCZ(BN_MONT_CTX_set(mctx, mdp->modulus, bnctx));\n\tif (off + 6 > param_len) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\twf = decode_32(param, off);\n\toff += 4;\n\tif (wf > (unsigned long)LONG_MAX) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tmdp->work_factor = (long)wf;\n\tmdp->num = decode_16(param, off);\n\toff += 2;\n\tif (mdp->num == 0) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tCZ(mdp->alpha = malloc(mdp->num * sizeof *(mdp->alpha)));\n\tfor (u = 0; u < mdp->num; u ++) {\n\t\tmdp->alpha[u] = NULL;\n\t}\n\tCZ(mdp->beta = malloc(mdp->num * sizeof *(mdp->beta)));\n\tfor (u = 0; u < mdp->num; u ++) {\n\t\tmdp->beta[u] = NULL;\n\t}\n\tfor (u = 0; u < mdp->num; u ++) {\n\t\tCZ(mdp->alpha[u] = BN_new());\n\t\tCZ(mdp->beta[u] = BN_new());\n\t\tCF(decode_mpi(param, &off, param_len, mdp->alpha[u]));\n\t\tCF(decode_mpi(param, &off, param_len, mdp->beta[u]));\n\t\tif (BN_is_zero(mdp->alpha[u])\n\t\t\t|| BN_cmp(mdp->modulus, mdp->alpha[u]) <= 0\n\t\t\t|| BN_is_zero(mdp->beta[u])\n\t\t\t|| BN_cmp(mdp->modulus, mdp->beta[u]) <= 0)\n\t\t{\n\t\t\tRETURN(MAKWA_BADPARAM);\n\t\t}\n\t\t/* We convert all pair elements to Montgomery\n\t\t   representation. */\n\t\tCZ(BN_to_montgomery(mdp->alpha[u], mdp->alpha[u], mctx, bnctx));\n\t\tCZ(BN_to_montgomery(mdp->beta[u], mdp->beta[u], mctx, bnctx));\n\t}\n\nFUNCTION_EXIT:\n\tFREE_BNCTX(bnctx);\n\tFREE_MCTX(mctx);\n\tif (err != MAKWA_OK) {\n\t\tmdp_clear(mdp);\n\t}\n\treturn err;\n}\n\n/* see makwa.h */\nlong\nmakwa_delegation_get_work_factor(const makwa_delegation_parameters *mdp)\n{\n\treturn mdp->work_factor;\n}\n\n/*\n * Using the delegation parameters, create a \"mask pair\". The caller must\n * put the value to mask in z. This function replaces z with the value to\n * send, and stores the \"unmask\" integer in 'unmask'.\n */\nstatic int\ncreate_mask_pair(const makwa_delegation_parameters *mdp,\n\tBIGNUM *z, BIGNUM *unmask)\n{\n\tBN_CTX *bnctx;\n\tBN_MONT_CTX *mctx;\n\tunsigned char rnd[38];\n\tint err;\n\tsize_t u, n;\n\n\tbnctx = NULL;\n\tmctx = NULL;\n\tif (!RAND_bytes(rnd, sizeof rnd)) {\n\t\tRETURN(MAKWA_RAND_ERROR);\n\t}\n\tCZ(bnctx = BN_CTX_new());\n\tCZ(mctx = BN_MONT_CTX_new());\n\tCZ(BN_MONT_CTX_set(mctx, mdp->modulus, bnctx));\n\tCZ(BN_to_montgomery(z, z, mctx, bnctx));\n\tCZ(BN_set_word(unmask, 1));\n\tCZ(BN_to_montgomery(unmask, unmask, mctx, bnctx));\n\tn = mdp->num;\n\tif (n > 300) {\n\t\tn = 300;\n\t}\n\tfor (u = 0; u < n; u ++) {\n\t\tif (!((rnd[u >> 3] >> (u & 7)) & 1)) {\n\t\t\tcontinue;\n\t\t}\n\t\tCZ(BN_mod_mul_montgomery(\n\t\t\tz, z, mdp->alpha[u], mctx, bnctx));\n\t\tCZ(BN_mod_mul_montgomery(\n\t\t\tunmask, unmask, mdp->beta[u], mctx, bnctx));\n\t}\n\tCZ(BN_from_montgomery(z, z, mctx, bnctx));\n\tCZ(BN_from_montgomery(unmask, unmask, mctx, bnctx));\n\nFUNCTION_EXIT:\n\tFREE_BNCTX(bnctx);\n\tFREE_MCTX(mctx);\n\treturn err;\n}\n\nstruct makwa_delegation_context_ {\n\tBIGNUM *modulus;\n\tunsigned char modID[8];\n\tint hash_function;\n\tBIGNUM *z;\n\tlong work_factor;\n\tBIGNUM *unmask;\n\tint pre_hash;\n\tsize_t post_hash_length;\n\tvoid *salt;\n\tsize_t salt_len;\n\tvoid *ref_out;\n\tsize_t ref_out_len;\n};\n\n/* see makwa.h */\nmakwa_delegation_context *\nmakwa_delegation_context_new(void)\n{\n\tmakwa_delegation_context *mdc;\n\n\tmdc = malloc(sizeof *mdc);\n\tif (mdc == NULL) {\n\t\treturn NULL;\n\t}\n\tmdc->modulus = BN_new();\n\tmdc->z = BN_new();\n\tmdc->unmask = BN_new();\n\tmdc->hash_function = -1;\n\tmdc->salt = NULL;\n\tmdc->ref_out = NULL;\n\tif (mdc->modulus == NULL || mdc->z == NULL || mdc->unmask == NULL) {\n\t\tgoto exit_oom;\n\t}\n\treturn mdc;\n\nexit_oom:\n\tmakwa_delegation_context_free(mdc);\n\treturn NULL;\n}\n\n/* see makwa.h */\nvoid\nmakwa_delegation_context_free(makwa_delegation_context *mdc)\n{\n\tif (mdc == NULL) {\n\t\treturn;\n\t}\n\tFREE_BN(mdc->modulus);\n\tFREE_BN(mdc->z);\n\tFREE_BN(mdc->unmask);\n\tFREE(mdc->salt);\n\tFREE(mdc->ref_out);\n\tfree(mdc);\n}\n\n/* see makwa.h */\nint\nmakwa_hash_delegate_begin(const makwa_context *ctx,\n\tconst makwa_delegation_parameters *mdp,\n\tconst void *input, size_t input_len,\n\tconst void *salt, size_t salt_len,\n\tint pre_hash, size_t post_hash_length,\n\tmakwa_delegation_context *mdc)\n{\n\tint err;\n\tunsigned char *Xbuf;\n\n\tXbuf = NULL;\n\n\t/*\n\t * Verify that the delegation parameters use the same modulus\n\t * as the context.\n\t */\n\tif (BN_cmp(ctx->modulus, mdp->modulus) != 0) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\n\t/*\n\t * Hash with no post-hashing and a work factor 0; the\n\t * output then is the value we want to mask and send.\n\t */\n\tCZ(Xbuf = malloc(ctx->mod_len));\n\tCF(makwa_hash(ctx, input, input_len, salt, salt_len,\n\t\tpre_hash, 0, 0, Xbuf, NULL));\n\tCF(OS2IP(ctx, Xbuf, mdc->z));\n\n\t/*\n\t * Now mask the value.\n\t */\n\tCF(create_mask_pair(mdp, mdc->z, mdc->unmask));\n\tmdc->hash_function = ctx->hash_function;\n\tmdc->work_factor = mdp->work_factor;\n\tmdc->pre_hash = pre_hash;\n\tmdc->post_hash_length = post_hash_length;\n\tCZ(BN_copy(mdc->modulus, mdp->modulus));\n\tmemcpy(mdc->modID, ctx->modID, 8);\n\n\t/*\n\t * We need to keep a copy of the salt, in case a string-encoded\n\t * output is required.\n\t */\n\tFREE(mdc->salt);\n\tmdc->salt = NULL;\n\tif (salt_len > 0) {\n\t\tCZ(mdc->salt = malloc(salt_len));\n\t\tmdc->salt_len = salt_len;\n\t\tmemcpy(mdc->salt, salt, salt_len);\n\t}\n\tFREE(mdc->ref_out);\n\tmdc->ref_out = NULL;\n\nFUNCTION_EXIT:\n\tFREE(Xbuf);\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_hash_delegate_end(const makwa_delegation_context *mdc,\n\tconst void *ans, size_t ans_len,\n\tvoid *out, size_t *out_len)\n{\n\tBN_CTX *bnctx;\n\tBIGNUM *z;\n\tsize_t off, k, len;\n\tvoid *Zbuf;\n\tint err;\n\n\tbnctx = NULL;\n\tz = NULL;\n\tZbuf = NULL;\n\n\tCZ(z = BN_new());\n\n\t/* Decode answer. */\n\toff = 0;\n\tif (ans_len < 4 || decode_32(ans, 0) != MAGIC_DELEG_ANS) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\toff += 4;\n\tCF(decode_mpi(ans, &off, ans_len, z));\n\tif (BN_is_zero(z) || BN_cmp(mdc->modulus, z) <= 0) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tif (off != ans_len) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\n\t/* Process output buffer semantics. */\n\tk = BN_num_bytes(mdc->modulus);\n\tlen = (mdc->post_hash_length == 0) ? k : mdc->post_hash_length;\n\tDO_BUFFER(out, out_len, len);\n\n\t/* Unmask the integer. */\n\tCZ(bnctx = BN_CTX_new());\n\tCZ(BN_mod_mul(z, z, mdc->unmask, mdc->modulus, bnctx));\n\n\t/* Encode result; apply post-hashing if necessary. */\n\tif (mdc->post_hash_length == 0) {\n\t\tCF(I2OSP_ex(k, z, out));\n\t} else {\n\t\tCZ(Zbuf = malloc(k));\n\t\tCF(I2OSP_ex(k, z, Zbuf));\n\t\tCF(makwa_kdf(mdc->hash_function,\n\t\t\tZbuf, k, out, mdc->post_hash_length));\n\t}\n\nFUNCTION_EXIT:\n\tFREE_BNCTX(bnctx);\n\tFREE_BN(z);\n\tFREE(Zbuf);\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_delegation_context_encode(\n\tconst makwa_delegation_context *mdc, void *req, size_t *req_len)\n{\n\tsize_t len, mlen, zlen;\n\tunsigned char *buf;\n\tint err;\n\n\tmlen = mpi_length(mdc->modulus);\n\tzlen = mpi_length(mdc->z);\n\tlen = 8 + mlen + zlen;\n\tDO_BUFFER(req, req_len, len);\n\n\t/*\n\t * Since we take care to allow only \"correct\" values to reach our\n\t * context structures, the MPI encoding functions below cannot\n\t * fail.\n\t */\n\tbuf = req;\n\tencode_32(buf, MAGIC_DELEG_REQ);\n\tbuf += 4;\n\tCF(encode_mpi(mdc->modulus, buf, &mlen));\n\tbuf += mlen;\n\tencode_32(buf, mdc->work_factor);\n\tbuf += 4;\n\tCF(encode_mpi(mdc->z, buf, &zlen));\n\tbuf += zlen;\n\nFUNCTION_EXIT:\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_delegation_answer(\n\tconst void *req, size_t req_len, void *ans, size_t *ans_len)\n{\n\tBIGNUM *n, *z;\n\tsize_t off, k;\n\tint err;\n\tunsigned long work_factor;\n\tunsigned char *buf;\n\tsize_t buf_len;\n\n\tn = NULL;\n\tz = NULL;\n\tCZ(n = BN_new());\n\tCZ(z = BN_new());\n\n\t/* Decode request. */\n\toff = 0;\n\tif (req_len < 4 || decode_32(req, 0) != MAGIC_DELEG_REQ) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\toff += 4;\n\tCF(decode_mpi(req, &off, req_len, n));\n\tif ((off + 4) > req_len) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\twork_factor = decode_32(req, off);\n\toff += 4;\n\tCF(decode_mpi(req, &off, req_len, z));\n\tif (off != req_len) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\n\t/* Verify request elements. */\n\tk = BN_num_bytes(n);\n\tif (k < 160) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tif (!BN_is_bit_set(n, 0) || BN_is_bit_set(n, 1)) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tif (BN_is_zero(z) || BN_cmp(n, z) <= 0) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\n\t/* Handle the output buffer semantics. */\n\tDO_BUFFER(ans, ans_len, k + 6);\n\n\t/* Apply the squarings. */\n\tCF(multi_square_cf(z, work_factor, n));\n\n\t/* Encode the result. */\n\tbuf = ans;\n\tencode_32(buf, MAGIC_DELEG_ANS);\n\tbuf_len = k + 2;\n\tCF(encode_mpi(z, buf + 4, &buf_len));\n\nFUNCTION_EXIT:\n\tFREE_BN(n);\n\tFREE_BN(z);\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_simple_hash_new_delegate_begin(const makwa_context *ctx,\n\tconst makwa_delegation_parameters *mdp,\n\tchar *password, makwa_delegation_context *mdc)\n{\n\tint err;\n\tunsigned char salt[16];\n\n\tCF(wflog(mdp->work_factor, NULL));\n\tCF(makwa_make_new_salt(salt, sizeof salt));\n\tCF(makwa_hash_delegate_begin(ctx, mdp,\n\t\tpassword, strlen(password),\n\t\tsalt, sizeof salt, ctx->default_pre_hash,\n\t\tctx->default_post_hash_length, mdc));\n\nFUNCTION_EXIT:\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_simple_hash_verify_delegate_begin(const makwa_context *ctx,\n\tconst makwa_delegation_parameters *mdp,\n\tchar *password, const char *ref, makwa_delegation_context *mdc)\n{\n\tint err;\n\tvoid *salt, *ref_out;\n\tint pre_hash;\n\tsize_t post_hash_length;\n\tlong work_factor;\n\tsize_t salt_len, ref_out_len;\n\n\tsalt = NULL;\n\tref_out = NULL;\n\tCF(wflog(mdp->work_factor, NULL));\n\tCF(makwa_decode_string(ctx, ref, NULL, &salt_len, &pre_hash,\n\t\t&post_hash_length, &work_factor, NULL, &ref_out_len));\n\tif (salt_len > 0) {\n\t\tCZ(salt = malloc(salt_len));\n\t}\n\tCZ(ref_out = malloc(ref_out_len));\n\tCF(makwa_decode_string(ctx, ref, salt, &salt_len, &pre_hash,\n\t\t&post_hash_length, &work_factor, ref_out, &ref_out_len));\n\tif (work_factor != mdp->work_factor) {\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tCF(makwa_hash_delegate_begin(ctx, mdp,\n\t\tpassword, strlen(password),\n\t\tsalt, salt_len, pre_hash, post_hash_length, mdc));\n\tFREE(mdc->ref_out);\n\tmdc->ref_out = ref_out;\n\tmdc->ref_out_len = ref_out_len;\n\tref_out = NULL;\n\nFUNCTION_EXIT:\n\tFREE(salt);\n\tFREE(ref_out);\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_simple_hash_delegate_end(const makwa_delegation_context *mdc,\n\tconst void *ans, size_t ans_len, void *str_out, size_t *str_out_len)\n{\n\tint err;\n\tvoid *out;\n\tsize_t out_len;\n\n\tout = NULL;\n\tout_len = mdc->post_hash_length == 0\n\t\t? (size_t)BN_num_bytes(mdc->modulus)\n\t\t: mdc->post_hash_length;\n\tDO_BUFFER(str_out, str_out_len,\n\t\tget_string_output_length(mdc->salt_len, out_len));\n\n\tCF(makwa_hash_delegate_end(mdc, ans, ans_len, NULL, &out_len));\n\tCZ(out = malloc(out_len));\n\tCF(makwa_hash_delegate_end(mdc, ans, ans_len, out, &out_len));\n\n\tCF(encode_string_inner(mdc->modID, BN_num_bytes(mdc->modulus),\n\t\tmdc->salt, mdc->salt_len, mdc->pre_hash,\n\t\tmdc->post_hash_length, mdc->work_factor,\n\t\tout, str_out, str_out_len));\n\nFUNCTION_EXIT:\n\tFREE(out);\n\treturn err;\n}\n\n/* see makwa.h */\nint\nmakwa_simple_hash_verify_delegate_end(\n\tconst makwa_delegation_context *mdc, const void *ans, size_t ans_len)\n{\n\tint err;\n\tvoid *out;\n\tsize_t out_len;\n\n\tout = NULL;\n\tif (mdc->ref_out == NULL) {\n\t\t/* No recorded output; the context was not initialized with\n\t\t   makwa_simple_hash_verify_delegate_begin(). */\n\t\tRETURN(MAKWA_BADPARAM);\n\t}\n\tCF(makwa_hash_delegate_end(mdc, ans, ans_len, NULL, &out_len));\n\tCZ(out = malloc(out_len));\n\tCF(makwa_hash_delegate_end(mdc, ans, ans_len, out, &out_len));\n\tif (out_len != mdc->ref_out_len\n\t\t|| memcmp(out, mdc->ref_out, out_len) != 0)\n\t{\n\t\tRETURN(MAKWA_WRONG_PASSWORD);\n\t}\n\nFUNCTION_EXIT:\n\tFREE(out);\n\treturn err;\n}\n"
        },
        {
            "file_name": "Mars.cpp",
            "content": "#include \"stdafx.h\"\n\n#  pragma intrinsic(_lrotr,_lrotl)\n\n#  define rotr(x,n) _lrotr(x,n)\n#  define rotl(x,n) _lrotl(x,n)\n\n#define bswap(x)    (rotl(x, 8) & 0x00ff00ff | rotr(x, 8) & 0xff00ff00)\n\n#define byte(x,n)   ((BYTE)((x) >> (8 * n)))\n\n#ifdef  BLOCK_SWAP\n#define BYTE_SWAP\n#define WORD_SWAP\n#endif\n\n#ifdef  BYTE_SWAP\n#define io_swap(x)  bswap(x)\n#else\n#define io_swap(x)  (x)\n#endif\n\n#ifdef  WORD_SWAP\n\n#define get_block(x)                            \\\n    ((DWORD *)(x))[0] = io_swap(in_blk[3]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_blk[2]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_blk[1]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_blk[0])\n\n#define put_block(x)                            \\\n    out_blk[3] = io_swap(((DWORD *)(x))[0]);    \\\n    out_blk[2] = io_swap(((DWORD *)(x))[1]);    \\\n    out_blk[1] = io_swap(((DWORD *)(x))[2]);    \\\n    out_blk[0] = io_swap(((DWORD *)(x))[3])\n\n#define get_key(x,len)                          \\\n    ((DWORD *)(x))[4] = ((DWORD *)(x))[5] =     \\\n    ((DWORD *)(x))[6] = ((DWORD *)(x))[7] = 0;  \\\n    switch((((len) + 63) / 64)) {               \\\n    case 2:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[0]);     \\\n    break;                                      \\\n    case 3:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[5]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[0]);     \\\n    break;                                      \\\n    case 4:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[7]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[6]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[5]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[6] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[7] = io_swap(in_key[0]);     \\\n    }\n\n#else\n\n#define get_block(x)                            \\\n    ((DWORD *)(x))[0] = io_swap(in_blk[0]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_blk[1]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_blk[2]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_blk[3])\n\n#define put_block(x)                            \\\n    out_blk[0] = io_swap(((DWORD *)(x))[0]);    \\\n    out_blk[1] = io_swap(((DWORD *)(x))[1]);    \\\n    out_blk[2] = io_swap(((DWORD *)(x))[2]);    \\\n    out_blk[3] = io_swap(((DWORD *)(x))[3])\n\n#define get_key(x,len)                          \\\n    ((DWORD *)(x))[4] = ((DWORD *)(x))[5] =     \\\n    ((DWORD *)(x))[6] = ((DWORD *)(x))[7] = 0;  \\\n    switch((((len) + 63) / 64)) {               \\\n    case 4:                                     \\\n    ((DWORD *)(x))[6] = io_swap(in_key[6]);     \\\n    ((DWORD *)(x))[7] = io_swap(in_key[7]);     \\\n    case 3:                                     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[5]);     \\\n    case 2:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[0]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[3]);     \\\n    }\n\n#endif\n\nconst DWORD s_box[] = \n{\n    0x09d0c479, 0x28c8ffe0, 0x84aa6c39, 0x9dad7287, /* 0x000    */\n    0x7dff9be3, 0xd4268361, 0xc96da1d4, 0x7974cc93, \n    0x85d0582e, 0x2a4b5705, 0x1ca16a62, 0xc3bd279d, \n    0x0f1f25e5, 0x5160372f, 0xc695c1fb, 0x4d7ff1e4, \n    0xae5f6bf4, 0x0d72ee46, 0xff23de8a, 0xb1cf8e83, /* 0x010    */\n    0xf14902e2, 0x3e981e42, 0x8bf53eb6, 0x7f4bf8ac, \n    0x83631f83, 0x25970205, 0x76afe784, 0x3a7931d4, \n    0x4f846450, 0x5c64c3f6, 0x210a5f18, 0xc6986a26, \n    0x28f4e826, 0x3a60a81c, 0xd340a664, 0x7ea820c4, /* 0x020    */\n    0x526687c5, 0x7eddd12b, 0x32a11d1d, 0x9c9ef086, \n    0x80f6e831, 0xab6f04ad, 0x56fb9b53, 0x8b2e095c, \n    0xb68556ae, 0xd2250b0d, 0x294a7721, 0xe21fb253, \n    0xae136749, 0xe82aae86, 0x93365104, 0x99404a66, /* 0x030    */\n    0x78a784dc, 0xb69ba84b, 0x04046793, 0x23db5c1e, \n    0x46cae1d6, 0x2fe28134, 0x5a223942, 0x1863cd5b, \n    0xc190c6e3, 0x07dfb846, 0x6eb88816, 0x2d0dcc4a, \n    0xa4ccae59, 0x3798670d, 0xcbfa9493, 0x4f481d45, /* 0x040    */\n    0xeafc8ca8, 0xdb1129d6, 0xb0449e20, 0x0f5407fb, \n    0x6167d9a8, 0xd1f45763, 0x4daa96c3, 0x3bec5958, \n    0xababa014, 0xb6ccd201, 0x38d6279f, 0x02682215, \n    0x8f376cd5, 0x092c237e, 0xbfc56593, 0x32889d2c, /* 0x050    */\n    0x854b3e95, 0x05bb9b43, 0x7dcd5dcd, 0xa02e926c, \n    0xfae527e5, 0x36a1c330, 0x3412e1ae, 0xf257f462, \n    0x3c4f1d71, 0x30a2e809, 0x68e5f551, 0x9c61ba44, \n    0x5ded0ab8, 0x75ce09c8, 0x9654f93e, 0x698c0cca, /* 0x060    */\n    0x243cb3e4, 0x2b062b97, 0x0f3b8d9e, 0x00e050df, \n    0xfc5d6166, 0xe35f9288, 0xc079550d, 0x0591aee8, \n    0x8e531e74, 0x75fe3578, 0x2f6d829a, 0xf60b21ae, \n    0x95e8eb8d, 0x6699486b, 0x901d7d9b, 0xfd6d6e31, /* 0x070    */ \n    0x1090acef, 0xe0670dd8, 0xdab2e692, 0xcd6d4365, \n    0xe5393514, 0x3af345f0, 0x6241fc4d, 0x460da3a3, \n    0x7bcf3729, 0x8bf1d1e0, 0x14aac070, 0x1587ed55, \n    0x3afd7d3e, 0xd2f29e01, 0x29a9d1f6, 0xefb10c53, /* 0x080    */\n    0xcf3b870f, 0xb414935c, 0x664465ed, 0x024acac7, \n    0x59a744c1, 0x1d2936a7, 0xdc580aa6, 0xcf574ca8, \n    0x040a7a10, 0x6cd81807, 0x8a98be4c, 0xaccea063, \n    0xc33e92b5, 0xd1e0e03d, 0xb322517e, 0x2092bd13, /* 0x090    */\n    0x386b2c4a, 0x52e8dd58, 0x58656dfb, 0x50820371, \n    0x41811896, 0xe337ef7e, 0xd39fb119, 0xc97f0df6, \n    0x68fea01b, 0xa150a6e5, 0x55258962, 0xeb6ff41b, \n    0xd7c9cd7a, 0xa619cd9e, 0xbcf09576, 0x2672c073, /* 0x0a0    */\n    0xf003fb3c, 0x4ab7a50b, 0x1484126a, 0x487ba9b1, \n    0xa64fc9c6, 0xf6957d49, 0x38b06a75, 0xdd805fcd, \n    0x63d094cf, 0xf51c999e, 0x1aa4d343, 0xb8495294, \n    0xce9f8e99, 0xbffcd770, 0xc7c275cc, 0x378453a7, /* 0x0b0    */\n    0x7b21be33, 0x397f41bd, 0x4e94d131, 0x92cc1f98, \n    0x5915ea51, 0x99f861b7, 0xc9980a88, 0x1d74fd5f, \n    0xb0a495f8, 0x614deed0, 0xb5778eea, 0x5941792d, \n    0xfa90c1f8, 0x33f824b4, 0xc4965372, 0x3ff6d550, /* 0x0c0    */\n    0x4ca5fec0, 0x8630e964, 0x5b3fbbd6, 0x7da26a48,\n    0xb203231a, 0x04297514, 0x2d639306, 0x2eb13149, \n    0x16a45272, 0x532459a0, 0x8e5f4872, 0xf966c7d9, \n    0x07128dc0, 0x0d44db62, 0xafc8d52d, 0x06316131, /* 0x0d0    */ \n    0xd838e7ce, 0x1bc41d00, 0x3a2e8c0f, 0xea83837e,\n    0xb984737d, 0x13ba4891, 0xc4f8b949, 0xa6d6acb3, \n    0xa215cdce, 0x8359838b, 0x6bd1aa31, 0xf579dd52, \n    0x21b93f93, 0xf5176781, 0x187dfdde, 0xe94aeb76, /* 0x0e0    */ \n    0x2b38fd54, 0x431de1da, 0xab394825, 0x9ad3048f,\n    0xdfea32aa, 0x659473e3, 0x623f7863, 0xf3346c59, \n    0xab3ab685, 0x3346a90b, 0x6b56443e, 0xc6de01f8, \n    0x8d421fc0, 0x9b0ed10c, 0x88f1a1e9, 0x54c1f029, /* 0x0f0    */ \n    0x7dead57b, 0x8d7ba426, 0x4cf5178a, 0x551a7cca, \n    0x1a9a5f08, 0xfcd651b9, 0x25605182, 0xe11fc6c3, \n    0xb6fd9676, 0x337b3027, 0xb7c8eb14, 0x9e5fd030,\n\n    0x6b57e354, 0xad913cf7, 0x7e16688d, 0x58872a69, /* 0x100    */\n    0x2c2fc7df, 0xe389ccc6, 0x30738df1, 0x0824a734, \n    0xe1797a8b, 0xa4a8d57b, 0x5b5d193b, 0xc8a8309b, \n    0x73f9a978, 0x73398d32, 0x0f59573e, 0xe9df2b03, \n    0xe8a5b6c8, 0x848d0704, 0x98df93c2, 0x720a1dc3, /* 0x110    */ \n    0x684f259a, 0x943ba848, 0xa6370152, 0x863b5ea3, \n    0xd17b978b, 0x6d9b58ef, 0x0a700dd4, 0xa73d36bf, \n    0x8e6a0829, 0x8695bc14, 0xe35b3447, 0x933ac568, \n    0x8894b022, 0x2f511c27, 0xddfbcc3c, 0x006662b6, /* 0x120    */\n    0x117c83fe, 0x4e12b414, 0xc2bca766, 0x3a2fec10, \n    0xf4562420, 0x55792e2a, 0x46f5d857, 0xceda25ce, \n    0xc3601d3b, 0x6c00ab46, 0xefac9c28, 0xb3c35047, \n    0x611dfee3, 0x257c3207, 0xfdd58482, 0x3b14d84f, /* 0x130    */\n    0x23becb64, 0xa075f3a3, 0x088f8ead, 0x07adf158, \n    0x7796943c, 0xfacabf3d, 0xc09730cd, 0xf7679969, \n    0xda44e9ed, 0x2c854c12, 0x35935fa3, 0x2f057d9f, \n    0x690624f8, 0x1cb0bafd, 0x7b0dbdc6, 0x810f23bb, /* 0x140    */\n    0xfa929a1a, 0x6d969a17, 0x6742979b, 0x74ac7d05, \n    0x010e65c4, 0x86a3d963, 0xf907b5a0, 0xd0042bd3, \n    0x158d7d03, 0x287a8255, 0xbba8366f, 0x096edc33, \n    0x21916a7b, 0x77b56b86, 0x951622f9, 0xa6c5e650, /* 0x150    */\n    0x8cea17d1, 0xcd8c62bc, 0xa3d63433, 0x358a68fd, \n    0x0f9b9d3c, 0xd6aa295b, 0xfe33384a, 0xc000738e, \n    0xcd67eb2f, 0xe2eb6dc2, 0x97338b02, 0x06c9f246, \n    0x419cf1ad, 0x2b83c045, 0x3723f18a, 0xcb5b3089, /* 0x160    */\n    0x160bead7, 0x5d494656, 0x35f8a74b, 0x1e4e6c9e, \n    0x000399bd, 0x67466880, 0xb4174831, 0xacf423b2, \n    0xca815ab3, 0x5a6395e7, 0x302a67c5, 0x8bdb446b, \n    0x108f8fa4, 0x10223eda, 0x92b8b48b, 0x7f38d0ee, /* 0x170    */\n    0xab2701d4, 0x0262d415, 0xaf224a30, 0xb3d88aba, \n    0xf8b2c3af, 0xdaf7ef70, 0xcc97d3b7, 0xe9614b6c, \n    0x2baebff4, 0x70f687cf, 0x386c9156, 0xce092ee5, \n    0x01e87da6, 0x6ce91e6a, 0xbb7bcc84, 0xc7922c20, /* 0x180    */\n    0x9d3b71fd, 0x060e41c6, 0xd7590f15, 0x4e03bb47, \n    0x183c198e, 0x63eeb240, 0x2ddbf49a, 0x6d5cba54, \n    0x923750af, 0xf9e14236, 0x7838162b, 0x59726c72, \n    0x81b66760, 0xbb2926c1, 0x48a0ce0d, 0xa6c0496d, /* 0x190    */\n    0xad43507b, 0x718d496a, 0x9df057af, 0x44b1bde6, \n    0x054356dc, 0xde7ced35, 0xd51a138b, 0x62088cc9, \n    0x35830311, 0xc96efca2, 0x686f86ec, 0x8e77cb68, \n    0x63e1d6b8, 0xc80f9778, 0x79c491fd, 0x1b4c67f2, /* 0x1a0    */\n    0x72698d7d, 0x5e368c31, 0xf7d95e2e, 0xa1d3493f,\n    0xdcd9433e, 0x896f1552, 0x4bc4ca7a, 0xa6d1baf4, \n    0xa5a96dcc, 0x0bef8b46, 0xa169fda7, 0x74df40b7, \n    0x4e208804, 0x9a756607, 0x038e87c8, 0x20211e44, /* 0x1b0    */ \n    0x8b7ad4bf, 0xc6403f35, 0x1848e36d, 0x80bdb038, \n    0x1e62891c, 0x643d2107, 0xbf04d6f8, 0x21092c8c, \n    0xf644f389, 0x0778404e, 0x7b78adb8, 0xa2c52d53, \n    0x42157abe, 0xa2253e2e, 0x7bf3f4ae, 0x80f594f9, /* 0x1c0    */\n    0x953194e7, 0x77eb92ed, 0xb3816930, 0xda8d9336, \n    0xbf447469, 0xf26d9483, 0xee6faed5, 0x71371235, \n    0xde425f73, 0xb4e59f43, 0x7dbe2d4e, 0x2d37b185, \n    0x49dc9a63, 0x98c39d98, 0x1301c9a2, 0x389b1bbf, /* 0x1d0    */\n    0x0c18588d, 0xa421c1ba, 0x7aa3865c, 0x71e08558, \n    0x3c5cfcaa, 0x7d239ca4, 0x0297d9dd, 0xd7dc2830, \n    0x4b37802b, 0x7428ab54, 0xaeee0347, 0x4b3fbb85, \n    0x692f2f08, 0x134e578e, 0x36d9e0bf, 0xae8b5fcf, /* 0x1e0    */\n    0xedb93ecf, 0x2b27248e, 0x170eb1ef, 0x7dc57fd6, \n    0x1e760f16, 0xb1136601, 0x864e1b9b, 0xd7ea7319, \n    0x3ab871bd, 0xcfa4d76f, 0xe31bd782, 0x0dbeb469, \n    0xabb96061, 0x5370f85d, 0xffb07e37, 0xda30d0fb, /* 0x1f0    */\n    0xebc977b6, 0x0b98b40f, 0x3a4d0fe6, 0xdf4fc26b, \n    0x159cf22a, 0xc298d6e2, 0x2b78ef6a, 0x61a94ac0, \n    0xab561187, 0x14eea0f0, 0xdf0d4164, 0x19af70ee\n};\n\n#define f_mix(a,b,c,d)                  \\\n        r = rotr(a, 8);                 \\\n        b ^= s_box[a & 255];            \\\n        b += s_box[(r & 255) + 256];    \\\n        r = rotr(a, 16);                \\\n        a  = rotr(a, 24);               \\\n        c += s_box[r & 255];            \\\n        d ^= s_box[(a & 255) + 256]\n\n#define b_mix(a,b,c,d)                  \\\n        r = rotl(a, 8);                 \\\n        b ^= s_box[(a & 255) + 256];    \\\n        c -= s_box[r & 255];            \\\n        r = rotl(a, 16);                \\\n        a  = rotl(a, 24);               \\\n        d -= s_box[(r & 255) + 256];    \\\n        d ^= s_box[a & 255]\n\n#define f_ktr(a,b,c,d,i)    \\\n    m = a + l_key[i];       \\\n    a = rotl(a, 13);        \\\n    r = a * l_key[i + 1];   \\\n    l = s_box[m & 511];     \\\n    r = rotl(r, 5);         \\\n    c += rotl(m, r);        \\\n    l ^= r;                 \\\n    r = rotl(r, 5);         \\\n    l ^= r;                 \\\n    d ^= r;                 \\\n    b += rotl(l, r)\n\n#define r_ktr(a,b,c,d,i)    \\\n    r = a * l_key[i + 1];   \\\n    a = rotr(a, 13);        \\\n    m = a + l_key[i];       \\\n    l = s_box[m & 511];     \\\n    r = rotl(r, 5);         \\\n    l ^= r;                 \\\n    c -= rotl(m, r);        \\\n    r = rotl(r, 5);         \\\n    l ^= r;                 \\\n    d ^= r;                 \\\n    b -= rotl(l, r)\n\n/* For a 32 bit word (x) generate a mask (m) such that a bit in */\n/* m is set to 1 if and only if the corresponding bit in x is:  */\n/*                                                              */\n/* 1. in a sequence of 10 or more adjacent '0' bits             */\n/* 2. in a sequence of 10 or more adjacent '1' bits             */\n/* 3. but is not either endpoint of such a sequence unless such */\n/*    an endpoint is at the top bit (bit 31) of a word and is   */\n/*    in a sequence of '0' bits.                                */\n/*                                                              */\n/* The only situation in which a sequence endpoint is included  */\n/* in the mask is hence when the endpoint is at bit 31 and is   */\n/* the endpoint of a sequence of '0' bits. My thanks go to Shai */\n/* Halevi of IBM for the neat trick (which I missed) of finding */\n/* the '0' and '1' sequences at the same time.                  */\n\nDWORD gen_mask(DWORD x)\n{\n\tDWORD  m;\n\n    /* if m{bn} stands for bit number bn of m, set m{bn} = 1 if */\n    /* x{bn} == x{bn+1} for 0 <= bn <= 30.  That is, set a bit  */\n    /* in m if the corresponding bit and the next higher bit in */\n    /* x are equal in value (set m{31} = 0).                    */\n\n    m = (~x ^ (x >> 1)) & 0x7fffffff;\n\n    /* Sequences of 9 '1' bits in m now correspond to sequences */\n    /* of 10 '0's or 10 '1' bits in x.  Shift and 'and' bits in */\n    /* m to find sequences of 9 or more '1' bits.   As a result */\n    /* bits in m are set if they are at the bottom of sequences */\n    /* of 10 adjacent '0's or 10 adjacent '1's in x.            */\n\n    m &= (m >> 1) & (m >> 2); m &= (m >> 3) & (m >> 6); \n    \n    if(!m)  /* return if mask is empty - no key fixing needed   */\n            /* is this early return worthwhile?                 */\n        return 0;\n    \n    /* We need the internal bits in each continuous sequence of */\n    /* matching bits (that is the bits less the two endpoints). */\n    /* We thus propagate each set bit into the 8 internal bits  */\n    /* that it represents, starting 1 left and finsihing 8 left */\n    /* of its position.                                         */\n\n    m <<= 1; m |= (m << 1); m |= (m << 2); m |= (m << 4);\n\n    /* m is now correct except for the odd behaviour of bit 31, */\n    /* that is, it will be set if it is in a sequence of 10 or  */\n    /* more '0's and clear otherwise.                           */\n\n    m |= (m << 1) & ~x & 0x80000000;\n\n    return m & 0xfffffffc;\n}\n\n/* My thanks to Louis Granboulan for spotting an error in the   */\n/* previous version of set_key.                                 */\n\nvoid Mars_set_key(DWORD *l_key,DWORD *vk,const DWORD *in_key, const DWORD key_len)\n{\n\tDWORD  i, j, m, w; \n\n    m = key_len / 32 - 1;\n\n    for(i = j = 0; i < 39; ++i)\n    {\n      vk[i + 7] = rotl(vk[i] ^ vk[i + 5], 3) ^ in_key[j] ^ i;\n\n      j = (j == m ? 0 : j + 1);\n    }\n\n    vk[46] = key_len / 32;\n\n    for(j = 0; j < 7; ++j)\n    {\n         for(i = 1; i < 40; ++i)\n         \n            vk[i + 7] = rotl(vk[i + 7] + s_box[vk[i + 6] & 511], 9);\n\n        vk[7] = rotl(vk[7] + s_box[vk[46] & 511], 9);\n    }\n\n    for(i = j = 0; i < 40; ++i)\n    {\n        l_key[j] = vk[i + 7];\n\n        j = (j < 33 ? j + 7 : j - 33);\n    }\n\n    for(i = 5; i < 37; i += 2)\n    {\n        w = l_key[i] | 3; \n\n        if(m = gen_mask(w))\n        \n            w ^= (rotl(s_box[265 + (l_key[i] & 3)], l_key[i + 3] & 31) & m);\n\n        l_key[i] = w;\n    }\n}\n\nvoid Mars_encrypt(const DWORD *l_key,const DWORD *in_blk, DWORD *out_blk)\n{\n\tDWORD  a, b, c, d, l, m, r;\n\n    a = in_blk[0] + l_key[0]; b = in_blk[1] + l_key[1];\n    c = in_blk[2] + l_key[2]; d = in_blk[3] + l_key[3];\n\n    f_mix(a,b,c,d); a += d;\n    f_mix(b,c,d,a); b += c;\n    f_mix(c,d,a,b);\n    f_mix(d,a,b,c);\n    f_mix(a,b,c,d); a += d;\n    f_mix(b,c,d,a); b += c;\n    f_mix(c,d,a,b);\n    f_mix(d,a,b,c);\n\n    f_ktr(a,b,c,d, 4); f_ktr(b,c,d,a, 6); f_ktr(c,d,a,b, 8); f_ktr(d,a,b,c,10); \n    f_ktr(a,b,c,d,12); f_ktr(b,c,d,a,14); f_ktr(c,d,a,b,16); f_ktr(d,a,b,c,18); \n    f_ktr(a,d,c,b,20); f_ktr(b,a,d,c,22); f_ktr(c,b,a,d,24); f_ktr(d,c,b,a,26); \n    f_ktr(a,d,c,b,28); f_ktr(b,a,d,c,30); f_ktr(c,b,a,d,32); f_ktr(d,c,b,a,34); \n\n    b_mix(a,b,c,d);\n    b_mix(b,c,d,a); c -= b;\n    b_mix(c,d,a,b); d -= a;\n    b_mix(d,a,b,c);\n    b_mix(a,b,c,d);\n    b_mix(b,c,d,a); c -= b;\n    b_mix(c,d,a,b); d -= a;\n    b_mix(d,a,b,c);\n\n    out_blk[0] = a - l_key[36]; out_blk[1] = b - l_key[37];\n    out_blk[2] = c - l_key[38]; out_blk[3] = d - l_key[39];\n}\n\nvoid Mars_decrypt(const DWORD *l_key,const DWORD *in_blk, DWORD *out_blk)\n{\n\tDWORD  a, b, c, d, l, m, r;\n    \n    d = in_blk[0] + l_key[36]; c = in_blk[1] + l_key[37];\n    b = in_blk[2] + l_key[38]; a = in_blk[3] + l_key[39];\n\n    f_mix(a,b,c,d); a += d;\n    f_mix(b,c,d,a); b += c;\n    f_mix(c,d,a,b); \n    f_mix(d,a,b,c);\n    f_mix(a,b,c,d); a += d;\n    f_mix(b,c,d,a); b += c;\n    f_mix(c,d,a,b);\n    f_mix(d,a,b,c);\n\n    r_ktr(a,b,c,d,34); r_ktr(b,c,d,a,32); r_ktr(c,d,a,b,30); r_ktr(d,a,b,c,28);\n    r_ktr(a,b,c,d,26); r_ktr(b,c,d,a,24); r_ktr(c,d,a,b,22); r_ktr(d,a,b,c,20);\n    r_ktr(a,d,c,b,18); r_ktr(b,a,d,c,16); r_ktr(c,b,a,d,14); r_ktr(d,c,b,a,12);\n    r_ktr(a,d,c,b,10); r_ktr(b,a,d,c, 8); r_ktr(c,b,a,d, 6); r_ktr(d,c,b,a, 4);\n\n    b_mix(a,b,c,d);\n    b_mix(b,c,d,a); c -= b;\n    b_mix(c,d,a,b); d -= a;\n    b_mix(d,a,b,c);\n    b_mix(a,b,c,d);\n    b_mix(b,c,d,a); c -= b;\n    b_mix(c,d,a,b); d -= a;\n    b_mix(d,a,b,c);\n\n    out_blk[0] = d - l_key[0]; out_blk[1] = c - l_key[1];\n    out_blk[2] = b - l_key[2]; out_blk[3] = a - l_key[3];\n}\n"
        },
        {
            "file_name": "mcssha8.cpp",
            "content": "//# Algorithm Name: MCSSHA-8\n//# Principal Submitter: Mikhail Maslennikov\n//# Revision: 17.02.2014 \n\n#include <stdio.h>\n#include <memory.h>\n#include \"mcssha8.h\"\n#include \"mcssha8_macros.h\"\n\n//#define DEBUG_MODE\n\n// logariphmic substitution\nstatic BitSequence S[256]={\n\t0x30, 0x60, 0x67, 0xB5, 0x43, 0xEA, 0x93, 0x25,\t0x48, 0x0D, 0x18, 0x6F, 0x28, 0x7A, 0xFE, 0xB6,\n\t0xD5, 0x9C, 0x23, 0x86, 0x52, 0x42, 0xF7, 0xFD,\t0xF6, 0x9B, 0xEE, 0x99, 0x91, 0xBC, 0x2A, 0x63,\n\t0xA1, 0xA0, 0x57, 0x3C, 0x39, 0xD2, 0xEC, 0x71,\t0x45, 0xCB, 0x41, 0xDC, 0x0B, 0x5B, 0xC2, 0x36,\n\t0x01, 0x55, 0x7D, 0xFB, 0xED, 0x83, 0x8F, 0x31,\t0xC0, 0x4C, 0x08, 0xE3, 0x9D, 0xC1, 0xD3, 0xE9,\n\t0xB8, 0xBD, 0xAE, 0x0F, 0xE7, 0x70, 0x5A, 0xEB,\t0x4D, 0x29, 0xF9, 0xA9, 0x3D, 0x26, 0x46, 0x06,\n\t0xD0, 0x50, 0xA5, 0xBE, 0x66, 0x90, 0xF4, 0x20,\t0xE4, 0x33, 0x27, 0xE2, 0xAB, 0xEF, 0x68, 0x54,\n\t0x37, 0x6A, 0xDB, 0xBB, 0xD8, 0x7B, 0x69, 0xC4,\t0xF2, 0xBF, 0x85, 0xC7, 0xA6, 0xB4, 0x9A, 0xDD,\n\t0x72, 0x34, 0xE8, 0xFC, 0xD6, 0x21, 0x98, 0x96,\t0x32, 0xCA, 0x49, 0xB3, 0xF3, 0x97, 0x8E, 0x2F,\n\t0x00, 0xB0, 0x10, 0x1A, 0x77, 0x38, 0xCF, 0x51,\t0xBA, 0x1F, 0x22, 0xAC, 0x62, 0x89, 0x76, 0xC3,\n\t0x02, 0x6E, 0x2C, 0x47, 0x3A, 0x5C, 0x1B, 0x56,\t0x8A, 0x5D, 0x03, 0x16, 0x74, 0x58, 0x79, 0x09,\n\t0xD7, 0xF5, 0x0A, 0x92, 0x4F, 0x87, 0xCD, 0xDA,\t0x8C, 0xC9, 0x9E, 0x3B, 0x12, 0x6B, 0x53, 0xFF,\n\t0x80, 0xB7, 0xF8, 0xD9, 0xF1, 0x5E, 0xAF, 0xE0,\t0x05, 0xA4, 0x14, 0x2B, 0xA3, 0xCC, 0x6C, 0x7C,\n\t0x78, 0xAA, 0x95, 0x84, 0x61, 0xA8, 0xCE, 0x13,\t0x88, 0xFA, 0x59, 0x4E, 0xB9, 0xC8, 0x4B, 0x24,\n\t0xD1, 0x07, 0x94, 0x2E, 0xDF, 0xB1, 0x17, 0xA2,\t0x1D, 0x4A, 0xC6, 0xAD, 0x15, 0x19, 0x35, 0x7F,\n\t0x81, 0x44, 0x0C, 0x9F, 0x75, 0x7E, 0xD4, 0x82,\t0xDE, 0xE6, 0xE1, 0x2D, 0x3E, 0x73, 0x11, 0x8B,\n\t0xC5, 0xA7, 0xF0, 0x6D, 0x1C, 0x64, 0x0E, 0x04,\t0x40, 0x1E, 0x8D, 0xE5, 0x3F, 0xB2, 0x65, 0x5F,\n\t};\n\n// Delay is constant for MCSSHA-8\n// Reserved. Not used.\nstatic BitSequence delay = 3;\n\n// Hash Init\n// Prepare hashState structure\n// c->hashbitlen - remember hashbitlen for final hash computation\n// c->SRbyteLen - calculate SR length in bytes for pre-hach and final hash computation\n// Initialize SR for pre-hash computation\n// Prepare two bytes for remain bits\n// Total size hashState structure = 152 bytes\nHashReturn Init(hashState *c,DataLength hashbitlen)\n\t{\n\t\tBitSequence i;\n\t\tif(c == NULL)return FAIL;\n\t\tif((hashbitlen & 0x7) != 0)return BAD_HASHBITLEN;\n\t\tc->SRbyteLen = (hashbitlen>>3);\n\n\t\tif(c->SRbyteLen > 32 && c->SRbyteLen <= 64)c->SRbyteLen = 128;\n\t\telse if(c->SRbyteLen > 16 && c->SRbyteLen <= 32)c->SRbyteLen = 64;\n\t\telse if(c->SRbyteLen > 8 && c->SRbyteLen <= 16)c->SRbyteLen = 32;\n\t\telse if(c->SRbyteLen > 4 && c->SRbyteLen <= 8)c->SRbyteLen = 16;\n\t\telse if(c->SRbyteLen ==  4)c->SRbyteLen = 8;\n\t\telse return BAD_HASHBITLEN;\n\n\t\tc->hashbitlen = hashbitlen;\n\t\tc->x[0] = 0;\n\t\tc->x[1] = 1;\n\t\tc->x[2] = (BitSequence)(c->SRbyteLen - 4);\n\t\tc->x[3] = (BitSequence)(c->SRbyteLen - 1);\n\t    for( i = 0; i < c->SRbyteLen; i++)c->data[i] = i;\n// Two parameters for DataLength != 8*k bits\n// bits - number of the last bits, i.e. DataLength - 8*k\n\t\tc->x[4] = 0;\n// last - last bits value\n\t\tc->x[5] = 0;\n\n\t\treturn(SUCCESS);\n\t}\n\n//-------------------------------------------------------------------\n\n// Pre-hash computation.\n\nHashReturn Update(hashState *c, const BitSequence *data, DataLength databitlen)\n\t{\n\n\t\tDataLength len = databitlen>>3;\n\t\tregister unsigned long x1,x2,x3,x4,SRLen,i,len1;\n\t\tBitSequence empty,bits,last,SRLen_1;\n\n// Control tests\n\t\tif((c == NULL) || (data == NULL && databitlen != 0)) return FAIL;\n        if((data == NULL) && (databitlen == 0))return(SUCCESS);\n        CHECK_HASH_LEN\n\n        if((data == NULL) && (databitlen == 0))return SUCCESS;\n\t\tif((data == NULL) && (databitlen != 0))return FAIL;\n// For use fast register memory\n\t\tx1 = c->x[0];\n\t\tx2 = c->x[1];\n\t\tx3 = c->x[2];\n\t\tx4 = c->x[3];\n\t\tbits = c->x[4];\n\t\tlast = c->x[5];\n\t\tSRLen = (unsigned long)c->SRbyteLen;\n\t\tSRLen_1 = (BitSequence)c->SRbyteLen - 1;\n\n\n\n\t\ti = 0;\n\t\tlen1 = (unsigned long)((databitlen + bits)>>3);\n\t\twhile(i < len1)\n\t\t{\n \t\t\tINPUT_BYTE\n\t\t\tempty += SUBSTITUTION;\n            INCREASE_POINTS_2N\n\t\t\tc->data[x4] = empty;\n\t\t\tDELAY\n\t\t\ti++; \n\t\t}\n\n\t\tif(bits == 0)\n\t\t{\n// Prepare remain bits and remain bits length\n\t\t   c->x[4] = (BitSequence)(databitlen  - (len<<3));\n\t\t   if(c->x[4] != 0)c->x[5] = ((data[i]<<(8-c->x[4]))>>(8-c->x[4]));\n\t\t}\n\t\telse\n\t\t{\n// Calculate remain bits and remain bits length for next step\n\t\t   c->x[4] = (BitSequence)(databitlen + bits - (i<<3));\n\t\t   if(i != 0)c->x[5] = (last>>(8-c->x[4]))<<(8-c->x[4]);\n\t\t   else c->x[5] = ((last ^ (data[i]>>bits))>>(8-c->x[4]))<<(8-c->x[4]);\n\t\t}\n\n\n// Restore hash structure\n\t\tc->x[0]=(BitSequence)x1;\n\t\tc->x[1]=(BitSequence)x2;\n\t\tc->x[2]=(BitSequence)x3;\n\t\tc->x[3]=(BitSequence)x4;\n\n\t\treturn(SUCCESS);\n\n\t}\n\n\n//---------------------------------------------------------------------------\n\n// Final hash computation\nHashReturn Final(hashState *c, BitSequence *md)\n{\n\n\n\t\tregister unsigned long x1,x2,x3,x4,SRLen,i;\n\t\tBitSequence empty,bits,last;\n\t\tBitSequence data1[65],data2[65];\n\t\tBitSequence i1,j1,i2;\n\n\t\tif(c == NULL || md == NULL)return FAIL;\n\t\tCHECK_HASH_LEN\n\t\tbits = c->x[4];\n\t\tlast = c->x[5];\n\n\t\ti1 = 0;\n\t\ti2 = 0;\n\t\tj1 = c->x[3]; \n\t    \n        SRLen = (unsigned long)(c->hashbitlen>>3);\n\t\twhile( i2 < SRLen )\n\t\t{\n\t\t\tif(i1 < SRLen)data1[i1] = c->data[j1];\n\t\t\ti1++;\n\t\t\tSKIP_POINT\n\t\t\tif(i1 < SRLen)data1[i1] = c->data[j1];\n\t\t\ti1++;\n\t\t\tSKIP_POINT\n\t\t\tif(i2 < SRLen)data2[i2] = c->data[j1];\n\t\t\ti2++;\n\t\t\tSKIP_POINT\n\t\t\tif(i2 < SRLen)data2[i2] = c->data[j1];\n\t\t\ti2++;\n\t\t\tSKIP_POINT\n\t\t}\n\t\tdata1[SRLen] = (BitSequence)SRLen;\n\t\tdata2[SRLen] = (BitSequence)SRLen;\n\t\t\n\t\tfor(i = 0; i < SRLen; i ++)c->data[i] = (BitSequence)i;\n\n\t\tx1 = 0;\n\t\tx2 = 1;\n\t\tx4 = SRLen - 1;\n\t\tif(SRLen > 6)\n\t\t\tx3 = SRLen - 4;\n\t\telse\n\t\t\tx3 = 2;\n\n\t\ti = 0;\n\t\twhile(i < SRLen + 1)\n\t\t{\n\t\t\tINPUT_BYTE1  \n\t\t\tempty += SUBSTITUTION;\n            INCREASE_POINTS\n\t\t\tc->data[x4] = empty;\n\t\t\ti++; \n\t\t}\n\n\t\tmemcpy(md,c->data,SRLen);\n\n\t\tfor(i = 0; i < SRLen; i ++)c->data[i] = (BitSequence)i;\n\n\t\tx1 = 0;\n\t\tx2 = 1;\n\t\tx4 = SRLen - 1;\n\t\tif(SRLen > 6)\n\t\t\tx3 = SRLen - 4;\n\t\telse\n\t\t\tx3 = 2;\n\n\t\ti = 0;\n\t\twhile(i < SRLen + 1)\n\t\t{\n            if(i == SRLen - 1)\n\t\t\t\ti = i;\n\t\t\tINPUT_BYTE2  \n\t\t\tempty += SUBSTITUTION;\n            INCREASE_POINTS\n\t\t\tc->data[x4] = empty;\n\t\t\ti++; \n\t\t}\n\t\tfor(i = 0; i < SRLen; i ++)md[i] ^= c->data[i];\n\nreturn (SUCCESS);\n}\n\n\n//------------------------------------------------------------------\n\n\n\nHashReturn Hash(DataLength hashbitlen,\n\t\t\t\tconst BitSequence *data,\n\t\t\t\tDataLength databitlen,\n\t\t\t\tBitSequence *hashval)\n{\n\t  HashReturn ret;\n\t  hashState c;\n\t  ret = Init(&c,hashbitlen);\n\t  if(ret != SUCCESS)return(ret);\n\t  ret = Update(&c,data,databitlen);\n\t  if(ret != SUCCESS)return(ret);\n\t  return(Final(&c,hashval));\n}\n\n//------------------------------------------------------------------\n\n\n"
        },
        {
            "file_name": "mcs_psw.cpp",
            "content": "//# Algorithm Name: MCS_PSW\n//# Principal Submitter: Mikhail Maslennikov\n//# Revision: 12.02.2014 \n\n#include <stdio.h>\n#include <memory.h>\n#include <windows.h>\n#include \"mcs_psw.h\"\n#include \"../mcssha8/mcssha8.h\"\n\n// MCS password hashing scheme (MCS_PHS)\nint PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost)\n{\n     int ret = 0;\n\t DWORD dwErr = 0;\n\t BYTE tmp[256]; //temprorary memory for MCS_PHS\n\t BYTE hash[64] = {0};\n\t unsigned int i = 0;\n\t unsigned int len = 0;\n\t unsigned int mcost = 256;\n\t do\n\t {\n//Parameters control\n\t\t if(\n\t\t\t out == NULL  ||\n\t\t\t outlen == 0  ||\n\t\t\t ( in == NULL && inlen != 0 )  || \n\t\t\t inlen == 0   ||\n\t\t\t salt == 0    ||\n\t\t\t saltlen == 0 ||\n\t\t\t inlen + saltlen > 256 ||\n\t\t\t outlen > 64\n\t\t\t ){\n\t\t\t\t dwErr = NTE_BAD_DATA;\n\t\t\t\t break;\n\t\t }\n\n\t\t if(m_cost != 0)\n\t\t\t mcost = m_cost;\n\n\t\t if(mcost < saltlen + inlen + 2)\n\t\t {\n\t\t\t\t dwErr = NTE_BAD_DATA;\n\t\t\t\t break;\n\t\t }\n\n// Preparing temprorary memory\n\n\t\t tmp[0] = inlen;  // Password length (to protect from password's length attack)\n\n\t\t if(inlen != 0)memcpy(tmp + 1,in,inlen); // add password\n\n\t\t tmp[inlen + 1] = saltlen;\n\n\t\t memcpy(tmp + inlen + 2 ,salt,saltlen); // add salt\n\t\t \n\t\t for(i = saltlen + inlen + 2; i < mcost; i++)tmp[i] = i; // add auxiliary bytes\n\n\n// First hashing using MCSSHA-8. Hash length = 64 bytes \n\t\t if(Hash(512,tmp,mcost<<3,hash))\n\t\t {\n\t\t\t\tdwErr = NTE_FAIL;\n\t\t\t\tbreak;\n\t\t }\n// Main hash cycle. Each step reduces the length of the hash on 1 from 64 to 32 bytes.\n\t\t for( i = 63; i >= outlen; i--)\n\t\t {\n\t\t\t if(Hash(i<<3,hash,(i+1)<<3,hash))\n\t\t\t {\n\t\t\t\t\tdwErr = NTE_FAIL;\n\t\t\t\t\tbreak;\n\t\t\t }\n\t\t }\n\t\t if(i >= outlen)break;\n\n// If t_cost != 0 perform additional cycle.\n\t\t if(t_cost)\n\t\t {\n\t\t\t for(i = 0; i < t_cost; i++)\n\t\t\t {\n\t\t\t\t if(Hash(outlen<<3,hash,outlen<<3,hash))\n\t\t\t\t {\n\t\t\t\t\t\tdwErr = NTE_FAIL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t }\n\t\t\t }\n\t\t\t if(i < t_cost)break;\n\t\t }\n\n// Perform final computation for protect against attack in 5.1 (PBKDF1) from Frances F. Yao and Yiqun Lisa Yin \"Design and Analysis of Password-Based Key Derivation Functions\"\n\n\t\tif(outlen != 64)\n\t\t{\n\t\t\tif(Hash(512,hash,outlen<<3,hash) || Hash(outlen<<3,hash,512,hash))\n\t\t\t{\n\t\t\t\tdwErr = NTE_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(i = 0; i < 64; i++)hash[i] += (BYTE)i;\n\t\t\tif(Hash(512,hash,512,hash))\n\t\t\t{\n\t\t\t\tdwErr = NTE_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n// Final hash for password\n\t\t memcpy(out,hash,outlen);\n\n\t }while(0);\n\n\t SetLastError(dwErr);\n\t if(dwErr != 0)ret = -1;\n\n\t return ret;\n}\n"
        },
        {
            "file_name": "memxor.c",
            "content": "/* memxor.c\n *\n */\n\n/* nettle, low-level cryptographics library\n *\n * Copyright (C) 1991, 1993, 1995 Free Software Foundation, Inc.\n * Copyright (C) 2010 Niels M\u00c3\u00b6ller\n *  \n * The nettle library is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or (at your\n * option) any later version.\n * \n * The nettle library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n * License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with the nettle library; see the file COPYING.LIB.  If not, write to\n * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n * MA 02111-1301, USA.\n */\n\n/* Implementation inspired by memcmp in glibc, contributed to the FSF\n   by Torbjorn Granlund.\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <limits.h>\n\n#include \"memxor.h\"\n\n/* For uintptr_t */\n#include \"nettle-types.h\"\n\ntypedef unsigned long int word_t;\n\n#if SIZEOF_LONG & (SIZEOF_LONG - 1)\n#error Word size must be a power of two\n#endif\n\n#define ALIGN_OFFSET(p) ((uintptr_t) (p) % sizeof(word_t))\n\n#ifndef WORDS_BIGENDIAN\n#define MERGE(w0, sh_1, w1, sh_2) (((w0) >> (sh_1)) | ((w1) << (sh_2)))\n#else\n#define MERGE(w0, sh_1, w1, sh_2) (((w0) << (sh_1)) | ((w1) >> (sh_2)))\n#endif\n\n#define WORD_T_THRESH 16\n\n/* Defines of sizes here to skip build system for now. */\n#define SIZEOF_LONG sizeof(long)\n\n\n/* XOR word-aligned areas. n is the number of words, not bytes. */\nstatic void\nmemxor_common_alignment (word_t *dst, const word_t *src, size_t n)\n{\n  /* FIXME: Require n > 0? */\n  /* FIXME: Unroll four times, like memcmp? Probably not worth the\n     effort. */\n\n  if (n & 1)\n    {\n      *dst++ ^= *src++;\n      n--;\n    }\n  for (; n >= 2; dst += 2, src += 2, n -= 2)\n    {\n      dst[0] ^= src[0];\n      dst[1] ^= src[1];\n    }\n}\n\n/* XOR *un-aligned* src-area onto aligned dst area. n is number of\n   words, not bytes. Assumes we can read complete words at the start\n   and end of the src operand. */\nstatic void\nmemxor_different_alignment (word_t *dst, const char *src, size_t n)\n{\n  size_t i;\n  int shl, shr;\n  const word_t *src_word;\n  unsigned offset = ALIGN_OFFSET (src);\n  word_t s0, s1;\n\n  shl = CHAR_BIT * offset;\n  shr = CHAR_BIT * (sizeof(word_t) - offset);\n\n  src_word = (const word_t *) ((uintptr_t) src & -SIZEOF_LONG);\n\n  /* FIXME: Unroll four times, like memcmp? */\n  i = n & 1;\n  s0 = src_word[i];\n  if (i)\n    {\n      s1 = src_word[0];\n      dst[0] ^= MERGE (s1, shl, s0, shr);\n    }\n\n  for (; i < n; i += 2)\n    {\n      s1 = src_word[i+1];\n      dst[i] ^= MERGE(s0, shl, s1, shr);\n      s0 = src_word[i+2];\n      dst[i+1] ^= MERGE(s1, shl, s0, shr);\n    }\n}\n\n/* Performance, Intel SU1400 (x86_64): 0.25 cycles/byte aligned, 0.45\n   cycles/byte unaligned. */\n\n/* XOR LEN bytes starting at SRCADDR onto DESTADDR. Result undefined\n   if the source overlaps with the destination. Return DESTADDR. */\nvoid *\nmemxor(void *dst_in, const void *src_in, size_t n)\n{\n  char *dst = dst_in;\n  const char *src = src_in;\n\n  if (n >= WORD_T_THRESH)\n    {\n      /* There are at least some bytes to compare.  No need to test\n\t for N == 0 in this alignment loop.  */\n      while (ALIGN_OFFSET (dst))\n\t{\n\t  *dst++ ^= *src++;\n\t  n--;\n\t}\n      if (ALIGN_OFFSET (src))\n\tmemxor_different_alignment ((word_t *) dst, src, n / sizeof(word_t));\n      else\n\tmemxor_common_alignment ((word_t *) dst, (const word_t *) src, n / sizeof(word_t));\n\n      dst += n & -SIZEOF_LONG;\n      src += n & -SIZEOF_LONG;\n      n = n & (SIZEOF_LONG - 1);\n    }\n  for (; n > 0; n--)\n    *dst++ ^= *src++;\n\n  return dst_in;\n}\n\n\n/* XOR word-aligned areas. n is the number of words, not bytes. */\nstatic void\nmemxor3_common_alignment (word_t *dst,\n\t\t\t  const word_t *a, const word_t *b, size_t n)\n{\n  /* FIXME: Require n > 0? */\n  while (n-- > 0)\n    dst[n] = a[n] ^ b[n];\n}\n\nstatic void\nmemxor3_different_alignment_b (word_t *dst,\n\t\t\t       const word_t *a, const char *b, unsigned offset, size_t n)\n{\n  int shl, shr;\n  const word_t *b_word;\n\n  word_t s0, s1;\n\n  shl = CHAR_BIT * offset;\n  shr = CHAR_BIT * (sizeof(word_t) - offset);\n\n  b_word = (const word_t *) ((uintptr_t) b & -SIZEOF_LONG);\n\n  if (n & 1)\n    {\n      n--;\n      s1 = b_word[n];\n      s0 = b_word[n+1];\n      dst[n] = a[n] ^ MERGE (s1, shl, s0, shr);\n    }\n  else\n    s1 = b_word[n];\n  \n  while (n > 0)\n    {\n      n -= 2;\n      s0 = b_word[n+1]; \n      dst[n+1] = a[n+1] ^ MERGE(s0, shl, s1, shr);\n      s1 = b_word[n];\n      dst[n] = a[n] ^ MERGE(s1, shl, s0, shr);\n    }\n}\n\nstatic void\nmemxor3_different_alignment_ab (word_t *dst,\n\t\t\t\tconst char *a, const char *b,\n\t\t\t\tunsigned offset, size_t n)\n{\n  int shl, shr;\n  const word_t *a_word;\n  const word_t *b_word;\n  \n  word_t s0, s1;\n\n  shl = CHAR_BIT * offset;\n  shr = CHAR_BIT * (sizeof(word_t) - offset);\n\n  a_word = (const word_t *) ((uintptr_t) a & -SIZEOF_LONG);\n  b_word = (const word_t *) ((uintptr_t) b & -SIZEOF_LONG);\n\n  if (n & 1)\n    {\n      n--;\n      s1 = a_word[n] ^ b_word[n];\n      s0 = a_word[n+1] ^ b_word[n+1];\n      dst[n] = MERGE (s1, shl, s0, shr);\n    }\n  else    \n    s1 = a_word[n] ^ b_word[n];\n  \n  while (n > 0)\n    {\n      n -= 2;\n      s0 = a_word[n+1] ^ b_word[n+1]; \n      dst[n+1] = MERGE(s0, shl, s1, shr);\n      s1 = a_word[n] ^ b_word[n];\n      dst[n] = MERGE(s1, shl, s0, shr);\n    }\n}\n\nstatic void\nmemxor3_different_alignment_all (word_t *dst,\n\t\t\t\t const char *a, const char *b,\n\t\t\t\t unsigned a_offset, unsigned b_offset,\n\t\t\t\t size_t n)\n{\n  int al, ar, bl, br;\n  const word_t *a_word;\n  const word_t *b_word;\n  \n  word_t a0, a1, b0, b1;\n\n  al = CHAR_BIT * a_offset;\n  ar = CHAR_BIT * (sizeof(word_t) - a_offset);\n  bl = CHAR_BIT * b_offset;\n  br = CHAR_BIT * (sizeof(word_t) - b_offset);\n\n  a_word = (const word_t *) ((uintptr_t) a & -SIZEOF_LONG);\n  b_word = (const word_t *) ((uintptr_t) b & -SIZEOF_LONG);\n\n  if (n & 1)\n    {\n      n--;\n      a1 = a_word[n]; a0 = a_word[n+1];\n      b1 = b_word[n]; b0 = b_word[n+1];\n      \n      dst[n] = MERGE (a1, al, a0, ar) ^ MERGE (b1, bl, b0, br);\n    }\n  else    \n    {\n      a1 = a_word[n];\n      b1 = b_word[n];\n    }\n  \n  while (n > 0)\n    {\n      n -= 2;\n      a0 = a_word[n+1]; b0 = b_word[n+1]; \n      dst[n+1] = MERGE(a0, al, a1, ar) ^ MERGE(b0, bl, b1, br);\n      a1 = a_word[n]; b1 = b_word[n];\n      dst[n] = MERGE(a1, al, a0, ar) ^ MERGE(b1, bl, b0, br);\n    }\n}\n\n/* Current implementation processes data in descending order, to\n   support overlapping operation with one of the sources overlapping\n   the start of the destination area. This feature is used only\n   internally by cbc decrypt, and it is not advertised or documented\n   to nettle users. */\nvoid *\nmemxor3(void *dst_in, const void *a_in, const void *b_in, size_t n)\n{\n  char *dst = dst_in;\n  const char *a = a_in;\n  const char *b = b_in;\n\n  if (n >= WORD_T_THRESH)\n    {\n      unsigned i;\n      unsigned a_offset;\n      unsigned b_offset;\n      size_t nwords;\n\n      for (i = ALIGN_OFFSET(dst + n); i > 0; i--)\n\t{\n\t  n--;\n\t  dst[n] = a[n] ^ b[n];\n\t}\n\n      a_offset = ALIGN_OFFSET(a + n);\n      b_offset = ALIGN_OFFSET(b + n);\n\n      nwords = n / sizeof (word_t);\n      n %= sizeof (word_t);\n\n      if (a_offset == b_offset)\n\t{\n\t  if (!a_offset)\n\t    memxor3_common_alignment((word_t *) (dst + n),\n\t\t\t\t     (const word_t *) (a + n),\n\t\t\t\t     (const word_t *) (b + n), nwords);\n\t  else\n\t    memxor3_different_alignment_ab((word_t *) (dst + n),\n\t\t\t\t\t   a + n, b + n, a_offset,\n\t\t\t\t\t   nwords);\n\t}\n      else if (!a_offset)\n\tmemxor3_different_alignment_b((word_t *) (dst + n),\n\t\t\t\t      (const word_t *) (a + n), b + n,\n\t\t\t\t      b_offset, nwords);\n      else if (!b_offset)\n\tmemxor3_different_alignment_b((word_t *) (dst + n),\n\t\t\t\t      (const word_t *) (b + n), a + n,\n\t\t\t\t      a_offset, nwords);\n      else\n\tmemxor3_different_alignment_all((word_t *) (dst + n), a + n, b + n,\n\t\t\t\t\ta_offset, b_offset, nwords);\n\t\t\t\t\t\n    }\n  while (n-- > 0)\n    dst[n] = a[n] ^ b[n];\n\n  return dst;\n}\n"
        },
        {
            "file_name": "minalpherv1_encrypt.cpp",
            "content": "/*\n  Minalpher v1 reference code version 1.0.0\n\nCopyright (c) 2014\nNTT (Nippon Telegraph and Telephone Corporation)\nand Mitsubishi Electric Corporation\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"minalpherv1_encrypt.h\"\n#include \"minalpherv1_api.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Minalpherv1_raw {\nint numRounds = -1;\n\n/*==== Macros ====*/\n#define Copy(p1,p2,n) do{int u; for( u=0; u<n; u++ ) p1[u]  = p2[u];}while(0)\n#define Xor(p1,p2,n)  do{int u; for( u=0; u<n; u++ ) p1[u] ^= p2[u];}while(0)\n#define Clear(p,n)    do{int u; for( u=0; u<n; u++ ) p[u] = 0x00;}while(0)\n\n/*==== Constants ====*/\nconst static unsigned char s[16] = {\n  0x0B,0x03,0x04,0x01,0x02,0x08,0x0C,0x0F,0x05,0x0D,0x0E,0x00,0x06,0x09,0x0A,0x07};\nconst static int SR1[4]  = {3,0,1,2};\nconst static int SR2[4]  = {2,0,3,1};\nconst static int iSR1[4] = {1,2,3,0};\nconst static int iSR2[4] = {1,3,0,2};\nconst static unsigned char R = 0xA3;\n\n/*==== System parameters ====*/\n#define BLOCK_SIZE 32\n#define TAGBYTES   16\n#define RNUM       17\n\n#define FLG_AD  0x00\n#define FLG_M   0x40\n#define FLG_MAC 0x80\n\n/*== Directions of Permutation ==*/\n#define FORWARD  0\n#define BACKWARD 1\n \n\n\n/*==== Subfunctions in the round function of Minalpher-P ====*/\n/********************************************\n *  Name:       S                           *\n *  Function:   S-Function                  *\n *              (SubNibbles)                *\n *  Return:     Void                        *\n ********************************************/\nstatic void S( \n  unsigned char *_m_      /* I/O  Message     */\n  )       \n{\n  int i;\n  unsigned char t;\n\n  /*--- SubNibbles ---*/\n  for( i=0; i<BLOCK_SIZE; i++ ){\n    t = _m_[i];\n    _m_[i] = (s[t>>4]<<4) | s[t&0x0f];\n  }\n}\n    \n\n/********************************************\n *  Name:       T                           *\n *  Function:   T-Function                  *\n *              (ShuffleRows, SwapMatrices) *\n *  Return:     Void                        *\n ********************************************/\nstatic void T( \n  unsigned char *_m_      /* I/O  Message     */\n  )\n{\n  int i,j;\n  unsigned char t0,t1,t2,t3,temp[16];\n\n  /*--- ShuffleRows ---*/\n  for( i=0; i<4; i++ ){\n    t0 = _m_[SR1[i]];\n    t1 = _m_[SR2[i]+8];\n    t2 = _m_[iSR1[i]+16];\n    t3 = _m_[iSR2[i]+24];\n\n    if( i == 0 ){\n      t2 = (t2>>4) | (t2<<4);\n    }else if( i == 1 ){\n      t0 = (t0>>4) | (t0<<4);\n    }else if( i == 2 ){\n      t1 = (t1>>4) | (t1<<4);\n    }else if( i == 3 ){\n      t3 = (t3>>4) | (t3<<4);\n    }\n\n    temp[i]    = t0;\n    temp[i+4]  = t1;\n    temp[i+8]  = t2;\n    temp[i+12] = t3;\n  }\n\n  for( i=0; i<4; i++ ){\n    _m_[i]    = temp[i];\n    _m_[i+8]  = temp[i+4];\n    _m_[i+16] = temp[i+8];\n    _m_[i+24] = temp[i+12];\n  }       \n\n  for( i=0; i<4; i++ ){\n    t0 = _m_[iSR1[i]+4];\n    t1 = _m_[iSR2[i]+8+4];\n    t2 = _m_[SR1[i]+16+4];\n    t3 = _m_[SR2[i]+24+4];\n\n    if( i == 0 ){\n      t0 = (t0>>4) | (t0<<4);\n    }else if( i == 1 ){\n      t2 = (t2>>4) | (t2<<4);\n    }else if( i == 2 ){\n      t3 = (t3>>4) | (t3<<4);\n    }else if( i == 3 ){\n      t1 = (t1>>4) | (t1<<4);\n    }\n\n    temp[i]    = t0;\n    temp[i+4]  = t1;\n    temp[i+8]  = t2;\n    temp[i+12] = t3;\n  }\n\n  for( i=0; i<4; i++ ){\n    _m_[i+4]    = temp[i];\n    _m_[i+8+4]  = temp[i+4];\n    _m_[i+16+4] = temp[i+8];\n    _m_[i+24+4] = temp[i+12];\n  }       \n\n  /*=== SwapMatrices ===*/\n  for( i=0; i<BLOCK_SIZE; i+=8 ){\n    for( j=0; j<4; j++ ){\n      t0 = _m_[i+j];\n      _m_[i+j] = _m_[i+j+4];\n      _m_[i+j+4] = t0;\n    }\n  }\n}\n\n\n/********************************************\n *  Name:       M                           *\n *  Function:   M-Function                  *\n *              (XorMatrix, MixColumns)     *\n *  Return:     Void                        *\n ********************************************/\nstatic void M( \n  unsigned char *_m_      /* I/O  Message     */\n  )\n{\n  int i;\n  unsigned char t0,t1,t2,t3;\n\n  /*--- XorMatrix ---*/\n  for( i=0; i<BLOCK_SIZE; i+=8 ){\n    _m_[i+4] ^= _m_[i];\n    _m_[i+5] ^= _m_[i+1];\n    _m_[i+6] ^= _m_[i+2];\n    _m_[i+7] ^= _m_[i+3];\n  }\n\n  /*--- MixColumns ---*/\n  for( i=0; i<8; i++ ){\n    t0 = _m_[i];\n    t1 = _m_[i+8];\n    t2 = _m_[i+16];\n    t3 = _m_[i+24];\n\n    _m_[i]  = t0 ^ t1 ^ t3;\n    _m_[i+ 8] = t1 ^ t2 ^ t0;\n    _m_[i+16] = t2 ^ t3 ^ t1;\n    _m_[i+24] = t3 ^ t0 ^ t2;\n  }\n}\n\n\n/********************************************\n *  Name:       E                           *\n *  Function:   E-Function                  *\n *              (Add the round constant)    *\n *  Return:     Void                        *\n ********************************************/\nstatic void E( \n    unsigned char   *_m_,   /* I/O  Message         */\n    int             _r      /* I    Round number    */\n    )\n{\n  int i,j;\n  unsigned char t;\n\n  j=0;\n  for( i=0; i<4; i++ ){\n    t = ( ( ((unsigned char)i) ^ ((unsigned char)_r)&0x0f )<<4 ) | ( ((unsigned char)i) ^ ((unsigned char)_r)&0x0f );\n    _m_[j+4] ^= 0x01 ^ t;\n    _m_[j+5] ^= 0x23 ^ t;\n    j+=8;\n  }   \n}\n\n\n\n/*==== Tweakable Even-Mansour and Minalpher-P ====*/\n/************************************\n *  Name:       minalpher_P         *\n *  Function:   Permutation         *\n *  Return:     Void                *\n ************************************/\nstatic void minalpher_P(\n  unsigned char   *_msg_,     /* I/O  Message                                 */\n  unsigned char   _dir        /* I    Direction (0x00)Forward, (0x01)Backward */\n)\n{\n  int r,rn;\n  unsigned char dat[BLOCK_SIZE];\n\n  Copy( dat, _msg_, BLOCK_SIZE );\n  r = RNUM;\n\n  while( r > 0 ){\n    S( dat );\n    T( dat );\n\n    if( _dir == FORWARD ){\n      rn = RNUM - r;\n      M( dat );\n      E( dat,rn );\n    }else if( _dir == BACKWARD ){\n      rn = r-1;\n      E( dat,rn );\n      M( dat );\n    }\n    r--;\n  }\n\n  S( dat );\n  T( dat );\n\n  Copy( _msg_, dat, BLOCK_SIZE );\n}\n\n\n/********************************************\n *  Name:       TweakGen                    *\n *  Function:   Generate a tweak            *\n *  Return:     Void                        *\n *  Note:       Tweak _L_ is overwritten    *\n ********************************************/\nstatic void TweakGen(\n  unsigned char       *_L_,   /* I/O  Tweak       */\n  unsigned long long  _i,     /* I    an integer  */\n  unsigned long long  _j      /* I    an integer  */\n  )\n{\n  int d;\n  unsigned char t,dat[BLOCK_SIZE];\n\n  /*-- y^{i}(y+1)^{j}L --*/\n  while( _j>0 ){\n\n    Copy( dat, _L_, BLOCK_SIZE );\n    t = _L_[0];\n\n    for( d=0; d<(BLOCK_SIZE-1); d++ ) _L_[d] = _L_[d+1];\n    _L_[31]  = t<<1;\n    _L_[28] ^= t;\n    _L_[29] ^= t; \n\n    if( (t&0x80) == 0x80 ) _L_[31] ^= R;\n    Xor( _L_, dat, BLOCK_SIZE );\n\n    _j--;\n  }\n\n  while( _i>0 ){\n\n    Copy( dat, _L_, BLOCK_SIZE );\n    t = _L_[0];\n\n    for( d=0; d<(BLOCK_SIZE-1); d++ ) _L_[d] = _L_[d+1];\n    _L_[31]  = t<<1;\n    _L_[28] ^= t;\n    _L_[29] ^= t; \n\n    if( (t&0x80) == 0x80 ) _L_[31] ^= R;\n\n    _i--;\n  }\n}\n\n\n/********************************************************************\n *  Name:       TEM_ENC                                             *\n *  Function:   Encryption Algorithm of Tweakable Even-Mansour      *\n *              (Algorithm 1)                                       *\n *  Return:     Void                                                *\n *  Note:       return C in argument *C_                            *\n ********************************************************************/\nstatic void TEM_ENC(\n  const unsigned char     *_K,    /* I    Secret key              */\n  unsigned char           _flag,  /* I    Flag for the padding    */\n  const unsigned char     *_N,    /* I    Nonce                   */\n  unsigned long long      _i,     /* I    an integer              */\n  unsigned long long      _j,     /* I    an integer              */\n  unsigned char           *_M,    /* I    Message                 */\n\n  unsigned char           *C_     /* O    Ciphertext              */\n  )\n{\n  int d;\n  unsigned char L[BLOCK_SIZE];\n\n  /*-- L=(K||flag||N) + P(K||flag||N) --*/\n  Copy( L, _K, CRYPTO_KEYBYTES );\n  L[CRYPTO_KEYBYTES]   = _flag;\n  L[CRYPTO_KEYBYTES+1] = 0x00;\n  L[CRYPTO_KEYBYTES+2] = 0x00;\n  for( d=0; d<CRYPTO_NPUBBYTES; d++ ) L[d+CRYPTO_KEYBYTES+3] = _N[d];\n\n  minalpher_P( L, FORWARD );\n\n  Xor( L, _K, CRYPTO_KEYBYTES );\n  L[CRYPTO_KEYBYTES]   ^= _flag;\n  L[CRYPTO_KEYBYTES+1] ^= 0x00;\n  L[CRYPTO_KEYBYTES+2] ^= 0x00;\n  for( d=0; d<CRYPTO_NPUBBYTES; d++ ) L[d+CRYPTO_KEYBYTES+3] ^= _N[d];\n\n  /* C=y^{i}(y+1)^{j}L + P(M+y^{i}(y+1)^{j}L) --*/\n  Copy( C_, _M, BLOCK_SIZE );\n  TweakGen( L, _i, _j );\n  Xor(  C_,  L, BLOCK_SIZE );\n  minalpher_P( C_, FORWARD );\n  Xor(  C_,  L, BLOCK_SIZE );\n}\n\n\n/********************************************************************\n *  Name:       TEM_DEC                                             *\n *  Function:   Decryption Algorithm of Tweakable Even-Mansour      *\n *              (Algorithm 2)                                       *\n *  Return:     Void                                                *\n *  Note:       return M in argument *M_                            *\n ********************************************************************/\nstatic void TEM_DEC(\n  const unsigned char     *_K,    /* I    Secret key              */\n  unsigned char           _flag,  /* I    Flag for the padding    */\n  const unsigned char     *_N,    /* I    Nonce                   */\n  unsigned long long      _i,     /* I    an integer              */\n  unsigned long long      _j,     /* I    an integer              */\n  unsigned char           *_C,    /* I    Ciphertext              */\n\n  unsigned char           *M_     /* O    Message                 */\n  )\n{\n  int d;\n  unsigned char L[BLOCK_SIZE];\n\n  /*-- L=(K||flag||N) + P(K||flag||N) --*/\n  Copy( L, _K, CRYPTO_KEYBYTES );\n  L[CRYPTO_KEYBYTES]   = _flag;\n  L[CRYPTO_KEYBYTES+1] = 0x00;\n  L[CRYPTO_KEYBYTES+2] = 0x00;\n  for( d=0; d<CRYPTO_NPUBBYTES; d++ ) L[d+CRYPTO_KEYBYTES+3] = _N[d];\n\n  minalpher_P( L, FORWARD );\n\n  Xor( L, _K, CRYPTO_KEYBYTES );\n  L[CRYPTO_KEYBYTES]   ^= _flag;\n  L[CRYPTO_KEYBYTES+1] ^= 0x00;\n  L[CRYPTO_KEYBYTES+2] ^= 0x00;\n  for( d=0; d<CRYPTO_NPUBBYTES; d++ ) L[d+CRYPTO_KEYBYTES+3] ^= _N[d];\n\n  /* M=y^{i}(y+1)^{j}L + P^{-1}(C+y^{i}(y+1)^{j}L)    --*/\n  Copy( M_, _C, BLOCK_SIZE );\n  TweakGen( L, _i, _j );\n  Xor(  M_,  L, BLOCK_SIZE );\n  minalpher_P( M_, BACKWARD );\n  Xor(  M_,  L, BLOCK_SIZE );\n}\n\n\n\n/*==== Minalpher Modes ====*/\n/********************************************************************\n *  Name:       AEAD_CGEN                                           *\n *  Function:   Ciphertext Generation Algorithm of AEAD Mode        *\n *              (Algorithm 3)                                       *\n *  Return:     Void                                                *\n *  Note:       return C & its length in arguments *C_ & clen_      *\n ********************************************************************/\nstatic void AEAD_CGEN(\n  const unsigned char     *_K,    /* I    Secret key              */\n  const unsigned char     *_N,    /* I    Nonce                   */\n  const unsigned char     *_M,    /* I    Message                 */\n  unsigned long long      _mlen,  /* I    Length of Message       */\n\n  unsigned char           *C_,    /* O    Ciphertext              */\n  unsigned long long      *clen_  /* O    Length of Ciphertext    */\n  )\n{\n  int d, pad;\n  unsigned long long i, blocknum;\n  const unsigned char *mp;\n  unsigned char *cp, in[BLOCK_SIZE], out[BLOCK_SIZE];\n\n  i = 1;\n  mp = _M;\n  cp = C_;\n\n  pad = _mlen%BLOCK_SIZE;\n  blocknum = _mlen/BLOCK_SIZE+1;\n  *clen_ = blocknum*BLOCK_SIZE;\n\n  while( blocknum > 1 ){\n\n    Copy( in, mp, BLOCK_SIZE );\n    TEM_ENC( _K, FLG_M, _N, i, 0, in, out );\n    Copy( cp, out, BLOCK_SIZE );\n\n    i += 2;\n    blocknum--;\n    mp += BLOCK_SIZE;\n    cp += BLOCK_SIZE;\n  }\n\n  /* blocknum == 1 */\n\tCopy( in, mp, pad );\n\tin[pad] = 0x80;\n\tfor( d=pad+1; d<BLOCK_SIZE; d++ ) in[d] = 0x00;\n\tTEM_ENC( _K, FLG_M, _N, i, 0, in, out );\n\tCopy( cp, out, BLOCK_SIZE );\n}\n\n\n/********************************************************************\n *  Name:       AEAD_TGEN                                           *\n *  Function:   Tag Generation Algorithm of AEAD Mode               *\n *              (Algorithm 4)                                       *\n *  Return:     Void                                                *\n *  Note:       return Tag in argument *tag_                        *\n ********************************************************************/\nstatic void AEAD_TGEN(\n  const unsigned char     *_K,    /* I    Secret key                  */\n  const unsigned char     *_N,    /* I    Nonce                       */\n  const unsigned char     *_A,    /* I    Associated data             */\n  unsigned long long      _alen,  /* I    Length of Associated data   */\n  const unsigned char     *_C,    /* I    Ciphertext                  */\n  unsigned long long      _clen,  /* I    Length of Ciphertext        */\n\n  unsigned char           *tag_   /* O    Tag                         */\n  )\n{\n  int d, pad;\n  unsigned long long i, j, blocknum;\n  const unsigned char *ap, *cp;\n  unsigned char in[BLOCK_SIZE], out[BLOCK_SIZE], t[BLOCK_SIZE], zero[CRYPTO_NPUBBYTES];\n\n  i = 1;\n  j = 1;\n  ap = _A;\n  cp = _C;\n\n  /*-- Associated data --*/\n  pad = _alen%BLOCK_SIZE;\n  blocknum = _alen/BLOCK_SIZE;\n  if( pad != 0 ) blocknum += 1;\n  Clear( t, BLOCK_SIZE );\n  Clear( zero, CRYPTO_NPUBBYTES );\n\n  while( blocknum > 1 ){\n\n    Copy( in, ap, BLOCK_SIZE );\n    TEM_ENC( _K, FLG_AD, zero, i, 0, in, out );\n    Xor( t, out, BLOCK_SIZE );\n\n    i++;\n    blocknum--;\n    ap += BLOCK_SIZE;\n  }\n\n  if( blocknum == 1 ){\n\n    if( (pad == 0) && (_alen != 0) ){\n      Copy( in, ap, BLOCK_SIZE );\n    }else{\n      Copy( in, ap, pad );\n      in[pad] = 0x80;\n      for( d=pad+1; d<BLOCK_SIZE; d++ ) in[d] = 0x00;\n    }\n    Xor( in, t, BLOCK_SIZE );\n\n    if( pad == 0 ){\n      TEM_ENC( _K, FLG_AD, zero, i-1, 1, in, out );\n    }else{\n      TEM_ENC( _K, FLG_AD, zero, i-1, 2, in, out );\n    }\n\n    Copy( t, out, BLOCK_SIZE );\n  }\n\n\n  /*-- Ciphertext --*/\n  i=1;\n  blocknum = _clen/BLOCK_SIZE;\n\n  while( blocknum > 1 ){\n\n    Copy( in, cp, BLOCK_SIZE );\n    TEM_ENC( _K, FLG_M, _N, 2*i, 0, in, out );\n    Xor( t, out, BLOCK_SIZE );\n\n    i++;\n    blocknum--;\n    cp += BLOCK_SIZE;\n  }\n\n  /* blocknum == 1 */\n\tfor( d=0; d<BLOCK_SIZE; d++ ) in[d] = cp[d] ^ t[d];\n\tTEM_ENC( _K, FLG_M, _N, 2*i-1, 1, in, out );\n\tCopy( tag_, out, TAGBYTES );\n}\n\n\n/********************************************************************\n *\tName:\t\t\t\tAEAD_MGEN\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n *\tFunction:\t\tMessage Generation Algorithm of AEAD Mode\t\t\t\t\t\t*\n *\t\t\t\t\t\t\t(Algorithm 6)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n *\tReturn:\t\t\tAccept(0)/Reject(-1)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n *\tNote:\t\t\t\treturn M & its length in arguments *M_ & mlen_\t\t\t*\n ********************************************************************/\nstatic int AEAD_MGEN(\n\tconst unsigned char\t\t\t*_K,\t\t/* I\t\tSecret key\t\t\t\t\t\t\t*/\n\tconst unsigned char\t\t\t*_N,\t\t/* I\t\tNonce\t\t\t\t\t\t\t\t\t\t*/\n\tconst unsigned char\t\t\t*_C,\t\t/* I\t\tCiphertext\t\t\t\t\t\t\t*/\n\tunsigned long long\t\t\t_clen,\t/* I\t\tLength of Ciphertext\t\t*/\n\n\tunsigned char\t\t\t\t\t\t*M_,\t\t/* O\t\tMessage\t\t\t\t\t\t\t\t\t*/\n\tunsigned long long\t\t\t*mlen_\t/* O\t\tLength of Message\t\t\t\t*/\n\t)\n{\n\tint d, pad, cnt;\n\tunsigned long long i, blocknum, len;\n\tconst unsigned char *cp;\n\tunsigned char *mp, in[BLOCK_SIZE], out[BLOCK_SIZE];\n\n\ti = 1;\n\tcp = _C;\n\tmp = M_;\n\n\tpad = 0;\n\tcnt = 0;\n\tlen = 0;\n\tblocknum = _clen/BLOCK_SIZE;\n\n\twhile( blocknum > 1 ){\n\n\t\tCopy( in, cp, BLOCK_SIZE );\n\t\tTEM_DEC( _K, FLG_M, _N, i, 0, in, out );\n\t\tCopy( mp, out, BLOCK_SIZE );\n\n\t\ti += 2;\n\t\tblocknum--;\n\t\tcp += BLOCK_SIZE;\n\t\tmp += BLOCK_SIZE;\n\t\tlen += BLOCK_SIZE;\n\t}\n\n\tCopy( in, cp, BLOCK_SIZE );\n\tTEM_DEC( _K, FLG_M, _N, i, 0, in, out );\n\tfor(d=BLOCK_SIZE-1; d>=0; d--){\n\t\tif( out[d]==0x80 ){\n\t\t\tCopy( mp, out, d );\n\t\t\t*mlen_ = len + d;\n\t\t\treturn 0;\n\t\t}\n\t\tif( out[d]!=0x00 ) break;\n\t}\n\treturn -1;\n}\n\n\n/********************************************************************\n *  Name:       MAC_GEN                                             *\n *  Function:   Tag Generation Algorithm of MAC Mode                *\n *              (Algorithm 8)                                       *\n *  Return:     0                                                   *\n *  Note:       return tag & its length in arguments *C_ & clen_    *\n ********************************************************************/\nstatic int MAC_GEN(\n  const unsigned char     *_K,    /* I    Secret key              */\n  const unsigned char     *_M,    /* I    Message                 */\n  unsigned long long      _mlen,  /* I    Length of Message       */\n\n  unsigned char           *C_,    /* O    Tag                     */\n  unsigned long long      *clen_  /* O    Length of Tag           */\n  )\n{\n  int d, pad;\n  unsigned long long i, blocknum;\n  const unsigned char *mp;\n  unsigned char *cp, in[BLOCK_SIZE], out[BLOCK_SIZE], t[BLOCK_SIZE], zero[CRYPTO_NPUBBYTES];\n\n  i = 1;\n  mp = _M;\n  cp = C_;\n\n  pad = _mlen%BLOCK_SIZE;\n  blocknum = _mlen/BLOCK_SIZE;\n  if( (pad!=0) || (_mlen==0) ) blocknum += 1;\n  Clear( t, BLOCK_SIZE );\n  Clear( zero, CRYPTO_NPUBBYTES );\n\n  while( blocknum > 1 ){\n\n    Copy( in, mp, BLOCK_SIZE );\n    TEM_ENC( _K, FLG_MAC, zero, i, 0, in, out );\n    Xor( t, out, BLOCK_SIZE );\n\n    i++;\n    blocknum--;\n    mp += BLOCK_SIZE;\n  }\n\n  /* blocknum == 1 */\n\tif( (pad==0) && (_mlen!=0) ){\n\t\tCopy( in, mp, BLOCK_SIZE );\n\t}else{\n\t\tCopy( in, mp, pad );\n\t\tin[pad] = 0x80;\n\t\tfor( d=pad+1; d<BLOCK_SIZE; d++ ) in[d] = 0x00;\n\t}\n\n\tXor( in, t, BLOCK_SIZE );\n\tif( (pad==0) && (_mlen!=0) ){\n\t\tTEM_ENC( _K, FLG_MAC, zero, i-1, 1, in, out );\n\t}else{\n\t\tTEM_ENC( _K, FLG_MAC, zero, i-1, 2, in, out );\n\t}\n\tCopy( cp, out, TAGBYTES );\n\t*clen_ = TAGBYTES;\n\n\treturn 0;\n}\n\n\n/********************************************************************\n *  Name:       MAC_VERIF                                           *\n *  Function:   Tag Verification Algorithm of MAC Mode              *\n *              (Algorithm 9)                                       *\n *  Return:     Accept(0)/Reject(-1)                                *\n ********************************************************************/\nstatic int MAC_VERIF(\n  const unsigned char     *_K,    /* I    Secret key              */\n  const unsigned char     *_M,    /* I    Message                 */\n  unsigned long long      _mlen,  /* I    Length of Message       */\n\n  const unsigned char     *_C,    /* I    Tag to be verified      */\n  unsigned long long      _clen   /* I    Length of Tag           */\n  )\n{\n  int result=0;\n  unsigned long long d, len=0;\n  unsigned char tag[TAGBYTES];\n\n  result = MAC_GEN( _K, _M, _mlen, tag, &len );\n\n  if( len != _clen ) result |= 1;\n  for( d=0; d<len; d++ ){\n    if( tag[d] != _C[d] ) result |= 1;\n  }\n\n  if( result != 0 ) return -1;\n  return 0;\n}\n\n\n\n/*==== CAESAR API ====*/\n/************************************************************\n *  Name:       crypto_aead_encrypt                         *\n *  Function:   authenticated encryption                    *\n *  Return:     Valid(0)/Invalid(-1)                        *\n ************************************************************/\nint crypto_aead_encrypt(\n  unsigned char       *c,\n  unsigned long long  *clen,\n  const unsigned char *m,\n  unsigned long long  mlen,\n  const unsigned char *ad,\n  unsigned long long  adlen,\n  const unsigned char *nsec,\n  const unsigned char *npub,\n  const unsigned char *k\n  )\n{\n  unsigned long long cr;\n  int d;\n  unsigned char tag[TAGBYTES];\n\n  cr = mlen + adlen;\n  if( (cr<mlen) && (cr<adlen) ) return -1;\n\n  /* Algorithm 6 */\n  AEAD_CGEN( k, npub, m, mlen, c, clen );\n  AEAD_TGEN( k, npub, ad, adlen, c, *clen, tag );\n\n  for( d=0; d<TAGBYTES; d++ ) c[d+*clen] = tag[d];\n  *clen += TAGBYTES;\n\n  return 0;\n}\n\n\n/************************************************************\n *  Name:       crypto_aead_decrypt                         *\n *  Function:   authenticated decryption                    *\n *  Return:     Valid(0)/Invalid(-1)                        *\n ************************************************************/\nint crypto_aead_decrypt(\n  unsigned char       *m,\n  unsigned long long  *mlen,\n  unsigned char       *nsec,\n  const unsigned char *c,\n  unsigned long long  clen,\n  const unsigned char *ad,\n  unsigned long long  adlen,\n  const unsigned char *npub,\n  const unsigned char *k\n  )\n{\n  unsigned long long cr;\n  int d, ret=0;\n  unsigned char tag[TAGBYTES];\n\n  cr = clen + adlen;\n  if( (cr<clen) && (cr<adlen) ) return -1;\n\n  clen -= TAGBYTES;\n\tif( clen % BLOCK_SIZE ) return -1;\n\tif( clen < BLOCK_SIZE ) return -1;\n\n  /* Algorithm 7 */\n  AEAD_TGEN( k, npub, ad, adlen, c, clen, tag );\n  for( d=0; d<TAGBYTES; d++ ){\n    if( tag[d] != c[d+clen] ) ret |= 1;\n  }\n  if( ret != 0 )  return -1;\n  if(AEAD_MGEN( k, npub, c, clen, m, mlen ) < 0){\n    return -1;\n  }\n\n  return 0;\n}\n\n\n/************************************************************\n *  Name:       crypto_mac_gen                              *\n *  Function:   sign to a message                           *\n *  Return:     Valid(0)/Invalid(-1)                        *\n ************************************************************/\nint crypto_mac_gen(\n  unsigned char       *c,     /* O    Tag                                 */\n  unsigned long long  *clen,  /* O    Length of Tag                       */\n  const unsigned char *m,     /* I    Message                             */\n  unsigned long long  mlen,   /* I    Length of Message                   */\n  const unsigned char *nsec,  /* I    Secret message number (not used)    */\n  const unsigned char *npub,  /* I    Public message number (not used)    */\n  const unsigned char *k      /* I    Secret key                          */\n  )\n{\n  int ret;\n\n  ret = MAC_GEN(  k, \n                  m, mlen, \n                  c, clen );\n\n  return 0;\n}\n\n\n/************************************************************\n *  Name:       crypto_mac_verif                            *\n *  Function:   verify a signature                          *\n *  Return:     Valid(0)/Invalid(-1)                        *\n ************************************************************/\nint crypto_mac_verif(\n  const unsigned char *c,     /* I    Tag to verified                     */\n  unsigned long long  clen,   /* I    Length of Tag                       */\n  const unsigned char *m,     /* I    Message                             */\n  unsigned long long  mlen,   /* I    Length of Message                   */\n  const unsigned char *nsec,  /* I    Secret message number (not used)    */  \n  const unsigned char *npub,  /* I    Public message number (not used)    */\n  const unsigned char *k      /* I    Secret key                          */\n  )\n{\n  int ret;\n\n  ret = MAC_VERIF( k, \n                   m, mlen, \n                   c, clen );\n\n  if( ret != 0 ) return -1;\n\n  return 0;\n}\n\n} // namespace Minalpherv1_raw\n"
        },
        {
            "file_name": "MorusCore1280.cpp",
            "content": "#pragma once\n\n#ifndef MORUS_MANAGED_CORE_1280\n#define MORUS_MANAGED_CORE_1280\n\nusing namespace System;\nusing namespace System::IO;\n\nnamespace MorusManaged\n{\n\tnamespace MorusCore1280\n\t{\n\t\t// fibonacci sequence MOD 256, LITTLE ENDIAN\n#define CONST64_0_0\t0x0d08050302010100\n#define CONST64_0_1\t0x6279e99059372215\n#define CONST64_1_0\t0xf12fc26d55183ddb \n#define CONST64_1_1\t0xdd28b57342311120\n\n#define ROTL64C1 13\n#define ROTL64C2 46\n#define ROTL64C3 38\n#define ROTL64C4 7\n#define ROTL64C5 4\n\n#define RotL_64(x,n)   ((UInt64(x) << (n)) | (UInt64(x) >> (64-n)))\n#define MORUS_1280_TAG_LEN_BYTES\t16\n#define MORUS_1280_TAG_LEN_WORDS\t2\n\n\t\tstatic void _updateState(array<UInt64>^ state, array<const UInt64>^ msgblk)\n\t\t{\n\t\t\tUInt64 temp;\n\t\t\t// ROUND 1, Row0 ^= Row3 ^ (Row1 BITWISE-AND Row2)\n\t\t\tstate[0] ^= state[12] ^ (state[4] & state[8]);\n\t\t\tstate[1] ^= state[13] ^ (state[5] & state[9]);\n\t\t\tstate[2] ^= state[14] ^ (state[6] & state[10]); \n\t\t\tstate[3] ^= state[15] ^ (state[7] & state[11]);\n\t\t\t\n\t\t\tstate[0] = RotL_64(state[0], ROTL64C1); // Rotl_xxx_yy(S0, b0)\n\t\t\tstate[1] = RotL_64(state[1], ROTL64C1);       \n\t\t\tstate[2] = RotL_64(state[2], ROTL64C1);       \n\t\t\tstate[3] = RotL_64(state[3], ROTL64C1);\n\t\t\t\n\t\t\ttemp = state[15]; // rotate whole state row 64 bits right\n\t\t\tstate[15] = state[14];  \n\t\t\tstate[14] = state[13];  \n\t\t\tstate[13] = state[12];  \n\t\t\tstate[12] = temp;\n\n\t\t\t// ROUND 2, Row1 ^= Row4 ^ (Row2 BITWISE-AND Row3) ^ MSG\n\t\t\tstate[4] ^= state[16] ^ (state[8] & state[12]) ^ msgblk[0];   \n\t\t\tstate[5] ^= state[17] ^ (state[9] & state[13]) ^ msgblk[1];   \n\t\t\tstate[6] ^= state[18] ^ (state[10] & state[14]) ^ msgblk[2];   \n\t\t\tstate[7] ^= state[19] ^ (state[11] & state[15]) ^ msgblk[3];\n\n\t\t\tstate[4] = RotL_64(state[4], ROTL64C2); // Rotl_xxx_yy(S1, b1)\n\t\t\tstate[5] = RotL_64(state[5], ROTL64C2);\n\t\t\tstate[6] = RotL_64(state[6], ROTL64C2);\n\t\t\tstate[7] = RotL_64(state[7], ROTL64C2);\n\t\t\t\n\t\t\ttemp = state[19]; // rotate whole state row 128 bits\n\t\t\tstate[19] = state[17];  \n\t\t\tstate[17] = temp;\n\t\t\ttemp = state[18];\n\t\t\tstate[18] = state[16];\n\t\t\tstate[16] = temp;\n\n\t\t\t// ROUND 3, Row2 ^= Row0 ^ (Row3 BITWISE-AND Row4) ^ MSG\n\t\t\tstate[8] ^= state[0] ^ (state[12] & state[16]) ^ msgblk[0];\n\t\t\tstate[9] ^= state[1] ^ (state[13] & state[17]) ^ msgblk[1];\n\t\t\tstate[10] ^= state[2] ^ (state[14] & state[18]) ^ msgblk[2];\n\t\t\tstate[11] ^= state[3] ^ (state[15] & state[19]) ^ msgblk[3];\n\t\t\t\n\t\t\tstate[8] = RotL_64(state[8], ROTL64C3); // Rotl_xxx_yy(S2, b2)\n\t\t\tstate[9] = RotL_64(state[9], ROTL64C3);       \n\t\t\tstate[10] = RotL_64(state[10], ROTL64C3);       \n\t\t\tstate[11] = RotL_64(state[11], ROTL64C3);\n\t\t\t\n\t\t\ttemp = state[0]; // rotate whole state row 64 bits left\n\t\t\tstate[0] = state[1];\n\t\t\tstate[1] = state[2];\n\t\t\tstate[2] = state[3];\n\t\t\tstate[3] = temp;\n\n\t\t\t// ROUND 4, Row3 ^= Row1 ^ (Row4 BITWISE-AND Row0) ^ MSG\n\t\t\tstate[12] ^= state[4] ^ (state[16] & state[0]) ^ msgblk[0];\n\t\t\tstate[13] ^= state[5] ^ (state[17] & state[1]) ^ msgblk[1];\n\t\t\tstate[14] ^= state[6] ^ (state[18] & state[2]) ^ msgblk[2];\n\t\t\tstate[15] ^= state[7] ^ (state[19] & state[3]) ^ msgblk[3];\n\t\t\t\n\t\t\tstate[12] = RotL_64(state[12], ROTL64C4); // Rotl_xxx_yy(S3, b3)\n\t\t\tstate[13] = RotL_64(state[13], ROTL64C4);       \n\t\t\tstate[14] = RotL_64(state[14], ROTL64C4);       \n\t\t\tstate[15] = RotL_64(state[15], ROTL64C4);\n\t\t\t\n\t\t\ttemp = state[7]; // rotate whole state row 128 bits\n\t\t\tstate[7] = state[5]; \n\t\t\tstate[5] = temp;\n\t\t\ttemp = state[6];\n\t\t\tstate[6] = state[4]; \n\t\t\tstate[4] = temp;\n\n\t\t\t// ROUND 5, Row4 ^= Row2 ^ (Row0 BITWISE-AND Row1) ^ MSG\n\t\t\tstate[16] ^= state[8] ^ (state[0] & state[4]) ^ msgblk[0];  \n\t\t\tstate[17] ^= state[9] ^ (state[1] & state[5]) ^ msgblk[1];  \n\t\t\tstate[18] ^= state[10] ^ (state[2] & state[6]) ^ msgblk[2]; \n\t\t\tstate[19] ^= state[11] ^ (state[3] & state[7]) ^ msgblk[3];\n\t\t\t\t\n\t\t\tstate[16] = RotL_64(state[16], ROTL64C5); // Rotl_xxx_yy(S4, b4)\n\t\t\tstate[17] = RotL_64(state[17], ROTL64C5);\n\t\t\tstate[18] = RotL_64(state[18], ROTL64C5);\n\t\t\tstate[19] = RotL_64(state[19], ROTL64C5);\n\t\t\t\n\t\t\ttemp = state[11]; // rotate whole state row 64 bits right\n\t\t\tstate[11] = state[10];  \n\t\t\tstate[10] = state[9];  \n\t\t\tstate[9] = state[8];  \n\t\t\tstate[8] = temp;\n\t\t}\n\n\t\tstatic array<UInt64>^ _init(array<const Byte>^ key, array<const Byte>^ iv)\n\t\t{\n\t\t\tarray<UInt64>^ state = gcnew array<UInt64>{ // 5 rows * 4 words\n\t\t\t\t0,0,0,0, // iv goes in front half here\n\t\t\t\t0,0,0,0, // key goes here (twice if 16 bytes (128 bits), once if 32 bytes (256 bits))\n\t\t\t\tUInt64::MaxValue, UInt64::MaxValue, UInt64::MaxValue, UInt64::MaxValue, // all 1's\n\t\t\t\t0,0,0,0, // all 0's\n\t\t\t\tCONST64_0_0, CONST64_0_1, CONST64_1_0, CONST64_1_1}; // constant goes here\n\t\t\tarray<UInt64>^ temp = gcnew array<UInt64>(4); // all 0's\n\n\t\t\tBuffer::BlockCopy(iv, 0, state, 0, iv->Length); // IV fills first 16 bytes, next 16 bytes are 0\n\t\t\tif (key->Length == 16)\n\t\t\t{\n\t\t\t\tBuffer::BlockCopy(key, 0, state, 4 * sizeof(UInt64), key->Length); // key fills first 16 bytes...\n\t\t\t\tBuffer::BlockCopy(key, 0, state, 6 * sizeof(UInt64), key->Length); // ...repeated in second 16 bytes\n\t\t\t}\n\t\t\telse if(key->Length == 32)\n\t\t\t\tBuffer::BlockCopy(key, 0, state, 4 * sizeof(UInt64), key->Length); // key fills all 32 bytes (different from 1280-128)\n\n\t\t\tarray<UInt64>^ tempKey = gcnew array<UInt64>{ state[4], state[5], state[6], state[7] }; // need temp key down below\n\t\t\tByte i;\n\t\t\tfor (i = 0; i < 16; i++) _updateState(state, (array<const UInt64>^)temp); // update state 16 times\n\t\t\tfor (i = 0; i < 4; i++) state[i + 4] ^= tempKey[i]; // XOR key in a second time after mixing state\n\t\t\tBuffer::BlockCopy(temp, 0, tempKey, 0, temp->Length * sizeof(UInt64)); // clear tempkey\n\t\t\t// prevent compiler optimizations; these should all be 0 and thus have no mathematical effect\n\t\t\tfor (i = 0; i < 4; i++) state[i + 4] ^= tempKey[i];\n\t\t\ttempKey = nullptr;\n\t\t\ttemp = nullptr;\n\t\t\treturn state;\n\t\t}\n\n\t\t//the finalization state of MORUS\n\t\tstatic __inline void _finalize_state(array<UInt64>^ state, const UInt64 adlen, const UInt64 msglen)\n\t\t{\n\t\t\t// XOR the first row into the fifth\n\t\t\tstate[16] ^= state[0]; \n\t\t\tstate[17] ^= state[1]; \n\t\t\tstate[18] ^= state[2]; \n\t\t\tstate[19] ^= state[3];\n\n\t\t\t// help prevent forgeries/extension attacks by incorporating plaintext attributes\n\t\t\t{// C# USING t64\n\t\t\t\tarray<const UInt64>^ t64 = { adlen << 3, msglen << 3, 0, 0 };\n\t\t\t\tfor (Byte i = 0; i < 10; i++) _updateState(state, t64); // update state 10 times\n\t\t\t}\n\t\t\t// Row0 ^= (Row1 >>> 64 bits) ^ (Row2 BITWISE-AND Row3), this is output as the tag after this step\n\t\t\tstate[0] ^= state[5] ^ (state[8] & state[12]);\n\t\t\tstate[1] ^= state[6] ^ (state[9] & state[13]);\n\t\t\t//state[2] ^= state[7] ^ (state[10] & state[14]); // these aren't needed, we only need 128 bits, half a state row\n\t\t\t//state[3] ^= state[4] ^ (state[11] & state[15]);\n\t\t}\n\n\t\tstatic int _encryptStream(\n\t\t\tMemoryStream^ AdditionalData,\n\t\t\tMemoryStream^ Plaintext,\n\t\t\tarray<const Byte>^ Key,\n\t\t\tarray<const Byte>^ Nonce,\n\t\t\tMemoryStream^ Ciphertext,\n\t\t\tMemoryStream^ Tag)\n\t\t{\n\t\t\tUInt64 MSGLen = Plaintext != nullptr ? Plaintext->Length : 0;\n\t\t\tarray<UInt64>^ state = _init(Key, Nonce);\n\t\t\t//Ciphertext = gcnew array<Byte>(MSGLen + 16);\n\t\t\tUInt64 i;\n\t\t\tUInt64 ADLen = AdditionalData != nullptr ? AdditionalData->Length : 0;\n\t\t\tif (ADLen > 0)\n\t\t\t{\t// C# USING: br, buf, NO OUTPUT DURING THIS PHASE! ONLY STATE UPDATES!\n\t\t\t\tBinaryReader^ br = gcnew BinaryReader(AdditionalData);\n\t\t\t\tarray<UInt64>^ buf = gcnew array<UInt64>(4);\n\t\t\t\tfor (i = 0; (i + 32) <= ADLen; i += 32)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(32), 0, buf, 0, 32);\n\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)buf);\n\t\t\t\t}\n\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\tif (0 != ADLen % 32)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(ADLen % 32), 0, buf, 0, ADLen % 32);\n\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)buf);\n\t\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\t\tstate[0] ^= buf[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate[0] ^= buf[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t} // end USING\n\t\t\t{ // C# USING: bw\n\t\t\t\tBinaryWriter^ bw = gcnew BinaryWriter(Ciphertext);\n\t\t\t\tif (MSGLen > 0)\n\t\t\t\t{\t// C# USING: br, buf, inputBlock\n\t\t\t\t\tBinaryReader^ br = gcnew BinaryReader(Plaintext);\n\t\t\t\t\tarray<UInt64>^ inputBlock = gcnew array<UInt64>(4);\n\t\t\t\t\tfor (i = 0; (i + 32) <= MSGLen; i += 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tinputBlock[0] = br->ReadUInt64(); inputBlock[1] = br->ReadUInt64();\n\t\t\t\t\t\tinputBlock[2] = br->ReadUInt64(); inputBlock[3] = br->ReadUInt64();\n\t\t\t\t\t\tbw->Write(inputBlock[0] ^ state[0] ^ state[5] ^ (state[8] & state[12]));\n\t\t\t\t\t\tbw->Write(inputBlock[1] ^ state[1] ^ state[6] ^ (state[9] & state[13]));\n\t\t\t\t\t\tbw->Write(inputBlock[2] ^ state[2] ^ state[7] ^ (state[10] & state[14]));\n\t\t\t\t\t\tbw->Write(inputBlock[3] ^ state[3] ^ state[4] ^ (state[11] & state[15]));\n\t\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)inputBlock);\n\t\t\t\t\t}\n\t\t\t\t\tArray::Clear(inputBlock, 0, inputBlock->Length);\n\t\t\t\t\tif (0 != MSGLen % 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(MSGLen % 32), 0, inputBlock, 0, MSGLen % 32);\n\t\t\t\t\t\tarray<UInt64>^ outputBlock = gcnew array<UInt64>(4);\n\t\t\t\t\t\toutputBlock[0] = inputBlock[0] ^ state[0] ^ state[5] ^ (state[8] & state[12]);\n\t\t\t\t\t\toutputBlock[1] = inputBlock[1] ^ state[1] ^ state[6] ^ (state[9] & state[13]);\n\t\t\t\t\t\toutputBlock[2] = inputBlock[2] ^ state[2] ^ state[7] ^ (state[10] & state[14]);\n\t\t\t\t\t\toutputBlock[3] = inputBlock[3] ^ state[3] ^ state[4] ^ (state[11] & state[15]);\n\t\t\t\t\t\tfor (Byte i = 0; i < MSGLen % 32; i++) // timing attack????\n\t\t\t\t\t\t\tbw->Write(Buffer::GetByte(outputBlock, i));\n\t\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)inputBlock);\n\t\t\t\t\t\tArray::Clear(inputBlock, 0, 4);\n\t\t\t\t\t\tstate[0] ^= inputBlock[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tstate[0] ^= inputBlock[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t\t} // end USING\n\t\t\t\tbw->Flush();\n\t\t\t\tbw = nullptr;\n\t\t\t} // end USING\n\t\t\t// TAG GENERATION\n\t\t\tMorusCore1280::_finalize_state(state, ADLen, MSGLen); // 1280 128 and 256 do this the same way\n\t\t\tBinaryWriter^ tw = gcnew BinaryWriter(Tag);\n\t\t\ttw->Write(state[0]);\n\t\t\ttw->Write(state[1]);\n\t\t\ttw->Flush();\n\t\t\ttw = nullptr;\n\t\t\ttry {\n\t\t\t\tArray::Clear(state, 0, state->Length);\n\t\t\t\tstate = gcnew array<UInt64>{state[0], state[1]};\n\t\t\t}\n\t\t\tcatch (...) {}\n\t\t\treturn (int)state[0]; // should be zero, but used to prevent compiler optimization of Clear\n\t\t}\n\n\t\tstatic int _decryptStream(\n\t\t\tMemoryStream^ AdditionalData,\n\t\t\tMemoryStream^ Ciphertext,\n\t\t\tMemoryStream^ Tag,\n\t\t\tarray<const Byte>^ Key,\n\t\t\tarray<const Byte>^ Nonce,\n\t\t\tMemoryStream^ Plaintext) \n\t\t{\n\t\t\tInt64 MSGLen = 0;\n\t\t\tif (Ciphertext != nullptr)\n\t\t\t{\n\t\t\t\t// if we have a cipher text BUT NO SEPARATE TAG, then the overall length = C.Len - 16\n\t\t\t\t// ELSE if we have a separate tag, the length is the length (tag is already accounted for)\n\t\t\t\tMSGLen = Tag == nullptr ? Ciphertext->Length - 16 : MSGLen = Ciphertext->Length;\n\t\t\t}\n\t\t\tif (MSGLen < 0)\n\t\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Ciphertext\", \"Ciphertext cannot be shorter than 16 bytes (length of Tag)\");\n\t\t\tarray<UInt64>^ state = MorusCore1280::_init(Key, Nonce);\n\t\t\tInt64 i;\n\t\t\tInt64 ADLen = AdditionalData != nullptr ? AdditionalData->Length : 0;\n\t\t\tif (ADLen > 0)\n\t\t\t{\t// C# USING: br, buf, NO OUTPUT DURING THIS PHASE! ONLY STATE UPDATES!\n\t\t\t\tBinaryReader^ br = gcnew BinaryReader(AdditionalData);\n\t\t\t\tarray<UInt64>^ buf = gcnew array<UInt64>(4);\n\t\t\t\tfor (i = 0; (i + 32) <= ADLen; i += 32)\n\t\t\t\t{\n\t\t\t\t\t//Buffer::BlockCopy(AdditionalData, i, buf, 0, 32);\n\t\t\t\t\tbuf[0] = br->ReadUInt64(); buf[1] = br->ReadUInt64(); buf[2] = br->ReadUInt64(); buf[3] = br->ReadUInt64();\n\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)buf);\n\t\t\t\t}\n\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\tif (0 != ADLen % 32)\n\t\t\t\t{\n\t\t\t\t\t//Buffer::BlockCopy(AdditionalData, i, buf, 0, ADLen % 32);\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(ADLen % 32), 0, buf, 0, ADLen % 32);\n\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)buf);\n\t\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\t\tstate[0] ^= buf[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate[0] ^= buf[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t} // end USING\n\t\t\tBinaryReader^ br = gcnew BinaryReader(Ciphertext);\n\t\t\tBinaryWriter^ bw = gcnew BinaryWriter(Plaintext);\n\t\t\tif (MSGLen > 0)\n\t\t\t{\t// C# USING: buf, inputBlock\n\n\t\t\t\tarray<UInt64>^ inputBlock = gcnew array<UInt64>(4);\n\t\t\t\tarray<UInt64>^ outputBlock = gcnew array<UInt64>(4);\n\t\t\t\tfor (i = 0; (i + 32) <= MSGLen; i += 32)\n\t\t\t\t{\n\t\t\t\t\tinputBlock[0] = br->ReadUInt64(); inputBlock[1] = br->ReadUInt64();\n\t\t\t\t\tinputBlock[2] = br->ReadUInt64(); inputBlock[3] = br->ReadUInt64();\n\t\t\t\t\toutputBlock[0] = inputBlock[0] ^ state[0] ^ state[5] ^ (state[8] & state[12]);\n\t\t\t\t\toutputBlock[1] = inputBlock[1] ^ state[1] ^ state[6] ^ (state[9] & state[13]);\n\t\t\t\t\toutputBlock[2] = inputBlock[2] ^ state[2] ^ state[7] ^ (state[10] & state[14]);\n\t\t\t\t\toutputBlock[3] = inputBlock[3] ^ state[3] ^ state[4] ^ (state[11] & state[15]);\n\t\t\t\t\tbw->Write(outputBlock[0]);\n\t\t\t\t\tbw->Write(outputBlock[1]);\n\t\t\t\t\tbw->Write(outputBlock[2]);\n\t\t\t\t\tbw->Write(outputBlock[3]);\n\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)outputBlock);\n\t\t\t\t}\n\t\t\t\tArray::Clear(inputBlock, 0, inputBlock->Length); // zero out array\n\t\t\t\tArray::Clear(outputBlock, 0, outputBlock->Length); // zero out array\n\t\t\t\tif (0 != MSGLen % 32)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(MSGLen % 32), 0, inputBlock, 0, MSGLen % 32);\n\t\t\t\t\toutputBlock[0] = inputBlock[0] ^ state[0] ^ state[5] ^ (state[8] & state[12]);\n\t\t\t\t\toutputBlock[1] = inputBlock[1] ^ state[1] ^ state[6] ^ (state[9] & state[13]);\n\t\t\t\t\toutputBlock[2] = inputBlock[2] ^ state[2] ^ state[7] ^ (state[10] & state[14]);\n\t\t\t\t\toutputBlock[3] = inputBlock[3] ^ state[3] ^ state[4] ^ (state[11] & state[15]);\n\t\t\t\t\tfor (Byte i = 0; i < 32; i++) // timing attack during the IF statement?? analyse to be sure\n\t\t\t\t\t\tif (i < MSGLen % 32)\n\t\t\t\t\t\t\tbw->Write(Buffer::GetByte(outputBlock, i)); // output the partial block as plaintext\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tBuffer::SetByte(outputBlock, i, 0); // recreate the zero whitespace at the end of the plaintext\n\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)outputBlock);\n\t\t\t\t\tArray::Clear(inputBlock, 0, inputBlock->Length);\n\t\t\t\t\tArray::Clear(outputBlock, 0, outputBlock->Length);\n\t\t\t\t\tstate[0] ^= inputBlock[0] | outputBlock[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate[0] ^= inputBlock[3] | outputBlock[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t} // end USING\n\t\t\tbw->Flush();\n\t\t\t// TAG GENERATION\n\t\t\tMorusCore1280::_finalize_state(state, ADLen, MSGLen); // 1280 128 and 256 do this the same way\n\t\t\tBinaryReader^ tr = gcnew BinaryReader(Tag != nullptr ? Tag : Ciphertext); // if no separate tag, it's in the Ciphertext buffer);\n\t\t\tUInt64 a = tr->ReadUInt64(), b = tr->ReadUInt64();\n\t\t\tUInt64 compare = (a ^ state[0]) | (b ^ state[1]);\n\t\t\tArray::Clear(state, 0, state->Length); // zero the state\n\t\t\tfor (Byte i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tstate[16] |= (state[i*4] | UInt64::MaxValue) + compare;\n\t\t\t}\n\t\t\tstate = gcnew array<UInt64>{state[0], compare | UInt64::MaxValue};\n\t\t\t//br->Close();\n\t\t\tif (compare == 0)\n\t\t\t{\n\t\t\t\treturn (int)(state[0]); // prevent compiler optimization of Clear operation above; this value should be 0\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttry {\n\t\t\t\t\tif (Plaintext != nullptr && Plaintext->Length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tArray::Clear(Plaintext->GetBuffer(), 0, MSGLen);\n\t\t\t\t\t\t// no matter what, state gets bitwiped to 1 or 0, and then shifted to 0, but this prevents the compiler from optimizing out the Clear\n\t\t\t\t\t\tPlaintext->Seek(0, SeekOrigin::Begin); // if we can't seek, then the exception gets swallowed\n\t\t\t\t\t\tPlaintext->Write(Plaintext->GetBuffer(), 0, 4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (...)\n\t\t\t\t{\n\t\t\t\t\tSystem::Diagnostics::Debug::Print(\"EXCEPTION!\");\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tstatic int _encrypt(\n\t\t\tarray<const Byte>^ AdditionalData,\n\t\t\tarray<const Byte>^ Plaintext,\n\t\t\tarray<const Byte>^ Key,\n\t\t\tarray<const Byte>^ Nonce,\n\t\t\tarray<Byte>^% Ciphertext,\n\t\t\tarray<Byte>^% Tag)\n\t\t{\n\t\t\tint MSGLen = Plaintext != nullptr ? Plaintext->Length : 0;\n\t\t\tarray<array<UInt64>^>^ state = _init(Key, Nonce);\n\t\t\t//Ciphertext = gcnew array<Byte>(MSGLen + 16);\n\t\t\tint i;\n\t\t\tint ADLen = AdditionalData != nullptr ? AdditionalData->Length : 0;\n\t\t\tif (ADLen > 0)\n\t\t\t{\t// C# USING: br, buf, NO OUTPUT DURING THIS PHASE! ONLY STATE UPDATES!\n\t\t\t\tBinaryReader^ br = gcnew BinaryReader(gcnew MemoryStream((array<Byte>^)AdditionalData, false));\n\t\t\t\tarray<UInt64>^ buf = gcnew array<UInt64>(4);\n\t\t\t\tfor (i = 0; (i + 32) <= ADLen; i += 32)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(AdditionalData, i, buf, 0, 32);\n\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)buf);\n\t\t\t\t}\n\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\tif (0 != ADLen % 32)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(AdditionalData, i, buf, 0, ADLen % 32);\n\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)buf);\n\t\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\t\tstate[0][0] ^= buf[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate[0][0] ^= buf[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t} // end USING\n\t\t\tBinaryWriter^ bw = gcnew BinaryWriter(gcnew MemoryStream(Ciphertext, true));\n\t\t\tif (MSGLen > 0)\n\t\t\t{\t// C# USING: br, buf, inputBlock\n\t\t\t\tBinaryReader^ br = gcnew BinaryReader(gcnew MemoryStream((array<Byte>^)Plaintext, false));\n\t\t\t\tarray<UInt64>^ inputBlock = gcnew array<UInt64>(4);\n\t\t\t\tfor (i = 0; (i + 32) <= MSGLen; i += 32)\n\t\t\t\t{\n\t\t\t\t\tinputBlock[0] = br->ReadUInt64(); inputBlock[1] = br->ReadUInt64();\n\t\t\t\t\tinputBlock[2] = br->ReadUInt64(); inputBlock[3] = br->ReadUInt64();\n\t\t\t\t\tbw->Write(inputBlock[0] ^ state[0][0] ^ state[5] ^ (state[8] & state[12]));\n\t\t\t\t\tbw->Write(inputBlock[1] ^ state[0][1] ^ state[6] ^ (state[9] & state[13]));\n\t\t\t\t\tbw->Write(inputBlock[2] ^ state[0][2] ^ state[7] ^ (state[10] & state[14]));\n\t\t\t\t\tbw->Write(inputBlock[3] ^ state[0][3] ^ state[4] ^ (state[11] & state[15]));\n\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)inputBlock);\n\t\t\t\t}\n\t\t\t\tArray::Clear(inputBlock, 0, inputBlock->Length);\n\t\t\t\tif (0 != MSGLen % 32)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(MSGLen % 32), 0, inputBlock, 0, MSGLen % 32);\n\t\t\t\t\tarray<UInt64>^ outputBlock = gcnew array<UInt64>(4);\n\t\t\t\t\toutputBlock[0] = inputBlock[0] ^ state[0][0] ^ state[5] ^ (state[8] & state[12]);\n\t\t\t\t\toutputBlock[1] = inputBlock[1] ^ state[0][1] ^ state[6] ^ (state[9] & state[13]);\n\t\t\t\t\toutputBlock[2] = inputBlock[2] ^ state[0][2] ^ state[7] ^ (state[10] & state[14]);\n\t\t\t\t\toutputBlock[3] = inputBlock[3] ^ state[0][3] ^ state[4] ^ (state[11] & state[15]);\n\t\t\t\t\tfor (Byte i = 0; i < MSGLen % 32; i++) // timing attack????\n\t\t\t\t\t\tbw->Write(Buffer::GetByte(outputBlock, i));\n\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)inputBlock);\n\t\t\t\t\tArray::Clear(inputBlock, 0, 4);\n\t\t\t\t\tstate[0][0] ^= inputBlock[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate[0][0] ^= inputBlock[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t} // end USING\n\t\t\tbw->Flush();\n\t\t\tbw->Close();\n\t\t\t// TAG GENERATION\n\t\t\tMorusCore1280::_finalize_state(state, ADLen, MSGLen); // 1280 128 and 256 do this the same way\n\t\t\tBinaryWriter^ tw = gcnew BinaryWriter(gcnew MemoryStream(Tag, true));\n\t\t\ttw->Write(state[0][0]);\n\t\t\ttw->Write(state[0][1]);\n\t\t\ttw->Flush();\n\t\t\ttry {\n\t\t\t\tArray::Clear(state, 0, state->Length);\n\t\t\t\tstate[0] = gcnew array<UInt64>(1);\n\t\t\t}\n\t\t\tcatch (...) {}\n\t\t\treturn (int)state[0][0]; // should be zero, but used to prevent compiler optimization of Clear\n\t\t}\n\n\t\tstatic int _decrypt(\n\t\t\tarray<const Byte>^ AdditionalData,\n\t\t\tarray<const Byte>^ Ciphertext,\n\t\t\tarray<const Byte>^ Tag,\n\t\t\tarray<const Byte>^ Key,\n\t\t\tarray<const Byte>^ Nonce,\n\t\t\tarray<Byte>^ Plaintext)\n\t\t{\n\t\t\tint MSGLen = Ciphertext != nullptr ? Ciphertext->Length - 16 : 16; // full length - tag, or just tag\n\t\t\tif (MSGLen < 0)\n\t\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Ciphertext\", \"Ciphertext cannot be shorter than 16 bytes (length of Tag)\");\n\t\t\tarray<array<UInt64>^>^ state = MorusCore1280::_init(Key, Nonce);\n\t\t\tint i;\n\t\t\tint ADLen = AdditionalData != nullptr ? AdditionalData->Length : 0;\n\t\t\tif (ADLen > 0)\n\t\t\t{\t// C# USING: br, buf, NO OUTPUT DURING THIS PHASE! ONLY STATE UPDATES!\n\t\t\t\tBinaryReader^ br = gcnew BinaryReader(gcnew MemoryStream((array<Byte>^)AdditionalData, false));\n\t\t\t\tarray<UInt64>^ buf = gcnew array<UInt64>(4);\n\t\t\t\tfor (i = 0; (i + 32) <= ADLen; i += 32)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(AdditionalData, i, buf, 0, 32);\n\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)buf);\n\t\t\t\t}\n\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\tif (0 != ADLen % 32)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(AdditionalData, i, buf, 0, ADLen % 32);\n\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)buf);\n\t\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\t\tstate[0][0] ^= buf[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate[0][0] ^= buf[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t} // end USING\n\t\t\t//array<Byte>^ tempPlaintext = gcnew array<Byte>(MSGLen);\n\t\t\t{ // C# USING: br, bw\n\t\t\t\tBinaryReader^ br = gcnew BinaryReader(gcnew MemoryStream((array<Byte>^)Ciphertext, false));\n\t\t\t\tBinaryWriter^ bw = gcnew BinaryWriter(gcnew MemoryStream(Plaintext, true));\n\t\t\t\tif (MSGLen > 0)\n\t\t\t\t{\t// C# USING: buf, inputBlock\n\n\t\t\t\t\tarray<UInt64>^ inputBlock = gcnew array<UInt64>(4);\n\t\t\t\t\tarray<UInt64>^ outputBlock = gcnew array<UInt64>(4);\n\t\t\t\t\tfor (i = 0; (i + 32) <= MSGLen; i += 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tinputBlock[0] = br->ReadUInt64(); inputBlock[1] = br->ReadUInt64();\n\t\t\t\t\t\tinputBlock[2] = br->ReadUInt64(); inputBlock[3] = br->ReadUInt64();\n\t\t\t\t\t\toutputBlock[0] = inputBlock[0] ^ state[0][0] ^ state[5] ^ (state[8] & state[12]);\n\t\t\t\t\t\toutputBlock[1] = inputBlock[1] ^ state[0][1] ^ state[6] ^ (state[9] & state[13]);\n\t\t\t\t\t\toutputBlock[2] = inputBlock[2] ^ state[0][2] ^ state[7] ^ (state[10] & state[14]);\n\t\t\t\t\t\toutputBlock[3] = inputBlock[3] ^ state[0][3] ^ state[4] ^ (state[11] & state[15]);\n\t\t\t\t\t\tbw->Write(outputBlock[0]);\n\t\t\t\t\t\tbw->Write(outputBlock[1]);\n\t\t\t\t\t\tbw->Write(outputBlock[2]);\n\t\t\t\t\t\tbw->Write(outputBlock[3]);\n\t\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)outputBlock);\n\t\t\t\t\t}\n\t\t\t\t\tArray::Clear(inputBlock, 0, inputBlock->Length); // zero out array\n\t\t\t\t\tArray::Clear(outputBlock, 0, outputBlock->Length); // zero out array\n\t\t\t\t\tif (0 != MSGLen % 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(MSGLen % 32), 0, inputBlock, 0, MSGLen % 32);\n\t\t\t\t\t\toutputBlock[0] = inputBlock[0] ^ state[0][0] ^ state[5] ^ (state[8] & state[12]);\n\t\t\t\t\t\toutputBlock[1] = inputBlock[1] ^ state[0][1] ^ state[6] ^ (state[9] & state[13]);\n\t\t\t\t\t\toutputBlock[2] = inputBlock[2] ^ state[0][2] ^ state[7] ^ (state[10] & state[14]);\n\t\t\t\t\t\toutputBlock[3] = inputBlock[3] ^ state[0][3] ^ state[4] ^ (state[11] & state[15]);\n\t\t\t\t\t\tfor (Byte i = 0; i < 32; i++) // timing attack during the IF statement?? analyse to be sure\n\t\t\t\t\t\t\tif (i < MSGLen % 32)\n\t\t\t\t\t\t\t\tbw->Write(Buffer::GetByte(outputBlock, i)); // output the partial block as plaintext\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tBuffer::SetByte(outputBlock, i, 0); // recreate the zero whitespace at the end of the plaintext\n\t\t\t\t\t\tMorusCore1280::_updateState(state, (array<const UInt64>^)outputBlock);\n\t\t\t\t\t\tArray::Clear(inputBlock, 0, inputBlock->Length);\n\t\t\t\t\t\tArray::Clear(outputBlock, 0, outputBlock->Length);\n\t\t\t\t\t\tstate[0][0] ^= inputBlock[0] | outputBlock[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tstate[0][0] ^= inputBlock[3] | outputBlock[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t\t} // end USING\n\t\t\t\tbw->Flush();\n\t\t\t\tbw->Close();\n\t\t\t\tbr->Close();\n\t\t\t} // end USING\n\t\t\t// TAG GENERATION\n\t\t\tMorusCore1280::_finalize_state(state, ADLen, MSGLen); // 1280 128 and 256 do this the same way\n\t\t\tBinaryReader^ tr = gcnew BinaryReader(gcnew MemoryStream((array<Byte>^)Tag, false));\n\t\t\tUInt64 a = tr->ReadUInt64(), b = tr->ReadUInt64();\n\t\t\tUInt64 compare = (a ^ state[0][0]) | (b ^ state[0][1]);\n\t\t\tfor (Byte i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tArray::Clear(state[i], 0, state[i]->Length); // zero the row\n\t\t\t\tstate[16] |= (state[i][0] | UInt64::MaxValue) + compare;\n\t\t\t}\n\t\t\ttry // try to prevent compiler optimization\n\t\t\t{\n\t\t\t\tArray::Clear(state, 0, state->Length); // blow away the individual row array references\n\t\t\t\tstate[0] = gcnew array<UInt64>{compare | UInt64::MaxValue};\n\t\t\t}\n\t\t\tcatch (...)\n\t\t\t{\n\t\t\t\tSystem::Diagnostics::Debug::Print(\"EXCEPTION!\");\n\t\t\t}\t\t\n\t\t\tif (compare == 0)\n\t\t\t{\n\t\t\t\t//Plaintext = tempPlaintext;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttry {\n\t\t\t\t\tif (Plaintext != nullptr && Plaintext->Length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tArray::Clear(Plaintext, 0, MSGLen);\n\t\t\t\t\t\t// no matter what, state gets bitwiped to 1 or 0, and then shifted to 0, but this prevents the compiler from optimizing out the Clear\n\t\t\t\t\t\tPlaintext[0] = (Byte)(state[0][0] & (UInt64)compare) >> 1;\n\t\t\t\t\t}\n\t\t\t\t\t//else tempPlaintext = gcnew array<Byte>(1);\n\t\t\t\t}\n\t\t\t\tcatch (...)\n\t\t\t\t{\n\t\t\t\t\tSystem::Diagnostics::Debug::Print(\"EXCEPTION!\");\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}*/\n\t}\n}\n#endif // !MORUS_MANAGED_CORE_128\n"
        },
        {
            "file_name": "MorusCore640.cpp",
            "content": "#pragma once\n\n#ifndef MORUS_MANAGED_CORE_640\n#define MORUS_MANAGED_CORE_640\n\nusing namespace System;\nusing namespace System::IO;\n\nnamespace MorusManaged\n{\n\tnamespace MorusCore640\n\t{\n\t\t// fibonacci sequence MOD 256, LITTLE ENDIAN\n#define CONST32_0_0\t0x02010100\n#define CONST32_0_1\t0x0d080503\n#define CONST32_0_2 0x59372215\n#define CONST32_0_3 0x6279e990\n#define CONST32_1_0\t0x55183ddb \n#define CONST32_1_1\t0xf12fc26d\n#define CONST32_1_2 0x42311120\n#define CONST32_1_3 0xdd28b573\n\n#define ROTL32C1 5 \n#define ROTL32C2 31\n#define ROTL32C3 7\n#define ROTL32C4 22\n#define ROTL32C5 13\n\n#define RotL_32(x,n)   ((UInt32(x) << n) | (UInt32(x) >> (32-n)))  \n\n\t\tstatic void _updateState(array<UInt32>^ state, array<const UInt32>^ msgblk)\n\t\t{\n\t\t\tUInt32 temp;\n\t\t\t// ROUND 1, Row0 ^= Row3 ^ (Row1 BITWISE-AND Row2)\n\t\t\tstate[0] ^= state[12] ^ (state[4] & state[8]);\n\t\t\tstate[1] ^= state[13] ^ (state[5] & state[9]);\n\t\t\tstate[2] ^= state[14] ^ (state[6] & state[10]);\n\t\t\tstate[3] ^= state[15] ^ (state[7] & state[11]);\n\n\t\t\tstate[0] = RotL_32(state[0], ROTL32C1); // Rotl_xxx_yy(S0, b0)\n\t\t\tstate[1] = RotL_32(state[1], ROTL32C1);\n\t\t\tstate[2] = RotL_32(state[2], ROTL32C1);\n\t\t\tstate[3] = RotL_32(state[3], ROTL32C1);\n\n\t\t\ttemp = state[15]; // rotate whole state row 32 bits right\n\t\t\tstate[15] = state[14];\n\t\t\tstate[14] = state[13];\n\t\t\tstate[13] = state[12];\n\t\t\tstate[12] = temp;\n\n\t\t\t// ROUND 2, Row1 ^= Row4 ^ (Row2 BITWISE-AND Row3) ^ MSG\n\t\t\tstate[4] ^= state[16] ^ (state[8] & state[12]) ^ msgblk[0];\n\t\t\tstate[5] ^= state[17] ^ (state[9] & state[13]) ^ msgblk[1];\n\t\t\tstate[6] ^= state[18] ^ (state[10] & state[14]) ^ msgblk[2];\n\t\t\tstate[7] ^= state[19] ^ (state[11] & state[15]) ^ msgblk[3];\n\n\t\t\tstate[4] = RotL_32(state[4], ROTL32C2); // Rotl_xxx_yy(S1, b1)\n\t\t\tstate[5] = RotL_32(state[5], ROTL32C2);\n\t\t\tstate[6] = RotL_32(state[6], ROTL32C2);\n\t\t\tstate[7] = RotL_32(state[7], ROTL32C2);\n\n\t\t\ttemp = state[19]; // rotate whole state row 64 bits\n\t\t\tstate[19] = state[17];\n\t\t\tstate[17] = temp;\n\t\t\ttemp = state[18];\n\t\t\tstate[18] = state[16];\n\t\t\tstate[16] = temp;\n\n\t\t\t// ROUND 3, Row2 ^= Row0 ^ (Row3 BITWISE-AND Row4) ^ MSG\n\t\t\tstate[8] ^= state[0] ^ (state[12] & state[16]) ^ msgblk[0];\n\t\t\tstate[9] ^= state[1] ^ (state[13] & state[17]) ^ msgblk[1];\n\t\t\tstate[10] ^= state[2] ^ (state[14] & state[18]) ^ msgblk[2];\n\t\t\tstate[11] ^= state[3] ^ (state[15] & state[19]) ^ msgblk[3];\n\n\t\t\tstate[8] = RotL_32(state[8], ROTL32C3); // Rotl_xxx_yy(S2, b2)\n\t\t\tstate[9] = RotL_32(state[9], ROTL32C3);\n\t\t\tstate[10] = RotL_32(state[10], ROTL32C3);\n\t\t\tstate[11] = RotL_32(state[11], ROTL32C3);\n\n\t\t\ttemp = state[0]; // rotate whole state row 32 bits left\n\t\t\tstate[0] = state[1];\n\t\t\tstate[1] = state[2];\n\t\t\tstate[2] = state[3];\n\t\t\tstate[3] = temp;\n\n\t\t\t// ROUND 4, Row3 ^= Row1 ^ (Row4 BITWISE-AND Row0) ^ MSG\n\t\t\tstate[12] ^= state[4] ^ (state[16] & state[0]) ^ msgblk[0];\n\t\t\tstate[13] ^= state[5] ^ (state[17] & state[1]) ^ msgblk[1];\n\t\t\tstate[14] ^= state[6] ^ (state[18] & state[2]) ^ msgblk[2];\n\t\t\tstate[15] ^= state[7] ^ (state[19] & state[3]) ^ msgblk[3];\n\n\t\t\tstate[12] = RotL_32(state[12], ROTL32C4); // Rotl_xxx_yy(S3, b3)\n\t\t\tstate[13] = RotL_32(state[13], ROTL32C4);\n\t\t\tstate[14] = RotL_32(state[14], ROTL32C4);\n\t\t\tstate[15] = RotL_32(state[15], ROTL32C4);\n\n\t\t\ttemp = state[7]; // rotate whole state row 64 bits\n\t\t\tstate[7] = state[5];\n\t\t\tstate[5] = temp;\n\t\t\ttemp = state[6];\n\t\t\tstate[6] = state[4];\n\t\t\tstate[4] = temp;\n\n\t\t\t// ROUND 5, Row4 ^= Row2 ^ (Row0 BITWISE-AND Row1) ^ MSG\n\t\t\tstate[16] ^= state[8] ^ (state[0] & state[4]) ^ msgblk[0];\n\t\t\tstate[17] ^= state[9] ^ (state[1] & state[5]) ^ msgblk[1];\n\t\t\tstate[18] ^= state[10] ^ (state[2] & state[6]) ^ msgblk[2];\n\t\t\tstate[19] ^= state[11] ^ (state[3] & state[7]) ^ msgblk[3];\n\n\t\t\tstate[16] = RotL_32(state[16], ROTL32C5); // Rotl_xxx_yy(S4, b4)\n\t\t\tstate[17] = RotL_32(state[17], ROTL32C5);\n\t\t\tstate[18] = RotL_32(state[18], ROTL32C5);\n\t\t\tstate[19] = RotL_32(state[19], ROTL32C5);\n\n\t\t\ttemp = state[11]; // rotate whole state row 32 bits right\n\t\t\tstate[11] = state[10];\n\t\t\tstate[10] = state[9];\n\t\t\tstate[9] = state[8];\n\t\t\tstate[8] = temp;\n\t\t}\n\n\t\tstatic array<UInt32>^ _init(array<const Byte>^ key, array<const Byte>^ iv)\n\t\t{\n\t\t\tarray<UInt32>^ state = gcnew array<UInt32>{ // 5 rows of 4 words\n\t\t\t\t0,0,0,0, //iv goes here\n\t\t\t\t0,0,0,0, // key goes here\n\t\t\t\tUInt32::MaxValue, UInt32::MaxValue, UInt32::MaxValue, UInt32::MaxValue, // all 1's\n\t\t\t\tCONST32_0_0, CONST32_0_1, CONST32_0_2, CONST32_0_3, // low constant goes here\n\t\t\t\tCONST32_1_0, CONST32_1_1, CONST32_1_2, CONST32_1_3  // high constant goes here\n\t\t\t}; \n\t\t\tarray<const UInt32>^ temp = gcnew array<const UInt32>(4); // all 0's\n\n\t\t\tBuffer::BlockCopy(iv, 0, state, 0, iv->Length); // IV fills 16 bytes, full row\n\t\t\tBuffer::BlockCopy(key, 0, state, 4 * sizeof(UInt32), key->Length); // key fills 16 bytes\n\n\t\t\tarray<const UInt32>^ tempKey = gcnew array<const UInt32>{ state[4], state[5], state[6], state[7] }; // need temp key down below\n\t\t\tByte i;\n\t\t\tfor (i = 0; i < 16; i++) MorusCore640::_updateState(state, temp); // update state 16 times\n\t\t\tfor (i = 0; i < 4; i++)\tstate[i + 4] ^= tempKey[i]; // XOR key in a second time after mixing state\t\n\t\t\tBuffer::BlockCopy(temp, 0, tempKey, 0, temp->Length * sizeof(UInt32)); // clear tempkey\n\t\t\t// prevent compiler optimizations; these should all be 0 and thus have no mathematical effect\n\t\t\tfor (i = 0; i < 4; i++) state[i + 4] ^= tempKey[i];\n\t\t\ttempKey = nullptr;\n\t\t\ttemp = nullptr;\n\t\t\treturn state;\n\t\t}\n\n\t\t//the finalization state of MORUS\n\t\tstatic __inline void _finalize_state(array<UInt32>^ state, const UInt64 adlen, const UInt64 msglen)\n\t\t{\n\t\t\t// XOR the first row into the fifth\n\t\t\tstate[16] ^= state[0]; \n\t\t\tstate[17] ^= state[1]; \n\t\t\tstate[18] ^= state[2]; \n\t\t\tstate[19] ^= state[3];\n\n\t\t\t// help prevent forgeries/extension attacks by incorporating plaintext attributes\n\t\t\t// ad & msg lens are always expressed as 64 bits\n\t\t\t{ // C# USING t32, t64\n\t\t\t\tarray<const UInt32>^ t32 = gcnew array<const UInt32>(4);\n\t\t\t\tarray<const UInt64>^ t64 = gcnew array<const UInt64>{adlen << 3, msglen << 3};\n\t\t\t\tBuffer::BlockCopy(t64, 0, t32, 0, 16);\n\t\t\t\tfor (Byte i = 0; i < 10; i++) _updateState(state, t32); // update state 10 times\n\t\t\t}\n\t\t\t// Row0 ^= (Row1 >>> 32 bits) ^ (Row2 BITWISE-AND Row3), this is output as the tag after this step\n\t\t\tstate[0] ^= state[5] ^ (state[8] & state[12]);\n\t\t\tstate[1] ^= state[6] ^ (state[9] & state[13]);\n\t\t\tstate[2] ^= state[7] ^ (state[10] & state[14]);\n\t\t\tstate[3] ^= state[4] ^ (state[11] & state[15]);\n\t\t}\n\n\t\tstatic int _encryptStream(\n\t\t\tMemoryStream^ AdditionalData,\n\t\t\tMemoryStream^ Plaintext,\n\t\t\tarray<const Byte>^ Key,\n\t\t\tarray<const Byte>^ Nonce,\n\t\t\tMemoryStream^ Ciphertext,\n\t\t\tMemoryStream^ Tag)\n\t\t{\n\t\t\tUInt64 MSGLen = Plaintext != nullptr ? Plaintext->Length : 0;\n\t\t\tarray<UInt32>^ state = MorusCore640::_init(Key, Nonce);\n\t\t\t//Ciphertext = gcnew array<Byte>(MSGLen + 16);\n\t\t\tUInt64 i;\n\t\t\tUInt64 ADLen = AdditionalData != nullptr ? AdditionalData->Length : 0;\n\t\t\tif (ADLen > 0)\n\t\t\t{\t// C# USING: br, buf, NO OUTPUT DURING THIS PHASE! ONLY STATE UPDATES!\n\t\t\t\tBinaryReader^ br = gcnew BinaryReader(AdditionalData);\n\t\t\t\tarray<UInt32>^ buf = gcnew array<UInt32>(4);\n\t\t\t\tfor (i = 0; (i + 16) <= ADLen; i += 16)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(16), 0, buf, 0, 16);\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)buf);\n\t\t\t\t}\n\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\tif (0 != ADLen % 16)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(ADLen % 16), 0, buf, 0, ADLen % 16);\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)buf);\n\t\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\t\tstate[0] ^= buf[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate[0] ^= buf[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t} // end USING\n\t\t\tBinaryWriter^ bw = gcnew BinaryWriter(Ciphertext);\n\t\t\tif (MSGLen > 0)\n\t\t\t{\t// C# USING: br, buf, inputBlock\n\t\t\t\tBinaryReader^ br = gcnew BinaryReader(Plaintext);\n\t\t\t\tarray<UInt32>^ inputBlock = gcnew array<UInt32>(4);\n\t\t\t\tfor (i = 0; (i + 16) <= MSGLen; i += 16)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(16), 0, inputBlock, 0, 16);\n\t\t\t\t\tbw->Write(inputBlock[0] ^ state[0] ^ state[5] ^ (state[8] & state[12]));\n\t\t\t\t\tbw->Write(inputBlock[1] ^ state[1] ^ state[6] ^ (state[9] & state[13]));\n\t\t\t\t\tbw->Write(inputBlock[2] ^ state[2] ^ state[7] ^ (state[10] & state[14]));\n\t\t\t\t\tbw->Write(inputBlock[3] ^ state[3] ^ state[4] ^ (state[11] & state[15]));\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)inputBlock);\n\t\t\t\t}\n\t\t\t\tArray::Clear(inputBlock, 0, inputBlock->Length);\n\t\t\t\tif (0 != MSGLen % 16)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(MSGLen % 16), 0, inputBlock, 0, MSGLen % 16);\n\t\t\t\t\tarray<UInt32>^ outputBlock = gcnew array<UInt32>(4);\n\t\t\t\t\toutputBlock[0] = inputBlock[0] ^ state[0] ^ state[5] ^ (state[8] & state[12]);\n\t\t\t\t\toutputBlock[1] = inputBlock[1] ^ state[1] ^ state[6] ^ (state[9] & state[13]);\n\t\t\t\t\toutputBlock[2] = inputBlock[2] ^ state[2] ^ state[7] ^ (state[10] & state[14]);\n\t\t\t\t\toutputBlock[3] = inputBlock[3] ^ state[3] ^ state[4] ^ (state[11] & state[15]);\n\t\t\t\t\tfor (Byte i = 0; i < MSGLen % 16; i++) // timing attack????\n\t\t\t\t\t\tbw->Write(Buffer::GetByte(outputBlock, i));\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)inputBlock);\n\t\t\t\t\tArray::Clear(inputBlock, 0, 4);\n\t\t\t\t\tstate[0] ^= inputBlock[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate[0] ^= inputBlock[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t} // end USING\n\t\t\tbw->Flush();\n\t\t\t// TAG GENERATION\n\t\t\tMorusCore640::_finalize_state(state, ADLen, MSGLen); // 1280 128 and 256 do this the same way\n\t\t\tBinaryWriter^ tw = gcnew BinaryWriter(Tag);\n\t\t\ttw->Write(state[0]);\n\t\t\ttw->Write(state[1]);\n\t\t\ttw->Write(state[2]);\n\t\t\ttw->Write(state[3]);\n\t\t\ttw->Flush();\n\t\t\ttry {\n\t\t\t\tArray::Clear(state, 0, state->Length);\n\t\t\t\tstate = gcnew array<UInt32>{state[0], state[1]};\n\t\t\t}\n\t\t\tcatch (...) {}\n\t\t\treturn (int)state[0]; // should be zero, but used to prevent compiler optimization of Clear\n\t\t}\n\n\t\tstatic int _decryptStream(\n\t\t\tMemoryStream^ AdditionalData,\n\t\t\tMemoryStream^ Ciphertext,\n\t\t\tMemoryStream^ Tag,\n\t\t\tarray<const Byte>^ Key,\n\t\t\tarray<const Byte>^ Nonce,\n\t\t\tMemoryStream^% Plaintext) // this is assigned by _decryptStream in the event the Plaintext has to be wiped for security\n\t\t{\n\t\t\tInt64 MSGLen = 0;\n\t\t\tif (Ciphertext != nullptr)\n\t\t\t{\n\t\t\t\t// if we have a cipher text BUT NO SEPARATE TAG, then the overall length = C.Len - 16\n\t\t\t\t// ELSE if we have a separate tag, the length is the length (tag is already accounted for)\n\t\t\t\tMSGLen = Tag == nullptr ? Ciphertext->Length - 16 : MSGLen = Ciphertext->Length;\n\t\t\t}\n\t\t\tif (MSGLen < 0)\n\t\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Ciphertext\", \"Ciphertext cannot be shorter than 16 bytes (length of Tag)\");\n\t\t\tarray<UInt32>^ state = MorusCore640::_init(Key, Nonce);\n\t\t\tInt64 i;\n\t\t\tInt64 ADLen = AdditionalData != nullptr ? AdditionalData->Length : 0;\n\t\t\tif (ADLen > 0)\n\t\t\t{\t// C# USING: br, buf, NO OUTPUT DURING THIS PHASE! ONLY STATE UPDATES!\n\t\t\t\tBinaryReader^ br = gcnew BinaryReader(AdditionalData);\n\t\t\t\tarray<UInt32>^ buf = gcnew array<UInt32>(4);\n\t\t\t\tfor (i = 0; (i + 16) <= ADLen; i += 16)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(16), 0, buf, 0, 16);\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)buf);\n\t\t\t\t}\n\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\tif (0 != ADLen % 16)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(ADLen % 16), 0, buf, 0, ADLen % 16);\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)buf);\n\t\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\t\tstate[0] ^= buf[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate[0] ^= buf[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t} // end USING\n\t\t\tBinaryReader^ br = gcnew BinaryReader(Ciphertext);\n\t\t\tBinaryWriter^ bw = gcnew BinaryWriter(Plaintext);\n\t\t\tif (MSGLen > 0)\n\t\t\t{\t// C# USING: buf, inputBlock\n\n\t\t\t\tarray<UInt32>^ inputBlock = gcnew array<UInt32>(4);\n\t\t\t\tarray<UInt32>^ outputBlock = gcnew array<UInt32>(4);\n\t\t\t\tfor (i = 0; (i + 16) <= MSGLen; i += 16)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(16), 0, inputBlock, 0, 16);\n\t\t\t\t\toutputBlock[0] = inputBlock[0] ^ state[0] ^ state[5] ^ (state[8] & state[12]);\n\t\t\t\t\toutputBlock[1] = inputBlock[1] ^ state[1] ^ state[6] ^ (state[9] & state[13]);\n\t\t\t\t\toutputBlock[2] = inputBlock[2] ^ state[2] ^ state[7] ^ (state[10] & state[14]);\n\t\t\t\t\toutputBlock[3] = inputBlock[3] ^ state[3] ^ state[4] ^ (state[11] & state[15]);\n\t\t\t\t\tbw->Write(outputBlock[0]);\n\t\t\t\t\tbw->Write(outputBlock[1]);\n\t\t\t\t\tbw->Write(outputBlock[2]);\n\t\t\t\t\tbw->Write(outputBlock[3]);\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)outputBlock);\n\t\t\t\t}\n\t\t\t\tArray::Clear(inputBlock, 0, inputBlock->Length); // zero out array\n\t\t\t\tArray::Clear(outputBlock, 0, outputBlock->Length); // zero out array\n\t\t\t\tif (0 != MSGLen % 16)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(MSGLen % 16), 0, inputBlock, 0, MSGLen % 16);\n\t\t\t\t\toutputBlock[0] = inputBlock[0] ^ state[0] ^ state[5] ^ (state[8] & state[12]);\n\t\t\t\t\toutputBlock[1] = inputBlock[1] ^ state[1] ^ state[6] ^ (state[9] & state[13]);\n\t\t\t\t\toutputBlock[2] = inputBlock[2] ^ state[2] ^ state[7] ^ (state[10] & state[14]);\n\t\t\t\t\toutputBlock[3] = inputBlock[3] ^ state[3] ^ state[4] ^ (state[11] & state[15]);\n\t\t\t\t\tfor (Byte i = 0; i < 16; i++) // timing attack during the IF statement?? analyse to be sure\n\t\t\t\t\t\tif (i < MSGLen % 16)\n\t\t\t\t\t\t\tbw->Write(Buffer::GetByte(outputBlock, i)); // output the partial block as plaintext\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tBuffer::SetByte(outputBlock, i, 0); // recreate the zero whitespace at the end of the plaintext\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)outputBlock);\n\t\t\t\t\tArray::Clear(inputBlock, 0, inputBlock->Length);\n\t\t\t\t\tArray::Clear(outputBlock, 0, outputBlock->Length);\n\t\t\t\t\tstate[0] ^= inputBlock[0] | outputBlock[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate[0] ^= inputBlock[3] | outputBlock[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t} // end USING\n\t\t\tbw->Flush();\n\t\t\t//bw->Close();\n\t\t\t// TAG GENERATION\n\t\t\tMorusCore640::_finalize_state(state, ADLen, MSGLen); // 1280 128 and 256 do this the same way\n\t\t\tBinaryReader^ tr = gcnew BinaryReader(Tag != nullptr ? Tag : Ciphertext); // if no separate tag, it's in the Ciphertext buffer\n\t\t\tUInt32 a = tr->ReadUInt32(), b = tr->ReadUInt32(), c = tr->ReadUInt32(), d = tr->ReadUInt32();\n\t\t\tUInt32 compare = (a ^ state[0]) | (b ^ state[1]) | (c ^ state[2]) | (d ^ state[3]);\n\t\t\tArray::Clear(state, 0, state->Length); // zero the array\n\t\t\tfor (Byte i = 0; i < 5; i++) // go through the rows to zero them\n\t\t\t{\n\t\t\t\tstate[16] |= (state[(i*4)] | UInt32::MaxValue) + compare;\n\t\t\t}\n\t\t\tstate = gcnew array<UInt32>{0, compare | UInt32::MaxValue};\n\t\t\t//br->Close();\n\t\t\tif (compare == 0)\n\t\t\t{\n\t\t\t\treturn (int)(state[0]); // prevent compiler optimization of Clear operation above; this value should be 0\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttry {\n\t\t\t\t\tif (Plaintext != nullptr && Plaintext->Length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tArray::Clear(Plaintext->GetBuffer(), 0, MSGLen);\n\t\t\t\t\t\t// no matter what, state gets bitwiped to 1 or 0, and then shifted to 0, but this prevents the compiler from optimizing out the Clear\n\t\t\t\t\t\tPlaintext->Seek(0, SeekOrigin::Begin); // if we can't seek, then the exception gets swallowed\n\t\t\t\t\t\tPlaintext->Write(Plaintext->GetBuffer(), 0, 4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (...)\n\t\t\t\t{\n\t\t\t\t\tSystem::Diagnostics::Debug::Print(\"EXCEPTION!\");\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tstatic int _encrypt(\n\t\t\tarray<const Byte>^ AdditionalData,\n\t\t\tarray<const Byte>^ Plaintext,\n\t\t\tarray<const Byte>^ Key,\n\t\t\tarray<const Byte>^ Nonce,\n\t\t\t[Out] array<Byte>^% Ciphertext)\n\t\t{\n\t\t\tint MSGLen = Plaintext != nullptr ? Plaintext->Length : 0;\n\t\t\tarray<array<UInt32>^>^ state = MorusCore640::_init(Key, Nonce);\n\t\t\tCiphertext = gcnew array<Byte>(MSGLen + 16);\n\t\t\tint i;\n\t\t\tint ADLen = AdditionalData != nullptr ? AdditionalData->Length : 0;\n\t\t\tif (ADLen > 0)\n\t\t\t{\t// C# USING: br, buf, NO OUTPUT DURING THIS PHASE! ONLY STATE UPDATES!\n\t\t\t\tBinaryReader^ br = gcnew BinaryReader(gcnew MemoryStream((array<Byte>^)AdditionalData, false));\n\t\t\t\tarray<UInt32>^ buf = gcnew array<UInt32>(4);\n\t\t\t\tfor (i = 0; (i + 16) <= ADLen; i += 16)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(AdditionalData, i, buf, 0, 16);\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)buf);\n\t\t\t\t}\n\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\tif (0 != ADLen % 16)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(AdditionalData, i, buf, 0, ADLen % 16);\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)buf);\n\t\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\t\tstate[0][0] ^= buf[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate[0][0] ^= buf[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t} // end USING\n\t\t\tBinaryWriter^ bw = gcnew BinaryWriter(gcnew MemoryStream(Ciphertext, true));\n\t\t\tif (MSGLen > 0)\n\t\t\t{\t// C# USING: br, buf, inputBlock\n\t\t\t\tBinaryReader^ br = gcnew BinaryReader(gcnew MemoryStream((array<Byte>^)Plaintext, false));\n\t\t\t\tarray<UInt32>^ inputBlock = gcnew array<UInt32>(4);\n\t\t\t\tfor (i = 0; (i + 16) <= MSGLen; i += 16)\n\t\t\t\t{\n\t\t\t\t\tinputBlock[0] = br->ReadUInt32(); inputBlock[1] = br->ReadUInt32();\n\t\t\t\t\tinputBlock[2] = br->ReadUInt32(); inputBlock[3] = br->ReadUInt32();\n\t\t\t\t\tbw->Write(inputBlock[0] ^ state[0][0] ^ state[5] ^ (state[8] & state[12]));\n\t\t\t\t\tbw->Write(inputBlock[1] ^ state[0][1] ^ state[6] ^ (state[9] & state[13]));\n\t\t\t\t\tbw->Write(inputBlock[2] ^ state[0][2] ^ state[7] ^ (state[10] & state[14]));\n\t\t\t\t\tbw->Write(inputBlock[3] ^ state[0][3] ^ state[4] ^ (state[11] & state[15]));\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)inputBlock);\n\t\t\t\t}\n\t\t\t\tArray::Clear(inputBlock, 0, inputBlock->Length);\n\t\t\t\tif (0 != MSGLen % 16)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(MSGLen % 16), 0, inputBlock, 0, MSGLen % 16);\n\t\t\t\t\tarray<UInt32>^ outputBlock = gcnew array<UInt32>(4);\n\t\t\t\t\toutputBlock[0] = inputBlock[0] ^ state[0][0] ^ state[5] ^ (state[8] & state[12]);\n\t\t\t\t\toutputBlock[1] = inputBlock[1] ^ state[0][1] ^ state[6] ^ (state[9] & state[13]);\n\t\t\t\t\toutputBlock[2] = inputBlock[2] ^ state[0][2] ^ state[7] ^ (state[10] & state[14]);\n\t\t\t\t\toutputBlock[3] = inputBlock[3] ^ state[0][3] ^ state[4] ^ (state[11] & state[15]);\n\t\t\t\t\tfor (Byte i = 0; i < MSGLen % 16; i++) // timing attack????\n\t\t\t\t\t\tbw->Write(Buffer::GetByte(outputBlock, i));\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)inputBlock);\n\t\t\t\t\tArray::Clear(inputBlock, 0, 4);\n\t\t\t\t\tstate[0][0] ^= inputBlock[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate[0][0] ^= inputBlock[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t} // end USING\n\n\t\t\t// TAG GENERATION\n\t\t\tMorusCore640::_finalize_state(state, ADLen, MSGLen); // 1280 128 and 256 do this the same way\n\t\t\tbw->Write(state[0][0]);\n\t\t\tbw->Write(state[0][1]);\n\t\t\tbw->Write(state[0][2]);\n\t\t\tbw->Write(state[0][3]);\n\t\t\tbw->Flush();\n\t\t\tbw->Close();\n\t\t\ttry {\n\t\t\t\tArray::Clear(state, 0, state->Length);\n\t\t\t\tstate[0] = gcnew array<UInt32>(1);\n\t\t\t}\n\t\t\tcatch (...) {}\n\t\t\treturn (int)state[0][0]; // should be zero, but used to prevent compiler optimization of Clear\n\t\t}\n\n\t\tstatic int _decrypt(\n\t\t\tarray<const Byte>^ AdditionalData,\n\t\t\tarray<const Byte>^ Ciphertext,\n\t\t\tarray<const Byte>^ Key,\n\t\t\tarray<const Byte>^ Nonce,\n\t\t\tarray<Byte>^% Plaintext)\n\t\t{\n\t\t\tint MSGLen = Ciphertext != nullptr ? Ciphertext->Length - 16 : 16; // full length - tag, or just tag\n\t\t\tif (MSGLen < 0)\n\t\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Ciphertext\", \"Ciphertext cannot be shorter than 16 bytes (length of Tag)\");\n\t\t\tarray<array<UInt32>^>^ state = MorusCore640::_init(Key, Nonce);\n\t\t\tint i;\n\t\t\tint ADLen = AdditionalData != nullptr ? AdditionalData->Length : 0;\n\t\t\tif (ADLen > 0)\n\t\t\t{\t// C# USING: br, buf, NO OUTPUT DURING THIS PHASE! ONLY STATE UPDATES!\n\t\t\t\tBinaryReader^ br = gcnew BinaryReader(gcnew MemoryStream((array<Byte>^)AdditionalData, false));\n\t\t\t\tarray<UInt32>^ buf = gcnew array<UInt32>(4);\n\t\t\t\tfor (i = 0; (i + 16) <= ADLen; i += 16)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(AdditionalData, i, buf, 0, 16);\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)buf);\n\t\t\t\t}\n\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\tif (0 != ADLen % 16)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(AdditionalData, i, buf, 0, ADLen % 16);\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)buf);\n\t\t\t\t\tArray::Clear(buf, 0, buf->Length);\n\t\t\t\t\tstate[0][0] ^= buf[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate[0][0] ^= buf[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t} // end USING\n\t\t\t//array<Byte>^ tempPlaintext = gcnew array<Byte>(MSGLen);\n\t\t\tBinaryReader^ br = gcnew BinaryReader(gcnew MemoryStream((array<Byte>^)Ciphertext, false));\n\t\t\tBinaryWriter^ bw = gcnew BinaryWriter(gcnew MemoryStream(Plaintext, true));\n\t\t\tif (MSGLen > 0)\n\t\t\t{\t// C# USING: buf, inputBlock\n\n\t\t\t\tarray<UInt32>^ inputBlock = gcnew array<UInt32>(4);\n\t\t\t\tarray<UInt32>^ outputBlock = gcnew array<UInt32>(4);\n\t\t\t\tfor (i = 0; (i + 16) <= MSGLen; i += 16)\n\t\t\t\t{\n\t\t\t\t\tinputBlock[0] = br->ReadUInt32(); inputBlock[1] = br->ReadUInt32();\n\t\t\t\t\tinputBlock[2] = br->ReadUInt32(); inputBlock[3] = br->ReadUInt32();\n\t\t\t\t\toutputBlock[0] = inputBlock[0] ^ state[0][0] ^ state[5] ^ (state[8] & state[12]);\n\t\t\t\t\toutputBlock[1] = inputBlock[1] ^ state[0][1] ^ state[6] ^ (state[9] & state[13]);\n\t\t\t\t\toutputBlock[2] = inputBlock[2] ^ state[0][2] ^ state[7] ^ (state[10] & state[14]);\n\t\t\t\t\toutputBlock[3] = inputBlock[3] ^ state[0][3] ^ state[4] ^ (state[11] & state[15]);\n\t\t\t\t\tbw->Write(outputBlock[0]);\n\t\t\t\t\tbw->Write(outputBlock[1]);\n\t\t\t\t\tbw->Write(outputBlock[2]);\n\t\t\t\t\tbw->Write(outputBlock[3]);\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)outputBlock);\n\t\t\t\t}\n\t\t\t\tArray::Clear(inputBlock, 0, inputBlock->Length); // zero out array\n\t\t\t\tArray::Clear(outputBlock, 0, outputBlock->Length); // zero out array\n\t\t\t\tif (0 != MSGLen % 16)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(br->ReadBytes(MSGLen % 16), 0, inputBlock, 0, MSGLen % 16);\n\t\t\t\t\toutputBlock[0] = inputBlock[0] ^ state[0][0] ^ state[5] ^ (state[8] & state[12]);\n\t\t\t\t\toutputBlock[1] = inputBlock[1] ^ state[0][1] ^ state[6] ^ (state[9] & state[13]);\n\t\t\t\t\toutputBlock[2] = inputBlock[2] ^ state[0][2] ^ state[7] ^ (state[10] & state[14]);\n\t\t\t\t\toutputBlock[3] = inputBlock[3] ^ state[0][3] ^ state[4] ^ (state[11] & state[15]);\n\t\t\t\t\tfor (Byte i = 0; i < 16; i++) // timing attack during the IF statement?? analyse to be sure\n\t\t\t\t\t\tif (i < MSGLen % 16)\n\t\t\t\t\t\t\tbw->Write(Buffer::GetByte(outputBlock, i)); // output the partial block as plaintext\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tBuffer::SetByte(outputBlock, i, 0); // recreate the zero whitespace at the end of the plaintext\n\t\t\t\t\tMorusCore640::_updateState(state, (array<const UInt32>^)outputBlock);\n\t\t\t\t\tArray::Clear(inputBlock, 0, inputBlock->Length);\n\t\t\t\t\tArray::Clear(outputBlock, 0, outputBlock->Length);\n\t\t\t\t\tstate[0][0] ^= inputBlock[0] | outputBlock[0]; // does nothing (0), but prevents compiler from optimizing out the previous statement\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate[0][0] ^= inputBlock[3] | outputBlock[3]; // does nothing (0), but prevents compiler from optimizing out the Clear statement \n\t\t\t} // end USING\n\t\t\tbw->Flush();\n\t\t\tbw->Close();\n\t\t\t// TAG GENERATION\n\t\t\tMorusCore640::_finalize_state(state, ADLen, MSGLen); // 1280 128 and 256 do this the same way\n\t\t\tUInt32 a, b, c, d;\n\t\t\ta = br->ReadUInt32();\n\t\t\tb = br->ReadUInt32();\n\t\t\tc = br->ReadUInt32();\n\t\t\td = br->ReadUInt32();\n\t\t\tUInt32 compare = (a ^ state[0][0]) | (b ^ state[0][1]) | (c ^ state[0][2]) | (d ^ state[0][3]);\n\t\t\tfor (Byte i = 0; i < 5; i++) // go through the rows to zero them\n\t\t\t{\n\t\t\t\tArray::Clear(state[i], 0, state[i]->Length); // zero the row\n\t\t\t\tstate[16] |= (state[i][0] | UInt32::MaxValue) + compare;\n\t\t\t}\n\t\t\ttry // try to prevent compiler optimization\n\t\t\t{\n\t\t\t\tArray::Clear(state, 0, state->Length); // blow away the individual row array references\n\t\t\t\tstate[0] = gcnew array<UInt32>{compare | UInt32::MaxValue};\n\t\t\t}\n\t\t\tcatch (...)\n\t\t\t{\n\t\t\t\tSystem::Diagnostics::Debug::Print(\"EXCEPTION!\");\n\t\t\t}\n\t\t\tbr->Close();\n\t\t\tif (compare == 0)\n\t\t\t{\n\t\t\t\t//Plaintext = tempPlaintext;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttry {\n\t\t\t\t\tif (Plaintext != nullptr && Plaintext->Length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tArray::Clear(Plaintext, 0, MSGLen);\n\t\t\t\t\t\t// no matter what, state gets bitwiped to 1 or 0, and then shifted to 0, but this prevents the compiler from optimizing out the Clear\n\t\t\t\t\t\tPlaintext[0] = (Byte)(state[0][0] & (UInt32)compare) >> 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (...)\n\t\t\t\t{\n\t\t\t\t\tSystem::Diagnostics::Debug::Print(\"EXCEPTION!\");\n\t\t\t\t}\n\t\t\t\treturn -1; \n\t\t\t}\n\t\t}*/\n\t}\n}\n#endif // !MORUS_MANAGED_CORE_640\n"
        },
        {
            "file_name": "MorusManaged.cpp",
            "content": "/* ====================================================================================== \n* From the source morusv2.pdf:\n* \n* The Authenticated Cipher MORUS (v2)\n* 15 Sep, 2016\n* Designers: Hongjun Wu, Tao Huang\n* Submitters: Hongjun Wu, Tao Huang\n* Division of Mathematical Sciences\n* Nanyang Technological University, Singapore\n* \n* Section 9:\n* \"MORUS is not patented and it is free of intellectual property restrictions.\"\n* ========================================================================================\n* This implementation taken direct (and modified for .Net C++/CLR) from the reference C\n* implemention by the authors, and is released into the Public Domain under CC(0) License.\n* You should have received a copy of the CC0 Public Domain Dedication along with\n* this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n* Dustin Sparks, March 2019\n* ========================================================================================\n*/\n\n#pragma once\n\n#ifndef MORUS_MANAGED_CPP\n#define MORUS_MANAGED_CPP\n\n#include \"MorusManaged.h\"\n#include \"MorusCore640.cpp\"\n#include \"MorusCore1280.cpp\"\n\nusing namespace System;\nusing namespace System::Runtime::InteropServices;\n\nnamespace MorusManaged\n{\n\tint MorusManaged::Morus_640_128::Encrypt(\n\t\tarray<const Byte>^ AdditionalData,\n\t\tarray<const Byte>^ Plaintext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\t[Out] array<Byte>^% Ciphertext)\n\t{\n\t\t//TODO Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 16 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tMemoryStream^ AD = AdditionalData != nullptr ? gcnew MemoryStream((array<Byte>^)AdditionalData, false) : nullptr;\n\t\tMemoryStream^ P = Plaintext != nullptr ? gcnew MemoryStream((array<Byte>^)Plaintext, false) : nullptr;\n\t\tMemoryStream^ tempCiphertext = gcnew MemoryStream(P != nullptr ? Plaintext->Length + 16 : 16);\n\t\tint result = MorusCore640::_encryptStream(AD, P, Key, Nonce, tempCiphertext, tempCiphertext);\n\t\tif (result == 0) Ciphertext = tempCiphertext->ToArray();\n\t\treturn result;\n\t}\n\n\tint MorusManaged::Morus_640_128::Decrypt(\n\t\tarray<const Byte>^ AdditionalData,\n\t\tarray<const Byte>^ Ciphertext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\t[Out] array<Byte>^% Plaintext)\n\t{\n\t\t//TODO Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 16 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tif (Ciphertext == nullptr || Ciphertext->Length < 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Ciphertext\", \"Ciphertext must at least contain the 16 byte tag and cannot be null.\");\n\t\tint apparentLength = Ciphertext->Length - 16;\n\t\tMemoryStream^ AD = AdditionalData != nullptr ? gcnew MemoryStream((array<Byte>^)AdditionalData, false) : nullptr;\n\t\tMemoryStream^ C = gcnew MemoryStream((array<Byte>^)Ciphertext, false);\n\t\tMemoryStream^ tempPlaintext = gcnew MemoryStream(apparentLength);\n\t\tint result = MorusCore640::_decryptStream(AD, C, nullptr, Key, Nonce, tempPlaintext);\n\t\tif (result == -1) tempPlaintext = nullptr; // already wiped within _decrypt\n\t\tPlaintext = tempPlaintext->ToArray(); // do the assignment method to prevent leakage of partial plaintext before verification!\n\t\treturn result;\n\t}\n\n\tint MorusManaged::Morus_640_128::Encrypt_Detached(\n\t\tarray<const Byte>^ AdditionalData,\n\t\tarray<const Byte>^ Plaintext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\t[Out] array<Byte>^% Ciphertext,\n\t\t[Out] array<Byte>^% Tag)\n\t{\n\t\t//TODO Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 16 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tMemoryStream^ AD = AdditionalData != nullptr ? gcnew MemoryStream((array<Byte>^)AdditionalData, false) : nullptr;\n\t\tMemoryStream^ P = Plaintext != nullptr ? gcnew MemoryStream((array<Byte>^)Plaintext, false) : nullptr;\n\t\tMemoryStream^ tempCiphertext = gcnew MemoryStream(P != nullptr ? Plaintext->Length : 0);\n\t\tMemoryStream^ tempTag = gcnew MemoryStream(16);\n\t\tint result = MorusCore640::_encryptStream(AD, P, Key, Nonce, tempCiphertext, tempTag);\n\t\tif (result == 0)\n\t\t{\n\t\t\tCiphertext = tempCiphertext->ToArray();\n\t\t\tTag = tempTag->ToArray();\n\t\t}\n\t\treturn result;\n\t}\n\n\tint MorusManaged::Morus_640_128::Decrypt_Detached(\n\t\tarray<const Byte>^ AdditionalData,\n\t\tarray<const Byte>^ Ciphertext,\n\t\tarray<const Byte>^ Tag,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\t[Out] array<Byte>^% Plaintext)\n\t{\n\t\t//TODO Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 16 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tif (Tag == nullptr || Tag->Length < 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Tag\", \"Must at least contain the 16-byte tag (cannot be null).\");\n\t\tMemoryStream^ AD = AdditionalData != nullptr ? gcnew MemoryStream((array<Byte>^)AdditionalData, false) : nullptr;\n\t\tMemoryStream^ C = Ciphertext != nullptr ? gcnew MemoryStream((array<Byte>^)Ciphertext, false) : nullptr;\n\t\tMemoryStream^ T = gcnew MemoryStream((array<Byte>^)Tag, false);\n\t\tMemoryStream^ tempPlaintext = gcnew MemoryStream(C != nullptr ? Ciphertext->Length : 0);\n\t\tint result = MorusCore640::_decryptStream(AD, C, T, Key, Nonce, tempPlaintext);\n\t\tif (result == 0) Plaintext = tempPlaintext->ToArray(); // do the assignment method to prevent leakage of partial plaintext before verification!\n\t\treturn result;\n\t}\n\n\tint MorusManaged::Morus_640_128::EncryptStream(\n\t\tMemoryStream^ AdditionalData,\n\t\tMemoryStream^ Plaintext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tMemoryStream^ Ciphertext)\n\t{\n\t\t//TODO  Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 16 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tif (!Ciphertext->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Ciphertext MemoryStream is READ ONLY. Operation aborted.\");\n\t\treturn MorusCore640::_encryptStream(AdditionalData, Plaintext, Key, Nonce, Ciphertext, Ciphertext); // write tag to same stream\n\t}\n\n\tint MorusManaged::Morus_640_128::DecryptStream(\n\t\tMemoryStream^ AdditionalData,\n\t\tMemoryStream^ Ciphertext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tMemoryStream^ Plaintext)\n\t{\n\t\t//TODO Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 16 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tif (Ciphertext == nullptr || Ciphertext->Length < 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Ciphertext\", \"Ciphertext Stream must at least contain the 16 byte tag and cannot be null.\");\n\t\tif (!Plaintext->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Plaintext MemoryStream is READ ONLY. Operation aborted.\");\n\t\treturn MorusCore640::_decryptStream(AdditionalData, Ciphertext, nullptr, Key, Nonce, Plaintext); // read tag from same stream\n\t}\n\n\t// the only different between 1280128 and 1280256 are the Guard Clauses (and then in only one regard), and the initialization\n\t// (which is handled in that function, otherwise the two are identical!)\n\tint MorusManaged::Morus_1280_128::Encrypt(\n\t\tarray<const Byte>^ AdditionalData,\n\t\tarray<const Byte>^ Plaintext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\t[Out] array<Byte>^% Ciphertext)\n\t{\n\t\t//TODO Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 16 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tMemoryStream^ AD = AdditionalData != nullptr ? gcnew MemoryStream((array<Byte>^)AdditionalData, false) : nullptr;\n\t\tMemoryStream^ P = Plaintext != nullptr ? gcnew MemoryStream((array<Byte>^)Plaintext, false) : nullptr;\n\t\tMemoryStream^ tempCiphertext = gcnew MemoryStream(P != nullptr ? Plaintext->Length + 16 : 16);\n\t\tint result = MorusCore1280::_encryptStream(AD, P, Key, Nonce, tempCiphertext, tempCiphertext);\n\t\tif (result == 0) Ciphertext = tempCiphertext->ToArray();\n\t\treturn result;\n\t}\n\t   \n\tint MorusManaged::Morus_1280_128::Decrypt(\n\t\tarray<const Byte>^ AdditionalData,\n\t\tarray<const Byte>^ Ciphertext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\t[Out] array<Byte>^% Plaintext)\n\t{\n\t\t//TODO Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 16 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tif (Ciphertext == nullptr || Ciphertext->Length < 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Ciphertext\", \"Ciphertext must at least contain the 16 byte tag and cannot be null.\");\n\t\tMemoryStream^ AD = AdditionalData != nullptr ? gcnew MemoryStream((array<Byte>^)AdditionalData, false) : nullptr;\n\t\tMemoryStream^ C = gcnew MemoryStream((array<Byte>^)Ciphertext, false);\n\t\tMemoryStream^ tempPlaintext = gcnew MemoryStream(Ciphertext->Length - 16);\n\t\tint result = MorusCore1280::_decryptStream(AD, C, nullptr, Key, Nonce, tempPlaintext);\n\t\tif (result == 0) Plaintext = tempPlaintext->ToArray();\n\t\treturn result;\n\t}\n\n\tint MorusManaged::Morus_1280_128::Encrypt_Detached(\n\t\tarray<const Byte>^ AdditionalData,\n\t\tarray<const Byte>^ Plaintext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\t[Out] array<Byte>^% Ciphertext,\n\t\t[Out] array<Byte>^% Tag)\n\t{\n\t\t//TODO Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 16 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tMemoryStream^ AD = AdditionalData != nullptr ? gcnew MemoryStream((array<Byte>^)AdditionalData, false) : nullptr;\n\t\tMemoryStream^ P = Plaintext != nullptr ? gcnew MemoryStream((array<Byte>^)Plaintext, false) : nullptr;\n\t\tMemoryStream^ tempCiphertext = gcnew MemoryStream(P != nullptr ? Plaintext->Length : 0);\n\t\tMemoryStream^ tempTag = gcnew MemoryStream(16);\n\t\tint result = MorusCore1280::_encryptStream(AD, P, Key, Nonce, tempCiphertext, tempTag);\n\t\tif (result == 0)\n\t\t{\n\t\t\tCiphertext = tempCiphertext->ToArray();\n\t\t\tTag = tempTag->ToArray();\n\t\t}\n\t\treturn result;\n\t}\n\n\tint MorusManaged::Morus_1280_128::Decrypt_Detached(\n\t\tarray<const Byte>^ AdditionalData,\n\t\tarray<const Byte>^ Ciphertext,\n\t\tarray<const Byte>^ Tag,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\t[Out] array<Byte>^% Plaintext)\n\t{\n\t\t//TODO Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 16 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tif (Tag == nullptr || Tag->Length < 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Tag\", \"Must at least contain the 16-byte tag (cannot be null).\");\n\t\tMemoryStream^ AD = AdditionalData != nullptr ? gcnew MemoryStream((array<Byte>^)AdditionalData, false) : nullptr;\n\t\tMemoryStream^ C = Ciphertext != nullptr ? gcnew MemoryStream((array<Byte>^)Ciphertext, false) : nullptr;\n\t\tMemoryStream^ T = gcnew MemoryStream((array<Byte>^)Tag, false);\n\t\tMemoryStream^ tempPlaintext = gcnew MemoryStream(C != nullptr ? C->Length : 0);\n\t\tint result = MorusCore1280::_decryptStream(AD, C, T, Key, Nonce, tempPlaintext);\n\t\tif (result == 0) Plaintext = tempPlaintext->ToArray(); // do the assignment method to prevent leakage of partial plaintext before verification!\n\t\treturn result;\n\t}\n\n\tint MorusManaged::Morus_1280_128::EncryptStream(\n\t\tMemoryStream^ AdditionalData,\n\t\tMemoryStream^ Plaintext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tMemoryStream^ Ciphertext)\n\t{\n\t\t//TODO  Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 16 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tif (!Ciphertext->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Ciphertext MemoryStream is READ ONLY. Operation aborted.\");\n\t\treturn MorusCore1280::_encryptStream(AdditionalData, Plaintext, Key, Nonce, Ciphertext, Ciphertext); // write tag to same stream\n\t}\n\n\tint MorusManaged::Morus_1280_128::DecryptStream(\n\t\tMemoryStream^ AdditionalData,\n\t\tMemoryStream^ Ciphertext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tMemoryStream^ Plaintext)\n\t{\n\t\t//TODO Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 16 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tif (Ciphertext == nullptr || Ciphertext->Length < 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Ciphertext\", \"Ciphertext Stream must at least contain the 16 byte tag and cannot be null.\");\n\t\tif (!Plaintext->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Plaintext MemoryStream is READ ONLY. Operation aborted.\");\n\t\treturn MorusCore1280::_decryptStream(AdditionalData, Ciphertext, nullptr, Key, Nonce, Plaintext); // read tag from same stream\n\t}\n\n\t// 1280_256\n\n\tint MorusManaged::Morus_1280_256::Encrypt(\n\t\tarray<const Byte>^ AdditionalData,\n\t\tarray<const Byte>^ Plaintext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\t[Out] array<Byte>^% Ciphertext)\n\t{\n\t\t//TODO  Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 32)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 32 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tMemoryStream^ AD = AdditionalData != nullptr ? gcnew MemoryStream((array<Byte>^)AdditionalData, false) : nullptr;\n\t\tMemoryStream^ P = Plaintext != nullptr ? gcnew MemoryStream((array<Byte>^)Plaintext, false) : nullptr;\n\t\tMemoryStream^ tempCiphertext = gcnew MemoryStream(P != nullptr ? Plaintext->Length : 16);\n\t\tint result = MorusCore1280::_encryptStream(AD, P, Key, Nonce, tempCiphertext, tempCiphertext);\n\t\tif (result == 0) Ciphertext = tempCiphertext->ToArray();\n\t\treturn result;\n\t}\n\n\tint MorusManaged::Morus_1280_256::Decrypt(\n\t\tarray<const Byte>^ AdditionalData,\n\t\tarray<const Byte>^ Ciphertext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\t[Out] array<Byte>^% Plaintext)\n\t{\n\t\t//TODO Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 32)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 32 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tif (Ciphertext == nullptr || Ciphertext->Length < 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Ciphertext\", \"Ciphertext must at least contain the 16 byte tag and cannot be null.\");\n\t\tMemoryStream^ AD = AdditionalData != nullptr ? gcnew MemoryStream((array<Byte>^)AdditionalData, false) : nullptr;\n\t\tMemoryStream^ C = gcnew MemoryStream((array<Byte>^)Ciphertext, false);\n\t\tMemoryStream^ tempPlaintext = gcnew MemoryStream(C->Length - 16);\n\t\tint result = MorusCore1280::_decryptStream(AD, C, nullptr, Key, Nonce, tempPlaintext);\n\t\tif (result == 0) Plaintext = tempPlaintext->ToArray();\n\t\treturn result;\n\t}\n\n\tint MorusManaged::Morus_1280_256::Encrypt_Detached(\n\t\tarray<const Byte>^ AdditionalData,\n\t\tarray<const Byte>^ Plaintext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\t[Out] array<Byte>^% Ciphertext,\n\t\t[Out] array<Byte>^% Tag)\n\t{\n\t\t//TODO Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 32)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 32 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tMemoryStream^ AD = AdditionalData != nullptr ? gcnew MemoryStream((array<Byte>^)AdditionalData, false) : nullptr;\n\t\tMemoryStream^ P = Plaintext != nullptr ? gcnew MemoryStream((array<Byte>^)Plaintext, false) : nullptr;\n\t\tMemoryStream^ tempCiphertext = gcnew MemoryStream(P != nullptr ? Plaintext->Length : 0);\n\t\tMemoryStream^ tempTag = gcnew MemoryStream(16);\n\t\tint result = MorusCore1280::_encryptStream(AD, P, Key, Nonce, tempCiphertext, tempTag);\n\t\tif (result == 0)\n\t\t{\n\t\t\tCiphertext = tempCiphertext->ToArray();\n\t\t\tTag = tempTag->ToArray();\n\t\t}\n\t\treturn result;\n\t}\n\n\tint MorusManaged::Morus_1280_256::Decrypt_Detached(\n\t\tarray<const Byte>^ AdditionalData,\n\t\tarray<const Byte>^ Ciphertext,\n\t\tarray<const Byte>^ Tag,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\t[Out] array<Byte>^% Plaintext)\n\t{\n\t\t//TODO Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 32)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 32 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tif (Tag == nullptr || Tag->Length < 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Tag\", \"Must at least contain the 16-byte tag (cannot be null).\");\n\t\tMemoryStream^ AD = AdditionalData != nullptr ? gcnew MemoryStream((array<Byte>^)AdditionalData, false) : nullptr;\n\t\tMemoryStream^ C = Ciphertext != nullptr ? gcnew MemoryStream((array<Byte>^)Ciphertext, false) : nullptr;\n\t\tMemoryStream^ T = gcnew MemoryStream((array<Byte>^)Tag, false);\n\t\tMemoryStream^ tempPlaintext = gcnew MemoryStream(C != nullptr ? C->Length : 0);\n\t\tint result = MorusCore1280::_decryptStream(AD, C, T, Key, Nonce, tempPlaintext);\n\t\tif (result == 0) Plaintext = tempPlaintext->ToArray(); // do the assignment method to prevent leakage of partial plaintext before verification!\n\t\treturn result;\n\t}\n\n\tint MorusManaged::Morus_1280_256::EncryptStream(\n\t\tMemoryStream^ AdditionalData,\n\t\tMemoryStream^ Plaintext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tMemoryStream^ Ciphertext)\n\t{\n\t\t//TODO  Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 32)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 32 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tif (!Ciphertext->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Ciphertext MemoryStream is READ ONLY. Operation aborted.\");\n\t\treturn MorusCore1280::_encryptStream(AdditionalData, Plaintext, Key, Nonce, Ciphertext, Ciphertext); // write tag to same stream\n\t}\n\n\tint MorusManaged::Morus_1280_256::DecryptStream(\n\t\tMemoryStream^ AdditionalData,\n\t\tMemoryStream^ Ciphertext,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tMemoryStream^ Plaintext)\n\t{\n\t\t//TODO Gaurd clauses!\n\t\tif (Key == nullptr || Key->Length != 32)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Key\", \"Key must not be null and be 32 bytes in length.\");\n\t\tif (Nonce == nullptr || Nonce->Length != 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Nonce\", \"Nonce must not be null and be 16 bytes in length.\");\n\t\tif (Ciphertext == nullptr || Ciphertext->Length < 16)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Ciphertext\", \"Ciphertext Stream must at least contain the 16 byte tag and cannot be null.\");\n\t\tif (!Plaintext->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Plaintext MemoryStream is READ ONLY. Operation aborted.\");\n\t\treturn MorusCore1280::_decryptStream(AdditionalData, Ciphertext, nullptr, Key, Nonce, Plaintext); // read tag from same stream\n\t}\n}\n\n#endif // !MORUS_MANAGED_CPP"
        },
        {
            "file_name": "Multi.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"MultiBase.h\"\n#include \"CSPRNG.h\"\n\n#include \"Multi_data.h\"\n\nvoid BlockXor(BYTE *data,const BYTE *value)\n{\n\t#if\tDATA_BLOCK_SIZE==16\n\t*((DWORD *) (data+ 0))\t^=*((DWORD *) (value+ 0));\n\t*((DWORD *) (data+ 4))\t^=*((DWORD *) (value+ 4));\n\t*((DWORD *) (data+ 8))\t^=*((DWORD *) (value+ 8));\n\t*((DWORD *) (data+12))\t^=*((DWORD *) (value+12));\n\t#else\n\t#error\n\t#endif\n}\n\nvoid Multi_setkey(MULTI_DATA *pMd,const BYTE *iv,const BYTE *passw1,const BYTE *passw2,DWORD nonce)\n{\n\tBYTE\t\tpassw[MAX_ALG][MAX_PASSW_SIZE];\n\tBYTE\t\tusedMap[MAX_ALG];\n\tDWORD\t\tindex;\n\n\tmemset(pMd,0,sizeof(MULTI_DATA));\n\n\t// CSPRNG <- Skein512(passw2 + nonce)\n\tCSPRNG_set_seed(&pMd->cd,SKEIN512_HASH,passw2,nonce);\n\n\t// IVs\n\tmemcpy(pMd->iv[0],iv,MAX_ALG*DATA_BLOCK_SIZE);\n\n\t// passw[] <- KDF4 : random ( hash( passw1 + nonce) )\n\tfor(index=0;index<MAX_HASH;index++)\n\t\t{\n\t\tDWORD\tpIndex;\n\n\t\tCSPRNG_DATA\ttmpCSPRNG;\n\n\t\tswitch(index)\n\t\t\t{\n\t\t\tcase 0:\tCSPRNG_set_seed(&tmpCSPRNG,SHA512_HASH,passw1,nonce); break;\n\t\t\tcase 1:\tCSPRNG_set_seed(&tmpCSPRNG,GROSTL512_HASH,passw1,nonce); break;\n\t\t\tcase 2:\tCSPRNG_set_seed(&tmpCSPRNG,KECCAK512_HASH,passw1,nonce); break;\n\t\t\tcase 3:\tCSPRNG_set_seed(&tmpCSPRNG,SKEIN512_HASH,passw1,nonce); break;\n\t\t\t}\n\n\t\tfor(pIndex=0;pIndex<(MAX_ALG/MAX_HASH);pIndex++)\n\t\t\t{\n\t\t\tDWORD\tsIndex;\n\n\t\t\tfor(sIndex=0;sIndex<MAX_PASSW_SIZE;sIndex++)\n\t\t\t\t{ passw[(index*(MAX_ALG/MAX_HASH))+pIndex][sIndex]=CSPRNG_get_byte(&tmpCSPRNG); }\n\t\t\t}\n\t\t}\n\n\tCSPRNG_array_init(&pMd->cd,MAX_ALG,usedMap);\n\n\t// subcipher setup\n\tMulti_single_setkey(&pMd->msd,ANUBIS_ALG,\t\tpassw[usedMap[ 0]]);\n\tMulti_single_setkey(&pMd->msd,CAMELLIA_ALG,\t\tpassw[usedMap[ 1]]);\n\tMulti_single_setkey(&pMd->msd,CAST256_ALG,\t\tpassw[usedMap[ 2]]);\n\tMulti_single_setkey(&pMd->msd,CLEFIA_ALG,\t\tpassw[usedMap[ 3]]);\n\tMulti_single_setkey(&pMd->msd,FROG_ALG,\t\t\tpassw[usedMap[ 4]]);\n\tMulti_single_setkey(&pMd->msd,HIEROCRYPT3_ALG,\tpassw[usedMap[ 5]]);\n\tMulti_single_setkey(&pMd->msd,IDEANXT128_ALG,\tpassw[usedMap[ 6]]);\n\tMulti_single_setkey(&pMd->msd,MARS_ALG,\t\t\tpassw[usedMap[ 7]]);\n\tMulti_single_setkey(&pMd->msd,RC6_ALG,\t\t\tpassw[usedMap[ 8]]);\n\tMulti_single_setkey(&pMd->msd,RIJNDAEL_ALG,\t\tpassw[usedMap[ 9]]);\n\tMulti_single_setkey(&pMd->msd,SAFERP_ALG,\t\tpassw[usedMap[10]]);\n\tMulti_single_setkey(&pMd->msd,SC2000_ALG,\t\tpassw[usedMap[11]]);\n\tMulti_single_setkey(&pMd->msd,SERPENT_ALG,\t\tpassw[usedMap[12]]);\n\tMulti_single_setkey(&pMd->msd,SPEED_ALG,\t\tpassw[usedMap[13]]);\n\tMulti_single_setkey(&pMd->msd,TWOFISH_ALG,\t\tpassw[usedMap[14]]);\n\tMulti_single_setkey(&pMd->msd,UNICORNA_ALG,\t\tpassw[usedMap[15]]);\n}\n\n#define\tREFRESH_COUNTDOWN\t100\n\nOBFUNC_RETV Multi_CBC_encrypt(MULTI_DATA *pMd,const DWORD len,BYTE *buf,perc_callback_t pFunc,void *pDesc,test_callback_t tFunc,void *tDesc)\n{\n\tDWORD\ttLen=len;\n\tBYTE\tlastPerc=0;\n\tWORD\trefCount=REFRESH_COUNTDOWN;\n\n\twhile(tLen>=DATA_BLOCK_SIZE)\n\t\t{\n\t\tBYTE\ttmpIN[DATA_BLOCK_SIZE];\n\t\tBYTE\tcurAlg=CSPRNG_get_byte(&pMd->cd)%MAX_ALG;\n\n\t\t// OUT = encrypt( IN ^ IV_or_previous_out_block )\n\t\tmemcpy(tmpIN,buf,DATA_BLOCK_SIZE);\n\t\tBlockXor(tmpIN,pMd->iv[curAlg]);\n\n\t\tMulti_ECB_single_encrypt(&pMd->msd,(ENUM_ALG) curAlg,tmpIN,buf);\n\n\t\tmemcpy(pMd->iv[curAlg],buf,DATA_BLOCK_SIZE);\n\n\t\tbuf+=DATA_BLOCK_SIZE;\n\t\ttLen-=DATA_BLOCK_SIZE;\n\n\t\tif(!refCount)\n\t\t\t{\n\t\t\trefCount=REFRESH_COUNTDOWN;\n\n\t\t\tif(pFunc)\n\t\t\t\t{\n\t\t\t\tBYTE\ttmp=(BYTE) ((((float) (len-tLen))/((float) len))*((float) 100));\n\t\t\t\tif(tmp>lastPerc)\n\t\t\t\t\t{\n\t\t\t\t\tlastPerc=tmp;\n\t\t\t\t\tpFunc(pDesc,lastPerc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(tFunc&&tFunc(tDesc))\n\t\t\t\t{ return(OBFUNC_STOP); }\n\t\t\t}\n\n\t\trefCount--;\n\t\t}\n\n\treturn(OBFUNC_OK);\n}\n\nOBFUNC_RETV Multi_CBC_decrypt(MULTI_DATA *pMd,const DWORD len,BYTE *buf,perc_callback_t pFunc,void *pDesc,test_callback_t tFunc,void *tDesc)\n{\n\tDWORD\ttLen=len;\n\tBYTE\tlastPerc=0;\n\tWORD\trefCount=REFRESH_COUNTDOWN;\n\n\twhile(tLen>=DATA_BLOCK_SIZE)\n\t\t{\n\t\tBYTE\ttmpOUT[DATA_BLOCK_SIZE];\n\t\tBYTE\tcurAlg=CSPRNG_get_byte(&pMd->cd)%MAX_ALG;\n\n\t\t// OUT = decrypt( IN ) ^ IV_or_previous_in_block )\n\t\tMulti_ECB_single_decrypt(&pMd->msd,(ENUM_ALG) curAlg,buf,tmpOUT);\n\n\t\tBlockXor(tmpOUT,pMd->iv[curAlg]);\n\t\tmemcpy(pMd->iv[curAlg],buf,DATA_BLOCK_SIZE);\n\t\tmemcpy(buf,tmpOUT,DATA_BLOCK_SIZE);\n\n\t\tbuf+=DATA_BLOCK_SIZE;\n\t\ttLen-=DATA_BLOCK_SIZE;\n\n\t\tif(!refCount)\n\t\t\t{\n\t\t\trefCount=REFRESH_COUNTDOWN;\n\n\t\t\tif(pFunc)\n\t\t\t\t{\n\t\t\t\tBYTE\ttmp=(BYTE) ((((float) (len-tLen))/((float) len))*((float) 100));\n\t\t\t\tif(tmp>lastPerc)\n\t\t\t\t\t{\n\t\t\t\t\tlastPerc=tmp;\n\t\t\t\t\tpFunc(pDesc,lastPerc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(tFunc&&tFunc(tDesc))\n\t\t\t\t{ return(OBFUNC_STOP); }\n\t\t\t}\n\n\t\trefCount--;\n\t\t}\n\n\treturn(OBFUNC_OK);\n}\n"
        },
        {
            "file_name": "MultiBase.cpp",
            "content": "#include \"stdafx.h\"\n#include \"CommonDef.h\"\n\n#include \"Anubis.h\"\n#include \"Camellia.h\"\n#include \"Cast256.h\"\n#include \"Clefia.h\"\n#include \"Frog.h\"\n#include \"Hierocrypt3.h\"\n#include \"Idea_nxt128.h\"\n#include \"Mars.h\"\n#include \"Rc6.h\"\n#include \"Rijndael.h\"\n#include \"Saferp.h\"\n#include \"Sc2000.h\"\n#include \"Serpent.h\"\n#include \"Sha512.h\"\n#include \"Speed.h\"\n#include \"Twofish.h\"\n#include \"Unicorn-A.h\"\n\n#include \"MultiBase_data.h\"\n\nvoid Multi_single_setkey(MULTI_STATIC_DATA *pMsd,const ENUM_ALG curAlg,const BYTE *passw)\n{\n\tswitch(curAlg)\n\t\t{\n\t\tcase ANUBIS_ALG:\n\t\t\tmemset(&pMsd->anubis,0,sizeof(ANUBIS_STATIC_DATA));\n\t\t\tAnubis_set_key(&pMsd->anubis.key,passw);\n\t\t\tbreak;\n\t\n\t\tcase CAMELLIA_ALG:\n\t\t\tmemset(&pMsd->camellia,0,sizeof(CAMELLIA_STATIC_DATA));\n\t\t\tCamellia_set_key(pMsd->camellia.key,MAX_PASSW_SIZE<<3,passw);\n\t\t\tbreak;\n\n\t\tcase CAST256_ALG:\n\t\t\tmemset(&pMsd->cast256,0,sizeof(CAST256_STATIC_DATA));\n\t\t\tCast256_set_key(pMsd->cast256.key,(DWORD *) passw,MAX_PASSW_SIZE<<3);\n\t\t\tbreak;\n\n\t\tcase CLEFIA_ALG:\n\t\t\tmemset(&pMsd->clefia,0,sizeof(CLEFIA_STATIC_DATA));\n\t\t\tClefia_set_key(&pMsd->clefia.key,passw,MAX_PASSW_SIZE<<3);\n\t\t\tbreak;\n\n\t\tcase FROG_ALG:\n\t\t\tmemset(&pMsd->frog,0,sizeof(FROG_STATIC_DATA));\n\t\t\tFrog_set_key(&pMsd->frog.key,(DWORD *) passw,MAX_PASSW_SIZE<<3);\n\t\t\tbreak;\n\n\t\tcase HIEROCRYPT3_ALG:\n\t\t\tmemset(&pMsd->hc3,0,sizeof(HIEROCRYPT3_STATIC_DATA));\n\t\t\tHierocrypt3_set_key(&pMsd->hc3.key,passw);\n\t\t\tbreak;\n\n\t\tcase IDEANXT128_ALG:\n\t\t\tmemset(&pMsd->ideanxt128,0,sizeof(IDEANXT128_STATIC_DATA));\n\t\t\tIdeanxt128_set_key(&pMsd->ideanxt128.key,passw,MAX_PASSW_SIZE<<3);\n\t\t\tbreak;\n\n\t\tcase MARS_ALG:\n\t\t\tmemset(&pMsd->mars,0,sizeof(MARS_STATIC_DATA));\n\n\t\t\tpMsd->mars.vk[0]=0x09d0c479;\n\t\t\tpMsd->mars.vk[1]=0x28c8ffe0;\n\t\t\tpMsd->mars.vk[2]=0x84aa6c39;\n\t\t\tpMsd->mars.vk[3]=0x9dad7287;\n\t\t\tpMsd->mars.vk[4]=0x7dff9be3;\n\t\t\tpMsd->mars.vk[5]=0xd4268361;\n\t\t\tpMsd->mars.vk[6]=0xc96da1d4;\n\n\t\t\tMars_set_key(pMsd->mars.key,pMsd->mars.vk,(DWORD *) passw,MAX_PASSW_SIZE<<3);\n\t\t\tbreak;\n\n\t\tcase RC6_ALG:\n\t\t\tmemset(&pMsd->rc6,0,sizeof(RC6_STATIC_DATA));\n\t\t\tRc6_set_key(pMsd->rc6.key,(DWORD *) passw,MAX_PASSW_SIZE<<3);\n\t\t\tbreak;\n\n\t\tcase RIJNDAEL_ALG:\n\t\t\tmemset(&pMsd->rijndael_enc,0,sizeof(RIJNDAEL_STATIC_DATA));\n\t\t\tmemset(&pMsd->rijndael_dec,0,sizeof(RIJNDAEL_STATIC_DATA));\n\t\t\tpMsd->rijndael_enc.nrounds=Rijndael_set_key_encrypt(pMsd->rijndael_enc.key,passw,MAX_PASSW_SIZE<<3);\n\t\t\t\n\t\t\tpMsd->rijndael_dec.nrounds=Rijndael_set_key_decrypt(pMsd->rijndael_dec.key,passw,MAX_PASSW_SIZE<<3);\n\t\t\tbreak;\n\n\t\tcase SAFERP_ALG:\n\t\t\tmemset(&pMsd->saferp,0,sizeof(SAFERP_STATIC_DATA));\n\t\t\tSaferp_set_key(&pMsd->saferp.key,(DWORD *) passw,MAX_PASSW_SIZE<<3);\n\t\t\tbreak;\n\n\t\tcase SC2000_ALG:\n\t\t\tmemset(&pMsd->sc2000,0,sizeof(SC2000_STATIC_DATA));\n\t\t\tSc2000_set_key(pMsd->sc2000.key,(DWORD *) passw);\n\t\t\tbreak;\n\n\t\tcase SERPENT_ALG:\n\t\t\tmemset(&pMsd->serpent,0,sizeof(SERPENT_STATIC_DATA));\n\t\t\tSerpent_set_key(pMsd->serpent.key,(DWORD *) passw,MAX_PASSW_SIZE<<3);\n\t\t\tbreak;\n\n\t\tcase SPEED_ALG:\n\t\t\tmemset(&pMsd->speed,0,sizeof(SPEED_STATIC_DATA));\n\t\t\tSpeed_set_key(pMsd->speed.key,passw);\n\t\t\tbreak;\n\n\t\tcase TWOFISH_ALG:\n\t\t\tmemset(&pMsd->twofish,0,sizeof(TWOFISH_STATIC_DATA));\n\t\t\tTwofish_set_key(&pMsd->twofish.key,(DWORD *) passw,MAX_PASSW_SIZE<<3);\n\t\t\tbreak;\n\n\t\tcase UNICORNA_ALG:\n\t\t\tmemset(&pMsd->unicorn,0,sizeof(UNICORNA_STATIC_DATA));\n\t\t\tUnicorn_set_key(pMsd->unicorn.key,passw);\n\t\t\tbreak;\n\t\t}\n}\n\nvoid Multi_ECB_single_encrypt(const MULTI_STATIC_DATA *pMsd,const ENUM_ALG curAlg,const BYTE *inBuf,BYTE *outBuf)\n{\n\tswitch(curAlg)\n\t\t{\n\t\tcase ANUBIS_ALG:\t\tAnubis_encrypt(&pMsd->anubis.key,inBuf,outBuf); break;\n\t\tcase CAMELLIA_ALG:\t\tCamellia_encrypt(pMsd->camellia.key,MAX_PASSW_SIZE<<3,inBuf,outBuf); break;\n\t\tcase CAST256_ALG:\t\tCast256_encrypt(pMsd->cast256.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase CLEFIA_ALG:\t\tClefia_encrypt(&pMsd->clefia.key,inBuf,outBuf); break;\n\t\tcase FROG_ALG:\t\t\tFrog_encrypt(&pMsd->frog.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase HIEROCRYPT3_ALG:\tHierocrypt3_encrypt(&pMsd->hc3.key,inBuf,outBuf); break;\n\t\tcase IDEANXT128_ALG:\tIdeanxt128_encrypt(&pMsd->ideanxt128.key,inBuf,outBuf); break;\n\t\tcase MARS_ALG:\t\t\tMars_encrypt(pMsd->mars.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase RC6_ALG:\t\t\tRc6_encrypt(pMsd->rc6.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase RIJNDAEL_ALG:\t\tRijndael_encrypt(pMsd->rijndael_enc.key,pMsd->rijndael_enc.nrounds,inBuf,outBuf); break;\n\t\tcase SAFERP_ALG:\t\tSaferp_encrypt(&pMsd->saferp.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase SC2000_ALG:\t\tSc2000_encrypt(pMsd->sc2000.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase SERPENT_ALG:\t\tSerpent_encrypt(pMsd->serpent.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase SPEED_ALG:\t\t\tSpeed_encrypt(pMsd->speed.key,inBuf,outBuf); break;\n\t\tcase TWOFISH_ALG:\t\tTwofish_encrypt(&pMsd->twofish.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase UNICORNA_ALG:\t\tUnicorn_encrypt(pMsd->unicorn.key,inBuf,outBuf); break;\n\t\t}\n}\n\nvoid Multi_ECB_single_decrypt(const MULTI_STATIC_DATA *pMsd,const ENUM_ALG curAlg,const BYTE *inBuf,BYTE *outBuf)\n{\n\tswitch(curAlg)\n\t\t{\n\t\tcase ANUBIS_ALG:\t\tAnubis_decrypt(&pMsd->anubis.key,inBuf,outBuf); break;\n\t\tcase CAMELLIA_ALG:\t\tCamellia_decrypt(pMsd->camellia.key,MAX_PASSW_SIZE<<3,inBuf,outBuf); break;\n\t\tcase CAST256_ALG:\t\tCast256_decrypt(pMsd->cast256.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase CLEFIA_ALG:\t\tClefia_decrypt(&pMsd->clefia.key,inBuf,outBuf); break;\n\t\tcase FROG_ALG:\t\t\tFrog_decrypt(&pMsd->frog.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase HIEROCRYPT3_ALG:\tHierocrypt3_decrypt(&pMsd->hc3.key,inBuf,outBuf); break;\n\t\tcase IDEANXT128_ALG:\tIdeanxt128_decrypt(&pMsd->ideanxt128.key,inBuf,outBuf); break;\n\t\tcase MARS_ALG:\t\t\tMars_decrypt(pMsd->mars.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase RC6_ALG:\t\t\tRc6_decrypt(pMsd->rc6.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase RIJNDAEL_ALG:\t\tRijndael_decrypt(pMsd->rijndael_dec.key,pMsd->rijndael_dec.nrounds,inBuf,outBuf); break;\n\t\tcase SAFERP_ALG:\t\tSaferp_decrypt(&pMsd->saferp.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase SC2000_ALG:\t\tSc2000_decrypt(pMsd->sc2000.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase SERPENT_ALG:\t\tSerpent_decrypt(pMsd->serpent.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase SPEED_ALG:\t\t\tSpeed_decrypt(pMsd->speed.key,inBuf,outBuf); break;\n\t\tcase TWOFISH_ALG:\t\tTwofish_decrypt(&pMsd->twofish.key,(DWORD *) inBuf,(DWORD *) outBuf); break;\n\t\tcase UNICORNA_ALG:\t\tUnicorn_decrypt(pMsd->unicorn.key,inBuf,outBuf); break;\n\t\t}\n}\n"
        },
        {
            "file_name": "norx6461v1_norx.cpp",
            "content": "/*\n   NORX reference source code package - reference C implementations\n\n   Written in 2014 by Samuel Neves <sneves@dei.uc.pt> and Philipp Jovanovic\n   <jovanovic@fim.uni-passau.de>\n\n   To the extent possible under law, the author(s) have dedicated all copyright\n   and related and neighboring rights to this software to the public domain\n   worldwide. This software is distributed without any warranty.\n\n   You should have received a copy of the CC0 Public Domain Dedication along with\n   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#if defined(NORX_DEBUG)\n#include <stdio.h>\n#include <inttypes.h>\n#endif\n\n#include \"norx6461v1_norx_util.h\"\n#include \"norx6461v1_norx.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Norx6461v1_raw {\nint numRounds = -1;\n\n\n#define NORX_N (NORX_W *  2)   /* Nonce size */\n#define NORX_K (NORX_W *  4)   /* Key size */\n#define NORX_B (NORX_W * 16)   /* Permutation width */\n#define NORX_C (NORX_W *  6)   /* Capacity */\n#define RATE (NORX_B - NORX_C) /* To avoid clashing with rounds... */\n\n#if   NORX_W == 64 /* NORX-64 specific */\n\n    #define LOAD load64\n    #define STORE store64\n\n    /* Rotation constants */\n    #define R0  8\n    #define R1 19\n    #define R2 40\n    #define R3 63\n\n    /* Initialization constants */\n    static const norx_word_t norx_ui[4] =\n    {\n      0x243F6A8885A308D3, 0x13198A2E03707344,\n      0xA4093822299F31D0, 0x082EFA98EC4E6C89,\n    };\n\n    #if defined(NORX_DEBUG)\n        #define NORX_FMT \"016\" PRIX64\n    #endif\n\n#elif NORX_W == 32 /* NORX-32 specific */\n\n    #define LOAD load32\n    #define STORE store32\n\n    /* Rotation constants */\n    #define R0  8\n    #define R1 11\n    #define R2 16\n    #define R3 31\n\n    /* Initialization constants */\n    static const norx_word_t norx_ui[4] =\n    {\n       0x243F6A88, 0x85A308D3,\n       0x13198A2E, 0x03707344\n    };\n\n    #if defined(NORX_DEBUG)\n        #define NORX_FMT \"08\" PRIX32\n    #endif\n\n#else\n    #error \"Invalid word size!\"\n#endif\n\n#if defined(NORX_DEBUG)\nstatic void norx_print_state(norx_state_t state)\n{\n    static const char fmt[] = \"%\" NORX_FMT \" \"\n                              \"%\" NORX_FMT \" \"\n                              \"%\" NORX_FMT \" \"\n                              \"%\" NORX_FMT \"\\n\";\n    const norx_word_t * S = state->S;\n    printf(fmt, S[ 0],S[ 1],S[ 2],S[ 3]);\n    printf(fmt, S[ 4],S[ 5],S[ 6],S[ 7]);\n    printf(fmt, S[ 8],S[ 9],S[10],S[11]);\n    printf(fmt, S[12],S[13],S[14],S[15]);\n    printf(\"\\n\");\n}\n#endif\n\ntypedef enum tag__\n{\n    HEADER_TAG  = 1 << 0,\n    PAYLOAD_TAG = 1 << 1,\n    TRAILER_TAG = 1 << 2,\n    FINAL_TAG   = 1 << 3,\n    BRANCH_TAG  = 1 << 4,\n    MERGE_TAG   = 1 << 5\n} tag_t;\n\n/* The nonlinear primitive */\n#define U(A, B) ( ( (A) ^ (B) ) ^ ( ( (A) & (B) ) << 1) )\n\n/* The quarter-round */\n#define G(A, B, C, D) \\\ndo \\\n{ \\\n    (A) = U(A, B); (D) ^= (A); (D) = ROTR((D), R0); \\\n    (C) = U(C, D); (B) ^= (C); (B) = ROTR((B), R1); \\\n    (A) = U(A, B); (D) ^= (A); (D) = ROTR((D), R2); \\\n    (C) = U(C, D); (B) ^= (C); (B) = ROTR((B), R3); \\\n} while (0)\n\n\n/* The full round */\nstatic NORX_INLINE void F(norx_word_t S[16])\n{\n    /* Column step */\n    G(S[ 0], S[ 4], S[ 8], S[12]);\n    G(S[ 1], S[ 5], S[ 9], S[13]);\n    G(S[ 2], S[ 6], S[10], S[14]);\n    G(S[ 3], S[ 7], S[11], S[15]);\n    /* Diagonal step */\n    G(S[ 0], S[ 5], S[10], S[15]);\n    G(S[ 1], S[ 6], S[11], S[12]);\n    G(S[ 2], S[ 7], S[ 8], S[13]);\n    G(S[ 3], S[ 4], S[ 9], S[14]);\n}\n\n/* The core permutation */\nstatic NORX_INLINE void norx_permutation(norx_state_t state)\n{\n    norx_word_t * S = state->S;\n    size_t i;\n\n    for (i = 0; i < NORX_R; ++i)\n        F(S);\n}\n\nstatic NORX_INLINE void norx_pad(uint8_t *out, const uint8_t *in, const size_t inlen)\n{\n    memset(out, 0, BYTES(RATE));\n    memcpy(out, in, inlen);\n    out[inlen] = 0x01;\n    out[BYTES(RATE) - 1] |= 0x80;\n}\n\nstatic NORX_INLINE void norx_setup(norx_state_t state, const uint8_t *k, const uint8_t *n)\n{\n    norx_word_t * S = state->S;\n    norx_word_t u[4];\n\n    S[0] = u[0] = norx_ui[0];\n    S[1] = LOAD(n + 0 * BYTES(NORX_W));\n    S[2] = LOAD(n + 1 * BYTES(NORX_W));\n    S[3] = u[1] = norx_ui[1];\n\n    S[4] = LOAD(k + 0 * BYTES(NORX_W));\n    S[5] = LOAD(k + 1 * BYTES(NORX_W));\n    S[6] = LOAD(k + 2 * BYTES(NORX_W));\n    S[7] = LOAD(k + 3 * BYTES(NORX_W));\n\n    S[8] = u[2] = norx_ui[2];\n    S[9] = u[3] = norx_ui[3];\n\n    G(u[0], u[1], u[2], u[3]);\n\n    S[10] = u[0];\n    S[11] = u[1];\n    S[12] = u[2];\n    S[13] = u[3];\n\n    G(u[0], u[1], u[2], u[3]);\n\n    S[14] = u[0];\n    S[15] = u[1];\n}\n\nstatic NORX_INLINE void norx_inject_tag(norx_state_t state, tag_t tag)\n{\n    norx_word_t * S = state->S;\n    S[15] ^= tag;\n}\n\n#if NORX_D != 1 /* only required in parallel modes */\nstatic NORX_INLINE void norx_inject_lane(norx_state_t state, uint64_t lane)\n{\n    norx_word_t * S = state->S;\n#if   NORX_W == 32\n    S[13] ^= (lane >>  0) & 0xFFFFFFFF;\n    S[14] ^= (lane >> 32) & 0xFFFFFFFF;\n#elif NORX_W == 64\n    S[13] ^= lane;\n#endif\n}\n#endif\n\nstatic NORX_INLINE void norx_inject_params(norx_state_t state)\n{\n    norx_word_t * S = state->S;\n    S[14] ^= (NORX_R << 26) | (NORX_D << 18) | (NORX_W << 10) | NORX_A;\n    norx_permutation(state);\n}\n\nstatic NORX_INLINE void norx_absorb(norx_state_t state, const uint8_t * in, tag_t tag)\n{\n    norx_word_t * S = state->S;\n    size_t i;\n\n    norx_inject_tag(state, tag);\n    norx_permutation(state);\n#if defined(NORX_DEBUG)\n    if (tag == HEADER_TAG)\n    {\n      printf(\"End of initialisation:\\n\");\n      norx_print_state(state);\n    }\n#endif\n\n    for (i = 0; i < WORDS(RATE); ++i)\n        S[i] ^= LOAD(in + i * BYTES(NORX_W));\n}\n\nstatic NORX_INLINE void norx_finalize(norx_state_t state)\n{\n    norx_inject_tag(state, FINAL_TAG);\n    norx_permutation(state);\n    norx_permutation(state);\n#if defined(NORX_DEBUG) && NORX_D == 1\n    printf(\"End of payload processing\\n\");\n    norx_print_state(state);\n#endif\n}\n\nstatic NORX_INLINE void norx_encrypt_block(norx_state_t state, uint8_t *out, const uint8_t * in)\n{\n    norx_word_t * S = state->S;\n    size_t i;\n\n    norx_inject_tag(state, PAYLOAD_TAG);\n    norx_permutation(state);\n\n#if defined(NORX_DEBUG) && NORX_D == 1\n    printf(\"End of header processing \\n\");\n    norx_print_state(state);\n#endif\n\n    for (i = 0; i < WORDS(RATE); ++i)\n    {\n        S[i] ^= LOAD(in + i * BYTES(NORX_W));\n        STORE(out + i * BYTES(NORX_W), S[i]);\n    }\n}\n\n\nstatic NORX_INLINE void norx_encrypt_lastblock(norx_state_t state, uint8_t *out, const uint8_t * in, size_t inlen)\n{\n    uint8_t lastblock[BYTES(RATE)];\n    norx_pad(lastblock, in, inlen);\n    norx_encrypt_block(state, lastblock, lastblock);\n    memcpy(out, lastblock, inlen);\n}\n\nstatic NORX_INLINE void norx_decrypt_block(norx_state_t state, uint8_t *out, const uint8_t * in)\n{\n    norx_word_t * S = state->S;\n    size_t i;\n\n    norx_inject_tag(state, PAYLOAD_TAG);\n    norx_permutation(state);\n\n    for (i = 0; i < WORDS(RATE); ++i)\n    {\n        const norx_word_t c = LOAD(in + i * BYTES(NORX_W));\n        STORE(out + i * BYTES(NORX_W), S[i] ^ c);\n        S[i] = c;\n    }\n}\n\nstatic NORX_INLINE void norx_decrypt_lastblock(norx_state_t state, uint8_t *out, const uint8_t * in, size_t inlen)\n{\n    norx_word_t * S = state->S;\n    uint8_t b[BYTES(NORX_W)];\n    size_t i, j;\n\n    norx_inject_tag(state, PAYLOAD_TAG);\n    norx_permutation(state);\n\n    /* Undo padding */\n    S[inlen / BYTES(NORX_W)] ^= 0x01ULL << ((inlen % BYTES(NORX_W)) * 8);\n    S[WORDS(RATE) - 1]  ^= 0x80ULL << (((BYTES(RATE) - 1) % BYTES(NORX_W)) * 8);\n\n    for(i = 0; inlen >= BYTES(NORX_W); ++i)\n    {\n        norx_word_t c = LOAD(in);\n        STORE(out, S[i] ^ c);\n        S[i] = c;\n\n        inlen -= BYTES(NORX_W);\n        in    += BYTES(NORX_W);\n        out   += BYTES(NORX_W);\n    }\n\n    STORE(b, S[i]);\n    for(j = 0; j < inlen; ++j)\n    {\n        uint8_t c = in[j];\n        out[j] = b[j] ^ c;\n        b[j]   = c;\n    }\n    S[i] = LOAD(b);\n}\n\n#if NORX_D != 1 /* only required in parallel modes */\nstatic NORX_INLINE void norx_branch(norx_state_t state, uint64_t lane)\n{\n    norx_inject_tag(state, BRANCH_TAG);\n    norx_permutation(state);\n#if defined(NORX_DEBUG)\n    if (lane == 0)\n    {\n      printf(\"End of header processing:\\n\");\n      norx_print_state(state);\n    }\n#endif\n    norx_inject_lane(state, lane);\n}\n\n/* state = state xor state1 */\nstatic NORX_INLINE void norx_merge(norx_state_t state, norx_state_t state1)\n{\n    norx_word_t * S = state->S;\n    norx_word_t * S1 = state1->S;\n    size_t i;\n\n    norx_inject_tag(state1, MERGE_TAG);\n    norx_permutation(state1);\n\n    for(i = 0; i < 16; ++i)\n        S[i] ^= S1[i];\n}\n#endif\n\nvoid norx_init(norx_state_t state, const unsigned char *k, const unsigned char *n)\n{\n    norx_setup(state, k, n);\n#if defined(NORX_DEBUG)\n    printf(\"Basic setup:\\n\");\n    norx_print_state(state);\n#endif\n    norx_inject_params(state);\n}\n\nvoid norx_process_header(norx_state_t state, const unsigned char * in, size_t inlen)\n{\n    if(inlen > 0)\n    {\n        uint8_t lastblock[BYTES(RATE)];\n\n        while (inlen >= BYTES(RATE))\n        {\n            norx_absorb(state, in, HEADER_TAG);\n            inlen -= BYTES(RATE);\n            in += BYTES(RATE);\n        }\n\n        norx_pad(lastblock, in, inlen);\n        norx_absorb(state, lastblock, HEADER_TAG);\n    }\n}\n\n#if NORX_D > 1 /* Parallel encryption/decryption */\n\nvoid norx_encrypt_msg(norx_state_t state, unsigned char *out, const unsigned char * in, size_t inlen)\n{\n    if(inlen > 0)\n    {\n        norx_state_t lane[NORX_D];\n        uint8_t emptyblock[BYTES(RATE)];\n        size_t i, j;\n\n        /* Initialize states + branch */\n        for(i = 0; i < NORX_D; ++i)\n        {\n            memcpy(lane[i], state, sizeof lane[i]);\n            norx_branch(lane[i], i);\n        }\n\n        /* parallel payload processing */\n        for(i = 0; inlen >= BYTES(RATE); ++i)\n        {\n            norx_encrypt_block(lane[i%NORX_D], out, in);\n            inlen -= BYTES(RATE);\n            out   += BYTES(RATE);\n            in    += BYTES(RATE);\n        }\n        norx_encrypt_lastblock(lane[i++%NORX_D], out, in, inlen);\n\n        /* Pad remaining blocks */\n        norx_pad(emptyblock, emptyblock, 0);\n        for(j = 0; j < (NORX_D-1); ++j, ++i)\n        {\n            norx_absorb(lane[i%NORX_D], emptyblock, PAYLOAD_TAG);\n        }\n\n        /* Merge */\n        memset(state, 0, sizeof(norx_state_t));\n        for(i = 0; i < NORX_D; ++i)\n        {\n#if defined(NORX_DEBUG)\n            printf(\"End of payload processing (lane %lu) \\n\", i);\n            norx_print_state(lane[i]);\n#endif\n            norx_merge(state, lane[i]);\n            burn(lane[i], 0, sizeof(norx_state_t));\n        }\n\n#if defined(NORX_DEBUG)\n        printf(\"End of merging:\\n\");\n        norx_print_state(state);\n#endif\n    }\n}\n\nvoid norx_decrypt_msg(norx_state_t state, unsigned char *out, const unsigned char * in, size_t inlen)\n{\n    if(inlen > 0)\n    {\n        norx_state_t lane[NORX_D];\n        uint8_t emptyblock[BYTES(RATE)];\n        size_t i, j;\n\n        /* Initialize states + branch */\n        for(i = 0; i < NORX_D; ++i)\n        {\n            memcpy(lane[i], state, sizeof lane[i]);\n            norx_branch(lane[i], i);\n        }\n\n        /* parallel payload processing */\n        for(i = 0; inlen >= BYTES(RATE); ++i)\n        {\n            norx_decrypt_block(lane[i%NORX_D], out, in);\n            inlen -= BYTES(RATE);\n            out   += BYTES(RATE);\n            in    += BYTES(RATE);\n        }\n        norx_decrypt_lastblock(lane[i++%NORX_D], out, in, inlen);\n\n        /* Pad remaining blocks */\n        norx_pad(emptyblock, emptyblock, 0);\n        for(j = 0; j < NORX_D - 1; ++j, ++i)\n        {\n            norx_absorb(lane[i%NORX_D], emptyblock, PAYLOAD_TAG);\n        }\n\n        /* Merge */\n        memset(state, 0, sizeof(norx_state_t));\n        for(i = 0; i < NORX_D; ++i)\n        {\n            norx_merge(state, lane[i]);\n            burn(lane[i], 0, sizeof(norx_state_t));\n        }\n\n    }\n}\n\n#elif NORX_D == 1 /* Sequential encryption/decryption */\n\nvoid norx_encrypt_msg(norx_state_t state, unsigned char *out, const unsigned char * in, size_t inlen)\n{\n    if(inlen > 0)\n    {\n        while (inlen >= BYTES(RATE))\n        {\n            norx_encrypt_block(state, out, in);\n            inlen -= BYTES(RATE);\n            in    += BYTES(RATE);\n            out   += BYTES(RATE);\n        }\n\n        norx_encrypt_lastblock(state, out, in, inlen);\n    }\n}\n\nvoid norx_decrypt_msg(norx_state_t state, unsigned char *out, const unsigned char * in, size_t inlen)\n{\n    if(inlen > 0)\n    {\n        while (inlen >= BYTES(RATE))\n        {\n            norx_decrypt_block(state, out, in);\n            inlen -= BYTES(RATE);\n            in    += BYTES(RATE);\n            out   += BYTES(RATE);\n        }\n\n        norx_decrypt_lastblock(state, out, in, inlen);\n    }\n}\n\n#elif NORX_D == 0 /* Unlimited parallelism */\n\nvoid norx_encrypt_msg(norx_state_t state, unsigned char *out, const unsigned char * in, size_t inlen)\n{\n    if(inlen > 0)\n    {\n        uint8_t emptyblock[BYTES(RATE)];\n        norx_state_t sum;\n        norx_state_t state2;\n        uint64_t lane = 0;\n\n        norx_pad(emptyblock, emptyblock, 0);\n        memset(sum, 0, sizeof(norx_state_t));\n\n        while (inlen >= BYTES(RATE))\n        {\n            /* branch */\n            memcpy(state2, state, sizeof(norx_state_t));\n            norx_branch(state2, lane++);\n            /* encrypt */\n            norx_encrypt_block(state2, out, in);\n            /* empty padding */\n            norx_absorb(state2, emptyblock, PAYLOAD_TAG);\n            /* merge */\n            norx_merge(sum, state2);\n\n            inlen -= BYTES(RATE);\n            in    += BYTES(RATE);\n            out   += BYTES(RATE);\n        }\n        /* last block, 0 < inlen < BYTES(RATE) */\n        if(inlen > 0)\n        {\n            /* branch */\n            memcpy(state2, state, sizeof(norx_state_t));\n            norx_branch(state2, lane++);\n            /* encrypt */\n            norx_encrypt_lastblock(state2, out, in, inlen);\n            /* merge */\n            norx_merge(sum, state2);\n        }\n        memcpy(state, sum, sizeof(norx_state_t));\n    }\n}\n\nvoid norx_decrypt_msg(norx_state_t state, unsigned char *out, const unsigned char * in, size_t inlen)\n{\n    if(inlen > 0)\n    {\n        uint8_t emptyblock[BYTES(RATE)];\n        norx_state_t sum;\n        norx_state_t state2;\n        size_t lane = 0;\n\n        norx_pad(emptyblock, emptyblock, 0);\n        memset(sum, 0, sizeof(norx_state_t));\n\n        while (inlen >= BYTES(RATE))\n        {\n            /* branch */\n            memcpy(state2, state, sizeof(norx_state_t));\n            norx_branch(state2, lane++);\n            /* decrypt */\n            norx_decrypt_block(state2, out, in);\n            /* empty padding */\n            norx_absorb(state2, emptyblock, PAYLOAD_TAG);\n            /* merge */\n            norx_merge(sum, state2);\n\n            inlen -= BYTES(RATE);\n            in    += BYTES(RATE);\n            out   += BYTES(RATE);\n        }\n        /* last block, 0 < inlen < BYTES(RATE) */\n        if(inlen > 0)\n        {\n            /* branch */\n            memcpy(state2, state, sizeof(norx_state_t));\n            norx_branch(state2, lane++);\n            /* decrypt */\n            norx_decrypt_lastblock(state2, out, in, inlen);\n            /* merge */\n            norx_merge(sum, state2);\n        }\n        memcpy(state, sum, sizeof(norx_state_t));\n    }\n}\n#else /* D < 0 */\n    #error \"NORX_D cannot be < 0\"\n#endif\n\n\nvoid norx_process_trailer(norx_state_t state, const unsigned char * in, size_t inlen)\n{\n    if(inlen > 0)\n    {\n        uint8_t lastblock[BYTES(RATE)];\n\n        while (inlen >= BYTES(RATE))\n        {\n            norx_absorb(state, in, TRAILER_TAG);\n            inlen -= BYTES(RATE);\n            in    += BYTES(RATE);\n        }\n\n        norx_pad(lastblock, in, inlen);\n        norx_absorb(state, lastblock, TRAILER_TAG);\n    }\n}\n\n\nvoid norx_output_tag(norx_state_t state, unsigned char * tag)\n{\n    norx_word_t * S = state->S;\n    uint8_t lastblock[BYTES(RATE)];\n    size_t i;\n\n    norx_finalize(state);\n\n    for (i = 0; i < WORDS(RATE); ++i)\n        STORE(lastblock + i * BYTES(NORX_W), S[i]);\n\n    memcpy(tag, lastblock, BYTES(NORX_A));\n    burn(lastblock, 0, BYTES(RATE)); /* burn full state dump */\n    burn(state, 0, sizeof(norx_state_t)); /* at this point we can also burn the state */\n}\n\n/* Verify tags in constant time: 0 for success, -1 for fail */\nint norx_verify_tag(const unsigned char * tag1, const unsigned char * tag2)\n{\n    unsigned acc = 0;\n    size_t i;\n\n    for(i = 0; i < BYTES(NORX_A); ++i)\n        acc |= tag1[i] ^ tag2[i];\n\n    return (((acc - 1) >> 8) & 1) - 1;\n}\n\nvoid norx_aead_encrypt(\n  unsigned char *c, size_t *clen,\n  const unsigned char *h, size_t hlen,\n  const unsigned char *p, size_t plen,\n  const unsigned char *t, size_t tlen,\n  const unsigned char *nonce,\n  const unsigned char *key\n)\n{\n    norx_state_t state;\n#if defined(NORX_DEBUG)\n    printf(\"ENCRYPTION\\n\");\n#endif\n    norx_init(state, key, nonce);\n    norx_process_header(state, h, hlen);\n    norx_encrypt_msg(state, c, p, plen);\n    norx_process_trailer(state, t, tlen);\n    norx_output_tag(state, c + plen); /* append tag to ciphertext */\n    *clen = plen + BYTES(NORX_A);\n    burn(state, 0, sizeof(norx_state_t));\n}\n\nint norx_aead_decrypt(\n  unsigned char *p, size_t *plen,\n  const unsigned char *h, size_t hlen,\n  const unsigned char *c, size_t clen,\n  const unsigned char *t, size_t tlen,\n  const unsigned char *nonce,\n  const unsigned char *key\n)\n{\n    unsigned char tag[BYTES(NORX_A)];\n    norx_state_t state;\n    int result = -1;\n\n    if (clen < BYTES(NORX_A))\n        return -1;\n\n#if defined(DEBUG)\n    printf(\"DECRYPTION\\n\");\n#endif\n    norx_init(state, key, nonce);\n    norx_process_header(state, h, hlen);\n    norx_decrypt_msg(state, p, c, clen - BYTES(NORX_A));\n    norx_process_trailer(state, t, tlen);\n    norx_output_tag(state, tag);\n    *plen = clen - BYTES(NORX_A);\n\n    result = norx_verify_tag(c + clen - BYTES(NORX_A), tag);\n    if(result != 0) /* burn decrypted plaintext on auth failure */\n        burn(p, 0, clen - BYTES(NORX_A));\n    burn(state, 0, sizeof(norx_state_t));\n    return result;\n}\n\n\n\n} // namespace Norx6461v1_raw\n"
        },
        {
            "file_name": "NorxCore32.cpp",
            "content": "using namespace System;\n\n#pragma once\n\n#ifndef NORX_NORX_CORE32\n#define NORX_NORX_CORE32\n#include <stdlib.h> // only needed for _rotr64 and _lotr\n\nnamespace NorxManaged\n{\n\tnamespace NorxCore32\n\t{\n#define NORX32_WORDBYTES\t4\n#define NORX32_STATEWORDS\t16\n#define NORX32_STATEBYTES\t64\n#define NORX32_NONCEBYTES\t16\n#define NORX32_NONCEWORDS\t4\n#define NORX32_KEYBYTES\t\t16\n#define NORX32_KEYWORDS\t\t4\n#define NORX32_RATEBYTES\t48\n#define NORX32_RATEWORDS\t12\n#define NORX32_CAPBYTES\t\t16\n#define NORX32_CAPWORDS\t\t4\n#define NORX32_TAGBYTES\t\t16\n#define NORX32_TAGWORDS\t\t4\n#define ROTR32(x, y) _lrotr(x, y)\n\n// The nonlinear primitive \n#define _H(A, B) ( A ^ B ^ (( (A) & (B) ) << 1) )\n\n// The quarter-round \n#define _G32(A, B, C, D)                               \\\n{                                                   \\\n    (A) = _H(A, B); (D) ^= (A); (D) = ROTR32((D), 8); \\\n    (C) = _H(C, D); (B) ^= (C); (B) = ROTR32((B), 11); \\\n    (A) = _H(A, B); (D) ^= (A); (D) = ROTR32((D), 16); \\\n    (C) = _H(C, D); (B) ^= (C); (B) = ROTR32((B), 31); \\\n}\n\t\t//These BURN methods should survive compiler optimization, they are only used at the end of a processes\n\t\t//Just in case, reference the source array in the calling function in some meaningful way to keep the references alive before the garbage collecter gets them\n\t\tstatic void _burn(array<UInt32>^ thing)\n\t\t{\n\t\t\tif (thing == nullptr) return;\n\t\t\ttry {\n\t\t\t\tfor (Byte i = 0; i < thing->Length; i++)\n\t\t\t\t{\n\t\t\t\t\tthing[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (...) { throw; }\n\t\t}\n\t\tstatic void _burn(array<Byte>^ thing)\n\t\t{\n\t\t\tif (thing == nullptr) return;\n\t\t\ttry {\n\t\t\t\tfor (int i = 0; i < thing->Length; i++)\n\t\t\t\t{\n\t\t\t\t\tthing[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (...) { throw; }\n\t\t}\n\n\t\tstatic __inline void _F(array<UInt32>^ state, const Byte rounds)\n\t\t{\n\t\t\t// normally this would be unrolled for performance, but with variable round amounts, that would be tedious to implement\n\t\t\tfor (Byte i = 0; i < rounds; i++)\n\t\t\t{\n\t\t\t\t// Column step \n\t\t\t\t_G32(state[0], state[4], state[8], state[12]);\n\t\t\t\t_G32(state[1], state[5], state[9], state[13]);\n\t\t\t\t_G32(state[2], state[6], state[10], state[14]);\n\t\t\t\t_G32(state[3], state[7], state[11], state[15]);\n\t\t\t\t// Diagonal step \n\t\t\t\t_G32(state[0], state[5], state[10], state[15]);\n\t\t\t\t_G32(state[1], state[6], state[11], state[12]);\n\t\t\t\t_G32(state[2], state[7], state[8], state[13]);\n\t\t\t\t_G32(state[3], state[4], state[9], state[14]);\n\t\t\t}\n\t\t}\n\n\t\t// Low-level operations \n\t\tstatic __inline array<UInt32>^ _init(array<const Byte>^ n, array<const UInt32>^ k, \n\t\t\tByte rounds, Byte lanes, short tagSizeBits)\n\t\t{\n\t\t\tarray<UInt32>^ state;\n#ifndef USE_COMPUTED_CONSTANTS\n\t\t\tstate = gcnew array<UInt32>(NORX32_STATEWORDS);\n\t\t\tif (n != nullptr) // nonce is optional, so check for null\n\t\t\t\tBuffer::BlockCopy(n, 0, state, 0, NORX32_NONCEBYTES);\n\t\t\tBuffer::BlockCopy(k, 0, state, NORX32_NONCEBYTES, NORX32_KEYBYTES);\n\n\t\t\t//instead of using the _F construction twice with 0,1,2...15 as the initial state, use pre-computed constants\n\t\t\tstate[8] = 0xA3D8D930;\n\t\t\tstate[9] = 0x3FA8B72C;\n\t\t\tstate[10] = 0xED84EB49;\n\t\t\tstate[11] = 0xEDCA4787;\n\n\t\t\t//while using pre-computed constants, merge in the parameters to the operation\n\t\t\tstate[12] = 0x335463EB ^ 32L;\n\t\t\tstate[13] = 0xF994220B ^ (UInt32)rounds;\n\t\t\tstate[14] = 0xBE0BF5C9 ^ (UInt32)lanes;\n\t\t\tstate[15] = 0xD7C49104 ^ (UInt32)tagSizeBits;\n#else\n\t\t\tstate = gcnew array<UInt32>{\n\t\t\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n\t\t\t};\n\t\t\t_F(state, 2);\n\t\t\tif (n != nullptr) // nonce is optional, so check for null\n\t\t\t\tBuffer::BlockCopy(n, 0, state, 0, NORX32_NONCEBYTES);\n\t\t\tBuffer::BlockCopy(k, 0, state, NORX32_NONCEBYTES, NORX32_KEYBYTES);\n\t\t\tstate[12] ^= 32L;\n\t\t\tstate[13] ^= (UInt32)rounds;\n\t\t\tstate[14] ^= (UInt32)lanes;\n\t\t\tstate[15] ^= (UInt32)tagSizeBits;\n#endif\n\t\t\t_F(state, rounds);\n\n\t\t\tstate[12] ^= k[0];\n\t\t\tstate[13] ^= k[1];\n\t\t\tstate[14] ^= k[2];\n\t\t\tstate[15] ^= k[3];\n\n\t\t\treturn state;\n\t\t}\n\n\t\tstatic void _absorb(\n\t\t\tarray<UInt32>^ state,\n\t\t\tarray<const Byte>^ in,\n\t\t\tconst _domain_separator_32 tag,\n\t\t\tconst Byte rounds)\n\t\t{\n\t\t\t// Used for P=1, and Header and Footer/Trailer (using appropriate domain separation constant)\n\t\t\tif (in == nullptr || in->Length == 0) return;\n\t\t\tInt64 outptr = 0;\n\t\t\tarray<UInt32>^ state_buffer = gcnew array<UInt32>(NORX32_RATEWORDS);\n\t\t\tfor (int i = 0; i < in->Length; i += NORX32_RATEBYTES)\n\t\t\t{\n\t\t\t\tif (i + NORX32_RATEBYTES >= in->Length)\n\t\t\t\t{\n\t\t\t\t\tarray<Byte>^ LastBlock = gcnew array<Byte>(NORX32_RATEBYTES);\n\t\t\t\t\tif (i < in->Length)\n\t\t\t\t\t\tBuffer::BlockCopy(in, i, LastBlock, 0, in->Length % NORX32_RATEBYTES);\n\t\t\t\t\tLastBlock[in->Length % NORX32_RATEBYTES] = 0x01;\n\t\t\t\t\tLastBlock[LastBlock->Length - 1] |= 0x80;\n\t\t\t\t\tBuffer::BlockCopy(LastBlock, 0, state_buffer, 0, NORX32_RATEBYTES);\n\t\t\t\t\t_burn(LastBlock);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(in, i, state_buffer, 0, NORX32_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tstate[15] ^= (UInt32)tag;\n\t\t\t\t_F(state, rounds);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\tstate[j] ^= state_buffer[j];\n\t\t\t\t};\n\t\t\t}\n\t\t\t_burn(state_buffer);\n\t\t\tstate_buffer[0] ^= state_buffer[1] ^ NORX32_CAPBYTES;\n\t\t}\n\n\t\tstatic void _encrypt_p1(\n\t\t\tarray<UInt32>^ state, \n\t\t\tarray<const Byte>^ in, int index, int length,\n\t\t\tconst _domain_separator_32 tag, \n\t\t\tconst Byte rounds, \n\t\t\tarray<Byte>^ out, int outIndex) // the input and output length will be the same (the TAG is added in another step)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism = 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0 || length == 0) return;\n\t\t\tint apparentLength = index + length;\n\t\t\tif (apparentLength > in->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore32::_encrypt_p1->The given index and length goes beyond the bounds of the supplied input array.\");\n\t\t\tif (outIndex + length > out->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore32::_encrypt_p1->The given index and length goes beyond the bounds of the supplied output array.\");\n\t\t\tint outptr = outIndex;\n\t\t\tarray<UInt32>^ state_buffer = gcnew array<UInt32>(NORX32_RATEWORDS);\n\t\t\tfor (int i = index; i < apparentLength; i += NORX32_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX32_RATEBYTES >= apparentLength;\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tarray<Byte>^ LastBlock = gcnew array<Byte>(NORX32_RATEBYTES);\n\t\t\t\t\tif (i < apparentLength)\n\t\t\t\t\t\tBuffer::BlockCopy(in, i, LastBlock, 0, apparentLength % NORX32_RATEBYTES);\n\t\t\t\t\tLastBlock[apparentLength % NORX32_RATEBYTES] = 0x01;\n\t\t\t\t\tLastBlock[LastBlock->Length - 1] |= 0x80;\n\t\t\t\t\tBuffer::BlockCopy(LastBlock, 0, state_buffer, 0, NORX32_RATEBYTES);\n\t\t\t\t\t_burn(LastBlock);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(in, i, state_buffer, 0, NORX32_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tstate[15] ^= (UInt32)tag;\n\t\t\t\t_F(state, rounds);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\tstate[j] ^= state_buffer[j];\n\t\t\t\t};\n\t\t\t\tif (last)\n\t\t\t\t\tBuffer::BlockCopy(state, 0, out, outptr, apparentLength % NORX32_RATEBYTES);\n\t\t\t\telse\n\t\t\t\t\tBuffer::BlockCopy(state, 0, out, outptr, NORX32_RATEBYTES);\n\t\t\t\toutptr += NORX32_RATEBYTES;\n\t\t\t}\n\t\t\t_burn(state_buffer);\n\t\t\tstate_buffer[0] ^= state_buffer[1] ^ NORX32_CAPBYTES;\n\t\t}\n\n\t\tstatic void _decrypt_p1(\n\t\t\tarray<UInt32>^ state,\n\t\t\tarray<const Byte>^ in, int index, int length, \n\t\t\tconst _domain_separator_32 tag, \n\t\t\tconst Byte rounds, \n\t\t\tint tagBytesInMessage, \n\t\t\tarray<Byte>^% out, \n\t\t\tint outIndex)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism = 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0 || length == 0) return;\n\t\t\tint apparentLength = index + length;\n\t\t\tif (apparentLength > in->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore32::_decrypt_p1->The given index and length goes beyond the bounds of the supplied input array.\");\n\t\t\tif (outIndex + length - tagBytesInMessage > out->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore32::_decrypt_p1->The given index and length goes beyond the bounds of the supplied output array.\");\n\n\t\t\tint outptr = outIndex;\n\t\t\tint actualLength = apparentLength - tagBytesInMessage; // the tag is processed in another step\n\t\t\tarray<UInt32>^ state_buffer = gcnew array<UInt32>(NORX32_RATEWORDS);\n\t\t\tfor (int i = 0; i < actualLength; i += NORX32_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX32_RATEBYTES >= actualLength;\n\t\t\t\tstate[15] ^= (UInt32)tag;\n\t\t\t\t_F(state, rounds);\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tarray<Byte>^ LastBlock = gcnew array<Byte>(NORX32_RATEBYTES);\n\t\t\t\t\tBuffer::BlockCopy(state, 0, LastBlock, 0, NORX32_RATEBYTES); // !!store state in last block, then overwrite with ciphertext\n\t\t\t\t\tif (i < actualLength)\n\t\t\t\t\t\tBuffer::BlockCopy(in, i, LastBlock, 0, actualLength % NORX32_RATEBYTES);\n\t\t\t\t\tLastBlock[actualLength % NORX32_RATEBYTES] ^= 0x01; // remove the padding\n\t\t\t\t\tLastBlock[LastBlock->Length - 1] ^= 0x80;\n\t\t\t\t\tBuffer::BlockCopy(LastBlock, 0, state_buffer, 0, NORX32_RATEBYTES);\n\t\t\t\t\t_burn(LastBlock);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(in, i, state_buffer, 0, NORX32_RATEBYTES);\n\t\t\t\t}\t\t\t\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\tUInt32 c = state_buffer[j];\n\t\t\t\t\tstate_buffer[j] ^= state[j];\n\t\t\t\t\tstate[j] = c;\n\t\t\t\t};\n\t\t\t\tif (last)\n\t\t\t\t\tBuffer::BlockCopy(state_buffer, 0, out, outptr, actualLength % NORX32_RATEBYTES);\n\t\t\t\telse\n\t\t\t\t\tBuffer::BlockCopy(state_buffer, 0, out, outptr, NORX32_RATEBYTES);\n\t\t\t\toutptr += NORX32_RATEBYTES;\n\t\t\t}\n\t\t\t_burn(state_buffer);\n\t\t\tstate_buffer[0] ^= state_buffer[1] ^ NORX32_CAPBYTES;\n\t\t}\n\n\t\tstatic void _encrypt_p2(\n\t\t\tarray<array<UInt32>^>^ states, \n\t\t\tarray<const Byte>^ in, int index, int length,\n\t\t\tconst _domain_separator_32 tag, \n\t\t\tconst Byte rounds, \n\t\t\tconst Byte lanes, \n\t\t\tarray<Byte>^% out, int outIndex)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism > 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0 || length == 0) return;\n\t\t\tint apparentLength = index + length;\n\t\t\tif (apparentLength > in->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore32::_encrypt_p2->The given index and length goes beyond the bounds of the supplied input array.\");\n\t\t\tif (outIndex + length > out->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore32::_encrypt_p2->The given index and length goes beyond the bounds of the supplied output array.\");\n\t\t\tint outptr = outIndex;\n\t\t\tByte laneptr = 0;\n\t\t\tarray<UInt32>^ state_buffer = gcnew array<UInt32>(NORX32_RATEWORDS);\n\t\t\tfor (int i = index; i < in->Length; i += NORX32_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX32_RATEBYTES >= in->Length;\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tarray<Byte>^ LastBlock = gcnew array<Byte>(NORX32_RATEBYTES);\n\t\t\t\t\tif (i < apparentLength)\n\t\t\t\t\t\tBuffer::BlockCopy(in, i, LastBlock, 0, apparentLength % NORX32_RATEBYTES);\n\t\t\t\t\tLastBlock[apparentLength % NORX32_RATEBYTES] = 0x01;\n\t\t\t\t\tLastBlock[LastBlock->Length - 1] |= 0x80;\n\t\t\t\t\tBuffer::BlockCopy(LastBlock, 0, state_buffer, 0, LastBlock->Length);\n\t\t\t\t\t_burn(LastBlock);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(in, i, state_buffer, 0, NORX32_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tstates[laneptr][15] ^= (UInt32)tag;\n\t\t\t\t_F(states[laneptr], rounds);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\t// STATE = STATE ^ P = C\n\t\t\t\t\tstates[laneptr][j] ^= state_buffer[j];\n\t\t\t\t};\n\t\t\t\tif (out != nullptr)\n\t\t\t\t{\n\t\t\t\t\tif (last)\n\t\t\t\t\t\tBuffer::BlockCopy(states[laneptr], 0, out, outptr, apparentLength % NORX32_RATEBYTES);\n\t\t\t\t\telse\n\t\t\t\t\t\tBuffer::BlockCopy(states[laneptr], 0, out, outptr, NORX32_RATEBYTES);\n\t\t\t\t\toutptr += NORX32_RATEBYTES;\n\t\t\t\t}\n\t\t\t\tlaneptr = ++laneptr % lanes;\n\t\t\t}\n\t\t\t_burn(state_buffer);\n\t\t\tstate_buffer[0] ^= state_buffer[1] ^ NORX32_CAPBYTES;\n\t\t}\n\n\t\tstatic void _decrypt_p2(\n\t\t\tarray<array<UInt32>^>^ states, \n\t\t\tarray<const Byte>^ in, int index, int length,\n\t\t\tconst _domain_separator_32 tag, \n\t\t\tconst Byte rounds, \n\t\t\tconst Byte lanes, \n\t\t\tint tagBytesInMessage, \n\t\t\tarray<Byte>^% out, int outIndex)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism > 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0 || length == 0) return;\n\t\t\tint apparentLength = index + length;\n\t\t\tif (apparentLength > in->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore32::_decrypt_p2->The given index and length goes beyond the bounds of the supplied input array.\");\n\t\t\tif (outIndex + length - tagBytesInMessage > out->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore32::_decrypt_p2->The given index and length goes beyond the bounds of the supplied output array.\");\n\t\t\tint outptr = outIndex;\n\t\t\tint actualLength = apparentLength - tagBytesInMessage; // the tag is processed in another step\n\t\t\tByte laneptr = 0;\n\t\t\tarray<UInt32>^ state_buffer = gcnew array<UInt32>(NORX32_RATEWORDS);\n\t\t\tfor (int i = index; i < actualLength; i += NORX32_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX32_RATEBYTES >= actualLength;\n\t\t\t\tstates[laneptr][15] ^= (UInt32)tag;\n\t\t\t\t_F(states[laneptr], rounds);\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tarray<Byte>^ LastBlock = gcnew array<Byte>(NORX32_RATEBYTES);\n\t\t\t\t\tBuffer::BlockCopy(states[laneptr], 0, LastBlock, 0, NORX32_RATEBYTES); // !!store state in last block, then overwrite with ciphertext\n\t\t\t\t\tif (i < actualLength)\n\t\t\t\t\t\tBuffer::BlockCopy(in, i, LastBlock, 0, actualLength % NORX32_RATEBYTES);\n\t\t\t\t\tLastBlock[actualLength % NORX32_RATEBYTES] ^= 0x01;\n\t\t\t\t\tLastBlock[LastBlock->Length - 1] ^= 0x80;\n\t\t\t\t\tBuffer::BlockCopy(LastBlock, 0, state_buffer, 0, LastBlock->Length);\n\t\t\t\t\t_burn(LastBlock);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(in, i, state_buffer, 0, NORX32_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\t// C = (from encryption) P ^ STATE, to recover P then C ^ STATE = P, to recover STATE, then P ^ C\n\t\t\t\t\tUInt32 c = state_buffer[j];\n\t\t\t\t\tstate_buffer[j] ^= states[laneptr][j];\n\t\t\t\t\tstates[laneptr][j] = c;\n\t\t\t\t};\n\t\t\t\tif (last)\n\t\t\t\t\tBuffer::BlockCopy(state_buffer, 0, out, outptr, actualLength % NORX32_RATEBYTES);\n\t\t\t\telse\n\t\t\t\t\tBuffer::BlockCopy(state_buffer, 0, out, outptr, NORX32_RATEBYTES);\n\t\t\t\toutptr += NORX32_RATEBYTES;\n\t\t\t\tlaneptr = ++laneptr % lanes;\n\t\t\t}\n\t\t\t_burn(state_buffer);\n\t\t\tstate_buffer[0] ^= state_buffer[1] ^ NORX32_CAPBYTES;\n\t\t}\n\n\t\t//static __inline void _branch(array<UInt32>^ state, Byte lane, const Byte rounds)\n\t\t//{\n\t\t//\tstate[15] ^= _domain_separator_32::BRANCH_TAG_32;\n\t\t//\t_F(state, rounds);\n\t\t//\t// Inject lane ID \n\t\t//\tfor (Byte i = 0; i < NORX32_RATEWORDS; ++i) {\n\t\t//\t\tstate[i] ^= lane;\n\t\t//\t}\n\t\t//}\n\n\t\t// stateA ^= stateB, then destroy stateB\n\t\tstatic __inline void _merge(array<UInt32>^ stateA, array<UInt32>^ stateB, const Byte rounds)\n\t\t{\n\t\t\tstateB[15] ^= _domain_separator_32::MERGE_TAG_32;\n\t\t\t_F(stateB, rounds);\n\t\t\tfor (Byte i = 0; i < 16; ++i) {\n\t\t\t\tstateA[i] ^= stateB[i];\n\t\t\t\tstateB[i] |= UInt32::MaxValue; // destroy contents of old state\n\t\t\t}\n\t\t}\n\n\t\tstatic __inline void _finalize(array<UInt32>^ state, array<const UInt32>^ k, const Byte rounds, const short tagsizebits, array<Byte>^% outTag)\n\t\t{\n\t\t\tstate[15] ^= _domain_separator_32::FINAL_TAG_32;\n\n\t\t\t_F(state, rounds);\n\t\t\tstate[12] ^= k[0];\n\t\t\tstate[13] ^= k[1];\n\t\t\tstate[14] ^= k[2];\n\t\t\tstate[15] ^= k[3];\n\t\t\t_F(state, rounds);\n\t\t\tstate[12] ^= k[0];\n\t\t\tstate[13] ^= k[1];\n\t\t\tstate[14] ^= k[2];\n\t\t\tstate[15] ^= k[3];\n\n\t\t\tBuffer::BlockCopy(state, NORX32_RATEWORDS * NORX32_WORDBYTES, outTag, 0, tagsizebits / 8); // extract Tag\n\t\t\t_burn(state); // at this point we can burn the state \n\t\t\tstate[0] ^= state[state[15] % 7] ^ NORX32_CAPBYTES; // prevent compiler optimizations?\n\t\t}\n\t}\n}\n#endif // !NORX_NORX_CORE32"
        },
        {
            "file_name": "NorxCore32Streams.cpp",
            "content": "#pragma once\n\n#ifndef NORX_NORX_CORE32_STREAMS\n#define NORX_NORX_CORE32_STREAMS\n#include <stdlib.h> // only needed for _rotr64 and _lotr\n#include \"NorxCore32.cpp\"\n\nnamespace NorxManaged\n{\n\tnamespace NorxCore32\n\t{\n\t\t// Low-level operations \n\t\tstatic void _absorb(array<UInt32>^ state, MemoryStream^ in, const _domain_separator_32 tag, const Byte rounds)\n\t\t{\n\t\t\t// Used for P=1, and Header and Footer/Trailer (using appropriate domain separation constant)\n\t\t\tif (in == nullptr || in->Length == 0) return;\n\t\t\tInt64 outptr = 0;\n\t\t\tarray<UInt32>^ state_buffer = gcnew array<UInt32>(NORX32_RATEWORDS);\n\t\t\tarray<Byte>^ block = gcnew array<Byte>(NORX32_RATEBYTES);\n\t\t\tfor (Int64 i = 0; i < in->Length; i += NORX32_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX32_RATEBYTES >= in->Length;\t\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tif (i < in->Length)\n\t\t\t\t\t\tin->Read(block, 0, in->Length % NORX32_RATEBYTES);\n\t\t\t\t\tblock[in->Length % NORX32_RATEBYTES] = 0x01;\n\t\t\t\t\tblock[block->Length - 1] |= 0x80;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tin->Read(block, 0, NORX32_RATEBYTES);\n\t\t\t\t}\t\n\t\t\t\tBuffer::BlockCopy(block, 0, state_buffer, 0, NORX32_RATEBYTES);\n\t\t\t\tstate[15] ^= (UInt32)tag;\n\t\t\t\tNorxCore32::_F(state, rounds);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\tstate[j] ^= state_buffer[j];\n\t\t\t\t};\n\t\t\t\tNorxCore32::_burn(state_buffer);\n\t\t\t\tNorxCore32::_burn(block);\n\t\t\t}\n\t\t\tstate_buffer[0] ^= (state_buffer[1] ^ block[0]) + NORX32_CAPBYTES;\n\t\t}\n\n\t\tstatic void _encrypt_p1(array<UInt32>^ state, MemoryStream^ in, const _domain_separator_32 tag, const Byte rounds, MemoryStream^ out)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism = 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0) return;\n\t\t\tarray<UInt32>^ state_buffer = gcnew array<UInt32>(NORX32_RATEWORDS);\n\t\t\tarray<Byte>^ block = gcnew array<Byte>(NORX32_RATEBYTES);\n\t\t\tfor (Int64 i = 0; i < in->Length; i += NORX32_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX32_RATEBYTES >= in->Length;\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tif (i < in->Length)\n\t\t\t\t\t\tin->Read(block, 0, in->Length % NORX32_RATEBYTES);\n\t\t\t\t\tblock[in->Length % NORX32_RATEBYTES] = 0x01;\n\t\t\t\t\tblock[block->Length - 1] |= 0x80;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tin->Read(block, 0, NORX32_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tBuffer::BlockCopy(block, 0, state_buffer, 0, NORX32_RATEBYTES);\n\t\t\t\tstate[15] ^= (UInt32)tag;\n\t\t\t\tNorxCore32::_F(state, rounds);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\tstate[j] ^= state_buffer[j];\n\t\t\t\t};\n\t\t\t\tBuffer::BlockCopy(state, 0, block, 0, NORX32_RATEBYTES);\n\t\t\t\tif (last)\n\t\t\t\t\tout->Write(block, 0, in->Length % NORX32_RATEBYTES);\n\t\t\t\telse\n\t\t\t\t\tout->Write(block, 0, NORX32_RATEBYTES);\n\t\t\t\tNorxCore32::_burn(block);\n\t\t\t\tNorxCore32::_burn(state_buffer);\n\t\t\t}\n\t\t\tstate_buffer[0] ^= (state_buffer[1] ^ block[0]) + NORX32_CAPBYTES;\n\t\t}\n\n\t\tstatic void _decrypt_p1(\n\t\t\tarray<UInt32>^ state, \n\t\t\tMemoryStream^ in, \n\t\t\tconst _domain_separator_32 tag, \n\t\t\tconst Byte rounds, \n\t\t\tint tagBytesInMessage, \n\t\t\tMemoryStream^ out)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism = 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0) return;\n\t\t\tInt64 actualLength = in->Length - tagBytesInMessage;\n\t\t\tarray<UInt32>^ state_buffer = gcnew array<UInt32>(NORX32_RATEWORDS);\n\t\t\tarray<Byte>^ block = gcnew array<Byte>(NORX32_RATEBYTES);\n\t\t\tfor (Int64 i = 0; i < actualLength; i += NORX32_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX32_RATEBYTES >= actualLength;\n\t\t\t\tstate[15] ^= (UInt32)tag;\n\t\t\t\tNorxCore32::_F(state, rounds);\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(state, 0, block, 0, NORX32_RATEBYTES); // !!store state in last block, then overwrite with ciphertext\n\t\t\t\t\tif (i < actualLength)\n\t\t\t\t\t\tin->Read(block, 0, actualLength % NORX32_RATEBYTES);\n\t\t\t\t\tblock[actualLength % NORX32_RATEBYTES] ^= 0x01; // remove the padding\n\t\t\t\t\tblock[block->Length - 1] ^= 0x80;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tin->Read(block, 0, NORX32_RATEBYTES);\n\t\t\t\t}\t\n\t\t\t\tBuffer::BlockCopy(block, 0, state_buffer, 0, NORX32_RATEBYTES);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\tUInt32 c = state_buffer[j];\n\t\t\t\t\tstate_buffer[j] ^= state[j];\n\t\t\t\t\tstate[j] = c;\n\t\t\t\t};\n\t\t\t\tBuffer::BlockCopy(state_buffer, 0, block, 0, NORX32_RATEBYTES);\n\t\t\t\tif (last)\n\t\t\t\t\tout->Write(block, 0, actualLength % NORX32_RATEBYTES);\n\t\t\t\telse\n\t\t\t\t\tout->Write(block, 0, NORX32_RATEBYTES);\n\t\t\t\tNorxCore32::_burn(state_buffer);\n\t\t\t\tNorxCore32::_burn(block);\n\t\t\t}\n\t\t\tstate_buffer[0] ^= (state_buffer[1] ^ block[0]) + NORX32_CAPBYTES;\n\t\t}\n\n\t\tstatic void _encrypt_p2(array<array<UInt32>^>^ states, MemoryStream^ in, const _domain_separator_32 tag, const Byte rounds, const Byte lanes, MemoryStream^ out)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism > 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0) return;\n\t\t\tByte laneptr = 0;\n\t\t\tarray<UInt32>^ state_buffer = gcnew array<UInt32>(NORX32_RATEWORDS);\n\t\t\tarray<Byte>^ block = gcnew array<Byte>(NORX32_RATEBYTES);\n\t\t\tfor (Int64 i = 0; i < in->Length; i += NORX32_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX32_RATEBYTES >= in->Length;\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tif (i < in->Length)\n\t\t\t\t\t\tin->Read(block, 0, in->Length % NORX32_RATEBYTES);\n\t\t\t\t\tblock[in->Length % NORX32_RATEBYTES] = 0x01;\n\t\t\t\t\tblock[block->Length - 1] |= 0x80;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tin->Read(block, 0, NORX32_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tBuffer::BlockCopy(block, 0, state_buffer, 0, NORX32_RATEBYTES);\n\t\t\t\tstates[laneptr][15] ^= (UInt32)tag;\n\t\t\t\tNorxCore32::_F(states[laneptr], rounds);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\t// STATE = STATE ^ P = C\n\t\t\t\t\tstates[laneptr][j] ^= state_buffer[j];\n\t\t\t\t};\n\t\t\t\tif (out != nullptr)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(states[laneptr], 0, block, 0, NORX32_RATEBYTES);\n\t\t\t\t\tif (last)\n\t\t\t\t\t\tout->Write(block, 0, in->Length % NORX32_RATEBYTES);\n\t\t\t\t\telse\n\t\t\t\t\t\tout->Write(block, 0, NORX32_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tlaneptr = ++laneptr % lanes;\n\t\t\t\tNorxCore32::_burn(state_buffer);\n\t\t\t\tNorxCore32::_burn(block);\n\t\t\t}\n\t\t\tstate_buffer[0] ^= (state_buffer[1] ^ block[0]) + NORX32_CAPBYTES;\n\t\t}\n\n\t\tstatic void _decrypt_p2(array<array<UInt32>^>^ states, MemoryStream^ in, const _domain_separator_32 tag, const Byte rounds, const Byte lanes, int tagBytesInMessage, MemoryStream^ out)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism > 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0) return;\n\t\t\tInt64 actualLength = in->Length - tagBytesInMessage;\n\t\t\tByte laneptr = 0;\n\t\t\tarray<UInt32>^ state_buffer = gcnew array<UInt32>(NORX32_RATEWORDS);\n\t\t\tarray<Byte>^ block = gcnew array<Byte>(NORX32_RATEBYTES);\n\t\t\tfor (Int64 i = 0; i < actualLength; i += NORX32_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX32_RATEBYTES >= actualLength;\n\t\t\t\tstates[laneptr][15] ^= (UInt32)tag;\n\t\t\t\tNorxCore32::_F(states[laneptr], rounds);\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(states[laneptr], 0, block, 0, NORX32_RATEBYTES); // !!store state in last block, then overwrite with ciphertext\n\t\t\t\t\tif (i < actualLength)\n\t\t\t\t\t\tin->Read(block, 0, actualLength % NORX32_RATEBYTES);\n\t\t\t\t\tblock[actualLength % NORX32_RATEBYTES] ^= 0x01;\n\t\t\t\t\tblock[block->Length - 1] ^= 0x80;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tin->Read(block, 0, NORX32_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tBuffer::BlockCopy(block, 0, state_buffer, 0, NORX32_RATEBYTES);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\t// C = (from encryption) P ^ STATE, to recover P then C ^ STATE = P, to recover STATE, then P ^ C\n\t\t\t\t\tUInt32 c = state_buffer[j];\n\t\t\t\t\tstate_buffer[j] ^= states[laneptr][j];\n\t\t\t\t\tstates[laneptr][j] = c;\n\t\t\t\t};\n\t\t\t\tBuffer::BlockCopy(state_buffer, 0, block, 0, NORX32_RATEBYTES);\n\t\t\t\tif (last)\n\t\t\t\t\tout->Write(block, 0, in->Length % NORX32_RATEBYTES);\n\t\t\t\telse\n\t\t\t\t\tout->Write(block, 0, NORX32_RATEBYTES);\n\t\t\t\tlaneptr = ++laneptr % lanes;\n\t\t\t\tNorxCore32::_burn(state_buffer);\n\t\t\t\tNorxCore32::_burn(block);\n\t\t\t}\n\t\t\tstate_buffer[0] ^= (state_buffer[1] ^ block[0]) + NORX32_CAPBYTES;\n\t\t}\n\n\t\tstatic __inline void _finalize_toStream(\n\t\t\tarray<UInt32>^ state, \n\t\t\tarray<const UInt32>^ k, \n\t\t\tconst Byte rounds, \n\t\t\tconst short tagsizebits, \n\t\t\tMemoryStream^ outTag)\n\t\t{\n\t\t\tstate[15] ^= _domain_separator_32::FINAL_TAG_32;\n\n\t\t\tNorxCore32::_F(state, rounds);\n\t\t\tstate[12] ^= k[0];\n\t\t\tstate[13] ^= k[1];\n\t\t\tstate[14] ^= k[2];\n\t\t\tstate[15] ^= k[3];\n\t\t\tNorxCore32::_F(state, rounds);\n\t\t\tstate[12] ^= k[0];\n\t\t\tstate[13] ^= k[1];\n\t\t\tstate[14] ^= k[2];\n\t\t\tstate[15] ^= k[3];\n\n\t\t\tarray<Byte>^ tempTag = gcnew array<Byte>(tagsizebits / 8);\n\t\t\tBuffer::BlockCopy(state, NORX32_RATEWORDS * NORX32_WORDBYTES, tempTag, 0, tempTag->Length); // extract Tag\n\t\t\toutTag->Write(tempTag, 0, tempTag->Length);\n\t\t\tNorxCore32::_burn(tempTag);\n\t\t\tNorxCore32::_burn(state); // at this point we can burn the state \n\t\t\tstate[0] ^= (state[1] ^ tempTag[0]) + NORX32_CAPBYTES;\n\t\t}\n\t}\n}\n#endif // !NORX_NORX_CORE32"
        },
        {
            "file_name": "NorxCore64.cpp",
            "content": "using namespace System;\nusing namespace System::Runtime::InteropServices;\n\n#pragma once\n\n#ifndef NORX_NORX_CORE64\n#define NORX_NORX_CORE64\n#include <stdlib.h> // only needed for _rotr64 and _lotr\n\nnamespace NorxManaged\n{\n\tnamespace NorxCore64\n\t{\n#define NORX64_WORDBYTES\t8\n#define NORX64_STATEWORDS\t16\n#define NORX64_STATEBYTES\t128\n#define NORX64_NONCEBYTES\t32\n#define NORX64_NONCEWORDS\t4\n#define NORX64_KEYBYTES\t\t32\n#define NORX64_KEYWORDS\t\t4\n#define NORX64_RATEBYTES\t96\n#define NORX64_RATEWORDS\t12\n#define NORX64_CAPBYTES\t\t32\n#define NORX64_CAPWORDS\t\t4\n#define NORX64_TAGBYTES\t\t32\n#define NORX64_TAGWORDS\t\t4\n#define ROTR64(x, y) _rotr64(x, y)\n\n// The nonlinear primitive \n#define _H(A, B) ( A ^ B ^ (( (A) & (B) ) << 1) )\n\n// The quarter-round \n#define _G64(A, B, C, D)                               \\\n{                                                   \\\n    (A) = _H(A, B); (D) ^= (A); (D) = ROTR64((D), 8); \\\n    (C) = _H(C, D); (B) ^= (C); (B) = ROTR64((B), 19); \\\n    (A) = _H(A, B); (D) ^= (A); (D) = ROTR64((D), 40); \\\n    (C) = _H(C, D); (B) ^= (C); (B) = ROTR64((B), 63); \\\n}\n\t\t//These BURN methods should survive compiler optimization, they are only used at the end of a process\n\t\t//Just in case, reference the source array in the calling function in some meaningful way to keep the references alive before the garbage collecter gets them\n\t\tstatic void _burn(array<UInt64>^ thing)\n\t\t{\n\t\t\tif (thing == nullptr) return;\n\t\t\ttry {\n\t\t\t\tfor (Byte i = 0; i < thing->Length; i++)\n\t\t\t\t{\n\t\t\t\t\tthing[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (...) { throw; }\n\t\t}\n\t\tstatic void _burn(array<Byte>^ thing)\n\t\t{\n\t\t\tif (thing == nullptr) return;\n\t\t\ttry {\n\t\t\t\tfor (int i = 0; i < thing->Length; i++)\n\t\t\t\t{\n\t\t\t\t\tthing[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (...) { throw; }\n\t\t}\n\n\t\tstatic __inline void _F(array<UInt64>^ state, const Byte rounds)\n\t\t{\n\t\t\t// normally this would be unrolled for performance, but with variable round amounts, that would be tedious to implement\n\t\t\tfor (Byte i = 0; i < rounds; i++)\n\t\t\t{\n\t\t\t\t// Column step \n\t\t\t\t_G64(state[0], state[4], state[8], state[12]);\n\t\t\t\t_G64(state[1], state[5], state[9], state[13]);\n\t\t\t\t_G64(state[2], state[6], state[10], state[14]);\n\t\t\t\t_G64(state[3], state[7], state[11], state[15]);\n\t\t\t\t// Diagonal step \n\t\t\t\t_G64(state[0], state[5], state[10], state[15]);\n\t\t\t\t_G64(state[1], state[6], state[11], state[12]);\n\t\t\t\t_G64(state[2], state[7], state[8], state[13]);\n\t\t\t\t_G64(state[3], state[4], state[9], state[14]);\n\t\t\t}\n\t\t}\n\n\t\t// Low-level operations \n\t\tstatic __inline array<UInt64>^ _init(array<const Byte>^ n, array<const UInt64>^ k, \n\t\t\tByte rounds, Byte lanes, short tagSizeBits)\n\t\t{\n\t\t\tarray<UInt64>^ state;\n#ifndef USE_COMPUTED_CONSTANTS\n\t\t\tstate = gcnew array<UInt64>(NORX64_STATEWORDS);\n\t\t\tif (n != nullptr)  // nonce is optional, so check for null\n\t\t\t\tBuffer::BlockCopy(n, 0, state, 0, NORX64_NONCEBYTES);\n\t\t\tBuffer::BlockCopy(k, 0, state, NORX64_NONCEBYTES, NORX64_KEYBYTES);\n\n\t\t\t//instead of using the _F construction twice with 0,1,2...15 as the initial state, use pre-computed constants\n\t\t\tstate[8] = 0xB15E641748DE5E6BUL;\n\t\t\tstate[9] = 0xAA95E955E10F8410UL;\n\t\t\tstate[10] = 0x28D1034441A9DD40UL;\n\t\t\tstate[11] = 0x7F31BBF964E93BF5UL;\n\n\t\t\t//while using pre-computed constants, merge in the parameters to the operation\n\t\t\tstate[12] = 0xB5E9E22493DFFB96UL ^ 64UL;\n\t\t\tstate[13] = 0xB980C852479FAFBDUL ^ (UInt64)rounds;\n\t\t\tstate[14] = 0xDA24516BF55EAFD4UL ^ (UInt64)lanes;\n\t\t\tstate[15] = 0x86026AE8536F1501UL ^ (UInt64)tagSizeBits;\n#else\n\t\t\tstate = gcnew array<UInt64>{\n\t\t\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n\t\t\t};\n\t\t\t_F(state, 2);\n\t\t\tif (n != nullptr)  // nonce is optional, so check for null\n\t\t\t\tBuffer::BlockCopy(n, 0, state, 0, NORX64_NONCEBYTES);\n\t\t\tBuffer::BlockCopy(k, 0, state, NORX64_NONCEBYTES, NORX64_KEYBYTES);\n\t\t\tstate[12] ^= 64UL;\n\t\t\tstate[13] ^= (UInt64)rounds;\n\t\t\tstate[14] ^= (UInt64)lanes;\n\t\t\tstate[15] ^= (UInt64)tagSizeBits;\n#endif\n\t\t\t_F(state, rounds);\n\n\t\t\tstate[12] ^= k[0];\n\t\t\tstate[13] ^= k[1];\n\t\t\tstate[14] ^= k[2];\n\t\t\tstate[15] ^= k[3];\n\t\t\t\n\t\t\treturn state;\n\t\t}\n\n\t\tstatic void _absorb(array<UInt64>^ state, array<const Byte>^ in, const _domain_separator_64 tag, const Byte rounds)\n\t\t{\n\t\t\t// Used for P=1, and Header and Footer/Trailer (using appropriate domain separation constant)\n\t\t\tif (in == nullptr || in->Length == 0) return;\n\t\t\tInt64 outptr = 0;\n\t\t\tarray<UInt64>^ state_buffer = gcnew array<UInt64>(NORX64_RATEWORDS);\n\t\t\tfor (int i = 0; i < in->Length; i += NORX64_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX64_RATEBYTES >= in->Length;\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tarray<Byte>^ LastBlock = gcnew array<Byte>(NORX64_RATEBYTES);\n\t\t\t\t\tif (i < in->Length)\n\t\t\t\t\t\tBuffer::BlockCopy(in, i, LastBlock, 0, in->Length % NORX64_RATEBYTES);\n\t\t\t\t\tLastBlock[in->Length % NORX64_RATEBYTES] = 0x01;\n\t\t\t\t\tLastBlock[LastBlock->Length - 1] |= 0x80;\n\t\t\t\t\tBuffer::BlockCopy(LastBlock, 0, state_buffer, 0, NORX64_RATEBYTES);\n\t\t\t\t\t_burn(LastBlock);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(in, i, state_buffer, 0, NORX64_RATEBYTES);\n\t\t\t\t}\t\t\t\n\t\t\t\tstate[15] ^= (UInt64)tag;\n\t\t\t\t_F(state, rounds);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\tstate[j] ^= state_buffer[j];\n\t\t\t\t};\n\t\t\t}\n\t\t\t_burn(state_buffer);\n\t\t\tstate_buffer[0] ^= state_buffer[1] ^ NORX64_CAPBYTES;\n\t\t}\n\n\t\tstatic void _encrypt_p1(\n\t\t\tarray<UInt64>^ state, \n\t\t\tarray<const Byte>^ in, int index, int length,\n\t\t\tconst _domain_separator_64 tag, \n\t\t\tconst Byte rounds, \n\t\t\tarray<Byte>^ out, int outIndex) // the input and output length will be the same (the TAG is added in another step)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism = 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0 || length == 0) return;\n\t\t\tint apparentLength = index + length;\n\t\t\tif (apparentLength > in->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore64::_encrypt_p1->The given index and length goes beyond the bounds of the supplied input array.\");\n\t\t\tif (outIndex + length > out->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore64::_encrypt_p1->The given index and length goes beyond the bounds of the supplied output array.\");\n\t\t\tint outptr = outIndex;\n\t\t\tarray<UInt64>^ state_buffer = gcnew array<UInt64>(NORX64_RATEWORDS);\n\t\t\tfor (int i = index; i < apparentLength; i += NORX64_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX64_RATEBYTES >= apparentLength;\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tarray<Byte>^ LastBlock = gcnew array<Byte>(NORX64_RATEBYTES);\n\t\t\t\t\tif (i < apparentLength)\n\t\t\t\t\t\tBuffer::BlockCopy(in, i, LastBlock, 0, apparentLength % NORX64_RATEBYTES);\n\t\t\t\t\tLastBlock[apparentLength % NORX64_RATEBYTES] = 0x01;\n\t\t\t\t\tLastBlock[LastBlock->Length - 1] |= 0x80;\n\t\t\t\t\tBuffer::BlockCopy(LastBlock, 0, state_buffer, 0, NORX64_RATEBYTES);\n\t\t\t\t\t_burn(LastBlock);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(in, i, state_buffer, 0, NORX64_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tstate[15] ^= (UInt64)tag;\n\t\t\t\t_F(state, rounds);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\tstate[j] ^= state_buffer[j];\n\t\t\t\t};\n\t\t\t\tif (last)\n\t\t\t\t\tBuffer::BlockCopy(state, 0, out, outptr, apparentLength % NORX64_RATEBYTES);\n\t\t\t\telse\n\t\t\t\t\tBuffer::BlockCopy(state, 0, out, outptr, NORX64_RATEBYTES);\n\t\t\t\toutptr += NORX64_RATEBYTES;\n\t\t\t}\n\t\t\t_burn(state_buffer);\n\t\t\tstate_buffer[0] ^= state_buffer[1] ^ NORX64_CAPBYTES;\n\t\t}\n\n\t\tstatic void _decrypt_p1(\n\t\t\tarray<UInt64>^ state, \n\t\t\tarray<const Byte>^ in, int index, int length, \n\t\t\tconst _domain_separator_64 tag, \n\t\t\tconst Byte rounds, \n\t\t\tint tagBytesInMessage, \n\t\t\tarray<Byte>^% out, int outIndex)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism = 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0 || length == 0) return;\n\t\t\tint apparentLength = index + length;\n\t\t\tif (apparentLength > in->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore64::_decrypt_p1->The given index and length goes beyond the bounds of the supplied input array.\");\n\t\t\tif (outIndex + length - tagBytesInMessage > out->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore64::_decrypt_p1->The given index and length goes beyond the bounds of the supplied output array.\");\n\t\t\tint outptr = outIndex;\n\t\t\tint actualLength = apparentLength - tagBytesInMessage; // the tag is processed in another step\n\t\t\tarray<UInt64>^ state_buffer = gcnew array<UInt64>(NORX64_RATEWORDS);\n\t\t\tfor (int i = index; i < actualLength; i += NORX64_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX64_RATEBYTES >= actualLength;\n\t\t\t\tstate[15] ^= (UInt64)tag;\n\t\t\t\t_F(state, rounds);\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tarray<Byte>^ LastBlock = gcnew array<Byte>(NORX64_RATEBYTES);\n\t\t\t\t\tBuffer::BlockCopy(state, 0, LastBlock, 0, NORX64_RATEBYTES); // !!store state in last block, then overwrite with ciphertext\n\t\t\t\t\tif (i < actualLength)\n\t\t\t\t\t\tBuffer::BlockCopy(in, i, LastBlock, 0, actualLength % NORX64_RATEBYTES);\n\t\t\t\t\tLastBlock[actualLength % NORX64_RATEBYTES] ^= 0x01; // remove the padding\n\t\t\t\t\tLastBlock[LastBlock->Length - 1] ^= 0x80;\n\t\t\t\t\tBuffer::BlockCopy(LastBlock, 0, state_buffer, 0, NORX64_RATEBYTES);\n\t\t\t\t\t_burn(LastBlock);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(in, i, state_buffer, 0, NORX64_RATEBYTES);\n\t\t\t\t}\t\t\t\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\tUInt64 c = state_buffer[j];\n\t\t\t\t\tstate_buffer[j] ^= state[j];\n\t\t\t\t\tstate[j] = c;\n\t\t\t\t};\n\t\t\t\tif (last)\n\t\t\t\t\tBuffer::BlockCopy(state_buffer, 0, out, outptr, actualLength % NORX64_RATEBYTES);\n\t\t\t\telse\n\t\t\t\t\tBuffer::BlockCopy(state_buffer, 0, out, outptr, NORX64_RATEBYTES);\n\t\t\t\toutptr += NORX64_RATEBYTES;\n\t\t\t}\n\t\t\t_burn(state_buffer);\n\t\t\tstate_buffer[0] ^= state_buffer[1] ^ NORX64_CAPBYTES;\n\t\t}\n\n\t\tstatic void _encrypt_p2(\n\t\t\tarray<array<UInt64>^>^ states, \n\t\t\tarray<const Byte>^ in, int index, int length, \n\t\t\tconst _domain_separator_64 tag, \n\t\t\tconst Byte rounds, \n\t\t\tconst Byte lanes, \n\t\t\tarray<Byte>^% out, int outIndex)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism > 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0 || length == 0) return;\n\t\t\tint apparentLength = index + length;\n\t\t\tif (apparentLength > in->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore64::_encrypt_p2->The given index and length goes beyond the bounds of the supplied input array.\");\n\t\t\tif (outIndex + length > out->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore64::_encrypt_p2->The given index and length goes beyond the bounds of the supplied output array.\");\n\t\t\tint outptr = outIndex;\n\t\t\tByte laneptr = 0;\n\t\t\tarray<UInt64>^ state_buffer = gcnew array<UInt64>(NORX64_RATEWORDS);\n\t\t\tfor (int i = index; i < apparentLength; i += NORX64_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX64_RATEBYTES >= in->Length;\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tarray<Byte>^ LastBlock = gcnew array<Byte>(NORX64_RATEBYTES);\n\t\t\t\t\tif (i < in->Length)\n\t\t\t\t\t\tBuffer::BlockCopy(in, i, LastBlock, 0, apparentLength % NORX64_RATEBYTES);\n\t\t\t\t\tLastBlock[in->Length % NORX64_RATEBYTES] = 0x01;\n\t\t\t\t\tLastBlock[LastBlock->Length - 1] |= 0x80;\n\t\t\t\t\tBuffer::BlockCopy(LastBlock, 0, state_buffer, 0, LastBlock->Length);\n\t\t\t\t\t_burn(LastBlock);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(in, i, state_buffer, 0, NORX64_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tstates[laneptr][15] ^= (UInt64)tag;\n\t\t\t\t_F(states[laneptr], rounds);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\t// STATE = STATE ^ P = C\n\t\t\t\t\tstates[laneptr][j] ^= state_buffer[j];\n\t\t\t\t};\n\t\t\t\tif (out != nullptr)\n\t\t\t\t{\n\t\t\t\t\tif (last)\n\t\t\t\t\t\tBuffer::BlockCopy(states[laneptr], 0, out, outptr, apparentLength % NORX64_RATEBYTES);\n\t\t\t\t\telse\n\t\t\t\t\t\tBuffer::BlockCopy(states[laneptr], 0, out, outptr, NORX64_RATEBYTES);\n\t\t\t\t\toutptr += NORX64_RATEBYTES;\n\t\t\t\t}\n\t\t\t\tlaneptr = ++laneptr % lanes;\n\t\t\t}\n\t\t\t_burn(state_buffer);\n\t\t\tstate_buffer[0] ^= state_buffer[1] ^ NORX64_CAPBYTES;\n\t\t}\n\n\t\tstatic void _decrypt_p2(\n\t\t\tarray<array<UInt64>^>^ states, \n\t\t\tarray<const Byte>^ in, int index, int length,\n\t\t\tconst _domain_separator_64 tag, \n\t\t\tconst Byte rounds, \n\t\t\tconst Byte lanes, \n\t\t\tint tagBytesInMessage, \n\t\t\tarray<Byte>^% out, int outIndex)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism > 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0 || length == 0) return;\n\t\t\tint apparentLength = index + length;\n\t\t\tif (apparentLength > in->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore64::_decrypt_p2->The given index and length goes beyond the bounds of the supplied input array.\");\n\t\t\tif (outIndex + length - tagBytesInMessage > out->Length)\n\t\t\t\tthrow gcnew System::IndexOutOfRangeException(\"NorxCore64::_decrypt_p2->The given index and length goes beyond the bounds of the supplied output array.\");\n\n\t\t\tint outptr = outIndex;\n\t\t\tint actualLength = apparentLength - tagBytesInMessage; // the tag is processed in another step\n\t\t\tByte laneptr = 0;\n\t\t\tarray<UInt64>^ state_buffer = gcnew array<UInt64>(NORX64_RATEWORDS);\n\t\t\tfor (int i = index; i < actualLength; i += NORX64_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX64_RATEBYTES >= actualLength;\n\t\t\t\tstates[laneptr][15] ^= (UInt64)tag;\n\t\t\t\t_F(states[laneptr], rounds);\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tarray<Byte>^ LastBlock = gcnew array<Byte>(NORX64_RATEBYTES);\n\t\t\t\t\tBuffer::BlockCopy(states[laneptr], 0, LastBlock, 0, NORX64_RATEBYTES); // !!store state in last block, then overwrite with ciphertext\n\t\t\t\t\tif (i < actualLength)\n\t\t\t\t\t\tBuffer::BlockCopy(in, i, LastBlock, 0, actualLength % NORX64_RATEBYTES);\n\t\t\t\t\tLastBlock[actualLength % NORX64_RATEBYTES] ^= 0x01;\n\t\t\t\t\tLastBlock[LastBlock->Length - 1] ^= 0x80;\n\t\t\t\t\tBuffer::BlockCopy(LastBlock, 0, state_buffer, 0, LastBlock->Length);\n\t\t\t\t\t_burn(LastBlock);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(in, i, state_buffer, 0, NORX64_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\t// C = (from encryption) P ^ STATE, to recover P then C ^ STATE = P, to recover STATE, then P ^ C\n\t\t\t\t\tUInt64 c = state_buffer[j];\n\t\t\t\t\tstate_buffer[j] ^= states[laneptr][j];\n\t\t\t\t\tstates[laneptr][j] = c;\n\t\t\t\t};\n\t\t\t\tif (last)\n\t\t\t\t\tBuffer::BlockCopy(state_buffer, 0, out, outptr, actualLength % NORX64_RATEBYTES);\n\t\t\t\telse\n\t\t\t\t\tBuffer::BlockCopy(state_buffer, 0, out, outptr, NORX64_RATEBYTES);\n\t\t\t\toutptr += NORX64_RATEBYTES;\n\t\t\t\tlaneptr = ++laneptr % lanes;\n\t\t\t}\n\t\t\t_burn(state_buffer);\n\t\t\tstate_buffer[0] ^= state_buffer[1] ^ NORX64_CAPBYTES;\n\t\t}\n\n\t\t//static __inline void _branch(array<UInt64>^ state, Byte lane, const Byte rounds)\n\t\t//{\n\t\t//\tstate[15] ^= BRANCH_TAG_64;\n\t\t//\t_F(state, rounds);\n\t\t//\t// Inject lane ID \n\t\t//\tfor (Byte i = 0; i < NORX64_RATEWORDS; ++i) {\n\t\t//\t\tstate[i] ^= lane;\n\t\t//\t}\n\t\t//}\n\n\t\t// stateDest ^= (processed)stateSource, then overwrite stateSource\n\t\tstatic __inline void _merge(array<UInt64>^ stateDest, array<UInt64>^ stateSource, const Byte rounds)\n\t\t{\n\t\t\tstateSource[15] ^= MERGE_TAG_64;\n\t\t\t_F(stateSource, rounds);\n\t\t\tfor (Byte i = 0; i < 16; ++i) {\n\t\t\t\tstateDest[i] ^= stateSource[i];\n\t\t\t\tstateSource[i] |= UInt64::MaxValue; // destroy contents of old state\n\t\t\t}\n\t\t}\n\n\t\tstatic __inline void _finalize(array<UInt64>^ state, array<const UInt64>^ k, const Byte rounds, const short tagsizebits, array<Byte>^% outTag)\n\t\t{\n\t\t\tstate[15] ^= FINAL_TAG_64;\n\n\t\t\t_F(state, rounds);\n\t\t\tstate[12] ^= k[0];\n\t\t\tstate[13] ^= k[1];\n\t\t\tstate[14] ^= k[2];\n\t\t\tstate[15] ^= k[3];\n\t\t\t_F(state, rounds);\n\t\t\tstate[12] ^= k[0];\n\t\t\tstate[13] ^= k[1];\n\t\t\tstate[14] ^= k[2];\n\t\t\tstate[15] ^= k[3];\n\n\t\t\tBuffer::BlockCopy(state, NORX64_RATEWORDS * NORX64_WORDBYTES, outTag, 0, tagsizebits / 8); // extract Tag\n\t\t\t_burn(state); // at this point we can burn the state \n\t\t\tstate[0] ^= state[state[15] % 7] ^ NORX64_CAPBYTES; // prevent compiler optimizations?\n\t\t}\n\t}\n}\n#endif // !NORX_NORX_CORE64"
        },
        {
            "file_name": "NorxCore64Streams.cpp",
            "content": "#pragma once\n\n#ifndef NORX_NORX_CORE64_STREAMS\n#define NORX_NORX_CORE64_STREAMS\n#include <stdlib.h> // only needed for _rotr64 and _lotr\n#include \"NorxCore64.cpp\"\n\nnamespace NorxManaged\n{\n\tnamespace NorxCore64\n\t{\n\t\t// Low-level operations \n\t\tstatic void _absorb(array<UInt64>^ state, MemoryStream^ in, const _domain_separator_64 tag, const Byte rounds)\n\t\t{\n\t\t\t// Used for P=1, and Header and Footer/Trailer (using appropriate domain separation constant)\n\t\t\tif (in == nullptr || in->Length == 0) return;\n\t\t\tInt64 outptr = 0;\n\t\t\tarray<UInt64>^ state_buffer = gcnew array<UInt64>(NORX64_RATEWORDS);\n\t\t\tarray<Byte>^ block = gcnew array<Byte>(NORX64_RATEBYTES);\n\t\t\tfor (Int64 i = 0; i < in->Length; i += NORX64_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX64_RATEBYTES >= in->Length;\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tif (i < in->Length)\n\t\t\t\t\t\tin->Read(block, 0, in->Length % NORX64_RATEBYTES);\n\t\t\t\t\tblock[in->Length % NORX64_RATEBYTES] = 0x01;\n\t\t\t\t\tblock[block->Length - 1] |= 0x80;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tin->Read(block, 0, NORX64_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tBuffer::BlockCopy(block, 0, state_buffer, 0, NORX64_RATEBYTES);\n\t\t\t\tstate[15] ^= (UInt64)tag;\n\t\t\t\tNorxCore64::_F(state, rounds);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\tstate[j] ^= state_buffer[j];\n\t\t\t\t};\n\t\t\t\tNorxCore64::_burn(state_buffer);\n\t\t\t\tNorxCore64::_burn(block);\n\t\t\t}\n\t\t\tstate_buffer[0] ^= (state_buffer[1] ^ block[0]) + NORX64_CAPBYTES;\n\t\t}\n\n\t\tstatic void _encrypt_p1(array<UInt64>^ state, MemoryStream^ in, const _domain_separator_64 tag, const Byte rounds, MemoryStream^ out)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism = 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0) return;\n\t\t\tarray<UInt64>^ state_buffer = gcnew array<UInt64>(NORX64_RATEWORDS);\n\t\t\tarray<Byte>^ block = gcnew array<Byte>(NORX64_RATEBYTES);\n\t\t\tfor (Int64 i = 0; i < in->Length; i += NORX64_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX64_RATEBYTES >= in->Length;\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tif (i < in->Length)\n\t\t\t\t\t\tin->Read(block, 0, in->Length % NORX64_RATEBYTES);\n\t\t\t\t\tblock[in->Length % NORX64_RATEBYTES] = 0x01;\n\t\t\t\t\tblock[block->Length - 1] |= 0x80;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tin->Read(block, 0, NORX64_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tBuffer::BlockCopy(block, 0, state_buffer, 0, NORX64_RATEBYTES);\n\t\t\t\tstate[15] ^= (UInt64)tag;\n\t\t\t\tNorxCore64::_F(state, rounds);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\tstate[j] ^= state_buffer[j];\n\t\t\t\t};\n\t\t\t\tBuffer::BlockCopy(state, 0, block, 0, NORX64_RATEBYTES);\n\t\t\t\tif (last)\n\t\t\t\t\tout->Write(block, 0, in->Length % NORX64_RATEBYTES);\n\t\t\t\telse\n\t\t\t\t\tout->Write(block, 0, NORX64_RATEBYTES);\n\t\t\t\tNorxCore64::_burn(block);\n\t\t\t\tNorxCore64::_burn(state_buffer);\n\t\t\t}\n\t\t\tstate_buffer[0] ^= (state_buffer[1] ^ block[0]) + NORX64_CAPBYTES;\n\t\t}\n\n\t\tstatic void _decrypt_p1(array<UInt64>^ state, MemoryStream^ in, const _domain_separator_64 tag, const Byte rounds, int tagBytesInMessage, MemoryStream^ out)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism = 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0) return;\n\t\t\tInt64 actualLength = in->Length - tagBytesInMessage;\n\t\t\tarray<UInt64>^ state_buffer = gcnew array<UInt64>(NORX64_RATEWORDS);\n\t\t\tarray<Byte>^ block = gcnew array<Byte>(NORX64_RATEBYTES);\n\t\t\tfor (Int64 i = 0; i < actualLength; i += NORX64_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX64_RATEBYTES >= actualLength;\n\t\t\t\tstate[15] ^= (UInt64)tag;\n\t\t\t\tNorxCore64::_F(state, rounds);\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(state, 0, block, 0, NORX64_RATEBYTES); // !!store state in last block, then overwrite with ciphertext\n\t\t\t\t\tif (i < actualLength)\n\t\t\t\t\t\tin->Read(block, 0, actualLength % NORX64_RATEBYTES);\n\t\t\t\t\tblock[actualLength % NORX64_RATEBYTES] ^= 0x01; // remove the padding\n\t\t\t\t\tblock[block->Length - 1] ^= 0x80;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tin->Read(block, 0, NORX64_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tBuffer::BlockCopy(block, 0, state_buffer, 0, NORX64_RATEBYTES);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\tUInt64 c = state_buffer[j];\n\t\t\t\t\tstate_buffer[j] ^= state[j];\n\t\t\t\t\tstate[j] = c;\n\t\t\t\t};\n\t\t\t\tBuffer::BlockCopy(state_buffer, 0, block, 0, NORX64_RATEBYTES);\n\t\t\t\tif (last)\n\t\t\t\t\tout->Write(block, 0, actualLength % NORX64_RATEBYTES);\n\t\t\t\telse\n\t\t\t\t\tout->Write(block, 0, NORX64_RATEBYTES);\n\t\t\t\tNorxCore64::_burn(state_buffer);\n\t\t\t\tNorxCore64::_burn(block);\n\t\t\t}\n\t\t\tstate_buffer[0] ^= (state_buffer[1] ^ block[0]) + NORX64_CAPBYTES;\n\t\t}\n\n\t\tstatic void _encrypt_p2(array<array<UInt64>^>^ states, MemoryStream^ in, const _domain_separator_64 tag, const Byte rounds, const Byte lanes, MemoryStream^ out)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism > 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0) return;\n\t\t\tByte laneptr = 0;\n\t\t\tarray<UInt64>^ state_buffer = gcnew array<UInt64>(NORX64_RATEWORDS);\n\t\t\tarray<Byte>^ block = gcnew array<Byte>(NORX64_RATEBYTES);\n\t\t\tfor (Int64 i = 0; i < in->Length; i += NORX64_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX64_RATEBYTES >= in->Length;\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tif (i < in->Length)\n\t\t\t\t\t\tin->Read(block, 0, in->Length % NORX64_RATEBYTES);\n\t\t\t\t\tblock[in->Length % NORX64_RATEBYTES] = 0x01;\n\t\t\t\t\tblock[block->Length - 1] |= 0x80;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tin->Read(block, 0, NORX64_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tBuffer::BlockCopy(block, 0, state_buffer, 0, NORX64_RATEBYTES);\n\t\t\t\tstates[laneptr][15] ^= (UInt64)tag;\n\t\t\t\tNorxCore64::_F(states[laneptr], rounds);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\t// STATE = STATE ^ P = C\n\t\t\t\t\tstates[laneptr][j] ^= state_buffer[j];\n\t\t\t\t};\n\t\t\t\tif (out != nullptr)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(states[laneptr], 0, block, 0, NORX64_RATEBYTES);\n\t\t\t\t\tif (last)\n\t\t\t\t\t\tout->Write(block, 0, in->Length % NORX64_RATEBYTES);\n\t\t\t\t\telse\n\t\t\t\t\t\tout->Write(block, 0, NORX64_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tlaneptr = ++laneptr % lanes;\n\t\t\t\tNorxCore64::_burn(state_buffer);\n\t\t\t\tNorxCore64::_burn(block);\n\t\t\t}\n\t\t\tstate_buffer[0] ^= (state_buffer[1] ^ block[0]) + NORX64_CAPBYTES;\n\t\t}\n\n\t\tstatic void _decrypt_p2(array<array<UInt64>^>^ states, MemoryStream^ in, const _domain_separator_64 tag, const Byte rounds, const Byte lanes, int tagBytesInMessage, MemoryStream^ out)\n\t\t{\n\t\t\t// Used only for Payload of Parallelism > 1 (not P=0)\n\t\t\tif (in == nullptr || in->Length == 0) return;\n\t\t\tInt64 actualLength = in->Length - tagBytesInMessage;\n\t\t\tByte laneptr = 0;\n\t\t\tarray<UInt64>^ state_buffer = gcnew array<UInt64>(NORX64_RATEWORDS);\n\t\t\tarray<Byte>^ block = gcnew array<Byte>(NORX64_RATEBYTES);\n\t\t\tfor (Int64 i = 0; i < actualLength; i += NORX64_RATEBYTES)\n\t\t\t{\n\t\t\t\tbool last = i + NORX64_RATEBYTES >= actualLength;\n\t\t\t\tstates[laneptr][15] ^= (UInt64)tag;\n\t\t\t\t_F(states[laneptr], rounds);\n\t\t\t\tif (last)\n\t\t\t\t{\n\t\t\t\t\tBuffer::BlockCopy(states[laneptr], 0, block, 0, NORX64_RATEBYTES); // !!store state in last block, then overwrite with ciphertext\n\t\t\t\t\tif (i < actualLength)\n\t\t\t\t\t\tin->Read(block, 0, actualLength % NORX64_RATEBYTES);\n\t\t\t\t\tblock[actualLength % NORX64_RATEBYTES] ^= 0x01;\n\t\t\t\t\tblock[block->Length - 1] ^= 0x80;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tin->Read(block, 0, NORX64_RATEBYTES);\n\t\t\t\t}\n\t\t\t\tBuffer::BlockCopy(block, 0, state_buffer, 0, NORX64_RATEBYTES);\n\t\t\t\tfor (int j = 0; j < state_buffer->Length; j++)\n\t\t\t\t{\n\t\t\t\t\t// C = (from encryption) P ^ STATE, to recover P then C ^ STATE = P, to recover STATE, then P ^ C\n\t\t\t\t\tUInt64 c = state_buffer[j];\n\t\t\t\t\tstate_buffer[j] ^= states[laneptr][j];\n\t\t\t\t\tstates[laneptr][j] = c;\n\t\t\t\t};\n\t\t\t\tBuffer::BlockCopy(state_buffer, 0, block, 0, NORX64_RATEBYTES);\n\t\t\t\tif (last)\n\t\t\t\t\tout->Write(block, 0, actualLength % NORX64_RATEBYTES);\n\t\t\t\telse\n\t\t\t\t\tout->Write(block, 0, NORX64_RATEBYTES);\n\t\t\t\tlaneptr = ++laneptr % lanes;\n\t\t\t\tNorxCore64::_burn(state_buffer);\n\t\t\t\tNorxCore64::_burn(block);\n\t\t\t}\n\t\t\tstate_buffer[0] ^= (state_buffer[1] ^ block[0]) + NORX64_CAPBYTES;\n\t\t}\n\n\t\tstatic __inline void _finalize_toStream(\n\t\t\tarray<UInt64>^ state,\n\t\t\tarray<const UInt64>^ k,\n\t\t\tconst Byte rounds,\n\t\t\tconst short tagsizebits,\n\t\t\tMemoryStream^ outTag)\n\t\t{\n\t\t\tstate[15] ^= _domain_separator_64::FINAL_TAG_64;\n\n\t\t\tNorxCore64::_F(state, rounds);\n\t\t\tstate[12] ^= k[0];\n\t\t\tstate[13] ^= k[1];\n\t\t\tstate[14] ^= k[2];\n\t\t\tstate[15] ^= k[3];\n\t\t\tNorxCore64::_F(state, rounds);\n\t\t\tstate[12] ^= k[0];\n\t\t\tstate[13] ^= k[1];\n\t\t\tstate[14] ^= k[2];\n\t\t\tstate[15] ^= k[3];\n\n\t\t\tarray<Byte>^ tempTag = gcnew array<Byte>(tagsizebits / 8);\n\t\t\tBuffer::BlockCopy(state, NORX64_RATEWORDS * NORX64_WORDBYTES, tempTag, 0, tempTag->Length); // extract Tag\n\t\t\toutTag->Write(tempTag, 0, tempTag->Length);\n\t\t\tNorxCore64::_burn(tempTag);\n\t\t\tNorxCore64::_burn(state); // at this point we can burn the state \n\t\t\tstate[0] ^= (state[1] ^ tempTag[0]) + NORX64_CAPBYTES;\n\t\t}\n\t}\n}\n#endif // !NORX_NORX_CORE64_STREAMS"
        },
        {
            "file_name": "NorxManaged32.cpp",
            "content": "/*\n* Modified from NORX reference source code package - reference C implementations\n*\n* Written 2014-2016 by:\n*\n*      - Samuel Neves <sneves@dei.uc.pt>\n*      - Philipp Jovanovic <philipp@jovanovic.io>\n*\n* Modified 2017-2019 by:\n*      - Dustin Sparks <sparkdustjoe@gmail.com>\n*\n* To the extent possible under law, the author(s) have dedicated all copyright\n* and related and neighboring rights to this software to the public domain\n* worldwide. This software is distributed without any warranty.\n*\n* You should have received a copy of the CC0 Public Domain Dedication along with\n* this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n\n#pragma once\n\n#include \"NorxManaged32.h\"\n#include \"NorxCore32.cpp\"\n\nnamespace NorxManaged\n{\n\t// 32 BIT PUBLIC METHODS\n\tint NorxManaged::Norx32::Encrypt(\n\t\tarray<const Byte>^ Header,\n\t\tarray<const Byte>^ Message, int Index, int Length,\n\t\tarray<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key, array<const Byte>^ Nonce,\n\t\tconst Byte Rounds, const Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\t[Out] array<Byte>^% Output)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX32_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional. Must be \" + NORX32_KEYBYTES + \" bytes.\");\n\t\tif (Nonce != nullptr && Nonce->Length != NORX32_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX32_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (TagBitSize == 0 || TagBitSize % 8 != 0)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"TagBitSize\", \"Tag length must be specified as a multiple of 8 bits, and (0 < x <= \" + NORX32_TAGBYTES * 8 + \").\");\n\t\tif (Message != nullptr && (Index + Length) > Message->Length)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Length\", \"The specified length at the given index exceeds the length of the message.\");\n\t\tarray<const UInt32>^ kt = reinterpret_cast<array<const UInt32>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt32>^ kt = gcnew array<UInt32>(NORX32_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX32_KEYBYTES);\n\t\tarray<UInt32>^ state = NorxCore32::_init(Nonce, kt, Rounds, Parallelism, TagBitSize);\n\t\tNorxCore32::_absorb(state, Header, HEADER_TAG_32, Rounds);\n\t\tOutput = gcnew array<Byte>(Message != nullptr ? Length + NORX32_TAGBYTES : NORX32_TAGBYTES);\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore32::_encrypt_p1(state, Message, Index, Length, PAYLOAD_TAG_32, Rounds, Output, 0);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt32>^>^ lanes = gcnew array<array<UInt32>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_32;\n\t\t\tNorxCore32::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++) // THIS IS RIPE FOR .NET PARALLELISM\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt32>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX32_RATEWORDS; ++j) \n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t} //end .net parallelism\n\t\t\tNorxCore32::_burn(state);\n\t\t\tNorxCore32::_encrypt_p2(lanes, Message, Index, Length, PAYLOAD_TAG_32, Rounds, Parallelism, Output, 0);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore32::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxCore32::_absorb(state, Trailer, TRAILER_TAG_32, Rounds);\n\t\tarray<Byte>^ tempTag = gcnew array<Byte>(NORX32_TAGBYTES);\n\t\tNorxCore32::_finalize(state, kt, Rounds, TagBitSize, tempTag);\n\t\tBuffer::BlockCopy(tempTag, 0, Output, Length, NORX32_TAGBYTES);\n\t\tNorxCore32::_burn(tempTag);\n\t\tkt = nullptr;\n\t\treturn 0; // OK\n\t}\n\n\tint NorxManaged::Norx32::Encrypt(\n\t\tarray<const Byte>^ Header, array<const Byte>^ Message, array<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key, array<const Byte>^ Nonce,\n\t\tconst Byte Rounds, const Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\t[Out] array<Byte>^% Output)\n\t{\n\t\treturn NorxManaged::Norx32::Encrypt(Header, Message, 0, Message == nullptr ? 0 : Message->Length, Trailer, \n\t\t\tKey, Nonce, Rounds, Parallelism, TagBitSize, Output);\n\t}\n\n\tint NorxManaged::Norx32::DecryptVerify(\n\t\tarray<const Byte>^ Header,\n\t\tarray<const Byte>^ Message, int Index, int Length,\n\t\tarray<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key, array<const Byte>^ Nonce,\n\t\tconst Byte Rounds, const Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\t[Out] array<Byte>^% Output)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX32_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional.  Must be \" + NORX32_KEYBYTES + \" bytes.\");\n\t\tif (Nonce == nullptr && Nonce->Length != NORX32_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX32_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (TagBitSize == 0 || TagBitSize % 8 != 0)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"TagBitSize\", \"Tag length must be specified as a multiple of 8 bits, and (0 < x <= \" + NORX32_TAGBYTES * 8 + \").\");\n\t\tif (Message == nullptr || Message->LongLength < TagBitSize / 8 || Length < TagBitSize / 8)\n\t\t\tthrow gcnew ArgumentNullException(\"Message\", \"Message cannot be NULL, and must be at least (TagBitSize / 8) bytes in length.\");\n\t\tarray<const UInt32>^ kt = reinterpret_cast<array<const UInt32>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt32>^ kt = gcnew array<UInt32>(NORX32_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX32_KEYBYTES);\n\t\tarray<UInt32>^ state = NorxCore32::_init(Nonce, kt, Rounds, Parallelism, TagBitSize);\n\t\tNorxCore32::_absorb(state, Header, HEADER_TAG_32, Rounds);\n\t\tOutput = nullptr;\n\t\tif (Message != nullptr)\n\t\t\tOutput = (Length >= NORX32_TAGBYTES) ? gcnew array<Byte>(Length - NORX32_TAGBYTES) : nullptr;\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore32::_decrypt_p1(state, Message, Index, Length, PAYLOAD_TAG_32, Rounds, TagBitSize / 8, Output, 0);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt32>^>^ lanes = gcnew array<array<UInt32>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_32;\n\t\t\tNorxCore32::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt32>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX32_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore32::_burn(state);\n\t\t\tNorxCore32::_decrypt_p2(lanes, Message, Index, Length, PAYLOAD_TAG_32, Rounds, Parallelism, TagBitSize / 8, Output, 0);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore32::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxCore32::_absorb(state, Trailer, TRAILER_TAG_32, Rounds);\n\t\tarray<Byte>^ tempTag = gcnew array<Byte>(TagBitSize / 8);\n\t\tarray<Byte>^ inputTag = gcnew array<Byte>(TagBitSize / 8);\n\t\tBuffer::BlockCopy(Message, Length - (TagBitSize / 8), inputTag, 0, TagBitSize / 8);\n\t\tNorxCore32::_finalize(state, kt, Rounds, TagBitSize, tempTag);\n\t\tint returnValue = -1; // assume failure\n\t\tif (Norx32::norx_verify_tag32((array<const Byte>^)inputTag, (array<const Byte>^)tempTag) == 0)\n\t\t\treturnValue = 0; // OK\n\t\telse\n\t\t{\n\t\t\tNorxCore32::_burn(Output);\n\t\t\tThreading::Thread::MemoryBarrier();\n\t\t\tOutput = nullptr;\n\t\t}\n\t\tNorxCore32::_burn(inputTag);\n\t\tNorxCore32::_burn(tempTag);\n\t\tkt = nullptr;\n\t\treturn returnValue;\n\t}\n\n\tint NorxManaged::Norx32::DecryptVerify(\n\t\tarray<const Byte>^ Header, array<const Byte>^ Message, array<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key, array<const Byte>^ Nonce,\n\t\tconst Byte Rounds, const Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\t[Out] array<Byte>^% Output)\n\t{\n\t\treturn NorxManaged::Norx32::DecryptVerify(Header, Message, 0, Message == nullptr ? 0 : Message->Length, Trailer, \n\t\t\tKey, Nonce, Rounds, Parallelism, TagBitSize, Output);\n\t}\n\n\tint NorxManaged::Norx32::Encrypt_Detached(\n\t\tarray<const Byte>^ Header,\n\t\tarray<const Byte>^ Message, int Index, int Length,\n\t\tarray<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key, array<const Byte>^ Nonce,\n\t\tconst Byte Rounds, const Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\t[Out] array<Byte>^% Output,\n\t\t[Out] array<Byte>^% Tag)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX32_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional. Must be \" + NORX32_KEYBYTES + \" bytes.\");\n\t\tif (Nonce == nullptr && Nonce->Length != NORX32_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX32_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (TagBitSize == 0 || TagBitSize % 8 != 0)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"TagBitSize\", \"Tag length must be specified as a multiple of 8 bits, and (0 < x <= \" + NORX32_TAGBYTES * 8 + \").\");\n\t\t//if (output_tag == nullptr || output_tag->Length * 8 != TagBitSize)\n\t\t//\tthrow gcnew ArgumentOutOfRangeException(\"output_tag\", \"The Tag buffer must be allocated by the caller, and be the same bit size as specified in TagBitSize.\");\n\t\tTag = gcnew array<Byte>(NORX32_TAGBYTES);\n\t\tOutput = Message != nullptr ? gcnew array<Byte>(Message->Length) : nullptr;\n\t\tarray<const UInt32>^ kt = reinterpret_cast<array<const UInt32>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt32>^ kt = gcnew array<UInt32>(NORX32_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX32_KEYBYTES);\n\t\tarray<UInt32>^ state = NorxCore32::_init(Nonce, kt, Rounds, Parallelism, TagBitSize);\n\t\tNorxCore32::_absorb(state, Header, HEADER_TAG_32, Rounds);\n\t\tif (Message != nullptr)\n\t\t\tOutput = gcnew array<Byte>(Length);\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore32::_encrypt_p1(state, Message, Index, Length, PAYLOAD_TAG_32, Rounds, Output, 0);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt32>^>^ lanes = gcnew array<array<UInt32>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_32;\n\t\t\tNorxCore32::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt32>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX32_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore32::_burn(state);\n\t\t\tNorxCore32::_encrypt_p2(lanes, Message, Index, Length, PAYLOAD_TAG_32, Rounds, Parallelism, Output, 0);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore32::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxCore32::_absorb(state, Trailer, TRAILER_TAG_32, Rounds);\n\t\tNorxCore32::_finalize(state, kt, Rounds, TagBitSize, Tag);\n\t\treturn 0; // OK\n\t}\n\n\tint NorxManaged::Norx32::Encrypt_Detached(\n\t\tarray<const Byte>^ Header, array<const Byte>^ Message, array<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key,\tarray<const Byte>^ Nonce,\n\t\tconst Byte Rounds, const Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\t[Out] array<Byte>^% Output,\n\t\t[Out] array<Byte>^% Tag)\n\t{\n\t\treturn NorxManaged::Norx32::Encrypt_Detached(Header, Message, 0, Message == nullptr ? 0 : Message->Length, Trailer, \n\t\t\tKey, Nonce, Rounds, Parallelism, TagBitSize, Output, Tag);\n\t}\n\n\tint NorxManaged::Norx32::DecryptVerify_Detached(\n\t\tarray<const Byte>^ Header,\n\t\tarray<const Byte>^ Message, int Index, int Length,\n\t\tarray<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key,\tarray<const Byte>^ Nonce,\n\t\tconst Byte Rounds, const Byte Parallelism,\n\t\tarray<const Byte>^ Tag,\n\t\t[Out] array<Byte>^% Output)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX32_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional.  Must be \" + NORX32_KEYBYTES + \" bytes.\");\n\t\tif (Nonce == nullptr && Nonce->Length != NORX32_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX32_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (Tag == nullptr || Tag->Length > NORX32_TAGBYTES)\n\t\t\tthrow gcnew ArgumentNullException(\"Tag\", \"Tag cannot be NULL or 0 length, and must be less than or equal to \" + NORX32_TAGBYTES + \" bytes in length.\");\n\t\tarray<const UInt32>^ kt = reinterpret_cast<array<const UInt32>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt32>^ kt = gcnew array<UInt32>(NORX32_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX32_KEYBYTES);\n\t\tarray<UInt32>^ state = NorxCore32::_init(Nonce, kt, Rounds, Parallelism, Tag->Length * 8);\n\t\tNorxCore32::_absorb(state, Header, HEADER_TAG_32, Rounds);\n\t\tOutput = nullptr;\n\t\tif (Message != nullptr)\n\t\t\tOutput = gcnew array<Byte>(Length);\n\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore32::_decrypt_p1(state, Message, Index, Length, PAYLOAD_TAG_32, Rounds, 0, Output, 0);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt32>^>^ lanes = gcnew array<array<UInt32>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_32;\n\t\t\tNorxCore32::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt32>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX32_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore32::_burn(state);\n\t\t\tNorxCore32::_decrypt_p2(lanes, Message, Index, Length, PAYLOAD_TAG_32, Rounds, Parallelism, 0, Output, 0);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore32::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxCore32::_absorb(state, Trailer, TRAILER_TAG_32, Rounds);\n\t\tarray<Byte>^ temptag = gcnew array<Byte>(Tag->Length);\n\t\tNorxCore32::_finalize(state, kt, Rounds, Tag->Length * 8, temptag);\n\t\tif (Norx32::norx_verify_tag32(Tag, (array<const Byte>^)temptag) == 0)\n\t\t{\n\t\t\treturn 0; // ok\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNorxCore32::_burn(Output);\n\t\t\tOutput = nullptr;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tint NorxManaged::Norx32::DecryptVerify_Detached(\n\t\tarray<const Byte>^ Header, array<const Byte>^ Message, array<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key, array<const Byte>^ Nonce,\n\t\tconst Byte Rounds, const Byte Parallelism,\n\t\tarray<const Byte>^ Tag,\n\t\t[Out] array<Byte>^% Output)\n\t{\n\t\treturn NorxManaged::Norx32::DecryptVerify_Detached(Header, Message, 0, Message == nullptr ? 0 : Message->Length, Trailer, \n\t\t\tKey, Nonce, Rounds, Parallelism, Tag, Output);\n\t}\n}\n"
        },
        {
            "file_name": "NorxManaged64.cpp",
            "content": "/*\n* Modified from NORX reference source code package - reference C implementations\n*\n* Written 2014-2016 by:\n*\n*      - Samuel Neves <sneves@dei.uc.pt>\n*      - Philipp Jovanovic <philipp@jovanovic.io>\n*\n* Modified 2017-2019 by:\n*      - Dustin Sparks <sparkdustjoe@gmail.com>\n*\n* To the extent possible under law, the author(s) have dedicated all copyright\n* and related and neighboring rights to this software to the public domain\n* worldwide. This software is distributed without any warranty.\n*\n* You should have received a copy of the CC0 Public Domain Dedication along with\n* this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n\n#pragma once\n\n#include \"NorxManaged64.h\"\n#include \"NorxCore64.cpp\"\n\nnamespace NorxManaged\n{\n\t// 64 BIT PUBLIC METHODS \n\tint NorxManaged::Norx64::Encrypt(\n\t\tarray<const Byte>^ Header,\n\t\tarray<const Byte>^ Message, int Index, int Length,\n\t\tarray<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key, array<const Byte>^ Nonce,\n\t\tconst Byte Rounds, const Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\t[Out] array<Byte>^% Output)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX64_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional. Must be \" + NORX64_KEYBYTES + \" bytes.\");\n\t\tif (Nonce != nullptr && Nonce->Length != NORX64_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX64_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (TagBitSize == 0 || TagBitSize % 8 != 0)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"TagBitSize\", \"Tag length must be specified as a multiple of 8 bits, and (0 < x <= \" + NORX64_TAGBYTES * 8 + \").\");\n\t\tif (Message != nullptr && (Index + Length) > Message->Length)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Length\", \"The specified length at the given index exceeds the length of the message.\");\n\t\tarray<const UInt64>^ kt = reinterpret_cast<array<const UInt64>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt64>^ kt = gcnew array<UInt64>(NORX64_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX64_KEYBYTES);\n\t\tarray<UInt64>^ state = NorxCore64::_init(Nonce, kt, Rounds, Parallelism, TagBitSize);\n\t\tNorxCore64::_absorb(state, Header, HEADER_TAG_64, Rounds);\n\t\tOutput = gcnew array<Byte>(Message != nullptr ? Length + NORX64_TAGBYTES : NORX64_TAGBYTES);\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore64::_encrypt_p1(state, Message, Index, Length, PAYLOAD_TAG_64, Rounds, Output, 0);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt64>^>^ lanes = gcnew array<array<UInt64>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_64;\n\t\t\tNorxCore64::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor(Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt64>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX64_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore64::_burn(state);\n\t\t\tNorxCore64::_encrypt_p2(lanes, Message, Index, Length, PAYLOAD_TAG_64, Rounds, Parallelism, Output, 0);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore64::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxCore64::_absorb(state, Trailer, TRAILER_TAG_64, Rounds);\n\t\tarray<Byte>^ tempTag = gcnew array<Byte>(NORX64_TAGBYTES);\n\t\tNorxCore64::_finalize(state, kt, Rounds, TagBitSize, tempTag);\n\t\tBuffer::BlockCopy(tempTag, 0, Output, Output->Length - NORX64_TAGBYTES, NORX64_TAGBYTES);\n\t\tNorxCore64::_burn(tempTag);\n\t\tkt = nullptr;\n\t\treturn 0; // OK\n\t}\n\n\tint NorxManaged::Norx64::Encrypt(\n\t\tarray<const Byte>^ Header, array<const Byte>^ Message, array<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key, array<const Byte>^ Nonce,\n\t\tconst Byte Rounds, const Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\t[Out] array<Byte>^% Output)\n\t{\n\t\treturn NorxManaged::Norx64::Encrypt(Header, Message, 0, Message == nullptr ? 0 : Message->Length, Trailer, \n\t\t\tKey, Nonce, Rounds, Parallelism, TagBitSize, Output);\n\t}\n\n\tint NorxManaged::Norx64::DecryptVerify(\n\t\tarray<const Byte>^ Header,\n\t\tarray<const Byte>^ Message, int Index, int Length,\n\t\tarray<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tconst Byte Rounds,\n\t\tconst Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\t[Out] array<Byte>^% Output)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX64_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional.  Must be \" + NORX64_KEYBYTES + \" bytes.\");\n\t\tif (Nonce == nullptr && Nonce->Length != NORX64_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX64_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (TagBitSize == 0 || TagBitSize % 8 != 0)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"TagBitSize\", \"Tag length must be specified as a multiple of 8 bits, and (0 < x <= \" + NORX64_TAGBYTES * 8 + \").\");\n\t\tif (Message == nullptr || Message->LongLength < TagBitSize / 8 || Length < TagBitSize / 8)\n\t\t\tthrow gcnew ArgumentNullException(\"Message\", \"Message cannot be NULL, and must be at least (TagBitSize / 8) in length.\");\n\t\tarray<const UInt64>^ kt = reinterpret_cast<array<const UInt64>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt64>^ kt = gcnew array<UInt64>(NORX64_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX64_KEYBYTES);\n\t\tarray<UInt64>^ state = NorxCore64::_init(Nonce, kt, Rounds, Parallelism, TagBitSize);\n\t\tNorxCore64::_absorb(state, Header, HEADER_TAG_64, Rounds);\n\t\tOutput = nullptr;\n\t\tif (Message != nullptr)\n\t\t\tOutput = Length >= NORX64_TAGBYTES ? gcnew array<Byte>(Length - NORX64_TAGBYTES) : nullptr;\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore64::_decrypt_p1(state, Message, Index, Length, PAYLOAD_TAG_64, Rounds, TagBitSize / 8, Output, 0);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt64>^>^ lanes = gcnew array<array<UInt64>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_64;\n\t\t\tNorxCore64::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt64>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX64_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore64::_burn(state);\n\t\t\tNorxCore64::_decrypt_p2(lanes, Message, Index, Length, PAYLOAD_TAG_64, Rounds, Parallelism, TagBitSize / 8, Output, 0);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore64::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxCore64::_absorb(state, Trailer, TRAILER_TAG_64, Rounds);\n\t\tarray<Byte>^ tempTag = gcnew array<Byte>(TagBitSize / 8);\n\t\tarray<Byte>^ inputTag = gcnew array<Byte>(TagBitSize / 8);\n\t\tBuffer::BlockCopy(Message, Length - (TagBitSize / 8), inputTag, 0, TagBitSize / 8);\n\t\tNorxCore64::_finalize(state, kt, Rounds, TagBitSize, tempTag);\n\t\tint returnValue = -1; // assume failure\n\t\tif (Norx64::norx_verify_tag64((array<const Byte>^)inputTag, (array<const Byte>^)tempTag) == 0)\n\t\t\treturnValue = 0; // OK\n\t\telse\n\t\t{\n\t\t\tNorxCore64::_burn(Output);\n\t\t\tThreading::Thread::MemoryBarrier();\n\t\t\tOutput = nullptr;\n\t\t}\n\t\tNorxCore64::_burn(inputTag);\n\t\tNorxCore64::_burn(tempTag);\n\t\tkt = nullptr;\n\t\treturn returnValue;\n\t}\n\n\tint NorxManaged::Norx64::DecryptVerify(\n\t\tarray<const Byte>^ Header, array<const Byte>^ Message, array<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key, array<const Byte>^ Nonce,\n\t\tconst Byte Rounds, const Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\t[Out] array<Byte>^% Output)\n\t{\n\t\treturn NorxManaged::Norx64::DecryptVerify(Header, Message, 0, Message == nullptr ? 0 : Message->Length, Trailer, Key, Nonce, Rounds, Parallelism, TagBitSize, Output);\n\t}\n\n\tint NorxManaged::Norx64::Encrypt_Detached(\n\t\tarray<const Byte>^ Header,\n\t\tarray<const Byte>^ Message, int Index, int Length,\n\t\tarray<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tconst Byte Rounds,\n\t\tconst Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\t[Out] array<Byte>^% Output,\n\t\t[Out] array<Byte>^% Tag)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX64_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional. Must be \" + NORX64_KEYBYTES + \" bytes.\");\n\t\tif (Nonce == nullptr && Nonce->Length != NORX64_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX64_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (TagBitSize == 0 || TagBitSize % 8 != 0)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"TagBitSize\", \"Tag length must be specified as a multiple of 8, and (0 < x <= \" + NORX64_TAGBYTES * 8 + \").\");\n\t\t//if (output_tag == nullptr || output_tag->Length * 8 != TagBitSize)\n\t\t//\tthrow gcnew ArgumentOutOfRangeException(\"output_tag\", \"The Tag buffer must be allocated by the caller, and be the same bit size as specified in TagBitSize.\");\n\t\tTag = gcnew array<Byte>(NORX64_TAGBYTES);\n\t\tOutput = Message != nullptr ? gcnew array<Byte>(Message->Length) : nullptr;\n\t\tarray<const UInt64>^ kt = reinterpret_cast<array<const UInt64>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt64>^ kt = gcnew array<UInt64>(NORX64_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX64_KEYBYTES);\n\t\tarray<UInt64>^ state = NorxCore64::_init(Nonce, kt, Rounds, Parallelism, TagBitSize);\n\t\tNorxCore64::_absorb(state, Header, HEADER_TAG_64, Rounds);\n\t\tif (Message != nullptr)\n\t\t\tOutput = gcnew array<Byte>(Length);\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore64::_encrypt_p1(state, Message, Index, Length, PAYLOAD_TAG_64, Rounds, Output, 0);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt64>^>^ lanes = gcnew array<array<UInt64>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_64;\n\t\t\tNorxCore64::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt64>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX64_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore64::_burn(state);\n\t\t\tNorxCore64::_encrypt_p2(lanes, Message, Index, Length, PAYLOAD_TAG_64, Rounds, Parallelism, Output, 0);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore64::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxCore64::_absorb(state, Trailer, TRAILER_TAG_64, Rounds);\n\t\tNorxCore64::_finalize(state, kt, Rounds, TagBitSize, Tag); \n\t\tkt = nullptr;\n\t\treturn 0; // OK\n\t}\n\n\tint NorxManaged::Norx64::Encrypt_Detached(\n\t\tarray<const Byte>^ Header,\n\t\tarray<const Byte>^ Message,\n\t\tarray<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tconst Byte Rounds,\n\t\tconst Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\t[Out] array<Byte>^% Output,\n\t\t[Out] array<Byte>^% Tag)\n\t{\n\t\treturn NorxManaged::Norx64::Encrypt_Detached(Header, Message, 0, Message == nullptr ? 0 : Message->Length, Trailer, Key, Nonce, Rounds, Parallelism, TagBitSize, Output, Tag);\n\t}\n\n\tint NorxManaged::Norx64::DecryptVerify_Detached(\n\t\tarray<const Byte>^ Header,\n\t\tarray<const Byte>^ Message, int Index, int Length,\n\t\tarray<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tconst Byte Rounds,\n\t\tconst Byte Parallelism,\n\t\tarray<const Byte>^ Tag,\n\t\t[Out] array<Byte>^% Output)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX64_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional.  Must be \" + NORX64_KEYBYTES + \" bytes.\");\n\t\tif (Nonce == nullptr && Nonce->Length != NORX64_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX64_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (Tag == nullptr || Tag->Length > NORX64_TAGBYTES)\n\t\t\tthrow gcnew ArgumentNullException(\"Tag\", \"Tag cannot be NULL or 0 length, and must be less than or equal to \" + NORX64_TAGBYTES + \" bytes in length.\");\n\t\tarray<const UInt64>^ kt = reinterpret_cast<array<const UInt64>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt64>^ kt = gcnew array<UInt64>(NORX64_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX64_KEYBYTES);\n\t\tarray<UInt64>^ state = NorxCore64::_init(Nonce, kt, Rounds, Parallelism, Tag->Length * 8);\n\t\tNorxCore64::_absorb(state, Header, HEADER_TAG_64, Rounds);\n\t\tOutput = nullptr;\n\t\tif (Message != nullptr)\n\t\t\tOutput = gcnew array<Byte>(Length);\n\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore64::_decrypt_p1(state, Message, Index, Length, PAYLOAD_TAG_64, Rounds, 0, Output, 0);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt64>^>^ lanes = gcnew array<array<UInt64>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_64;\n\t\t\tNorxCore64::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt64>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX64_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore64::_burn(state);\n\t\t\tNorxCore64::_decrypt_p2(lanes, Message, Index, Length, PAYLOAD_TAG_64, Rounds, Parallelism, 0, Output, 0);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore64::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxCore64::_absorb(state, Trailer, TRAILER_TAG_64, Rounds);\n\t\tarray<Byte>^ tempTag = gcnew array<Byte>(Tag->Length);\n\t\tNorxCore64::_finalize(state, kt, Rounds, Tag->Length * 8, tempTag);\n\t\tkt = nullptr;\n\t\tint returnValue = -1;\n\t\tif (Norx64::norx_verify_tag64(Tag, (array<const Byte>^)tempTag) == 0)\n\t\t\treturnValue = 0; // ok\n\t\telse\n\t\t{\n\t\t\tNorxCore64::_burn(Output);\n\t\t\tThreading::Thread::MemoryBarrier();\n\t\t\tOutput = nullptr;\n\t\t\treturnValue = -1;\n\t\t}\n\t\tNorxCore64::_burn(tempTag);\n\t\treturn returnValue;\n\t}\n\n\tint NorxManaged::Norx64::DecryptVerify_Detached(\n\t\tarray<const Byte>^ Header,\n\t\tarray<const Byte>^ Message,\n\t\tarray<const Byte>^ Trailer,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tconst Byte Rounds,\n\t\tconst Byte Parallelism,\n\t\tarray<const Byte>^ Tag,\n\t\t[Out] array<Byte>^% Output)\n\t{\n\t\treturn NorxManaged::Norx64::DecryptVerify_Detached(Header, Message, 0, Message == nullptr ? 0 : Message->Length, Trailer, \n\t\t\tKey, Nonce, Rounds, Parallelism, Tag, Output);\n\t}\n}\n"
        },
        {
            "file_name": "NorxManagedStreams32.cpp",
            "content": "/*\n* Modified from NORX reference source code package - reference C implementations\n*\n* Written 2014-2016 by:\n*\n*      - Samuel Neves <sneves@dei.uc.pt>\n*      - Philipp Jovanovic <philipp@jovanovic.io>\n*\n* Modified 2017-2019 by:\n*      - Dustin Sparks <sparkdustjoe@gmail.com>\n*\n* To the extent possible under law, the author(s) have dedicated all copyright\n* and related and neighboring rights to this software to the public domain\n* worldwide. This software is distributed without any warranty.\n*\n* You should have received a copy of the CC0 Public Domain Dedication along with\n* this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n\n#include \"NorxManaged32.h\"\n#include \"NorxCore32Streams.cpp\"\n\nnamespace NorxManaged\n{\n\t// 32 BIT PUBLIC METHODS\n\tint NorxManaged::Norx32::EncryptStream(\n\t\tMemoryStream^ Header,\n\t\tMemoryStream^ Message,\n\t\tMemoryStream^ Trailer,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tconst Byte Rounds,\n\t\tconst Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\tMemoryStream^ Output)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX32_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional. Must be \" + NORX32_KEYBYTES + \" bytes.\");\n\t\tif (Nonce == nullptr && Nonce->Length != NORX32_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX32_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (TagBitSize == 0 || TagBitSize % 8 != 0)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"TagBitSize\", \"Tag length must be specified as a multiple of 8 bits, and (0 < x <= \" + NORX32_TAGBYTES * 8 + \").\");\n\t\tif (!Output->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Output stream is not writable. Operation Aborted.\");\n\t\tarray<const UInt32>^ kt = reinterpret_cast<array<const UInt32>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt32>^ kt = gcnew array<UInt32>(NORX32_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX32_KEYBYTES);\n\t\tarray<UInt32>^ state = NorxManaged::NorxCore32::_init(Nonce, kt, Rounds, Parallelism, TagBitSize);\n\t\tNorxManaged::NorxCore32::_absorb(state, Header, HEADER_TAG_32, Rounds);\n\t\t//Output = gcnew array<Byte>(Message != nullptr ? Message->Length + NORX32_TAGBYTES : NORX32_TAGBYTES);\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore32::_encrypt_p1(state, Message, PAYLOAD_TAG_32, Rounds, Output);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt32>^>^ lanes = gcnew array<array<UInt32>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_32;\n\t\t\tNorxCore32::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt32>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX32_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore32::_burn(state);\n\t\t\tNorxCore32::_encrypt_p2(lanes, Message, PAYLOAD_TAG_32, Rounds, Parallelism, Output);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore32::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxCore32::_absorb(state, Trailer, TRAILER_TAG_32, Rounds);\n\t\tNorxCore32::_finalize_toStream(state, kt, Rounds, TagBitSize, Output);\n\t\tkt = nullptr;\n\t\treturn 0; // OK\n\t}\n\n\tint NorxManaged::Norx32::DecryptVerifyStream(\n\t\tMemoryStream^ Header,\n\t\tMemoryStream^ Message,\n\t\tMemoryStream^ Trailer,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tconst Byte Rounds,\n\t\tconst Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\tMemoryStream^ Output)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX32_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional.  Must be \" + NORX32_KEYBYTES + \" bytes.\");\n\t\tif (Nonce == nullptr && Nonce->Length != NORX32_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX32_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (TagBitSize == 0 || TagBitSize % 8 != 0)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"TagBitSize\", \"Tag length must be specified as a multiple of 8 bits, and (0 < x <= \" + NORX32_TAGBYTES * 8 + \").\");\n\t\tif (Message == nullptr || Message->Length == 0)\n\t\t\tthrow gcnew ArgumentNullException(\"Message\", \"Message cannot be NULL, and must be at least (TagBitSize / 8) bytes in length.\");\n\t\tif (!Output->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Output stream is not writable. Operation Aborted.\");\n\t\tarray<const UInt32>^ kt = reinterpret_cast<array<const UInt32>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt32>^ kt = gcnew array<UInt32>(NORX32_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX32_KEYBYTES);\n\t\tarray<UInt32>^ state = NorxManaged::NorxCore32::_init(Nonce, kt, Rounds, Parallelism, TagBitSize);\n\t\tNorxManaged::NorxCore32::_absorb(state, Header, HEADER_TAG_32, Rounds);\n\t\t//Output = nullptr;\n\t\t//if (Message != nullptr)\n\t\t//\tOutput = Message->Length >= NORX32_TAGBYTES ? gcnew array<Byte>(Message->Length - NORX32_TAGBYTES) : nullptr;\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore32::_decrypt_p1(state, Message, PAYLOAD_TAG_32, Rounds, TagBitSize / 8, Output);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt32>^>^ lanes = gcnew array<array<UInt32>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_32;\n\t\t\tNorxCore32::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt32>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX32_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore32::_burn(state);\n\t\t\tNorxCore32::_decrypt_p2(lanes, Message, PAYLOAD_TAG_32, Rounds, Parallelism, TagBitSize / 8, Output);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore32::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxManaged::NorxCore32::_absorb(state, Trailer, TRAILER_TAG_32, Rounds);\n\t\tarray<Byte>^ inputTag = gcnew array<Byte>(TagBitSize / 8);\n\t\tMessage->Read(inputTag, 0, TagBitSize / 8);\n\t\tarray<Byte>^ tempTag = gcnew array<Byte>(TagBitSize / 8);\n\t\tNorxManaged::NorxCore32::_finalize(state, kt, Rounds, TagBitSize, tempTag);\n\t\tint returnValue = -1;\n\t\tif (Norx32::norx_verify_tag32((array<const Byte>^)inputTag, (array<const Byte>^)tempTag) == 0)\n\t\t\treturnValue = 0; // OK\n\t\telse\n\t\t{\n\t\t\tNorxCore32::_burn(Output->GetBuffer());\n\t\t\tOutput->Flush();\n\t\t\tThreading::Thread::MemoryBarrier();\n\t\t\t//Output->Dispose();\n\t\t\treturnValue = -1;\n\t\t}\n\t\tNorxCore32::_burn(tempTag);\n\t\tNorxCore32::_burn(inputTag);\n\t\tkt = nullptr;\n\t\treturn returnValue;\n\t}\n\n\tint NorxManaged::Norx32::EncryptStream_Detached(\n\t\tMemoryStream^ Header,\n\t\tMemoryStream^ Message,\n\t\tMemoryStream^ Trailer,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tconst Byte Rounds,\n\t\tconst Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\tMemoryStream^ Output,\n\t\tMemoryStream^ Tag)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX32_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional. Must be \" + NORX32_KEYBYTES + \" bytes.\");\n\t\tif (Nonce == nullptr && Nonce->Length != NORX32_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX32_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (TagBitSize == 0 || TagBitSize % 8 != 0)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"TagBitSize\", \"Tag length must be specified as a multiple of 8 bits, and (0 < x <= \" + NORX32_TAGBYTES * 8 + \").\");\n\t\tif (!Output->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Output stream is not writable. Operation Aborted.\");\n\t\tif (!Tag->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Tag Output stream is not writable. Operation Aborted.\");\n\t\t//if (output_tag == nullptr || output_tag->Length * 8 != TagBitSize)\n\t\t//\tthrow gcnew ArgumentOutOfRangeException(\"output_tag\", \"The Tag buffer must be allocated by the caller, and be the same bit size as specified in TagBitSize.\");\n\t\t//Tag = gcnew array<Byte>(NORX32_TAGBYTES);\n\t\t//Output = Message != nullptr ? gcnew array<Byte>(Message->Length) : nullptr;\n\t\tarray<const UInt32>^ kt = reinterpret_cast<array<const UInt32>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt32>^ kt = gcnew array<UInt32>(NORX32_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX32_KEYBYTES);\n\t\tarray<UInt32>^ state = NorxManaged::NorxCore32::_init(Nonce, kt, Rounds, Parallelism, TagBitSize);\n\t\tNorxManaged::NorxCore32::_absorb(state, Header, HEADER_TAG_32, Rounds);\n\t\t//if (Message != nullptr)\n\t\t//\tOutput = gcnew array<Byte>(Message->Length);\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore32::_encrypt_p1(state, Message, PAYLOAD_TAG_32, Rounds, Output);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt32>^>^ lanes = gcnew array<array<UInt32>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_32;\n\t\t\tNorxCore32::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt32>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX32_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore32::_burn(state);\n\t\t\tNorxCore32::_encrypt_p2(lanes, Message, PAYLOAD_TAG_32, Rounds, Parallelism, Output);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore32::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxManaged::NorxCore32::_absorb(state, Trailer, TRAILER_TAG_32, Rounds);\n\t\tNorxManaged::NorxCore32::_finalize_toStream(state, kt, Rounds, TagBitSize, Tag);\n\t\tkt = nullptr;\n\t\treturn 0; // OK\n\t}\n\n\tint NorxManaged::Norx32::DecryptVerifyStream_Detached(\n\t\tMemoryStream^  Header,\n\t\tMemoryStream^  Message,\n\t\tMemoryStream^  Trailer,\n\t\tarray<const Byte>^  Key,\n\t\tarray<const Byte>^  Nonce,\n\t\tconst Byte Rounds,\n\t\tconst Byte Parallelism,\n\t\tarray<const Byte>^ Tag,\n\t\tMemoryStream^  Output)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX32_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional.  Must be \" + NORX32_KEYBYTES + \" bytes.\");\n\t\tif (Nonce == nullptr && Nonce->Length != NORX32_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX32_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (Tag == nullptr || Tag->Length > NORX32_TAGBYTES)\n\t\t\tthrow gcnew ArgumentNullException(\"Tag\", \"Tag cannot be NULL or 0 length, and must be less than or equal to \" + NORX32_TAGBYTES + \" bytes in length.\");\n\t\tif (!Output->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Output stream is not writable. Operation Aborted.\");\n\t\tarray<const UInt32>^ kt = reinterpret_cast<array<const UInt32>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt32>^ kt = gcnew array<UInt32>(NORX32_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX32_KEYBYTES);\n\t\tarray<UInt32>^ state = NorxManaged::NorxCore32::_init(Nonce, kt, Rounds, Parallelism, Tag->Length * 8);\n\t\tNorxManaged::NorxCore32::_absorb(state, Header, HEADER_TAG_32, Rounds);\n\t\t//Output = nullptr;\n\t\t//if (Message != nullptr)\n\t\t//\tOutput = gcnew array<Byte>(Message->Length);\n\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore32::_decrypt_p1(state, Message, PAYLOAD_TAG_32, Rounds, 0, Output);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt32>^>^ lanes = gcnew array<array<UInt32>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_32;\n\t\t\tNorxCore32::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt32>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX32_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore32::_burn(state);\n\t\t\tNorxCore32::_decrypt_p2(lanes, Message, PAYLOAD_TAG_32, Rounds, Parallelism, 0, Output);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore32::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxManaged::NorxCore32::_absorb(state, Trailer, TRAILER_TAG_32, Rounds);\n\t\tarray<Byte>^ tempTag = gcnew array<Byte>(Tag->Length);\n\t\tNorxManaged::NorxCore32::_finalize(state, kt, Rounds, Tag->Length * 8, tempTag);\n\t\tint returnValue = -1;\n\t\tif (Norx32::norx_verify_tag32(Tag, (array<const Byte>^)tempTag) == 0)\n\t\t\treturnValue = 0; // ok\n\t\telse\n\t\t{\n\t\t\tNorxCore32::_burn(Output->GetBuffer());\n\t\t\tOutput->Flush();\n\t\t\tThreading::Thread::MemoryBarrier();\n\t\t\t//Output->Dispose();\n\t\t\treturnValue = -1;\n\t\t}\n\t\tNorxCore32::_burn(tempTag);\n\t\tkt = nullptr;\n\t\treturn returnValue;\n\t}\n}"
        },
        {
            "file_name": "NorxManagedStreams64.cpp",
            "content": "/*\n* Modified from NORX reference source code package - reference C implementations\n*\n* Written 2014-2016 by:\n*\n*      - Samuel Neves <sneves@dei.uc.pt>\n*      - Philipp Jovanovic <philipp@jovanovic.io>\n*\n* Modified 2017-2019 by:\n*      - Dustin Sparks <sparkdustjoe@gmail.com>\n*\n* To the extent possible under law, the author(s) have dedicated all copyright\n* and related and neighboring rights to this software to the public domain\n* worldwide. This software is distributed without any warranty.\n*\n* You should have received a copy of the CC0 Public Domain Dedication along with\n* this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n\n#include \"NorxManaged64.h\"\n#include \"NorxCore64Streams.cpp\"\n\nusing namespace System::Threading;\nusing namespace System::Threading::Tasks;\n\nnamespace NorxManaged\n{\n\t// 64 BIT PUBLIC METHODS \n\tint NorxManaged::Norx64::EncryptStream(\n\t\tMemoryStream^ Header,\n\t\tMemoryStream^ Message,\n\t\tMemoryStream^ Trailer,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tconst Byte Rounds,\n\t\tconst Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\tMemoryStream^ Output)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX64_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional. Must be \" + NORX64_KEYBYTES + \" bytes.\");\n\t\tif (Nonce == nullptr && Nonce->Length != NORX64_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX64_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (TagBitSize == 0 || TagBitSize % 8 != 0)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"TagBitSize\", \"Tag length must be specified as a multiple of 8 bits, and (0 < x <= \" + NORX64_TAGBYTES * 8 + \").\");\n\t\tif (!Output->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Output stream is not writable. Operation Aborted.\");\n\t\tarray<const UInt64>^ kt = reinterpret_cast<array<const UInt64>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt64>^ kt = gcnew array<UInt64>(NORX64_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX64_KEYBYTES);\n\t\tarray<UInt64>^ state = NorxManaged::NorxCore64::_init(Nonce, kt, Rounds, Parallelism, TagBitSize);\n\t\tNorxManaged::NorxCore64::_absorb(state, Header, HEADER_TAG_64, Rounds);\n\t\t//Output = gcnew array<Byte>(Message != nullptr ? Message->Length + NORX64_TAGBYTES : NORX64_TAGBYTES);\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore64::_encrypt_p1(state, Message, PAYLOAD_TAG_64, Rounds, Output);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt64>^>^ lanes = gcnew array<array<UInt64>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_64;\n\t\t\tNorxCore64::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt64>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX64_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore64::_burn(state);\n\t\t\tNorxCore64::_encrypt_p2(lanes, Message, PAYLOAD_TAG_64, Rounds, Parallelism, Output);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore64::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxManaged::NorxCore64::_absorb(state, Trailer, TRAILER_TAG_64, Rounds);\n\t\tNorxManaged::NorxCore64::_finalize_toStream(state, kt, Rounds, TagBitSize, Output);\n\t\tkt = nullptr;\n\t\treturn 0; // OK\n\t}\n\n\tint NorxManaged::Norx64::DecryptVerifyStream(\n\t\tMemoryStream^ Header,\n\t\tMemoryStream^ Message,\n\t\tMemoryStream^ Trailer,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tconst Byte Rounds,\n\t\tconst Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\tMemoryStream^ Output)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX64_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional.  Must be \" + NORX64_KEYBYTES + \" bytes.\");\n\t\tif (Nonce == nullptr && Nonce->Length != NORX64_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX64_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (TagBitSize == 0 || TagBitSize % 8 != 0)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"TagBitSize\", \"Tag length must be specified as a multiple of 8 bits, and (0 < x <= \" + NORX64_TAGBYTES * 8 + \").\");\n\t\tif (Message == nullptr || Message->Length == 0)\n\t\t\tthrow gcnew ArgumentNullException(\"Message\", \"Message cannot be NULL, and must be at least (TagBitSize / 8) in length.\");\n\t\tif (!Output->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Output stream is not writable. Operation Aborted.\");\n\t\tarray<const UInt64>^ kt = reinterpret_cast<array<const UInt64>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt64>^ kt = gcnew array<UInt64>(NORX64_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX64_KEYBYTES);\n\t\tarray<UInt64>^ state = NorxManaged::NorxCore64::_init(Nonce, kt, Rounds, Parallelism, TagBitSize);\n\t\tNorxManaged::NorxCore64::_absorb(state, Header, HEADER_TAG_64, Rounds);\n\t\t//Output = nullptr;\n\t\t//if (Message != nullptr)\n\t\t//\tOutput = Message->Length >= NORX64_TAGBYTES ? gcnew array<Byte>(Message->Length - NORX64_TAGBYTES) : nullptr;\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore64::_decrypt_p1(state, Message, PAYLOAD_TAG_64, Rounds, TagBitSize / 8, Output);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt64>^>^ lanes = gcnew array<array<UInt64>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_64;\n\t\t\tNorxCore64::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt64>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX64_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore64::_burn(state);\n\t\t\tNorxCore64::_decrypt_p2(lanes, Message, PAYLOAD_TAG_64, Rounds, Parallelism, TagBitSize / 8, Output);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore64::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxManaged::NorxCore64::_absorb(state, Trailer, TRAILER_TAG_64, Rounds);\n\t\tarray<Byte>^ temptag = gcnew array<Byte>(TagBitSize / 8);\n\t\tarray<Byte>^ inputTag = gcnew array<Byte>(TagBitSize / 8);\n\t\tMessage->Read(inputTag, 0, inputTag->Length);\n\t\tNorxManaged::NorxCore64::_finalize(state, kt, Rounds, TagBitSize, temptag);\n\t\tint returnValue = -1;\n\t\tif (Norx64::norx_verify_tag64((array<const Byte>^)inputTag, (array<const Byte>^)temptag) == 0)\n\t\t\treturnValue = 0; // OK\n\t\telse\n\t\t{\n\t\t\tNorxCore64::_burn(Output->GetBuffer());\n\t\t\tOutput->Flush();\n\t\t\tThreading::Thread::MemoryBarrier();\n\t\t\t//Output->Dispose();\n\t\t\treturnValue = -1;\n\t\t}\n\t\tNorxCore64::_burn(temptag);\n\t\tkt = nullptr;\n\t\treturn returnValue;\n\t}\n\n\tint NorxManaged::Norx64::EncryptStream_Detached(\n\t\tMemoryStream^ Header,\n\t\tMemoryStream^ Message,\n\t\tMemoryStream^ Trailer,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tconst Byte Rounds,\n\t\tconst Byte Parallelism,\n\t\tconst short TagBitSize,\n\t\tMemoryStream^ Output,\n\t\tMemoryStream^ Tag)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX64_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional. Must be \" + NORX64_KEYBYTES + \" bytes.\");\n\t\tif (Nonce == nullptr && Nonce->Length != NORX64_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX64_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (TagBitSize == 0 || TagBitSize % 8 != 0)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"TagBitSize\", \"Tag length must be specified as a multiple of 8, and (0 < x <= \" + NORX64_TAGBYTES * 8 + \").\");\n\t\tif (!Output->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Output stream is not writable. Operation Aborted.\");\n\t\tif (!Tag->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Tag Output stream is not writable. Operation Aborted.\");\n\t\t//if (output_tag == nullptr || output_tag->Length * 8 != TagBitSize)\n\t\t//\tthrow gcnew ArgumentOutOfRangeException(\"output_tag\", \"The Tag buffer must be allocated by the caller, and be the same bit size as specified in TagBitSize.\");\n\t\t//Tag = gcnew array<Byte>(NORX64_TAGBYTES);\n\t\t//Output = Message != nullptr ? gcnew array<Byte>( Message->Length) : nullptr;\n\t\tarray<const UInt64>^ kt = reinterpret_cast<array<const UInt64>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt64>^ kt = gcnew array<UInt64>(NORX64_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX64_KEYBYTES);\n\t\tarray<UInt64>^ state = NorxManaged::NorxCore64::_init(Nonce, kt, Rounds, Parallelism, TagBitSize);\n\t\tNorxManaged::NorxCore64::_absorb(state, Header, HEADER_TAG_64, Rounds);\n\t\t//if (Message != nullptr)\n\t\t//\tOutput = gcnew array<Byte>(Message->Length);\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore64::_encrypt_p1(state, Message, PAYLOAD_TAG_64, Rounds, Output);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt64>^>^ lanes = gcnew array<array<UInt64>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_64;\n\t\t\tNorxCore64::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt64>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX64_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore64::_burn(state);\n\t\t\tNorxCore64::_encrypt_p2(lanes, Message, PAYLOAD_TAG_64, Rounds, Parallelism, Output);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore64::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxManaged::NorxCore64::_absorb(state, Trailer, TRAILER_TAG_64, Rounds);\n\t\tNorxManaged::NorxCore64::_finalize_toStream(state, kt, Rounds, TagBitSize, Tag);\n\t\tkt = nullptr;\n\t\treturn 0; // OK\n\t}\n\n\tint NorxManaged::Norx64::DecryptVerifyStream_Detached(\n\t\tMemoryStream^ Header,\n\t\tMemoryStream^ Message,\n\t\tMemoryStream^ Trailer,\n\t\tarray<const Byte>^ Key,\n\t\tarray<const Byte>^ Nonce,\n\t\tconst Byte Rounds,\n\t\tconst Byte Parallelism,\n\t\tarray<const Byte>^ Tag,\n\t\tMemoryStream^ Output)\n\t{\n\t\tif (Key == nullptr || Key->Length != NORX64_KEYBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Key not optional.  Must be \" + NORX64_KEYBYTES + \" bytes.\");\n\t\tif (Nonce == nullptr && Nonce->Length != NORX64_NONCEBYTES)\n\t\t\tthrow gcnew InvalidOperationException(\"Nonce is optional, but must be \" + NORX64_NONCEBYTES + \" when specified.\");\n\t\tif (Rounds < 4)\n\t\t\tthrow gcnew ArgumentOutOfRangeException(\"Rounds\", \"Rounds are limited to a minimum of 4.\");\n\t\tif (Parallelism == 0)\n\t\t\tthrow gcnew NotImplementedException(\"Parallelism must be > 0.\");\n\t\tif (Tag == nullptr || Tag->Length > NORX64_TAGBYTES)\n\t\t\tthrow gcnew ArgumentNullException(\"Tag\", \"Tag cannot be NULL or 0 length, and must be less than or equal to \" + NORX64_TAGBYTES + \" bytes in length.\");\n\t\tif (!Output->CanWrite)\n\t\t\tthrow gcnew InvalidOperationException(\"Output stream is not writable. Operation Aborted.\");\n\t\tarray<const UInt64>^ kt = reinterpret_cast<array<const UInt64>^>(Key); // prevent unneccessary memory copying of the key!\n\t\t//array<UInt64>^ kt = gcnew array<UInt64>(NORX64_KEYWORDS);\n\t\t//Buffer::BlockCopy(Key, 0, kt, 0, NORX64_KEYBYTES);\n\t\tarray<UInt64>^ state = NorxManaged::NorxCore64::_init(Nonce, kt, Rounds, Parallelism, Tag->Length * 8);\n\t\tNorxManaged::NorxCore64::_absorb(state, Header, HEADER_TAG_64, Rounds);\n\t\t//Output = nullptr;\n\t\t//if (Message != nullptr)\n\t\t//\tOutput = gcnew array<Byte>(Message->Length);\n\n\t\tif (Parallelism == 1)\n\t\t{\n\t\t\tNorxCore64::_decrypt_p1(state, Message, PAYLOAD_TAG_64, Rounds, 0, Output);\n\t\t}\n\t\telse if (Parallelism > 1)\n\t\t{\n\t\t\tarray<array<UInt64>^>^ lanes = gcnew array<array<UInt64>^>(Parallelism);\n\t\t\t// all branches get the same base state value operated on by a delimiter and then _F\n\t\t\tstate[15] ^= BRANCH_TAG_64;\n\t\t\tNorxCore64::_F(state, Rounds);\n\t\t\t// the Lane ID is XOR'd in after _F\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tlanes[i] = (array<UInt64>^)state->Clone();\n\t\t\t\tfor (Byte j = 0; j < NORX64_RATEWORDS; ++j)\n\t\t\t\t{\n\t\t\t\t\tlanes[i][j] ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNorxCore64::_burn(state);\n\t\t\tNorxCore64::_decrypt_p2(lanes, Message, PAYLOAD_TAG_64, Rounds, Parallelism, 0, Output);\n\t\t\tfor (Byte i = 0; i < Parallelism; i++)\n\t\t\t{\n\t\t\t\tNorxCore64::_merge(state, lanes[i], Rounds); // merge back into the main state and destroy the lane\n\t\t\t}\n\t\t}\n\t\t//else // Infinite parallelism not implemented (p=0)\n\t\t//{ }\n\t\tNorxManaged::NorxCore64::_absorb(state, Trailer, TRAILER_TAG_64, Rounds);\n\t\tarray<Byte>^ tempTag = gcnew array<Byte>(Tag->Length);\n\t\tNorxManaged::NorxCore64::_finalize(state, kt, Rounds, Tag->Length * 8, tempTag);\n\t\tint returnValue = -1;\n\t\tif (Norx64::norx_verify_tag64(Tag, (array<const Byte>^)tempTag) == 0)\n\t\t\treturnValue = 0; // ok\n\t\telse\n\t\t{\n\t\t\tNorxCore64::_burn(Output->GetBuffer());\n\t\t\tOutput->Flush();\n\t\t\tThreading::Thread::MemoryBarrier();\n\t\t\t//Output->Dispose();\n\t\t\treturnValue = -1;\n\t\t}\n\t\tNorxCore64::_burn(tempTag);\n\t\tkt = nullptr;\n\t\treturn returnValue;\n\t}\n}"
        },
        {
            "file_name": "ocrypt.c",
            "content": "/*\n * Omega Crypt (ocrypt)\n * Brandon Enright <bmenrigh@brandonenright.net>\n * http://www.brandonenright.net/ocrypt/\n *\n * 2014-03-31\n *\n * Placed in the public domain.\n *\n * Submitted to the Password Hashing Competition\n * https://password-hashing.net/index.html\n */\n\n\n#include \"ocrypt.h\"\n\n\n/* Lengths are in bytes */\nint ocrypt(uint8_t *out, size_t outlen, uint8_t *in, size_t inlen,\n\t   uint8_t *salt, size_t saltlen, uint8_t *key, size_t keylen,\n\t   unsigned int t_cost, unsigned int m_cost) {\n\n  uint8_t params[OCRYPT_PARAMS_SIZE];\n  uint8_t chash_out[CHASHSTATESIZE];\n  struct chacha_wrapper_ctx chawctx;\n  uint8_t chacha_key[32];\n  uint8_t chacha_iv[8];\n  uint64_t t_iterations;\n  uint32_t m_array_size;\n  uint32_t m_array_mask;\n  uint64_t *state_array;\n  uint8_t branch_select;\n  uint64_t tmp64;\n\n  /* For the state array manipulation */\n  uint64_t carry;\n  uint32_t tad_a, tad_b;\n  uint64_t tval_a, tval_b;\n\n  uint64_t i; /* Simple iterator */\n\n  /* \n   * Omega Crypt accepts output lengths of {128, 160, 224, 256, 384, 512} bits\n   */\n  if ((outlen != (128 / 8)) && (outlen != (160 / 8)) &&\n      (outlen != (224 / 8)) && (outlen != (256 / 8)) &&\n      (outlen != (384 / 8)) && (outlen != (512 / 8))) {\n    return OCRYPT_E_OLEN;\n  }\n\n  /* \n   * Omega Crypt accepts passwords, salts, and personalized keys of length\n   * less than or equal 255 bytes\n   */\n  if (inlen >= 256) {\n    return OCRYPT_E_PLEN;\n  }\n  if (saltlen >= 256) {\n    return OCRYPT_E_SLEN;\n  }\n  if (keylen >= 256) {\n    return OCRYPT_E_KLEN;\n  }\n\n  /*\n   * Omega Crypt accepts time and memory costs parametrs between 0 and 14\n   * inclusive.\n   *\n   * 0 time cost corresponds to 2^17 (131072) cipher-dependent branches\n   * 14 time cost corresponds to 2^31 (2147483648) cipher-dependent branches\n   *\n   * 0 memory cost corresponds to 1 MiB of memory usage\n   * 14 memory cost corresponds to 16 GiB of memory usage\n   *\n   */\n  if (t_cost > OCRYPT_MAX_TCOST) {\n    return OCRYPT_E_TCOST;\n  }\n  if (m_cost > OCRYPT_MAX_MCOST) {\n    return OCRYPT_E_MCOST;\n  }\n\n  /* \n   * Omega Crypt pads the password, salt, and key with null-bytes each to\n   * a length of 255 bytes and then the 256th byte is set to the length\n   * of each, respectively.  Once padded, the three are laid out in\n   * order <password><salt><key> and then three additional bytes are\n   * appened, one for each of the output size, time cost, and memory cost,\n   * in than order for a total of (256 * 3) + 3 = 771 bytes.\n   */\n\n  /* Do the \"padding\" all in one step */\n  memset(params, 0, OCRYPT_PARAMS_SIZE);\n  /* Copy in the password input bytes */\n  for (i = 0; i < inlen; i++) {\n    params[i] = in[i];\n  }\n  params[255] = inlen; /* Set the 256th password byte to inlen */\n  /* Copy in the salt input bytes */\n  for (i = 0; i < saltlen; i++) {\n    params[256 + i] = salt[i];\n  }\n  params[256 + 255] = saltlen; /* Set the 256th salt byte to saltlen */\n  /* Copy in the key input bytes */\n  for (i = 0; i < keylen; i++) {\n    params[(256 * 2) + i] = key[i];\n  }\n  params[(256 * 2) + 255] = keylen; /* Set the 256th key byte to keylen */\n  /* Set the remaining three bytes to outlen, t_cost, and m_cost */\n  params[(256 * 3) + 0] = outlen;\n  params[(256 * 3) + 1] = t_cost;\n  params[(256 * 3) + 2] = m_cost;\n\n  /* \n   * Omega Crypt hashes the 771-byte parameter input\n   * with cubehash160+16/32+160-256 to derive a 256-bit key\n   * for use with the ChaCha stream cipher.  The ChaCha IV\n   * is set to 64-bits of zeros to allow for replacing ChaCha\n   * with another stream cipher that doesn't take an IV.\n   */\n  chash_message(160, 16, 32, 160, 256,\n\t\t(uint8_t *)params, OCRYPT_PARAMS_SIZE, &chash_out);\n  memcpy(chacha_key, chash_out, 32); /* Get the 256 bit hash output */\n  memset(chacha_iv, 0, 8);\n  o_chacha_init(&chawctx, &chacha_key, &chacha_iv);\n\n  /* \n   * Omega Crypt allocates a state array of 2^m_cost 64-bit words.\n   * For initialization and finalization it is treated as an array of\n   * bytes and for random access it is treated as an arary of\n   * little-endian 64-bit words.\n   *\n   * Initialization sets the first 771 bytes to the parameter input\n   * used to derrive the ChaCha key and the remaining bytes to zero.\n   * Then ChaCha is used to encrypt (XOR) all of the 64-bit words.\n   */\n  m_array_size = 1 << (m_cost + OCRYPT_BASE_MCOST);\n  m_array_mask = m_array_size - 1; /* Useful for bitwise-and */\n\n  state_array = calloc(m_array_size, 8); /* allocates zero'd-mem */\n\n  if (state_array == NULL) {\n    return OCRYPT_E_MEM;\n  }\n\n  /* Copy in the params bytes */\n  memcpy(state_array, params, OCRYPT_PARAMS_SIZE);\n\n  /* Encrypt the state with ChaCha output */\n  for (i = 0; i < m_array_size; i++) {\n    o_chacha_getbytes(&chawctx, (uint8_t *)&tmp64, 8);\n    state_array[i] ^= tmp64;\n  }\n\n  /*\n   * Omega Crypt manipulates the state array 2^t_cost times using\n   * the output of ChaCha as the guide.\n   *\n   * For each iteration, a byte of ChaCha output is used to select\n   * between four possible branches of manipulation.  A 64-bit carry\n   * value is initialized and used between iterations to enforce\n   * data dependancy from each iteration to the next;\n   */\n  \n  t_iterations = 1 << (t_cost + OCRYPT_BASE_TCOST);\n\n  o_chacha_getbytes(&chawctx, (uint8_t *)&carry, 8);\n  for (i = 0; i < t_iterations; i++) {\n    o_chacha_getbytes(&chawctx, (uint8_t *)&branch_select, 1);\n    branch_select &= 3; /* Zero all but lower 2 bits */\n\n    if (branch_select == 0) {\n      o_chacha_getbytes(&chawctx, (uint8_t *)&tad_a, 4);\n      tad_a &= m_array_mask;\n      o_chacha_getbytes(&chawctx, (uint8_t *)&tval_a, 8);\n\n      state_array[tad_a] += carry;\n      carry ^= tval_a;\n    }\n    else if (branch_select == 1) {\n      o_chacha_getbytes(&chawctx, (uint8_t *)&tad_a, 4);\n      tad_a ^= 0x0a1b2c3d;\n      tad_a &= m_array_mask;\n      o_chacha_getbytes(&chawctx, (uint8_t *)&tval_a, 8);\n\n      state_array[tad_a] ^= carry;\n      carry += tval_a;\n    }\n    else if (branch_select == 2) {\n      o_chacha_getbytes(&chawctx, (uint8_t *)&tad_a, 4);\n      tad_a ^= 0xfedc0123;\n      tad_a &= m_array_mask;\n      o_chacha_getbytes(&chawctx, (uint8_t *)&tad_b, 4);\n      tad_b ^= 0xfedc0123;\n      tad_b &= m_array_mask;\n      o_chacha_getbytes(&chawctx, (uint8_t *)&tval_a, 8);\n      o_chacha_getbytes(&chawctx, (uint8_t *)&tval_b, 8);\n\n      state_array[tad_a] ^= tval_a;\n      state_array[tad_b] += (tval_b ^ carry);\n      carry ^= state_array[carry & m_array_mask];\n    }\n    else if (branch_select == 3) {\n      o_chacha_getbytes(&chawctx, (uint8_t *)&tad_a, 4);\n      tad_a ^= 0x76543210;\n      tad_a &= m_array_mask;\n      o_chacha_getbytes(&chawctx, (uint8_t *)&tval_a, 8);\n      o_chacha_getbytes(&chawctx, (uint8_t *)&tval_b, 8);\n      \n      state_array[state_array[tad_a] & m_array_mask] += (carry ^ tval_a);\n      carry += (state_array[tad_a] ^ tval_b);\n    }\n\n  }\n\n  /*\n   * Omega Hash applies hashes to the whole state array to derive\n   * the final hash output using cubehash16+8/64+320-N \n   * for an N-bit output.\n   */\n  chash_message(16, 8, 64, 320, outlen * 8,\n                (uint8_t *)state_array, m_array_size * 8, &chash_out);  \n  memcpy(out, chash_out, outlen); /* Get N-bit final output */\n\n  /* Give back all of that memory */\n  free(state_array);\n  \n  return OCRYPT_SUCCESS;\n}\n\n\n"
        },
        {
            "file_name": "omdsha512k512n256tau256v1_omdsha512.cpp",
            "content": "/**\n * The implementation of the omdsha512 mode\n */\n\n#include \"omdsha512k512n256tau256v1_omdsha512.h\"\n#include <string.h>\n\n// CHANGE namespace moved due to includes\nnamespace Omdsha512k512n256tau256v1_raw {\n\nvoid\nxor_block (hashblock res, const hashblock in1, const hashblock in2)\n{\n    unsigned int i;\n\n    for (i = 0; i < OMD_n ; i++)\n       {\n\t  res[i] = in1[i] ^ in2[i];\n       }\n}\n\nvoid\ndouble_block (hashblock res, const hashblock in)\n{\n    unsigned int i;\n    /* create bitmask from msb using signed shift */\n    unsigned char carry = (unsigned char) (((char) in[0]) >> 7);\n\n    for (i = 0; i < OMD_n-1; i++)\n       {\n\t  /* shift with carry from next block */\n\t  res[i] = (in[i] << 1) | (in[i+1] >> 7);\n       }\n\n    /* xor P(x) if msb */\n    res[OMD_n -2] = res[OMD_n -2] ^ (carry & 0x01);\n    /* shift and xor P(x) if msb */\n    res[OMD_n -1] = (in[OMD_n -1] << 1) ^ (carry & 0x25);\n}\n\nvoid\ntriple_block (hashblock res, const hashblock in)\n{\n    unsigned int i;\n    /* create bitmask from msb using signed shift */\n    unsigned char carry = (unsigned char) (((char) in[0]) >>7);\n\n    for (i = 0; i < OMD_n -1; i++)\n       {\n\t  /* shift and xor */\n\t  res[i] = in[i] ^ ((in[i] << 1) | (in[i+1] >> 7));\n       }\n\n    /* xor P(x) if msb */\n    res[OMD_n -2] = res[OMD_n -2] ^ (carry & 0x01);\n    /* shift and xor and xor P(x) if msb */\n    res[OMD_n -1] = (in[OMD_n -1] ^ (in[OMD_n -1] << 1)) ^ (carry & 0x25);\n}\n\nvoid\nl2b (hashblock bit_string, int value)\n{\n   int ptr = value*8;\n   unsigned int i = OMD_n;\n\n   memset(bit_string, 0x00, OMD_n);\n\n   while (i--)\n      {   /* write the bytes of value into tau */\n\t bit_string[i] = ptr & 0xff;\n\t ptr >>= 8;\n      }\n}\n\nvoid\nkey_func (hashblock res, const hashblock hash, const hashblock key,\n\t  const hashblock message)\n{\n   messageblock glue;\n\n   memcpy (glue, key, OMD_n);\n   /* K,M -> K||M */\n   memcpy (&glue[OMD_n], message, OMD_n);\n   /*call the underlying compression function*/\n   OMD_COMP (res, hash, glue);\n}\n\nvoid\ncalc_L_i (hashblock l, const hashblock lzero, unsigned int i)\n{\n   /* i==0 => l=lzero */\n   if (i == 0)\n      {\n\t memcpy (l, lzero, OMD_n );\n\t return;\n      }\n\n   double_block (l,lzero);\n\n   /* L[i]=2.L[i-1] */\n   while (--i)\n      {\n\t double_block (l,l);\n      }\n}\n\nint\nntz (int v)\n{\n   int c;\n\n   /* Set v's trailing 0s to 1s and zero rest */\n   v = (v ^ (v - 1)) >> 1;\n\n   for (c = 0; v; c++)\n      {\n\t v >>= 1;\n      }\n\n   return c;\n}\n\nvoid\nincrement_masking_message (hashblock delta_n, const hashblock delta_o,\n\t\t\t   const hashblock lzero, int i)\n{\n   hashblock l;\n\n   if (i < 1)\n      {\n\t return;\n      }\n\n   /* \\delta_{N, i, 0} = \\delta_{N, i-1, 0} ^ L[ntz(i)]  */\n   calc_L_i (l, lzero, ntz(i));\n   xor_block (delta_n, delta_o, l);\n\n}\n\nvoid\nfinal_masking_message (hashblock delta_n, const hashblock delta_o,\n\t\t       const hashblock lstar, int j)\n{\n   hashblock l;\n\n   switch (j)\n      {\n\t /* \\delta_{N, i, 1} = \\delta_{N, i, 0} ^ 2*L_*  */\n\t case 1: double_block (l, lstar); break;\n\n\t /* \\delta_{N, i, 2} = \\delta_{N, i, 0} ^ 3*L_*  */\n\t case 2: triple_block (l, lstar); break;\n      }\n\n\txor_block (delta_n, delta_o, l);\n}\n\nvoid\nincrement_masking_associated_data (hashblock delta_n, const hashblock delta_o,\n\t\t\t\t   const hashblock lzero, int i)\n{\n   hashblock l;\n\n   /* \\delta_{i, 0} = \\delta_{i-1, 0} ^ L[ntz(i)]  */\n   calc_L_i (l, lzero, ntz(i));\n   xor_block (delta_n, delta_o, l);\n}\n\nvoid\nfinal_masking_associated_data (hashblock delta_n, const hashblock delta_o,\n\t\t\t       const hashblock lstar)\n{\n   /* \\delta_{i, 0} = \\delta_{i-1, 0} ^ L[ntz(i)]  */\n   xor_block (delta_n, delta_o, lstar);\n}\n\nvoid\nhash (hashblock taga, const hashblock key, const unsigned char *ad,\n      unsigned long long int adlen)\n{\n   hashblock lstar, lzero;\n   hashblock delta;\n   hashblock left, right;\n   hashblock xor_res, key_func_res;\n   unsigned int  modlen;\n   long long int i, l;\n   size_t b;\n\n   /* L_* = F_K(0^n, 0^m) */\n   key_func (lstar, block0s, key, block0s);\n   /* L[0] = 4.L* */\n   double_block (lzero, lstar);\n   double_block (lzero, lzero);\n\n   /*b = n+m*/\n   b = OMD_n + OMD_m;\n\n   /* A_1 || A_2 \u00c2\u00b7\u00c2\u00b7\u00c2\u00b7 A_{l\u00e2\u02c6\u20191} || A_l = A, where |A_i| = b for 1 \u00e2\u2030\u00a4 i \u00e2\u2030\u00a4 l\u00e2\u02c6\u20191\n      and |A_l| \u00e2\u2030\u00a4 b */\n   /* l=ceil(adlen/b) */\n   l = (adlen + b - 1)/b;\n\n   /* Tag_a = 0^n  */\n   memset (taga, 0x00, OMD_n);\n   /* If AD=\"\" => Tag_a = 0^n */\n   if (adlen == 0)\n      {\n\t return;\n      }\n\n   /* \\bar{\\delta}_{0,0} = 0^n */\n   memset (delta, 0x00, OMD_n);\n\n   /** for i = 1 to l-1 **/\n   /**********************/\n   for (i = 1; i < l; i++)\n      {\n\t /*  \\bar{\\delta}_{i, 0} =  \\bar{\\delta}{i-1, 0} ^ L[ntz(i)]  */\n\t increment_masking_associated_data (delta, delta, lzero, i);\n\n\t /* Left = A_l[b-1...m]; */\n\t memcpy (left, &ad[(i-1)*b],  OMD_n);\n\t /* Right = A_l[m-1...0]  */\n\t memcpy (right,&ad[(i-1)*b+OMD_n],OMD_m);\n\n\t /* Tag_a = Tag_a ^ F_K(Left ^ \\delta_{i, 0}, right) */\n\t xor_block (xor_res, delta, left);\n\t key_func (key_func_res, xor_res, key, right);\n\t xor_block (taga, taga, key_func_res);\n      }\n   /**************************/\n   /******* endfor ***********/\n\n   /* here adlen!=0, we process last ad block*/\n\n   modlen = adlen%b;\n\n   /* |A_l| = b then */\n   if (modlen == 0)\n      {\n\t /* last mask = \\bar{\\delta}{l,0}  */\n\t increment_masking_associated_data (delta, delta, lzero,l);\n\n\t memcpy (left, &ad[(l-1)*b],      OMD_n);\n\t memcpy (right,&ad[(l-1)*b+OMD_n],OMD_m);\n      }\n   /* |A_l| < b then */\n   else\n      {\n\t /* last mask = \\bar{\\delta}{l-1,1}  */\n\t final_masking_associated_data (delta, delta, lstar);\n\n\t memset (left , 0x00, OMD_n);\n\t memset (right, 0x00, OMD_m);\n\n\t memcpy (left, &ad[(l-1)*b], (modlen < OMD_n ? modlen : OMD_n));\n\t memcpy (right, &ad[(l-1)*b+OMD_n], (modlen < OMD_n\n\t\t\t\t\t     ? 0\n\t\t\t\t\t     : modlen - OMD_n));\n\n\t if (modlen < OMD_n)\n\t    /* pad last block */\n\t    left[modlen] = 0x80;\n\t else\n\t    right[modlen-OMD_n] = 0x80;\n   }\n\n   /* Tag_a = Tag_a ^ F_K(Left ^ \\delta_{l, 0 or 1}, right) */\n   xor_block (xor_res, delta, left);\n   key_func (key_func_res, xor_res, key, right);\n   xor_block (taga, taga, key_func_res);\n}\n\nint\nomdsha512_process(unsigned char *data, const unsigned char* key,\n                  const unsigned char *data_process,\n                  unsigned long long int data_processlen,\n                  const unsigned char *ad, unsigned long long int adlen,\n                  const unsigned char *nonce,\n                  const enum mode encrypting)\n{\n   hashblock key_block;\n   hashblock lstar, lzero;\n   hashblock nonce_block;\n   hashblock delta;\n   hashblock h;\n   hashblock res, res2;\n   hashblock taures;\n   hashblock taga, tage, tag, tag_prime;\n   hashblock xor_res;\n   unsigned int statedelta, data_process_modlen;\n   long long int i, l = 0;\n\n   /* if |K| > n => return -1  */\n   if (10 > OMD_k || OMD_k > OMD_n)\n      return -1;\n\n   /* if |N| > n-1 => return -1 */\n   if ((12 > OMD_lnonce) || (OMD_lnonce > OMD_n-1))\n      return -1;\n\n   /* if |C| < tau => return -1 */\n   if ((encrypting == OMD_DECRYPT) && (data_processlen < OMD_tau))\n      return -1;\n\n   memset (key_block, 0x00, OMD_n);\n   memcpy (key_block, key, OMD_k);\n\n   /* Tag_a computed here to handle the case when the the buffers ad=c overlap\n    * This does not have any impact on the security, as Tag_e and Tag_a are \n    * computed independently */\n   /* Tag_a = HASH_k(ad)  */\n   hash(taga, key_block, ad, adlen);\n\n   if (encrypting == OMD_ENCRYPT)\n      {\n    /* M_1 || M_2 \u00c2\u00b7\u00c2\u00b7\u00c2\u00b7 M_{l\u00e2\u02c6\u20191} || M_l = M, where |M_i| = m for 1 \u00e2\u2030\u00a4 i \u00e2\u2030\u00a4 l\u00e2\u02c6\u20191\n\t and |M_l| \u00e2\u2030\u00a4 m */\n\t /* l = ceil(|M|/m) */\n\t l = (data_processlen + (OMD_m-1))/OMD_m;\n      }\n   else if (encrypting == OMD_DECRYPT)\n      {\n      /* C_1 || C_2 \u00c2\u00b7\u00c2\u00b7\u00c2\u00b7 C_{l\u00e2\u02c6\u20191} || C_l || Tag = \\mathbb{C},\n\t where |C_i| = m for 1 \u00e2\u2030\u00a4 i \u00e2\u2030\u00a4 l\u00e2\u02c6\u20191 and |C_l| \u00e2\u2030\u00a4 m and |Tag| = \\tau*/\n    data_processlen = data_processlen - OMD_tau;\n    /* l = ceil(|C|/m) */\n    l = (data_processlen +OMD_m-1)/OMD_m;\n      }\n\n   /* L* = F_K(0^n, 0^m) */\n   key_func (lstar, block0s, key_block, block0s);\n\n   /* L[0] = 4.L* */\n   double_block (lzero, lstar);   /* 2.L_* */\n   double_block (lzero, lzero);   /* 2.(2.L_*) */\n\n   /* pad nonce */\n   memset (nonce_block, 0x00, OMD_n);\n   memcpy (nonce_block, nonce, OMD_lnonce);\n   nonce_block[OMD_lnonce] = 0x80;\n\n   /* \\delta{N,0,0} = F_K(N || 10^{n-1-|N|}, 0^m  */\n   key_func (delta, nonce_block, key_block, block0s);\n\n   /* H = 0^n */\n   memset (h, 0x00, OMD_n);\n\n   /* \\delta{N,1,0} = \\delta{N,0,0} ^ L[ntz(1)]  */\n   increment_masking_message (delta, delta, lzero, 1);\n\n   /* H = F_K(H ^ \\delta_{N, 1, 0}, <tau>_m)  */\n   xor_block (h, h, delta);\n   l2b (taures, OMD_tau);\n   key_func (h, h, key_block, taures);\n\n   /* for i = 1 to l-1 do  */\n   /************************/\n   for (i = 1; i < l; i++)\n      {\n\t /* C_i = H ^ M_i */\n\t /* M_i = H ^ C_i */\n\t memcpy (res,&data_process[(i-1)*OMD_m],OMD_m);\n\t xor_block (res2, h, res);\n\t memcpy (&data[(i-1)*OMD_m],res2,OMD_m);\n\n\t /* \\delta_{N, i, 0} = \\delta{N, i-1, 0} ^ L[ntz(i)]  */\n\t increment_masking_message (delta, delta, lzero, i+1);\n\n\t /* H = F_K(H ^ \\delta{N, i, 0}, M_i) */\n\t xor_block (xor_res, delta, h);\n\n\t if (encrypting == OMD_ENCRYPT)\n\t    /* res  = M_i */\n\t    key_func(h, xor_res, key_block, res);\n\t else if (encrypting == OMD_DECRYPT)\n\t    /* res2 = M_i */\n\t    key_func(h, xor_res, key_block, res2);\n      }\n\n   /************************/\n   /******** endfor ********/\n\n\n   /* |M|>0 */\n   if (data_processlen !=0 )\n      {\n\t /* C_l = H ^ M_l */\n\t /* M_l = H ^ C_l *//* |M_l| = m then */\n\t data_process_modlen = data_processlen % OMD_m;\n\t memset (res,0x00,OMD_m);\n\t memcpy (res, &data_process[(l-1)*OMD_m], (data_process_modlen==0\n\t\t\t\t\t\t  \t\t  ? OMD_m\n\t\t\t\t\t\t  \t\t  : data_process_modlen));\n\t xor_block (res2, h, res);\n\t memcpy (&data[(l-1)*OMD_m], res2, (data_process_modlen==0\n\t\t\t\t\t   ? OMD_m : data_process_modlen));\n\n      /* if |M_\\ell|=m */\n      if (data_process_modlen == 0)\n         statedelta = 1;\n      /* else if |M_\\ell|<m*/\n      else\n         statedelta = 2;\n\n      /* \\delta{N, l, 1} = \\delta{N, l, 0} ^ (2 or 3)*L_* */\n      final_masking_message (delta, delta, lstar, statedelta);\n      /* Tag_e = F_K(H ^ \\delta{N, l, 1}, M_l)  */\n      xor_block (h, h, delta);\n\n      if (encrypting == OMD_ENCRYPT)\n\t {\n\t    /* if |M_\\ell|<m, we pad*/\n\t    if (statedelta==2)\n\t       res[data_process_modlen]=0x80;\n\n\t\t /* res  = M_i */\n\t    key_func(tage, h, key_block, res);\n\t }\n      else if (encrypting == OMD_DECRYPT)\n\t {\n\t    if(statedelta==2)\n\t       {\n\t\t  /* if |M_\\ell|<m, we pad*/\n\t\t  res2[data_process_modlen] = 0x80;\n\t\t  memset (&res2[data_process_modlen+1], 0x00,\n\t\t\t   OMD_m - data_process_modlen - 1);\n\t       }\n\n         /* res2 = M_i */\n         key_func(tage, h, key_block, res2);\n\t }\n\n      }\n   /* |M| = 0 => tage = H */\n   else\n      {\n\t memcpy(tage,h,OMD_n);\n      }\n\n   /* Tag = (Tag_e ^ Tag_a)[n-1 ... n- tau]  */\n   xor_block(tag, taga, tage);\n\n   /*ENCRYPT => output tag and return 0*/\n   if (encrypting == OMD_ENCRYPT)\n      {\n\t memcpy (&data[data_processlen], tag, OMD_tau);\n\n\t return 0;\n      }\n\n   /* or check tag */\n   memcpy(tag_prime, &data_process[data_processlen], OMD_tau);\n\n   if (memcmp (tag,tag_prime,OMD_tau) == 0)\n      {\n\t return 0;\n      }\n\n   return -1;\n}\n\n} // namespace Omdsha512k512n256tau256v1_raw\n"
        },
        {
            "file_name": "omdsha512k512n256tau256v1_sha512.cpp",
            "content": "/** Implementation of sha512 compression function, originally from openssl  */\n\n/**The original file was modified so that it implements\n * only the compression functions. Below follows the original copyright\n * notice.\n*/\n/** ====================================================================\n * Copyright (c) 2004 The OpenSSL Project.  All rights reserved\n * according to the OpenSSL license [found in ../../LICENSE].\n * ====================================================================\n */\n/**\n * IMPLEMENTATION NOTES.\n *\n * As you might have noticed 32-bit hash algorithms:\n *\n * - permit SHA_LONG to be wider than 32-bit (case on CRAY);\n * - optimized versions implement two transform functions: one operating\n *   on [aligned] data in host byte order and one - on data in input\n *   stream byte order;\n * - share common byte-order neutral collector and padding function\n *   implementations, ../md32_common.h;\n *\n * Neither of the above applies to this SHA-512 implementations. Reasons\n * [in reverse order] are:\n *\n * - it's the only 64-bit hash algorithm for the moment of this writing,\n *   there is no need for common collector/padding implementation [yet];\n * - by supporting only one transform function [which operates on\n *   *aligned* data in input stream byte order, big-endian in this case]\n *   we minimize burden of maintenance in two ways: a) collector/padding\n *   function is simpler; b) only one transform function to stare at;\n * - SHA_LONG64 is required to be exactly 64-bit in order to be able to\n *   apply a number of optimizations to mitigate potential performance\n *   penalties caused by previous design decision;\n *\n * Caveat lector.\n *\n * Implementation relies on the fact that \"long long\" is 64-bit on\n * both 32- and 64-bit platforms. If some compiler vendor comes up\n * with 128-bit long long, adjustment to sha.h would be required.\n * As this implementation relies on 64-bit integer type, it's totally\n * inappropriate for platforms which don't support it, most notably\n * 16-bit platforms.\n *\t\t\t\t\t<appro@fy.chalmers.se>\n */\n#include <stdlib.h>\n#include <string.h>\n\n#include \"omdsha512k512n256tau256v1_sha512.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Omdsha512k512n256tau256v1_raw {\n\n/** sha512 round constants*/\nstatic const uint64_t K512[80] = {\n        U64(0x428a2f98d728ae22),U64(0x7137449123ef65cd),\n        U64(0xb5c0fbcfec4d3b2f),U64(0xe9b5dba58189dbbc),\n        U64(0x3956c25bf348b538),U64(0x59f111f1b605d019),\n        U64(0x923f82a4af194f9b),U64(0xab1c5ed5da6d8118),\n        U64(0xd807aa98a3030242),U64(0x12835b0145706fbe),\n        U64(0x243185be4ee4b28c),U64(0x550c7dc3d5ffb4e2),\n        U64(0x72be5d74f27b896f),U64(0x80deb1fe3b1696b1),\n        U64(0x9bdc06a725c71235),U64(0xc19bf174cf692694),\n        U64(0xe49b69c19ef14ad2),U64(0xefbe4786384f25e3),\n        U64(0x0fc19dc68b8cd5b5),U64(0x240ca1cc77ac9c65),\n        U64(0x2de92c6f592b0275),U64(0x4a7484aa6ea6e483),\n        U64(0x5cb0a9dcbd41fbd4),U64(0x76f988da831153b5),\n        U64(0x983e5152ee66dfab),U64(0xa831c66d2db43210),\n        U64(0xb00327c898fb213f),U64(0xbf597fc7beef0ee4),\n        U64(0xc6e00bf33da88fc2),U64(0xd5a79147930aa725),\n        U64(0x06ca6351e003826f),U64(0x142929670a0e6e70),\n        U64(0x27b70a8546d22ffc),U64(0x2e1b21385c26c926),\n        U64(0x4d2c6dfc5ac42aed),U64(0x53380d139d95b3df),\n        U64(0x650a73548baf63de),U64(0x766a0abb3c77b2a8),\n        U64(0x81c2c92e47edaee6),U64(0x92722c851482353b),\n        U64(0xa2bfe8a14cf10364),U64(0xa81a664bbc423001),\n        U64(0xc24b8b70d0f89791),U64(0xc76c51a30654be30),\n        U64(0xd192e819d6ef5218),U64(0xd69906245565a910),\n        U64(0xf40e35855771202a),U64(0x106aa07032bbd1b8),\n        U64(0x19a4c116b8d2d0c8),U64(0x1e376c085141ab53),\n        U64(0x2748774cdf8eeb99),U64(0x34b0bcb5e19b48a8),\n        U64(0x391c0cb3c5c95a63),U64(0x4ed8aa4ae3418acb),\n        U64(0x5b9cca4f7763e373),U64(0x682e6ff3d6b2b8a3),\n        U64(0x748f82ee5defb2fc),U64(0x78a5636f43172f60),\n        U64(0x84c87814a1f0ab72),U64(0x8cc702081a6439ec),\n        U64(0x90befffa23631e28),U64(0xa4506cebde82bde9),\n        U64(0xbef9a3f7b2c67915),U64(0xc67178f2e372532b),\n        U64(0xca273eceea26619c),U64(0xd186b8c721c0c207),\n        U64(0xeada7dd6cde0eb1e),U64(0xf57d4f7fee6ed178),\n        U64(0x06f067aa72176fba),U64(0x0a637dc5a2c898a6),\n        U64(0x113f9804bef90dae),U64(0x1b710b35131c471b),\n        U64(0x28db77f523047d84),U64(0x32caab7b40c72493),\n        U64(0x3c9ebe0a15c9bebc),U64(0x431d67c49c100d4c),\n        U64(0x4cc5d4becb3e42b6),U64(0x597f299cfc657e2a),\n        U64(0x5fcb6fab3ad6faec),U64(0x6c44198c4a475817) };\n\n/** treat rotations and endians (for sha256 treated in sha-openssl/md32_common.h)*/\n#ifndef PULL64\n#define B(x,j)    (((uint64_t)(*(((const unsigned char *)(&x))+j)))<<((7-j)*8) )\n#define PULL64(x) (B(x,0)|B(x,1)|B(x,2)|B(x,3)|B(x,4)|B(x,5)|B(x,6)|B(x,7))\n#endif\n\n#ifndef PUSH64\n#define BB(x,c,j)    (*((&c)+j)=((x>>((7-j)*8))&0xff))\n#define PUSH64(x,c) (BB(x,c,0),\\\n                     BB(x,c,1),\\\n                     BB(x,c,2),\\\n                     BB(x,c,3),\\\n                     BB(x,c,4),\\\n                     BB(x,c,5),\\\n                     BB(x,c,6),\\\n                     BB(x,c,7))\n#endif\n\n#ifndef ROTR\n#define ROTR(x,s)\t(((x)>>s) | (x)<<(64-s))\n#endif\n\n#define Sigma0(x)\t(ROTR((x),28) ^ ROTR((x),34) ^ ROTR((x),39))\n#define Sigma1(x)\t(ROTR((x),14) ^ ROTR((x),18) ^ ROTR((x),41))\n#define sigma0(x)\t(ROTR((x),1)  ^ ROTR((x),8)  ^ ((x)>>7))\n#define sigma1(x)\t(ROTR((x),19) ^ ROTR((x),61) ^ ((x)>>6))\n\n#define Ch(x,y,z)\t(((x) & (y)) ^ ((~(x)) & (z)))\n#define Maj(x,y,z)\t(((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))\n\n\n#if defined(__i386) || defined(__i386__) || defined(_M_IX86)\n/*\n * This code should give better results on 32-bit CPU with less than\n * ~24 registers, both size and performance wise...\n */\n/**\n * sha512 compression function - 32-bit machines\n * @param res The resulting hash value\n * @param hash The chaining input value\n * @param in The message input\n */\nvoid sha512_comp (hashblock res, const hashblock hash, const messageblock in)\n\t{\n    // CHANGE type casting added due to c++\n    const uint64_t *W=reinterpret_cast<const uint64_t*>(in);\n\tuint64_t\tA,E,T;\n\tuint64_t\tX[9+80],*F;\n\tuint64_t H[8];\n\tint i;\n\n   for (i = 0; i < SHA512_DIGEST_LENGTH/8; i++) {\n\t   H[i]=PULL64(hash[i*8]);\n\t}\n\n\tF    = X+80;\n\tA    = H[0];\tF[1] = H[1];\n\tF[2] = H[2];\tF[3] = H[3];\n\tE    = H[4];\tF[5] = H[5];\n\tF[6] = H[6];\tF[7] = H[7];\n\n\tfor (i=0;i<16;i++,F--)\n\t\t{\n#ifdef B_ENDIAN\n\t\tT = W[i];\n#else\n\t\tT = PULL64(W[i]);\n#endif\n\t\tF[0] = A;\n\t\tF[4] = E;\n\t\tF[8] = T;\n\t\tT   += F[7] + Sigma1(E) + Ch(E,F[5],F[6]) + K512[i];\n\t\tE    = F[3] + T;\n\t\tA    = T + Sigma0(A) + Maj(A,F[1],F[2]);\n\t\t}\n\n\tfor (;i<80;i++,F--)\n\t\t{\n\t\tT    = sigma0(F[8+16-1]);\n\t\tT   += sigma1(F[8+16-14]);\n\t\tT   += F[8+16] + F[8+16-9];\n\n\t\tF[0] = A;\n\t\tF[4] = E;\n\t\tF[8] = T;\n\t\tT   += F[7] + Sigma1(E) + Ch(E,F[5],F[6]) + K512[i];\n\t\tE    = F[3] + T;\n\t\tA    = T + Sigma0(A) + Maj(A,F[1],F[2]);\n\t\t}\n\n\tH[0] += A;\t\tH[1] += F[1];\n\tH[2] += F[2];\tH[3] += F[3];\n\tH[4] += E;\t\tH[5] += F[5];\n\tH[6] += F[6];\tH[7] += F[7];\n\n   for (i = 0; i < SHA512_DIGEST_LENGTH/8; i++) {\n\t   PUSH64(H[i],res[i*8]);\n\t}\n\n\t}\n\n#else\n\n/**\n * sha512 compression function - 64-bit machines\n * @param res The resulting hash value\n * @param hash The chaining input value\n * @param in The message input\n */\nvoid sha512_comp (hashblock res, const hashblock hash, const messageblock in)\n\t{\n    // CHANGE type casting added due to c++\n\tconst uint64_t *W=reinterpret_cast<const uint64_t*>(in);\n\tuint64_t\ta,b,c,d,e,f,g,h,s0,s1,T1,T2;\n\tuint64_t\tX[16];\n\tuint64_t  H[8];\n\tint i;\n\n   for (i = 0; i < SHA512_DIGEST_LENGTH/8; i++) {\n\t   H[i]=PULL64(hash[i*8]);\n\t}\n\n\n\ta = H[0];\tb = H[1];\tc = H[2];\td = H[3];\n\te = H[4];\tf = H[5];\tg = H[6];\th = H[7];\n\n\tfor (i=0;i<16;i++)\n\t\t{\n#ifdef B_ENDIAN\n\t\tT1 = X[i] = W[i];\n#else\n\t\tT1 = X[i] = PULL64(W[i]);\n#endif\n\t\tT1 += h + Sigma1(e) + Ch(e,f,g) + K512[i];\n\t\tT2 = Sigma0(a) + Maj(a,b,c);\n\t\th = g;\tg = f;\tf = e;\te = d + T1;\n\t\td = c;\tc = b;\tb = a;\ta = T1 + T2;\n\t\t}\n\n\tfor (;i<80;i++)\n\t\t{\n\t\ts0 = X[(i+1)&0x0f];\ts0 = sigma0(s0);\n\t\ts1 = X[(i+14)&0x0f];\ts1 = sigma1(s1);\n\n\t\tT1 = X[i&0xf] += s0 + s1 + X[(i+9)&0xf];\n\t\tT1 += h + Sigma1(e) + Ch(e,f,g) + K512[i];\n\t\tT2 = Sigma0(a) + Maj(a,b,c);\n\t\th = g;\tg = f;\tf = e;\te = d + T1;\n\t\td = c;\tc = b;\tb = a;\ta = T1 + T2;\n\t\t}\n\n\tH[0] += a;\tH[1] += b;\tH[2] += c;\tH[3] += d;\n\tH[4] += e;\tH[5] += f;\tH[6] += g;\tH[7] += h;\n\n   for (i = 0; i < SHA512_DIGEST_LENGTH/8; i++) {\n\t   PUSH64(H[i],res[i*8]);\n\t}\n\n\t}\n\n\n\n#endif\n\n\n\n#if defined(PEDANTIC) || defined(__DECC) || defined(OPENSSL_SYS_MACOSX)\nstatic void *dummy=&dummy;\n#endif\n\n\n} // namespace Omdsha512k512n256tau256v1_raw\n"
        },
        {
            "file_name": "paeq160_encrypt.cpp",
            "content": "/* PAEQ-160: reference  version*/\n\n#ifndef NO_SUPERCOP\n#include \"paeq160_encrypt.h\"\n#endif\n#include \"paeq160_api.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include \"string.h\"\n//#include \"wmmintrin.h\"\n//#include <immintrin.h>\n\n// CHANGE namespace moved due to includes\nnamespace Paeq160_raw {\nint numRounds = -1;\n\n#define D_BYTES 2\n\n#define CRYPTO_MBLOCK (64-D_BYTES-CRYPTO_KEYBYTES)  //46 for 16-byte key\n#define CRYPTO_ADBLOCK (64-D_BYTES-2*CRYPTO_KEYBYTES) //30 for 16-byte key\n#define CRYPTO_COUNTERBYTES (64-D_BYTES-CRYPTO_KEYBYTES-CRYPTO_NPUBBYTES)  //34 for 16-byte key and 12-byte nonce\n#define CRYPTO_LENGTH 12 //Maximal length of plaintext/AD length\n\n#define AES_GROUP_ROUNDS 2\n#define AES_GROUPS 10\n//#define EXTRANONCE\n\n  //This is the implementation of PPAE instantiated with AESQ permutation\nint key_bytes = CRYPTO_KEYBYTES;\nint nonce_bytes = CRYPTO_NPUBBYTES;\nint tag_bytes = CRYPTO_ABYTES;\n\n//AES S-box\nconst static unsigned char sbox[256] =   {\n\t\t//0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F\n\t\t0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0\n\t\t0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1\n\t\t0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2\n\t\t0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3\n\t\t0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4\n\t\t0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5\n\t\t0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6\n\t\t0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7\n\t\t0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8\n\t\t0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9\n\t\t0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A\n\t\t0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B\n\t\t0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C\n\t\t0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D\n\t\t0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E\n\t\t0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };\n\nunsigned char mul[256][256]; //GF(256) multiplication table, initialized in Init().\n\nunsigned char Shuffle[16] = {3,15,10,6, 1,13,8,4, 2,14,11,7, 0,12,9,5};\n\nvoid AES_Round(unsigned char* state)  //SubBytes-ShiftRows-MixColumns\n{\n\tunsigned char tmp[4][4];\n\n\tfor(unsigned i=0; i<4; ++i)\n\t{\n\t\tfor(unsigned j=0; j<4; ++j)\n\t\t\ttmp[j][i] = state[4*i+j];//AES state conversion\n\t}\n\tfor(unsigned i=0; i<4; ++i)//Columnwise loop\n\t {\n\t \tstate[4*i] = mul[sbox[tmp[0][i]]][2] ^ mul[sbox[tmp[3][(i+3)%4]]][1] ^\n\t\t\t\t\t\tmul[sbox[tmp[2][(i+2)%4]]][1] ^ mul[sbox[tmp[1][(i+1)%4]]][3];\n\t\tstate[4*i+1] = mul[sbox[tmp[1][(i+1)%4]]][2] ^ mul[sbox[tmp[0][i]]][1] ^\n\t\t\t\t\tmul[sbox[tmp[3][(i+3)%4]]][1] ^ mul[sbox[tmp[2][(i+2)%4]]][3];\n\t\tstate[4*i+2] = mul[sbox[tmp[2][(i+2)%4]]][2] ^ mul[sbox[tmp[1][(i+1)%4]]][1] ^\n\t\t\t\t\tmul[sbox[tmp[0][i]]][1] ^ mul[sbox[tmp[3][(i+3)%4]]][3];\n\t\tstate[4*i+3] = mul[sbox[tmp[3][(i+3)%4]]][2] ^ mul[sbox[tmp[2][(i+2)%4]]][1] ^\n\t\t\t\t\tmul[sbox[tmp[1][(i+1)%4]]][1] ^ mul[sbox[tmp[0][i]]][3];\n\t }\n\n}\n\nvoid FPerm(const unsigned char* input, unsigned char* output)//AESQ permutation\n{\n\n\tunsigned char Registers[4][16];  //AES state registers\n\tunsigned char Registers_tmp[4][16];  //AES state registers\n\n\tfor(unsigned i=0; i<4; ++i)//Filling registers\n\t{\n\t\tfor(unsigned j=0; j<16; ++j)\n\t\t\tRegisters[i][j] = input[16*i+j];\n\t}\n\n\t//Main permutation\n\tfor(unsigned i=0; i<AES_GROUPS; ++i)//Group loop\n\t{\n\t\t//AES rounds\n\t\tfor(unsigned r=0; r<4; ++r)//Register loop\n\t\t{\n\t\t\tfor(unsigned j=0; j<AES_GROUP_ROUNDS; ++j)//Middle rounds\n\t\t\t{\n\t\t\t\tAES_Round(Registers[r]); //SB-SR-MC\n\t\t\t\tfor(unsigned k=0; k<4;++k)  //Round constants\n\t\t\t\t{\n\t\t\t\t\tRegisters[r][4*k] ^= 8*i+4*j+r+1;\n\t\t\t\t\t//printf(\"Constant for acc%d: %d\\n\",r,8*i+4*j+r+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//Permutation\n\t\tfor(unsigned r=0; r<4; ++r)//Register loop\n\t\t\tfor(unsigned j=0; j<16; ++j)\n\t\t\t\tRegisters_tmp[r][j] = Registers[r][j];\n\t\t\t\n\t\tfor(unsigned r=0; r<4; ++r)//Register loop\n\t\t{\n\t\t\tfor(unsigned i=0; i<4; ++i)//Column loop\n\t\t\t{\n\t\t\t\tunsigned char r_out = Shuffle[4*r+i]/4;  //Register index\n\t\t\t\tunsigned char c_out = Shuffle[4*r+i]%4;  //Column index\n\t\t\t\tfor(unsigned j=0; j<4; ++j)\n\t\t\t\t\tRegisters[r_out][4*c_out+j] = Registers_tmp[r][4*i+j];\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\tfor(unsigned i=0; i<4; ++i)//Filling registers\n\t{\n\t\tfor(unsigned j=0; j<16; ++j)\n\t\t\toutput[16*i+j] = Registers[i][j];\n\t}\n\n}\n\n//GF(256) multiplication\n\nunsigned char gmul_o(unsigned char a, unsigned char b) {\n\tunsigned char p = 0;\n\tunsigned char counter;\n\tunsigned char hi_bit_set;\n\tfor(counter = 0; counter < 8; counter++) {\n\t\tif((b & 1) == 1) \n\t\t\tp ^= a;\n\t\thi_bit_set = (a & 0x80);\n\t\ta <<= 1;\n\t\tif(hi_bit_set == 0x80) \n\t\t\ta ^= 0x1b;\t\t\n\t\tb >>= 1;\n\t}\n\treturn p;\n}\n\nvoid Init()\n{\n\tfor(unsigned i=0; i<256; ++i)\n\t\t{\n\t\t\tfor(unsigned j=0; j<256; ++j)\n\t\t\t\tmul[i][j] = gmul_o(i,j);\n\t\t}\n}\n\n\n/*Error values: 1 - Invalid clen pointer\n\t\t\t\t2 - Invalid key or ciphertext pointer\n\t\t\t\t3 - Invalid plaintext pointer\n\t\t\t\t4 - Invalid associated data pointer\n\n*/\n\n\n\nint GenerateNonce(unsigned char* output, const unsigned char *m,unsigned long long mlen,\n       const unsigned char *ad,unsigned long long adlen,\n       const unsigned char *k)\n\t   //Generate a nonce as a hash of the plaintext & AD by the AESQ-sponge function\n{\n\t//Does not work for keys longer than 192 bits\n\tif(CRYPTO_KEYBYTES >24)\n\t{\n\t\tmemset(output,0,CRYPTO_NPUBBYTES);\n\t\treturn -1;\n\t}\n\n\tunsigned char State[64];\n\tunsigned char Buffer[CRYPTO_KEYBYTES+2+2*CRYPTO_LENGTH];\n\tunsigned char StateOut[64];\n\tmemset(State,0,64);\n\n\t//Plaintext length\n\tfor(unsigned i=0; i<CRYPTO_LENGTH; ++i)\n\t\tBuffer[i] = (i<sizeof(mlen))? (mlen>>(8*i))&0xff:0;\n\n\t//Associated data length\n\tfor(unsigned i=0; i<CRYPTO_LENGTH; ++i)\n\t\tBuffer[i+CRYPTO_LENGTH] =  (i<sizeof(adlen))?(adlen>>(8*i))&0xff:0;\n\n\t//Key length\n\tBuffer[2*CRYPTO_LENGTH] = CRYPTO_KEYBYTES;\n\n\t//Nonce length\n\tBuffer[2*CRYPTO_LENGTH+1] = CRYPTO_NPUBBYTES;\n\n\t//Add key \n\tfor(unsigned i=0; i<CRYPTO_KEYBYTES; ++i)\n\t\tBuffer[i+CRYPTO_LENGTH*2+2] = k[i];\n\n\tunsigned state_index=0;\n\tunsigned long long message_index=0;\n\tunsigned long long ad_index=0;\n\t\n\tfor(unsigned i=0; (i<CRYPTO_KEYBYTES+2+2*CRYPTO_LENGTH); ++i)//Feeding buffer\n\t{\n\t\tState[state_index] ^= Buffer[i];\n\t\tstate_index++;\n\t\tif(state_index==64-2*CRYPTO_KEYBYTES)//end of state\n\t\t{\n\t\t\tFPerm(State,StateOut);\n\t\t\tstate_index = 0;\n\t\t\tfor(unsigned j=0; j<64; ++j) State[j] = StateOut[j];\n\t\t}\n\t}\n\n\twhile(mlen>0)//Feeding plaintext\n\t{\n\t\tState[state_index] ^= m[message_index];\n\t\tstate_index++;\n\t\tmessage_index++;\n\t\tmlen--;\n\t\tif(state_index==64-2*CRYPTO_KEYBYTES)//end of state\n\t\t{\n\t\t\tFPerm(State,StateOut);\n\t\t\tstate_index = 0;\n\t\t\tfor(unsigned j=0; j<64; ++j) State[j] = StateOut[j];\n\t\t}\n\t}\n\twhile(adlen>0) //Filling AD\n\t{\n\t\tState[state_index] ^= ad[ad_index];\n\t\tstate_index++;\n\t\tad_index++;\n\t\tadlen--;\n\t\tif(state_index==64-2*CRYPTO_KEYBYTES)//end of state\n\t\t{\n\t\t\tFPerm(State,StateOut);\n\t\t\tstate_index = 0;\n\t\t\tfor(unsigned j=0; j<64; ++j) State[j] = StateOut[j];\n\t\t}\n\t}\n\t//end of data\n\t//Padding 10*1\n\tState[state_index] ^= 1;\n\tif(state_index==64-2*CRYPTO_KEYBYTES)//end of state\n\t{\n\t\tFPerm(State,StateOut);\n\t\tstate_index = 0;\n\t\tfor(unsigned j=0; j<64; ++j) State[j] = StateOut[j];\n\t}\n\twhile(state_index <63-2*CRYPTO_KEYBYTES)\n\t{\n\t\tState[state_index] ^= 0;\n\t\tstate_index++;\n\t}\n\tState[state_index] ^= 1;//state_index must be =63 - 2*CRYPTO_KEYBYTES\n\tFPerm(State,StateOut);\n\tfor(unsigned j=0; j<CRYPTO_NPUBBYTES; ++j)\n\t\toutput[j] = StateOut[j];\n\n\treturn 0;\n\n}\n\nint crypto_aead_encrypt(\n       unsigned char *c,unsigned long long *clen,\n       const unsigned char *m,unsigned long long mlen,\n       const unsigned char *ad,unsigned long long adlen,\n       const unsigned char *nsec,\n       const unsigned char *npub,\n       const unsigned char *k\n     )\n\n     {\n\t\t Init();//Initializing GF(256) multiplication table for AES\n\n\t\t if(clen==NULL)\n\t\t\t return -1;\n\t\t if((mlen==0) && (adlen==0))\n\t\t {\n\t\t\t *clen=0;\n\t\t\t return 0;\n\t\t }\n\n\t\t //Assume that we do encryption and/or authentication so we need a key and a ciphertext pointer valid\n\t\t if( (k==NULL) || (c==NULL) )\n\t\t\t return -2;\n\n\t\t if(npub==NULL)\n\t\t\t return -7;\n\n\t\t //Initializing constants\n\t\tunsigned char D0[2];\n\t\tD0[0] = CRYPTO_NPUBBYTES*8; //nonce length in bits, zero for 256-bit nonce\n\t\tD0[1] = CRYPTO_KEYBYTES*8; //key length in bits\n\t\t(*clen)=0;\n\t\t \n\t\t //Block variables\n\t\t unsigned char BlockInput[64];  //V1 - input to the first layer call of F\n\t\t\t unsigned char BlockMiddle[64];  //W1 - output of the first layer call of F\n\t\t\t unsigned char BlockOutput[64];  //Y1 - output of the second layer call of F\n\t\t\t\n\t\t unsigned char BlockLastInput[64];  //Z1 - input to the last call of F\n\t\t memset(BlockLastInput,0,64);\n\t\t unsigned char Tag[64]; //Tag output\n\t\t \n\t\t unsigned long long encrypted_bytes=0;//Encrypted bytes counter\n\t\t \n\n\t\t //Encryption part\n\t\t if(mlen!=0)\n\t\t {\n\t\t\t if(m==NULL)\n\t\t\t {\n\t\t\t\t //Clearing variables\n\t\t\t\tfor(unsigned i=0; i<64; ++i)\n\t\t\t\t\tBlockInput[i] = BlockMiddle[i] = BlockOutput[i] = BlockLastInput[i] = 0;\n\t\t\t\treturn -3;\n\t\t\t }\n\t\t\t\t \n\t\t\t unsigned long long mblock_counter=1;   //Message block counter\n\t\t\t \n\t\t\t while((mlen>0))\n\t\t\t {\n\t\t\t\t /* I. First layer */\n\n\t\t\t\t //1. Domain-separation constant\n\t\t\t\t BlockInput[1] = D0[1]; \n\t\t\t\t if(mlen>= CRYPTO_MBLOCK)\n\t\t\t\t\t BlockInput[0] = D0[0];\n\t\t\t\t else //Last incomplete block\n\t\t\t\t\t BlockInput[0] = D0[0]+1;\n\n\t\t\t\t //2. Counter\n\t\t\t\t for(unsigned i=0; i<CRYPTO_COUNTERBYTES; ++i)\n\t\t\t\t {\n\t\t\t\t\t BlockInput[i+2] = (i<sizeof(mblock_counter))?(mblock_counter>>(8*i))&0xff :0;//copying counter bytewise\n\t\t\t\t }\n\t\t\t\t \n\t\t\t\t //3. Nonce\n\t\t\t\t for(unsigned i=0; i<CRYPTO_NPUBBYTES; ++i) \n\t\t\t\t {\n\t\t\t\t\t BlockInput[i+2+CRYPTO_COUNTERBYTES] = npub[i];\n\t\t\t\t }\n\n\t\t\t\t //4. Key\n\t\t\t\t for(unsigned i=0; i<CRYPTO_KEYBYTES; ++i) \n\t\t\t\t {\n\t\t\t\t\t BlockInput[i+2+CRYPTO_COUNTERBYTES+CRYPTO_NPUBBYTES] = k[i];\n\t\t\t\t }\t \n\n\t\t\t\t //5. Permutation call\n\t\t\t\t FPerm(BlockInput, BlockMiddle); //First layer call to F\n\n\t\t\t\t\n\n\t\t\t\t /* II. Encryption*/\n\n\t\t\t\t if(mlen>=CRYPTO_MBLOCK)//Full block encryption\n\t\t\t\t {\n\t\t\t\t\t for(unsigned i=0; i<CRYPTO_MBLOCK; ++i)\n\t\t\t\t\t {\n\t\t\t\t\t\t BlockMiddle[i+2] ^= m[encrypted_bytes+i];\n\t\t\t\t\t\t c[encrypted_bytes+i] = BlockMiddle[i+2];\n\t\t\t\t\t\t \n\t\t\t\t\t }\n\t\t\t\t\t BlockMiddle[1] =  D0[1];\n\t\t\t\t\t BlockMiddle[0] = D0[0]+2;  //New Di constant\n\n\t\t\t\t }\n\n\t\t\t\t else //Last incomplete block\n\t\t\t\t {\n\t\t\t\t\t for(unsigned i=0; i<(unsigned)mlen; ++i)//Incomplete block Encryption\n\t\t\t\t\t {\n\t\t\t\t\t\t BlockMiddle[i+2] ^= m[encrypted_bytes+i];\n\t\t\t\t\t\t c[encrypted_bytes+i] = BlockMiddle[i+2];\t\t\t\t\t\t \n\t\t\t\t\t }\n\t\t\t\t\t for(unsigned i=(unsigned)mlen; i<CRYPTO_MBLOCK; ++i)\n\t\t\t\t\t {\n\t\t\t\t\t\t BlockMiddle[i+2] ^=  (unsigned char)mlen;  //Extra Padding: extra bytes filled with the last block length in bytes\n\t\t\t\t\t }\n\n\t\t\t\t\t BlockMiddle[1] =  D0[1];\n\t\t\t\t\t BlockMiddle[0] = D0[0]+3;  //New Di constant\n\t\t\t\t }\n\n\t\t\t\t //III. Second permutation call\n\t\t\t\t //1. Call\n\t\t\t\t FPerm(BlockMiddle, BlockOutput); //Second layer call to F\n\t\t\t\t \n\t\t\t\t //2. Buffer update\n\t\t\t\t for(unsigned i=0; i<64-2-CRYPTO_KEYBYTES; ++i)//Adding the output to tag preparation buffer\n\t\t\t\t {\n\t\t\t\t\t BlockLastInput[i+2] ^= BlockOutput[i+2];\n\t\t\t\t }\n\n\n\t\t\t\t //Counters increment\n\t\t\t\t mblock_counter++;\n\t\t\t\t if(mlen>=CRYPTO_MBLOCK)\n\t\t\t\t {\t\t\t\t\t \n\t\t\t\t\t encrypted_bytes += CRYPTO_MBLOCK;\n\t\t\t\t\t mlen-=CRYPTO_MBLOCK;\n\t\t\t\t }\n\t\t\t\t else \n\t\t\t\t {\n\t\t\t\t\t encrypted_bytes += mlen;\n\t\t\t\t\t mlen=0;\n\t\t\t\t }\n\t\t\t\t (*clen) = encrypted_bytes;\n\t\t\t }\n\t\t }\n\n\t\t//Associated data part\t  \n\t\tif(adlen!=0)\n\t\t{\n\t\t\tif(ad==NULL)\n\t\t\t{\n\t\t\t\t//Clearing variables\n\t\t\t\tfor(unsigned i=0; i<64; ++i)\n\t\t\t\t\tBlockInput[i] = BlockMiddle[i] = BlockOutput[i] = BlockLastInput[i] = 0;\n\t\t\t\treturn -4;\n\t\t\t}\n\n\t\t\t unsigned long long adblock_counter=1;   //AD block counter\n\t\t\t unsigned long long auth_bytes=0;\n\n\t\t\twhile(adlen>0)\n\t\t\t{\n\t\t\t\t//1. Constant\n\t\t\t\tBlockInput[1] = D0[1];\n\t\t\t\tif(adlen>= CRYPTO_ADBLOCK)\n\t\t\t\t\t BlockInput[0] = D0[0]+4;\n\t\t\t\t else //Last incomplete block\n\t\t\t\t\t BlockInput[0] = D0[0]+5;\n\n\n\t\t\t\t//2. Counter\n\t\t\t\tfor(unsigned i=0; i<CRYPTO_KEYBYTES; ++i)\n\t\t\t\t\tBlockInput[i+2] =  (i<sizeof(adblock_counter))? (adblock_counter>>(8*i))&0xff:0;//copying counter bytewise\n\n\t\t\t\t//3. AD block\n\t\t\t\tif(adlen >= CRYPTO_ADBLOCK) //Filling AD block\n\t\t\t\t{\n\t\t\t\t\tfor(unsigned i=0; i<CRYPTO_ADBLOCK; ++i)\n\t\t\t\t\t\tBlockInput[i+2+CRYPTO_KEYBYTES] = ad[auth_bytes+i];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse //Last incomplete block\n\t\t\t\t{\n\t\t\t\t\tfor(unsigned i=0; i<adlen; ++i)\n\t\t\t\t\t\tBlockInput[i+2+CRYPTO_KEYBYTES] = ad[auth_bytes+i];\n\t\t\t\t\tfor(unsigned i=(unsigned)adlen; i<CRYPTO_ADBLOCK; ++i)\n\t\t\t\t\t\tBlockInput[i+2+CRYPTO_KEYBYTES] = (unsigned char)adlen;\n\t\t\t\t}\n\n\t\t\t\t//4. Key\n\t\t\t\tfor(unsigned i=0; i<CRYPTO_KEYBYTES; ++i) \n\t\t\t\t{\n\t\t\t\t\t BlockInput[i+CRYPTO_ADBLOCK+CRYPTO_KEYBYTES+2] = k[i];\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\t//5.Call to the F permutation\n\n\t\t\t\tFPerm(BlockInput,BlockOutput);//Call to the F permutation\n\n\t\t\t\t for(unsigned i=0; i<64-2-CRYPTO_KEYBYTES; ++i)//Adding the output to Z\n\t\t\t\t {\n\t\t\t\t\t BlockLastInput[i+2] ^= BlockOutput[i+2];\n\t\t\t\t }\n\n\t\t\t\t//Counters increment\n\t\t\t\t adblock_counter++;\n\t\t\t\t if(adlen>=CRYPTO_ADBLOCK)\n\t\t\t\t {\n\t\t\t\t\t auth_bytes += CRYPTO_ADBLOCK;\n\t\t\t\t\t adlen-=CRYPTO_ADBLOCK;\n\t\t\t\t }\n\t\t\t\t else \n\t\t\t\t {\n\t\t\t\t\t auth_bytes += adlen;\n\t\t\t\t\t adlen=0;\n\t\t\t\t }\n\t\t\t}\n\t\t}\n\n\t\t// Tag production \n\t\tfor(unsigned i=0; i<CRYPTO_KEYBYTES; ++i) //Key to the Z input\n\t\t\tBlockLastInput[64-CRYPTO_KEYBYTES+i] = k[i];\n\t\t BlockLastInput[0] = D0[0]+6;\n\t\t BlockLastInput[1] = D0[1];\n\n\t\t//1. Permutation call\n\t\tFPerm(BlockLastInput,Tag);\n\t\t//2. Key injection\n\t\tfor(unsigned i=0; i<CRYPTO_KEYBYTES; ++i) \n\t\t{\n\t\t\t\tTag[64-CRYPTO_KEYBYTES+i] ^= k[i];\n\t\t}\n\n\t\t//3. Truncation\n\t\tfor(unsigned i=0; i<CRYPTO_ABYTES; ++i)\n\t\t\tc[(*clen)+i] = Tag[i];\n\t\t*clen += CRYPTO_ABYTES;\n\n\n\t\t//Clearing variables\n\t\tfor(unsigned i=0; i<64; ++i)\n\t\t\tBlockInput[i] = BlockMiddle[i] = BlockOutput[i] = BlockLastInput[i] = 0;\n\t\t\n\n\t   \n\t\treturn 0;\n     }\n\t  \nint crypto_aead_encrypt_no_nonce(\n       unsigned char *c,unsigned long long *clen,\n       const unsigned char *m,unsigned long long mlen,\n       const unsigned char *ad,unsigned long long adlen,\n       const unsigned char *nsec,\n       unsigned char *npub,\n       const unsigned char *k\n     )\n\t //Generates nonce out of plaintext and AD and put it into npub\n\n     {\n\t\t Init();//Initializing GF(256) multiplication table for AES\n\n\t\t if(clen==NULL)\n\t\t\t return -1;\n\t\t if((mlen==0) && (adlen==0))\n\t\t {\n\t\t\t *clen=0;\n\t\t\t return 0;\n\t\t }\n\n\t\t //Assume that we do encryption and/or authentication so we need a key and a ciphertext pointer valid\n\t\t if( (k==NULL) || (c==NULL) )\n\t\t\t return -2;\n\n\t\tGenerateNonce(npub,m,mlen,ad,adlen,k);\n\n\t\t //Initializing constants\n\t\tunsigned char D0[2];\n\t\tD0[0] = CRYPTO_NPUBBYTES*8; //nonce length in bits, zero for 256-bit nonce\n\t\tD0[1] = CRYPTO_KEYBYTES*8; //key length in bits\n\t\t(*clen)=0;\n\t\t \n\t\t //Block variables\n\t\t unsigned char BlockInput[64];  //V1 - input to the first layer call of F\n\t\t\t unsigned char BlockMiddle[64];  //W1 - output of the first layer call of F\n\t\t\t unsigned char BlockOutput[64];  //Y1 - output of the second layer call of F\n\t\t\t\n\t\t unsigned char BlockLastInput[64];  //Z1 - input to the last call of F\n\t\t memset(BlockLastInput,0,64);\n\t\t unsigned char Tag[64]; //Tag output\n\t\t \n\t\t unsigned long long encrypted_bytes=0;//Encrypted bytes counter\n\t\t \n\n\t\t //Encryption part\n\t\t if(mlen!=0)\n\t\t {\n\t\t\t if(m==NULL)\n\t\t\t {\n\t\t\t\t //Clearing variables\n\t\t\t\tfor(unsigned i=0; i<64; ++i)\n\t\t\t\t\tBlockInput[i] = BlockMiddle[i] = BlockOutput[i] = BlockLastInput[i] = 0;\n\t\t\t\treturn -3;\n\t\t\t }\n\t\t\t\t \n\t\t\t unsigned long long mblock_counter=1;   //Message block counter\n\t\t\t \n\t\t\t while((mlen>0))\n\t\t\t {\n\t\t\t\t /* I. First layer */\n\n\t\t\t\t //1. Domain-separation constant\n\t\t\t\t BlockInput[1] = D0[1]; \n\t\t\t\t if(mlen>= CRYPTO_MBLOCK)\n\t\t\t\t\t BlockInput[0] = D0[0];\n\t\t\t\t else //Last incomplete block\n\t\t\t\t\t BlockInput[0] = D0[0]+1;\n\n\t\t\t\t //2. Counter\n\t\t\t\t for(unsigned i=0; i<CRYPTO_COUNTERBYTES; ++i)\n\t\t\t\t {\n\t\t\t\t\t BlockInput[i+2] = (i<sizeof(mblock_counter))?(mblock_counter>>(8*i))&0xff :0;//copying counter bytewise\n\t\t\t\t }\n\t\t\t\t \n\t\t\t\t //3. Nonce\n\t\t\t\t for(unsigned i=0; i<CRYPTO_NPUBBYTES; ++i) \n\t\t\t\t {\n\t\t\t\t\t BlockInput[i+2+CRYPTO_COUNTERBYTES] = npub[i];\n\t\t\t\t }\n\n\t\t\t\t //4. Key\n\t\t\t\t for(unsigned i=0; i<CRYPTO_KEYBYTES; ++i) \n\t\t\t\t {\n\t\t\t\t\t BlockInput[i+2+CRYPTO_COUNTERBYTES+CRYPTO_NPUBBYTES] = k[i];\n\t\t\t\t }\t \n\n\t\t\t\t //5. Permutation call\n\t\t\t\t FPerm(BlockInput, BlockMiddle); //First layer call to F\n\n\t\t\t\t /* II. Encryption*/\n\n\t\t\t\t if(mlen>=CRYPTO_MBLOCK)//Full block encryption\n\t\t\t\t {\n\t\t\t\t\t for(unsigned i=0; i<CRYPTO_MBLOCK; ++i)\n\t\t\t\t\t {\n\t\t\t\t\t\t BlockMiddle[i+2] ^= m[encrypted_bytes+i];\n\t\t\t\t\t\t c[encrypted_bytes+i] = BlockMiddle[i+2];\n\t\t\t\t\t\t \n\t\t\t\t\t }\n\t\t\t\t\t BlockMiddle[1] =  D0[1];\n\t\t\t\t\t BlockMiddle[0] = D0[0]+2;  //New Di constant\n\n\t\t\t\t }\n\n\t\t\t\t else //Last incomplete block\n\t\t\t\t {\n\t\t\t\t\t for(unsigned i=0; i<(unsigned)mlen; ++i)//Incomplete block Encryption\n\t\t\t\t\t {\n\t\t\t\t\t\t BlockMiddle[i+2] ^= m[encrypted_bytes+i];\n\t\t\t\t\t\t c[encrypted_bytes+i] = BlockMiddle[i+2];\t\t\t\t\t\t \n\t\t\t\t\t }\n\t\t\t\t\t for(unsigned i=(unsigned)mlen; i<CRYPTO_MBLOCK; ++i)\n\t\t\t\t\t {\n\t\t\t\t\t\t BlockMiddle[i+2] ^=  (unsigned char)mlen;  //Extra Padding: extra bytes filled with the last block length in bytes\n\t\t\t\t\t }\n\n\t\t\t\t\t BlockMiddle[1] =  D0[1];\n\t\t\t\t\t BlockMiddle[0] = D0[0]+3;  //New Di constant\n\t\t\t\t }\n\n\t\t\t\t //III. Second permutation call\n\t\t\t\t //1. Call\n\t\t\t\t FPerm(BlockMiddle, BlockOutput); //Second layer call to F\n\t\t\t\t \n\t\t\t\t //2. Buffer update\n\t\t\t\t for(unsigned i=0; i<64-2-CRYPTO_KEYBYTES; ++i)//Adding the output to tag preparation buffer\n\t\t\t\t {\n\t\t\t\t\t BlockLastInput[i+2] ^= BlockOutput[i+2];\n\t\t\t\t }\n\n\n\t\t\t\t //Counters increment\n\t\t\t\t mblock_counter++;\n\t\t\t\t if(mlen>=CRYPTO_MBLOCK)\n\t\t\t\t {\t\t\t\t\t \n\t\t\t\t\t encrypted_bytes += CRYPTO_MBLOCK;\n\t\t\t\t\t mlen-=CRYPTO_MBLOCK;\n\t\t\t\t }\n\t\t\t\t else \n\t\t\t\t {\n\t\t\t\t\t encrypted_bytes += mlen;\n\t\t\t\t\t mlen=0;\n\t\t\t\t }\n\t\t\t\t (*clen) = encrypted_bytes;\n\t\t\t }\n\t\t }\n\n\t\t//Associated data part\t  \n\t\tif(adlen!=0)\n\t\t{\n\t\t\tif(ad==NULL)\n\t\t\t{\n\t\t\t\t//Clearing variables\n\t\t\t\tfor(unsigned i=0; i<64; ++i)\n\t\t\t\t\tBlockInput[i] = BlockMiddle[i] = BlockOutput[i] = BlockLastInput[i] = 0;\n\t\t\t\treturn -4;\n\t\t\t}\n\n\t\t\t unsigned long long adblock_counter=1;   //AD block counter\n\t\t\t unsigned long long auth_bytes=0;\n\n\t\t\twhile(adlen>0)\n\t\t\t{\n\t\t\t\t//1. Constant\n\t\t\t\tBlockInput[1] = D0[1];\n\t\t\t\tif(adlen>= CRYPTO_ADBLOCK)\n\t\t\t\t\t BlockInput[0] = D0[0]+4;\n\t\t\t\t else //Last incomplete block\n\t\t\t\t\t BlockInput[0] = D0[0]+5;\n\n\n\t\t\t\t//2. Counter\n\t\t\t\tfor(unsigned i=0; i<CRYPTO_KEYBYTES; ++i)\n\t\t\t\t\tBlockInput[i+2] = (i<sizeof(adblock_counter))? (adblock_counter>>(8*i))&0xff:0;//copying counter bytewise\n\n\t\t\t\t//3. AD block\n\t\t\t\tif(adlen >= CRYPTO_ADBLOCK) //Filling AD block\n\t\t\t\t{\n\t\t\t\t\tfor(unsigned i=0; i<CRYPTO_ADBLOCK; ++i)\n\t\t\t\t\t\tBlockInput[i+2+CRYPTO_KEYBYTES] = ad[auth_bytes+i];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse //Last incomplete block\n\t\t\t\t{\n\t\t\t\t\tfor(unsigned i=0; i<adlen; ++i)\n\t\t\t\t\t\tBlockInput[i+2+CRYPTO_KEYBYTES] = ad[auth_bytes+i];\n\t\t\t\t\tfor(unsigned i=(unsigned)adlen; i<CRYPTO_ADBLOCK; ++i)\n\t\t\t\t\t\tBlockInput[i+2+CRYPTO_KEYBYTES] = (unsigned char)adlen;\n\t\t\t\t}\n\n\t\t\t\t//4. Key\n\t\t\t\tfor(unsigned i=0; i<CRYPTO_KEYBYTES; ++i) \n\t\t\t\t{\n\t\t\t\t\t BlockInput[i+CRYPTO_ADBLOCK+CRYPTO_KEYBYTES+2] = k[i];\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\t//5.Call to the F permutation\n\n\t\t\t\tFPerm(BlockInput,BlockOutput);//Call to the F permutation\n\n\t\t\t\t for(unsigned i=0; i<64-2-CRYPTO_KEYBYTES; ++i)//Adding the output to Z\n\t\t\t\t {\n\t\t\t\t\t BlockLastInput[i+2] ^= BlockOutput[i+2];\n\t\t\t\t }\n\n\t\t\t\t//Counters increment\n\t\t\t\t adblock_counter++;\n\t\t\t\t if(adlen>=CRYPTO_ADBLOCK)\n\t\t\t\t {\n\t\t\t\t\t auth_bytes += CRYPTO_ADBLOCK;\n\t\t\t\t\t adlen-=CRYPTO_ADBLOCK;\n\t\t\t\t }\n\t\t\t\t else \n\t\t\t\t {\n\t\t\t\t\t auth_bytes += adlen;\n\t\t\t\t\t adlen=0;\n\t\t\t\t }\n\t\t\t}\n\t\t}\n\n\t\t// Tag production \n\t\tfor(unsigned i=0; i<CRYPTO_KEYBYTES; ++i) //Key to the Z input\n\t\t\tBlockLastInput[64-CRYPTO_KEYBYTES+i] = k[i];\n\t\t BlockLastInput[0] = D0[0]+6;\n\t\t BlockLastInput[1] = D0[1];\n\n\t\t//1. Permutation call\n\t\tFPerm(BlockLastInput,Tag);\n\t\t//2. Key injection\n\t\tfor(unsigned i=0; i<CRYPTO_KEYBYTES; ++i) \n\t\t{\n\t\t\t\tTag[64-CRYPTO_KEYBYTES+i] ^= k[i];\n\t\t}\n\n\t\t//3. Truncation\n\t\tfor(unsigned i=0; i<CRYPTO_ABYTES; ++i)\n\t\t\tc[(*clen)+i] = Tag[i];\n\t\t*clen += CRYPTO_ABYTES;\n\n\n\t\t//Clearing variables\n\t\tfor(unsigned i=0; i<64; ++i)\n\t\t\tBlockInput[i] = BlockMiddle[i] = BlockOutput[i] = BlockLastInput[i] = 0;\n\t\t\n\n\t   \n\t\treturn 0;\n     }\n\t  \n     \n\n\n     int crypto_aead_decrypt(\n       unsigned char *m,unsigned long long *mlen,\n       unsigned char *nsec,\n       const unsigned char *c,unsigned long long clen,\n       const unsigned char *ad,unsigned long long adlen,\n       const unsigned char *npub,\n       const unsigned char *k\n     )\n     {\n       Init();//Initializing GF(256) multiplication table for AES\n\n\t\t if(mlen==NULL)\n\t\t\t return -1;\n\t\t if((clen==0) && (adlen==0))\n\t\t {\n\t\t\t *mlen=0;\n\t\t\t return 0;\n\t\t }\n\n\t\t //Here we do decryption and/or authentication so we need a key and a plaintext pointer valid\n\t\t if( (k==NULL) || (m==NULL) )\n\t\t\t return -2;\n\n\t\t //Minimum tag length verification\n\t\t if (clen < CRYPTO_ABYTES)\n\t\t\t return -1;\n\n\t\t //Initializing constants\n\t\tunsigned char D0[2];\n\t\tD0[0] = CRYPTO_NPUBBYTES*8; //nonce length in bits\n\t\tD0[1] = CRYPTO_KEYBYTES*8; //key length in bits\n\t\t(*mlen)=0;\n\t\t \n\t\t //Initializing the last input to F\n\t\t unsigned char BlockLastInput[64];  //Z1 - input to the last call of F\n\t\t memset(BlockLastInput,0,64);\n\t\t unsigned char Tag[64]; //Tag output\n\t\t for(unsigned i=0; i<CRYPTO_KEYBYTES; ++i) //Key to the Z input\n\t\t\tBlockLastInput[64-CRYPTO_KEYBYTES+i] = k[i];\n\t\t BlockLastInput[0] = D0[0]+6;\n\t\t BlockLastInput[1] = D0[1];\n\n\t\t unsigned long long decrypted_bytes=0;//Encrypted bytes counter\n\t\t \n\n\t\t //Encryption part\n\t\t if(clen!=CRYPTO_ABYTES) //Ciphertext is more than just a tag\n\t\t {\n\t\t\t if(c==NULL)\n\t\t\t\t return -3;\n\t\t\t unsigned char BlockInput[64];  //V1 - input to the first layer call of F\n\t\t\t unsigned char BlockMiddle[64];  //W1 - output of the first layer call of F\n\t\t\t unsigned char BlockOutput[64];  //Y1 - output of the second layer call of F\n\t\t\t unsigned long long mblock_counter=1;   //Message block counter\n\t\t\t \n\t\t\t while((clen>CRYPTO_ABYTES))\n\t\t\t {\n\t\t\t\t /* I. First layer */\n\n\t\t\t\t //1. Domain-separation constant\n\t\t\t\t BlockInput[1] = D0[1]; \n\t\t\t\t if(clen>= (CRYPTO_MBLOCK+CRYPTO_ABYTES))\n\t\t\t\t\t BlockInput[0] = D0[0];\n\t\t\t\t else //Last incomplete block\n\t\t\t\t\t BlockInput[0] = D0[0]+1;\n\n\t\t\t\t //2. Counter\n\t\t\t\t for(unsigned i=0; i<CRYPTO_COUNTERBYTES; ++i)\n\t\t\t\t {\n\t\t\t\t\t BlockInput[i+2] = (i<sizeof(mblock_counter))?(mblock_counter>>(8*i))&0xff :0;//copying counter bytewise\n\t\t\t\t }\n\t\t\t\t \n\t\t\t\t //3. Nonce\n\t\t\t\t for(unsigned i=0; i<CRYPTO_NPUBBYTES; ++i) \n\t\t\t\t {\n\t\t\t\t\t BlockInput[i+2+CRYPTO_COUNTERBYTES] = npub[i];\n\t\t\t\t }\n\n\t\t\t\t //4. Key\n\t\t\t\t for(unsigned i=0; i<CRYPTO_KEYBYTES; ++i) \n\t\t\t\t {\n\t\t\t\t\t BlockInput[i+2+CRYPTO_COUNTERBYTES+CRYPTO_NPUBBYTES] = k[i];\n\t\t\t\t }\t \n\n\t\t\t\t //5. Permutation call\n\t\t\t\t FPerm(BlockInput, BlockMiddle); //First layer call to F\n\n\t\t\t\t /* II. Encryption*/\n\n\t\t\t\t if(clen>=CRYPTO_MBLOCK+CRYPTO_ABYTES)//Full block encryption\n\t\t\t\t {\n\t\t\t\t\t for(unsigned i=0; i<CRYPTO_MBLOCK; ++i)\n\t\t\t\t\t {\n\t\t\t\t\t\t m[decrypted_bytes] = BlockMiddle[i+2]^c[decrypted_bytes];\n\t\t\t\t\t\t BlockMiddle[i+2] = c[decrypted_bytes];\n\t\t\t\t\t\t decrypted_bytes++;\n\t\t\t\t\t\t \n\t\t\t\t\t }\n\t\t\t\t\t BlockMiddle[1] =  D0[1];\n\t\t\t\t\t BlockMiddle[0] = D0[0]+2;  //New Di constant\n\n\t\t\t\t }\n\n\t\t\t\t else //Last incomplete block\n\t\t\t\t {\n\t\t\t\t\t for(unsigned i=0; i<(unsigned)clen-CRYPTO_ABYTES; ++i)//Incomplete block Encryption\n\t\t\t\t\t {\n\t\t\t\t\t\t  m[decrypted_bytes] = BlockMiddle[i+2]^c[decrypted_bytes];\n\t\t\t\t\t\t BlockMiddle[i+2] = c[decrypted_bytes];\n\t\t\t\t\t\t decrypted_bytes++;\n\t\t\t\t\t }\n\t\t\t\t\t for(unsigned i=(unsigned)clen-CRYPTO_ABYTES; i<CRYPTO_MBLOCK; ++i)\n\t\t\t\t\t {\n\t\t\t\t\t\t BlockMiddle[i+2] ^=  (unsigned char)(clen-CRYPTO_ABYTES);  //Extra Padding: extra bytes filled with the last block length in bytes\n\t\t\t\t\t }\n\n\t\t\t\t\t BlockMiddle[1] =  D0[1];\n\t\t\t\t\t BlockMiddle[0] = D0[0]+3;  //New Di constant\n\t\t\t\t }\n\n\t\t\t\t //III. Second permutation call\n\t\t\t\t //1. Call\n\t\t\t\t FPerm(BlockMiddle, BlockOutput); //Second layer call to F\n\t\t\t\t \n\t\t\t\t //2. Buffer update\n\t\t\t\t for(unsigned i=0; i<64-2-CRYPTO_KEYBYTES; ++i)//Adding the output to tag preparation buffer\n\t\t\t\t {\n\t\t\t\t\t BlockLastInput[i+2] ^= BlockOutput[i+2];\n\t\t\t\t }\n\n\n\t\t\t\t //Counters increment\n\t\t\t\t mblock_counter++;\n\t\t\t\t if(clen>=CRYPTO_MBLOCK+CRYPTO_ABYTES)\n\t\t\t\t\t clen-=CRYPTO_MBLOCK;\n\t\t\t\t \n\t\t\t\t else \n\t\t\t\t \t clen=CRYPTO_ABYTES;\n\t\t\t\t (*mlen) = decrypted_bytes;\n\t\t\t }\n\t\t }\n\n\t\t//Associated data part\t  \n\t\tif(adlen!=0)\n\t\t{\n\t\t\tif(ad==NULL)\n\t\t\t\treturn -4;\n\n\t\t\tunsigned char BlockInput[64];  //V1 - input to the first layer call of F\n\t\t\t unsigned char BlockOutput[64];  //Y1 - output of the second layer call of F\n\t\t\t unsigned long long adblock_counter=1;   //AD block counter\n\t\t\t unsigned long long auth_bytes=0;\n\n\t\t\twhile(adlen>0)\n\t\t\t{\n\t\t\t\t//1. Constant\n\t\t\t\tBlockInput[1] = D0[1];\n\t\t\t\tif(adlen>= CRYPTO_ADBLOCK)\n\t\t\t\t\t BlockInput[0] = D0[0]+4;\n\t\t\t\t else //Last incomplete block\n\t\t\t\t\t BlockInput[0] = D0[0]+5;\n\n\n\t\t\t\t//2. Counter\n\t\t\t\tfor(unsigned i=0; i<CRYPTO_KEYBYTES; ++i)\n\t\t\t\t\tBlockInput[i+2] = (i<sizeof(adblock_counter))? (adblock_counter>>(8*i))&0xff:0;//copying counter bytewise\n\n\t\t\t\t//3. AD block\n\t\t\t\tif(adlen >= CRYPTO_ADBLOCK) //Filling AD block\n\t\t\t\t{\n\t\t\t\t\tfor(unsigned i=0; i<CRYPTO_ADBLOCK; ++i)\n\t\t\t\t\t\tBlockInput[i+2+CRYPTO_KEYBYTES] = ad[auth_bytes+i];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse //Last incomplete block\n\t\t\t\t{\n\t\t\t\t\tfor(unsigned i=0; i<adlen; ++i)\n\t\t\t\t\t\tBlockInput[i+2+CRYPTO_KEYBYTES] = ad[auth_bytes+i];\n\t\t\t\t\tfor(unsigned i=(unsigned)adlen; i<CRYPTO_ADBLOCK; ++i)\n\t\t\t\t\t\tBlockInput[i+2+CRYPTO_KEYBYTES] = (unsigned char)adlen;\n\t\t\t\t}\n\n\t\t\t\t//4. Key\n\t\t\t\tfor(unsigned i=0; i<CRYPTO_KEYBYTES; ++i) \n\t\t\t\t{\n\t\t\t\t\t BlockInput[i+CRYPTO_ADBLOCK+CRYPTO_KEYBYTES+2] = k[i];\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\t//5.Call to the F permutation\n\n\t\t\t\tFPerm(BlockInput,BlockOutput);//Call to the F permutation\n\n\t\t\t\t for(unsigned i=0; i<64-2-CRYPTO_KEYBYTES; ++i)//Adding the output to Z\n\t\t\t\t {\n\t\t\t\t\t BlockLastInput[i+2] ^= BlockOutput[i+2];\n\t\t\t\t }\n\n\t\t\t\t//Counters increment\n\t\t\t\t adblock_counter++;\n\t\t\t\t if(adlen>=CRYPTO_ADBLOCK)\n\t\t\t\t {\n\t\t\t\t\t auth_bytes += CRYPTO_ADBLOCK;\n\t\t\t\t\t adlen-=CRYPTO_ADBLOCK;\n\t\t\t\t }\n\t\t\t\t else \n\t\t\t\t {\n\t\t\t\t\t auth_bytes += adlen;\n\t\t\t\t\t adlen=0;\n\t\t\t\t }\n\t\t\t}\n\t\t}\n\n\t\t// Tag production \n\n\t\t//1. Permutation call\n\t\tFPerm(BlockLastInput,Tag);\n\t\t//2. Key injection\n\t\tfor(unsigned i=0; i<CRYPTO_KEYBYTES; ++i) \n\t\t{\n\t\t\t\tTag[64-CRYPTO_KEYBYTES+i] ^= k[i];\n\t\t}\n\n\t\t//3. Truncation\n\t\tif(clen!=CRYPTO_ABYTES)//Incorrect tag length\n\t\t\treturn -1;\n\n\t\tfor(unsigned i=0; i<CRYPTO_ABYTES; ++i)\n\t\t{\n\t\t\tif(c[(*mlen)+i] != Tag[i])\n\t\t\t{\n\t\t\t\tfor(unsigned j=0; j< (*mlen); ++j)//Erasing decryption result\n\t\t\t\t\tm[j]=0;\n\t\t\t\treturn -1; //Invalid\n\t\t\t}\n\t\t}\n       return 0;\n     }\n} // namespace Paeq160_raw\n"
        },
        {
            "file_name": "phc copy 2.c",
            "content": "/*\n * -----------------------------------------------------------------------\n * (c) Thomas Pornin 2014. This software is provided 'as-is', without\n * any express or implied warranty. In no event will the author be held\n * liable for any damages arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to no restriction.\n *\n * Technical remarks and questions can be addressed to:\n * <pornin@bolet.org>\n * -----------------------------------------------------------------------\n */\n\n#include <limits.h>\n#include <string.h>\n\n#include \"makwa.h\"\n\n/*\n * 2048-bit modulus, generated on my laptop on 2014-02-20 12:56 UTC.\n * I did not save the private key (it was in RAM only) so don't ask for it.\n *\n * Note that the Known Answer Tests are generated with another, different\n * modulus, for which the private key is known and used (see makeKAT.c).\n */\nstatic const unsigned char PHC_PUB2048[] = {\n\t0x55, 0x41, 0x4d, 0x30, 0x01, 0x00, 0xc0, 0x84,\n\t0x7e, 0xa3, 0x72, 0xa4, 0xd0, 0xdb, 0xa1, 0xa3,\n\t0x20, 0x48, 0x89, 0x4d, 0xc7, 0x99, 0x97, 0xa1,\n\t0x0b, 0x84, 0x2a, 0x9d, 0xb1, 0x5f, 0xc5, 0x61,\n\t0x4b, 0xe5, 0xa5, 0x73, 0xba, 0xcc, 0x72, 0xa9,\n\t0x88, 0x0a, 0x57, 0x98, 0xa3, 0x87, 0x53, 0x9b,\n\t0x7a, 0x4c, 0x1c, 0x71, 0xb6, 0xb1, 0x3a, 0x84,\n\t0xdb, 0xad, 0xaf, 0x9b, 0x03, 0xf7, 0x6f, 0x32,\n\t0x70, 0x84, 0x49, 0xc4, 0xfd, 0x27, 0xd2, 0xc4,\n\t0xaf, 0xc9, 0xdc, 0x46, 0xc4, 0xa6, 0xbe, 0xc5,\n\t0x5e, 0x3a, 0x3d, 0xb1, 0xa9, 0xa2, 0x56, 0xaf,\n\t0x05, 0x39, 0xed, 0x2a, 0xb4, 0x48, 0xb8, 0x53,\n\t0xb0, 0xc1, 0xaf, 0x20, 0x7b, 0x6e, 0xa2, 0x94,\n\t0x06, 0x34, 0x91, 0xfb, 0x5e, 0xb2, 0xdc, 0x95,\n\t0x0e, 0x8e, 0x1e, 0x87, 0x19, 0xc4, 0xe5, 0x3c,\n\t0x06, 0xdd, 0x3e, 0x7a, 0x36, 0x4b, 0x44, 0x65,\n\t0x26, 0x81, 0x7d, 0xd5, 0x37, 0x3d, 0x00, 0xd6,\n\t0x71, 0x67, 0x59, 0x06, 0x93, 0x4d, 0xad, 0x0f,\n\t0x7f, 0x6c, 0xed, 0xda, 0x65, 0xb4, 0x33, 0x68,\n\t0xf8, 0x3b, 0xae, 0x26, 0xda, 0xc4, 0x84, 0xf0,\n\t0x00, 0x31, 0x8d, 0xbb, 0x74, 0x80, 0x22, 0x5c,\n\t0xe6, 0x0e, 0xbf, 0x3a, 0x75, 0xec, 0xa3, 0x65,\n\t0x6f, 0xc5, 0xa0, 0x85, 0xf0, 0xf3, 0x4e, 0xcf,\n\t0xa9, 0xcb, 0x72, 0x1b, 0xdb, 0xd8, 0xea, 0x37,\n\t0xb1, 0xd8, 0x63, 0x42, 0x2c, 0x62, 0x8c, 0x73,\n\t0x38, 0x5d, 0x90, 0x65, 0x4a, 0xa1, 0xd0, 0x7b,\n\t0x1a, 0x59, 0xf6, 0x23, 0x42, 0x94, 0x0b, 0xb4,\n\t0x8f, 0xb0, 0x5b, 0x31, 0x47, 0xc9, 0x4c, 0x57,\n\t0xd7, 0x90, 0xae, 0xc7, 0x49, 0x93, 0x3a, 0x2a,\n\t0x19, 0xfe, 0xc9, 0x95, 0x45, 0x37, 0x6e, 0x87,\n\t0x68, 0x16, 0xeb, 0x2a, 0x76, 0xac, 0x56, 0x9d,\n\t0x08, 0xd8, 0xe1, 0xfe, 0x51, 0x81, 0xdf, 0xfb,\n\t0x97, 0x52, 0xb5, 0xfc, 0xe1, 0xe9\n};\n\n/*\n * See makwa.h.\n *\n * This function implements the API requirements for the Password Hashing\n * Competition; however, you MUST NOT use it since it uses an hard-coded\n * modulus that you cannot trust.\n */\nint\nPHS(void *out, size_t outlen,\n\tconst void *in, size_t inlen,\n\tconst void *salt, size_t saltlen,\n\tunsigned int t_cost, unsigned int m_cost)\n{\n\tmakwa_context *mc;\n\tint err;\n\n\t(void)m_cost;\n#if UINT_MAX > LONG_MAX\n\tif ((unsigned long)t_cost > (unsigned long)LONG_MAX) {\n\t\treturn MAKWA_BADPARAM;\n\t}\n#endif\n\tmc = makwa_new();\n\tif (mc == NULL) {\n\t\treturn MAKWA_NOMEM;\n\t}\n\terr = makwa_init(mc, PHC_PUB2048, sizeof PHC_PUB2048, MAKWA_SHA256);\n\tif (err < 0) {\n\t\tmakwa_free(mc);\n\t\treturn err;\n\t}\n\terr = makwa_hash(mc, in, inlen, salt, saltlen,\n\t\t1, outlen, (long)t_cost, out, NULL);\n\tmakwa_free(mc);\n\treturn err;\n}\n"
        },
        {
            "file_name": "phc copy.c",
            "content": "/*\nphc.c - PHC API for EARWORM\nWritten in 2013 by Daniel Franke <dfoxfranke@gmail.com>\n\nTo the extent possible under law, the author(s) have dedicated all\ncopyright and related and neighboring rights to this software to the\npublic domain worldwide. This software is distributed without any\nwarranty.\n\nYou should have received a copy of the CC0 Public Domain Dedication\nalong with this software. If not, see\nhttp://creativecommons.org/publicdomain/zero/1.0/\n*/\n\n\n#include <assert.h>\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"core.h\"\n#include \"aes.h\"\n#include \"util.h\"\n\n#define AES_BLOCK_SIZE ((size_t)16)\n\nstatic const void* get_test_arena(unsigned int m_cost) {\n  static uint8_t* test_arena = NULL;\n  static unsigned int last_mcost;\n  static const uint8_t testseed[32] = {\n    'd', 'o', 'n', '\\'', 't', ' ', 'u', 's',\n    'e', ' ', 't', 'h',  'i', 's', ' ', 'k',\n    'e', 'y', ' ', 'i', 'n',  ' ', 'p', 'r', \n    'o', 'd', 'u', 'c', 't',  'i', 'o', 'n'\n  };\n  static aeskey_t key;\n  size_t i;\n\n  if(test_arena != NULL && m_cost <= last_mcost)\n    return test_arena;\n\n  if(validate_fit(EARWORM_CHUNK_AREA, m_cost) != 0)\n    return NULL;\n\n  free(test_arena);\n  test_arena = malloc16(arena_size(EARWORM_CHUNK_AREA, m_cost));\n  if(test_arena == NULL)\n    return NULL;\n\n  earworm_aes256enc_keysetup(testseed, &key);\n\n  for(i = 0;\n      i < EARWORM_CHUNK_AREA << m_cost;\n      i++) {\n    memset(test_arena + AES_BLOCK_SIZE * i, 0, 8);\n    be64enc(test_arena + AES_BLOCK_SIZE * i + 8, i);\n    earworm_aes256enc(test_arena + AES_BLOCK_SIZE * i, &key);\n  };\n\n  last_mcost = m_cost;\n  return test_arena;\n}\n\nint PHS_initialize_arena(unsigned int m_cost) {\n  if(get_test_arena(m_cost) == NULL)\n    return -1;\n  return 0;\n}\n\nint PHS(void *out, size_t outlen, \n        const void *in, size_t inlen,\n        const void *salt, size_t saltlen,\n        unsigned int t_cost, unsigned int m_cost) {\n\n  if(saltlen > EARWORM_MAX_SALT_SIZE ||\n     t_cost < 1 ||\n     t_cost > UINT32_MAX)\n    return -1;\n\n  const uint8_t *arena = get_test_arena(m_cost);\n\n  if(arena == NULL)\n    return -1;\n\n  return earworm_core(out, outlen, in, inlen, salt, saltlen,\n                      m_cost, 0, t_cost, arena);\n}\n"
        },
        {
            "file_name": "phc.c",
            "content": "#include <inttypes.h>    /* C99 fixed-width integer types w/ output macros */\n#include <math.h>        /* pow */\n#include <openssl/sha.h> /* for SHA512 */\n#include <stdio.h>       /* printf */\n#include <stdlib.h>      /* malloc */\n#include <string.h>      /* memcpy, memset */\n\n/* PHS definitions, types and prototypes */\n#include \"phc_debug.h\"   /* Debug only: Dprintf, DprintState macros */\n#include \"phc.h\"\n\n/* global variables some statistics in STATISTICS mode */\n#ifdef PHC_DEBUG_STATISTICS\nuint64_t cnt_idx[PHS_F_COUNT];\nuint64_t *cnt_tgt_addr;\n#endif\n\n/* TODO for next revision:\n *\n * Sanity check of input parameters (length of password)\n * Better error code on failures (some definitions already prepared)\n */\n\n/* F function mapping */\nuint32_t F (uint8_t idx, uint32_t v0) {\n\t/* choose function based on idx */\n\tswitch(idx) {\n\t\tcase  0:  return( F00(v0) );\n\t\tcase  1:  return( F01(v0) );\n\t\tcase  2:  return( F02(v0) );\n\t\tcase  3:  return( F03(v0) );\n\t\tcase  4:  return( F04(v0) );\n\t\tcase  5:  return( F05(v0) );\n\t\tcase  6:  return( F06(v0) );\n\t\tcase  7:  return( F07(v0) );\n\t\tcase  8:  return( F08(v0) );\n\t\tcase  9:  return( F09(v0) );\n\t\tcase 10:  return( F10(v0) );\n\t\tcase 11:  return( F11(v0) );\n\t\tcase 12:  return( F12(v0) );\n\t\tcase 13:  return( F13(v0) );\n\t\tcase 14:  return( F14(v0) );\n\t\tcase 15:  return( F15(v0) );\n\t\tdefault:  return( F15(v0) );\n\t}\n}\n\n/* initializes the state */\nvoid phs_init(phs_ctx_t *ctx, const uint8_t *salt, const uint8_t *pw, size_t pwlen) {\n\tuint8_t *state = (uint8_t *) ctx->state;\n\tuint16_t offset = 0;\n\n\tDprintf(\"DEBUG: phs_init() called.\\n\");\n\tDprintf(\"DEBUG: pw is \\'%s\\' of length %d\\n\", pw, (int) pwlen);\n\n\t/* copy salt to start of array */\n\tmemcpy(state, salt, PHS_SALT_SIZE);\n\toffset += PHS_SALT_SIZE;\n\t\n\t/* append password */\n\tmemcpy(state+offset, pw, pwlen);\n\toffset += pwlen;\n\n\t/* append 0x80 */\n\tstate[PHS_SALT_SIZE + pwlen] = 0x80;\n\toffset++;\n\n\t/* clear remaining bytes */\n\t// TODO is it a good choice to just clear it? would we increase security by doing something else?\n\t// if there are security concerns: \n\tmemset(state + offset, 0x00, ctx->state_bytes - offset);\n\n\t/* distribute entropy across the state */\n\tphs_upd_entropy(ctx);\n}\n\n/* This function derives the new state from the current hash stored in\n * ctx.rehash and is called by the phs_upd_entropy() function.\n *\n * In addition, we use this function to update previously generated key\n * material to a higher t_cost parameter.\n */\nvoid phs_store_derived_state(phs_ctx_t *ctx) {\n\t/* compute the number of 64-byte blocks needed to update the full state */\n\tuint32_t num_hashs = ctx->state_bytes / PHS_HASH_SIZE;\n\t/* input is the full rehash state, counting in the rehashprefix */\n\tuint8_t *in        = (uint8_t *) ctx->rehashprefix;\n\tuint32_t *cnt      = ctx->rehashprefix;\n\tuint8_t *out       = (uint8_t *) ctx->state;\n\n\t/* redistribute entropy evenly across the state */\n\tfor (*cnt = 0; (*cnt) < num_hashs; (*cnt)++) {\n\t\t/* compute SHA512 and update state */\n\t\tSHA512(in, PHS_REHASH_SIZE, out);\n\t\t/* move output pointer */\n\t\tout += PHS_HASH_SIZE;\n\t}\n}\n\n/* The function phs_upd_entropy re-distributes the entopy across the full state\n * using hash function calls. In the current implementation, only one hash function\n * (SHA-512) is called.\n *\n * It updates the full memory referenced by ctx.state.\n */ \nvoid phs_upd_entropy(phs_ctx_t *ctx) {\n\tuint8_t *state = (uint8_t *) ctx->state;\n\tuint8_t *rehash = (uint8_t *) ctx->rehash;\n\t\n\t/* debug output */\n\tDprintf(\"Executing phs_upd_entropy().\\n\");\n\tDprintf(\"Dumping current state...\\n\");\n\tDprintFullState(ctx);\n\n\t/* update rehash buffer */\n\tDprintf(\"Dumping rehash-buffer after phs_update_rehash_buffer()...\\n\");\n\tSHA512(state, ctx->state_bytes, rehash);\n\tDprintRehashState(ctx);\n\n\t/* derive the state by rehashing the rehash buffer */\n\tDprintf(\"Dumping new state ater phs_store_derived_state()...\\n\");\n\tphs_store_derived_state(ctx);\n\tDprintFullState(ctx);\n}\n\nvoid phs_upd_state(phs_ctx_t *ctx) {\n\tuint32_t *state = (uint32_t*) ctx->state;\n\tuint8_t idx_perm[PHS_F_COUNT];\n\tuint8_t idx;\n\tuint32_t tgt_addr;\n\tuint32_t res;\n\n\tfor (uint32_t i = 0; i < ctx->inner_rounds; i++) {\n\t\tDprintf(\"DEBUG: Starting inner round %d...\", i);\n\t\tfor (uint32_t j = 0; j < ctx->state_words; j++) {\n\t\t\t/* Retrieve state value of current round and ensure that the value\n\t\t\t * is modified with each inner round. We use the \"res\" value, as\n\t\t\t * the intermediate result is used to continue the sequence in the\n\t\t\t * inner loop.\n\t\t\t */\n\t\t\tres = state[j];\n\t\t\tres = ROTR(res, i % 32);\n\t\t\ttgt_addr = res % ctx->state_words;\n\n\t\t\tDprintf(\"DEBUG: pos = %\" PRIu32 \", tgt_addr = %\" PRIu32 \"\\n\", j, tgt_addr);\n\n\t\t\t/* We execute a sequence of PHS_F_COUNT functions as one iteration,\n\t\t\t * which corresponds to one of all PHS_F_COUNT! possible permutations\n\t\t\t * of the functions.\n\t\t\t * This ensures that the \"block\" is executed in constant time,\n\t\t\t * regardless of the target platform. It also ensures constant time\n\t\t\t * between two memory accesses.\n\t\t\t */\n\t\t\t\n\t\t\t/* Reset permutation index */\n\t\t\tfor (uint8_t i = 0; i < PHS_F_COUNT; i++) {\n\t\t\t\tidx_perm[i] = i;\n\t\t\t}\n\n\t\t\t/* Execute a specific sequence (permutation) using all functions */\n\t\t\tfor (uint8_t k = 0; k < PHS_F_COUNT; k++) {\t\n\t\t\t\t/* Derive the function index from the intermediate result in constant\n\t\t\t\t * time for each step.\n\t\t\t\t *\n\t\t\t\t * 1) It reads the value \"idx\" at position r(i) from the array \"perm\"\n\t\t\t\t * 2) It reads the value \"tmp\" at position PHS_F_COUNT-k from the array \"perm\"\n\t\t\t\t * 3) It overwrites the value at position r(i) with \"tmp\"\n\t\t\t\t * \n\t\t\t\t * Example: n = 7, init perm = [0, 1, 2, 3, 4, 5, 6], 0 <= r(i) < n-i in step i\n\t\t\t\t *  Step 0: r(0) = 4, idx = perm[4] = 4, new perm = [0, 1, 2, 3, 6, 5| 6]\n\t\t\t\t *  Step 1: r(1) = 5, idx = perm[5] = 5, new perm = [0, 1, 2, 3, 6| 5, 6]\n\t\t\t\t *  Step 2: r(2) = 2, idx = perm[2] = 2, new perm = [0, 1, 6, 3| 6, 5, 6]\n\t\t\t\t *  Step 3: r(3) = 2, idx = perm[2] = 6, new perm = [0, 1, 3| 3, 6, 5, 6]\n\t\t\t\t *  Step 4: r(4) = 0, idx = perm[0] = 0, new perm = [3, 1| 3, 3, 6, 5, 6]\n\t\t\t\t *  Step 5: r(5) = 1, idx = perm[1] = 1, new perm = [3| 1, 3, 3, 6, 5, 6]\n\t\t\t\t *  Step 6: r(6) = 0, idx = perm[0] = 3, new perm = [3, 1, 3, 3, 6, 5, 6]\n\t\t\t\t *\n\t\t\t\t * Please note that we can optimize this step in C by just changing the\n\t\t\t\t * pointers...\n\t\t\t\t */\n\t\t\t\tidx = idx_perm[res % (PHS_F_COUNT-k)];\n\t\t\t\tidx_perm[res % (PHS_F_COUNT-k)] = idx_perm[PHS_F_COUNT-k-1];\n\t\t\t\tDprintf(\"DEBUG: >> using idx = %d, coming from pos %d\\n\", idx, (res % (PHS_F_COUNT-k)));\n\n\t\t\t\t/* Evaluate function idx for res */\n\t\t\t\tres = F(idx, res);\n\t\t\t\t/* *********** Begin DEBUG-only statistics *********** */\n#ifdef PHC_DEBUG_STATISTICS\n\t\t\t\t/* increase counters */\n\t\t\t\tcnt_idx[idx]++;\n#endif\t\n\t\t\t\t/* *********** End DEBUG-only statistics *********** */\n\n\t\t\t\t/* debug output */\n\t\t\t\tDprintf(\"DEBUG: >> k = %02d, idx = %d, res = %08\" PRIx32 \"\\n\", k, idx, res);\n\t\t\t}\n\n\t\t\t/* XOR the result of the sequence to the target value */\n\t\t\tstate[tgt_addr] ^= res;\n\t\t\t/* *********** Begin DEBUG-only statistics *********** */\n#ifdef PHC_DEBUG_STATISTICS\n\t\t\tcnt_tgt_addr[tgt_addr]++;\n#endif\t\n\t\t\t/* *********** End DEBUG-only statistics *********** */\n\t\t}\n\t}\n}\n\n/* This function generates the output of the password hashing function.\n *\n * The output consists of a variable length of bits, starting with the output of\n * hash(state). If the output length is at least PHS_HASH_SIZE, this allows us to re-use\n * the information to upgrade previously generated passwords to a higher t_cost parameter.\n */\nvoid phs_gen_output(phs_ctx_t *ctx, size_t outlen, void* out) {\n\tuint32_t output_block;\n\tuint32_t output_remaining = outlen;\n\tuint8_t *out_u8 = (uint8_t *) out;\n\n\t/* Hash the entire state using SHA512 and store it in the rehash buffer temporarily */\n\tSHA512((uint8_t *) ctx->state, ctx->state_bytes, (uint8_t*) ctx->rehash);\n\n\t/* In order to create additional key material, we rehash the current state\n\t * and add a 32-bit word in front until we created enough output bits...\n\t *\n\t * If we use up to PHS_HASH_SIZE byte, we simply copy the hash to the output buffer.\n\t */\n\tif (outlen <= PHS_HASH_SIZE) {\n\t\tmemcpy(out_u8, (uint8_t*) ctx->rehash, outlen);\n\t}\n\t/* In order to create additional key material, we rehash the current state\n\t * and add a 32-bit word in front until we created enough output bits...\n\t */\n\telse {\n\t\tmemcpy(out_u8, (uint8_t*) ctx->rehash, PHS_HASH_SIZE);\n\n\t\t/* Update the pointers and the remaining byte count */\n\t\tout_u8 += PHS_HASH_SIZE;\n\t\toutput_remaining = outlen - PHS_HASH_SIZE;\n\n\t\t/* initialize the state prefix with 1 */\n\t\t*(ctx->stateprefix) = 1;\n\n\t\t/* copy additional output to the output buffer */\n\t\twhile (output_remaining != 0) {\n\t\t\t/* Now, we hash the entire state with the updated prefix and store it in rehash */\n\t\t\tSHA512((uint8_t *) ctx->stateprefix, ctx->state_bytes + sizeof(uint32_t), ctx->rehash);\n\n\t\t\t/* And derive a new state as additional key material */\n\t\t\tphs_store_derived_state(ctx);\n\t\n\t\t\t/* Set the block size to either the full state or a partial state */\n\t\t\tif (output_remaining < ctx->state_bytes) {\n\t\t\t\toutput_block = output_remaining;\n\t\t\t}\n\t\t\telse {\n\t\t\t\toutput_block = ctx->state_bytes;\n\t\t\t}\n\t\n\t\t\t/* copy to output buffer */\n\t\t\tmemcpy(out_u8, ctx->state, output_block);\n\n\t\t\t/* update remaining bytes and modify output pointer */\n\t\t\toutput_remaining -= output_block;\n\t\t\tout_u8 += output_block;\n\n\t\t\t/* increment the state prefix in case we need even more output */\n\t\t\t*(ctx->stateprefix) = *(ctx->stateprefix) + 1;\n\t\t} while (output_remaining != 0);\n\t}\n\n}\n\n/* TODO update description */\nint PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost) {\n\tphs_ctx_t ctx;\n\n\t/* *********** initialization steps *********** */\n\n\t// derive state size from somewhere\n\tctx.state_bytes = pow(2, m_cost+8);       /* we use at least 256 byte as the state */\n\tctx.state_words = ctx.state_bytes >> 2;   /* we operate on 32-bit words */\n\tctx.inner_rounds = m_cost >> 4;           /* number of times the whole state is overwritten */\n\tif (ctx.inner_rounds < 2) {               /* use at least two inner rounds! */\n\t\tctx.inner_rounds = 2;\n\t}\n\tctx.outer_rounds = t_cost;                /* number of times we rehash */\n\tif (ctx.outer_rounds == 0) {              /* use at least one outer round! */\n\t\tctx.outer_rounds = 1;\n\t}\n\n\t/* allocate memory for the full state (32-bit counter + state) and rehashing */\n\tDprintf(\"DEBUG: Allocating %\"PRIu64\" bytes of memory for prefixed state buffer...\\n\", (ctx.state_words + 1) * sizeof(uint32_t));\n\tctx.stateprefix = (uint32_t *) calloc(ctx.state_words + 1, sizeof(uint32_t));\n\tDprintf(\"DEBUG: Allocating %\"PRIu64\" bytes of memory for rehashing buffer...\\n\", ((PHS_REHASH_SIZE/4) + 1) * sizeof(uint32_t));\n\tctx.rehashprefix = (uint32_t *) calloc((PHS_REHASH_SIZE/4), sizeof(uint32_t));\n\n\t/* set the ctx.state and ctx.rehash pointers to the non-prefixed buffer */\n\tctx.state = ctx.stateprefix + 1;\n\tctx.rehash = ctx.rehashprefix + 1;\n\n\t/* initialize state from pw and salt */\n\tDprintf(\"DEBUG: initializing state with password and salt...\\n\");\n\tphs_init(&ctx, salt, in, inlen);\n\n\t/* **** end of initialization **** */\n\tDprintf(\"Info : we could wipe the pw and salt now...\\n\");\n\n\t/* *********** Begin DEBUG-only statistics *********** */\n#ifdef PHC_DEBUG_STATISTICS\n\t/* allocate space and clear counter values */\n\tfor (int i = 0; i < PHS_F_COUNT; i++) {\n\t\tcnt_idx[i] = 0;\n\t}\n\t/* allocate and clear memory for address counters */\n\tcnt_tgt_addr = (uint64_t*) calloc(ctx.state_words, sizeof(uint64_t));\n#endif\t\n\t/* *********** End DEBUG-only statistics *********** */\n\t\n\t/* *********** time wasting computation steps *********** */\n\tfor (uint32_t i = 0; i < ctx.outer_rounds; i++) {\n\t\tDprintf(\"DEBUG: executing outer round: %\" PRIu32 \" \\n\", i);\n\t\t/* perform multiple calls to function F and scramble the bits in the state */\n\t\tphs_upd_state(&ctx);\n\t\t/* re-distribute entropy */\n\t\tphs_upd_entropy(&ctx);\n\t}\n\n\t/* generate 'outlen' bytes of output and store it in 'out' */\n\tphs_gen_output(&ctx, outlen, out);\n\n\t/* Clean up the memory we allocated */\n\tDprintf(\"DEBUG: freeing state...\\n\");\n\tfree(ctx.stateprefix);\n\tDprintf(\"DEBUG: freeing rehash...\\n\");\n\tfree(ctx.rehashprefix);\n\n\t/* *********** Begin DEBUG-only statistics *********** */\n#ifdef PHC_DEBUG_STATISTICS\n\tprintf(\"********* Statistics **********\\n\");\n\tdouble rounds = ctx.inner_rounds * ctx.state_words * ctx.outer_rounds;\n\tprintf(\"Function calls:\\n\");\n\tfor (int i = 0; i < PHS_F_COUNT; i++) {\n\t\tdouble usage = (cnt_idx[i] / rounds) * 100;\n\t\tprintf(\"F[%d]: %07.4lf%% (%\" PRIu64 \")\\n\", i, usage, cnt_idx[i]);\n\t}\n\tprintf(\"State usage as [tgt] addresses: \\n\");\n\tfor (int i = 0; i < ctx.state_words; i++) {\n\t\tdouble tgt_usage = (cnt_tgt_addr[i] / rounds) * 100;\n\t\tprintf(\"[%08.6lf%%] \", tgt_usage);\n\t\tif (i % 8 == 7) {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\tprintf(\"Memory used: %\" PRIu32 \" byte, functions called: %0.0lf\\n\", ctx.state_bytes, rounds);\n\n\tfree(cnt_tgt_addr);\n#endif\t\n\t/* *********** End DEBUG-only statistics *********** */\n\t\n\treturn 0;\n}\n"
        },
        {
            "file_name": "pi64cipher256v1tworounds_encrypt.cpp",
            "content": "// Two rounds of Pi64Cipher256\n// implementation of the algorithm with 64-bit registers and security of 256-bits\n// bitrate is 512-bits, capacity is 512-bits -> state of the permutation function is 1024 bits long\n// key is 256 bits, PMN is 128 bits, SMN is 512 bits and the tag is 512 bits\n/*\n *\n * This code was developed by: Hristina Mihajloska and Danilo Gligoroski\n *\n */\n\n#include \"pi64cipher256v1tworounds_encrypt.h\"\n#include <stdio.h>\n#include \"pi64cipher256v1tworounds_api.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Pi64cipher256v1tworounds_raw {\nint numRounds = -1;\n\n// defining width of variables\ntypedef unsigned char         u_int8_t;\ntypedef unsigned short        u_int16_t;\ntypedef unsigned int          u_int32_t;\ntypedef unsigned long long    u_int64_t;\n\n#define RATE 64       // Rate of the Internal State in Bytes \n#define W 8\t      // Length of the bynary words in bytes\n#define N 4           // Number of chunks of the Internal State\n#define WORDS_CHUNK 4 // Number of w-bit words in one chunk\n#define IS_SIZE (N*4) // Size of the Internal State\n#define R 2\t\t\t  // Tweakable parameter R, that represents the number of rounds in pi-function\n#define bSMN CRYPTO_NSECBYTES/W // Offset for storing ciphertext after encrypted SMN\n\n// **ATTENTION** word_size is in a corellation with data type of InternalState (u_int64_t)\nu_int64_t IS[ IS_SIZE ];\nu_int64_t preCompIS[ IS_SIZE ];\n\n// initialization of the constants, used for the rounds  \nconst u_int64_t Constant[] = { \n  0x271E1D1B170FF0E8, 0xE4E2E1D8D4D2D1CC, 0xCAC9C6C5C3B8B4B2, 0xB1ACAAA9A6A5A39C, 0x9A999695938E8D8B, 0x87787472716C6A69, 0x6665635C5A595655, 0x534E4D4B473C3A39, \n  0x3635332E2D2B271E, 0x1D1B170FF0E8E4E2, 0xE1D8D4D2D1CCCAC9, 0xC6C5C3B8B4B2B1AC, 0xAAA9A6A5A39C9A99, 0x9695938E8D8B8778, 0x7472716C6A696665, 0x635C5A595655534E, \n  0x4D4B473C3A393635, 0x332E2D2B271E1D1B, 0x170FF0E8E4E2E1D8, 0xD4D2D1CCCAC9C6C5, 0xC3B8B4B2B1ACAAA9, 0xA6A5A39C9A999695, 0x938E8D8B87787472, 0x716C6A696665635C, \n  0x5A595655534E4D4B, 0x473C3A393635332E, 0x2D2B271E1D1B170F, 0xF0E8E4E2E1D8D4D2, 0xD1CCCAC9C6C5C3B8, 0xB4B2B1ACAAA9A6A5, 0xA39C9A999695938E, 0x8D8B87787472716C \n};\n\n// precalculated values for the * operation when the constants are used.\n// For the left constants of the rounds are calculated mu(C) and for the right constants nu(C)\nconst u_int64_t preCompConst[] = {\n  0xcfef1a845658df67, 0xece473d44641c7ab, 0x8031a321405d631f, 0xfade2718aa3f04af, 0xe93553e53236d66a, 0x90fbd1832e1f33a1, 0xbcb24e125fd2cf31, 0xea3c32ddc5b1d39e,\n  0x53a81f4591532d3b, 0xe02f10909e31ac36, 0x7583c3b10445de1b, 0xba86f63dd3b74c9e, 0x91b7835a5766e62b, 0x52a04ed1fb274049, 0x95e16bddb994fb76, 0xd88e3bca2c9e7bbf,\n  0x9612db13a8a06987, 0xf48d4c19111d9843, 0xe570003c57d4c90c, 0x5bba8e9eb0390c80, 0xf2fa6ba9b962eeaa, 0xf02e82d200f6f11b, 0x2a64f6bcd6bad13f, 0x23eb74f131d33a95,\n  0x86b6cb48e9d478d3, 0xab62393c653d0504, 0x2c0d636444f25f8d, 0xf91ab5b0b75f5088, 0x1a760223d2cde990, 0x0bd827132f353f09, 0xb3dc04e1dd3056de, 0xbba681c0f3d59d53\n\n};\n\n// macro for left rotation\n#define rotl64(x,n)   (((x) << n) | ((x) >> (64 - n)))\n\n// macro for * operation\n// definition of the mu-transformation\n#define mu64(x0, x1, x2, x3, t4, t5, t6, t7)\\\n{\\\n\tt10 = x0; t11 = x1; t12 = x2; t13 = x3; \\\n\tt8 = (t10  + t11); \\\n\tt9 = (t12  + t13); \\\n\tt0 = (0xF0E8E4E2E1D8D4D2 + t8 +  t12); \\\n\tt0 = rotl64((t0), 7);\\\n\tt1 = (0xD1CCCAC9C6C5C3B8 + t8 +  t13); \\\n\tt1 = rotl64((t1), 19); \\\n\tt2 = (0xB4B2B1ACAAA9A6A5 + t10 +  t9); \\\n\tt2 = rotl64((t2), 31); \\\n\tt3 = (0xA39C9A999695938E + t11 +  t9); \\\n\tt3 = rotl64((t3), 53); \\\n\\\n\tt8 = t0 ^ t1;\\\n\tt9 = t2 ^ t3;\\\n\\\n    t4 = t8 ^ t3;\\\n    t5 = t8 ^ t2;\\\n    t6 = t1 ^ t9;\\\n    t7 = t0 ^ t9;\\\n}\n\n// definition of the nu-transformation\n#define nu64(y0, y1, y2, y3, t8, t9, t10, t11)\\\n{\\\n    t4 = y0; t5 = y1; t6 = y2; t7 = y3; \\\n    t8 = (t6  + t7);\\\n    t9 = (t4  + t5);\\\n    t0 = (0x8D8B87787472716C + t4 +  t8);\\\n    t0 = rotl64((t0), 11);\\\n    t1 = (0x6A696665635C5A59 + t5 +  t8);\\\n    t1 = rotl64((t1), 23);\\\n    t2 = (0x5655534E4D4B473C + t9 +  t6);\\\n\tt2 = rotl64((t2), 37);\\\n    t3 = (0x3A393635332E2D2B + t9 +  t7);\\\n    t3 = rotl64((t3), 59);\\\n\\\n    t12 = t2  ^ t3; \\\n    t13 = t0  ^ t1; \\\n\\\n    t8  = t12 ^ t1; \\\n    t9  = t12 ^ t0; \\\n    t10 = t3 ^ t13; \\\n    t11 = t2 ^ t13; \\\n}\n\n// definition of the sigma-transformation\n#define sigma64(t4, t5, t6, t7, t8, t9, t10, t11, z0, z1, z2, z3) \\\n{ \\\n\tt0 = t4; \\\n\tt1 = t8; \\\n\tz0 = (t5 + t9);  \\\n\tz1 = (t6 + t10); \\\n\tz2 = (t7 + t11); \\\n\tz3 = (t0 + t1);  \\\n}\n\n// The pi-function\n#define pi() \\\n{ \\\n/* 1st round */ \\\n       nu64(IS[0], IS[1], IS[2], IS[3], \\\n\t        IS[0], IS[1], IS[2], IS[3]);\\\n\tsigma64(preCompConst[0], preCompConst[1], preCompConst[2], preCompConst[3], \\\n\t\t\tIS[0], IS[1], IS[2], IS[3], \\\n\t\t    IS[0], IS[1], IS[2], IS[3]); \\\n\tfor ( i = 0; i < N-1; i++ ) { \\\n\t\t\t  mu64(IS[4*i], IS[4*i+1], IS[4*i+2], IS[4*i+3], \\\n\t\t\t\t   preCompIS[4*i], preCompIS[4*i+1], preCompIS[4*i+2], preCompIS[4*i+3]);\\\n\t\t\t  nu64(IS[4*(i+1)], IS[4*(i+1)+1], IS[4*(i+1)+2], IS[4*(i+1)+3], \\\n\t\t\t\t   IS[4*(i+1)], IS[4*(i+1)+1], IS[4*(i+1)+2], IS[4*(i+1)+3]); \\\n\t\t   sigma64(preCompIS[4*i], preCompIS[4*i+1], preCompIS[4*i+2], preCompIS[4*i+3], \\\n\t\t\t\t   IS[4*(i+1)], IS[4*(i+1)+1], IS[4*(i+1)+2], IS[4*(i+1)+3], \\\n\t\t\t\t   IS[4*(i+1)], IS[4*(i+1)+1], IS[4*(i+1)+2], IS[4*(i+1)+3]); \\\n\t} \\\n\t\\\n\t\tmu64(IS[4*(N-1)], IS[4*(N-1)+1], IS[4*(N-1)+2], IS[4*(N-1)+3], \\\n\t\t\t preCompIS[4*(N-1)], preCompIS[4*(N-1)+1], preCompIS[4*(N-1)+2], preCompIS[4*(N-1)+3]); \\\n\tsigma64(preCompIS[4*(N-1)], preCompIS[4*(N-1)+1], preCompIS[4*(N-1)+2], preCompIS[4*(N-1)+3], \\\n\t\t\tpreCompConst[4], preCompConst[5], preCompConst[6], preCompConst[7], \\\n\t\t\tIS[4*(N-1)], IS[4*(N-1)+1], IS[4*(N-1)+2], IS[4*(N-1)+3]); \\\n\tfor ( i = N-1; i >= 1; i-- ) { \\\n\t\t\t  nu64(IS[4*i], IS[4*i+1], IS[4*i+2], IS[4*i+3], \\\n\t\t\t       preCompIS[4*i], preCompIS[4*i+1], preCompIS[4*i+2], preCompIS[4*i+3]); \\\n\t\t   sigma64(preCompIS[4*(i-1)], preCompIS[4*(i-1)+1], preCompIS[4*(i-1)+2], preCompIS[4*(i-1)+3], \\\n\t\t\t   \t   preCompIS[4*i], preCompIS[4*i+1], preCompIS[4*i+2], preCompIS[4*i+3], \\\n\t\t\t\t   IS[4*(i-1)], IS[4*(i-1)+1], IS[4*(i-1)+2], IS[4*(i-1)+3]); \\\n\t} \\\n/* 2nd round */ \\\n\t\tnu64(IS[0], IS[1], IS[2], IS[3], \\\n\t         preCompIS[0], preCompIS[1], preCompIS[2], preCompIS[3]);\\\n\t sigma64(preCompConst[8], preCompConst[9], preCompConst[10], preCompConst[11], \\\n\t\t\tpreCompIS[0], preCompIS[1], preCompIS[2], preCompIS[3], \\\n\t\t    IS[0], IS[1], IS[2], IS[3]); \\\n\tfor ( i = 0; i < N-1; i++ ) { \\\n\t\t\t  mu64(IS[4*i], IS[4*i+1], IS[4*i+2], IS[4*i+3], \\\n\t\t\t\t   preCompIS[4*i], preCompIS[4*i+1], preCompIS[4*i+2], preCompIS[4*i+3]);\\\n\t\t   sigma64(preCompIS[4*i], preCompIS[4*i+1], preCompIS[4*i+2], preCompIS[4*i+3], \\\n\t\t\t\t   preCompIS[4*(i+1)], preCompIS[4*(i+1)+1], preCompIS[4*(i+1)+2], preCompIS[4*(i+1)+3], \\\n\t\t\t\t   IS[4*(i+1)], IS[4*(i+1)+1], IS[4*(i+1)+2], IS[4*(i+1)+3]); \\\n\t} \\\n\t\\\n\t   mu64(IS[4*(N-1)], IS[4*(N-1)+1], IS[4*(N-1)+2], IS[4*(N-1)+3], \\\n\t\t    preCompIS[4*(N-1)], preCompIS[4*(N-1)+1], preCompIS[4*(N-1)+2], preCompIS[4*(N-1)+3]); \\\n\tsigma64(preCompIS[4*(N-1)], preCompIS[4*(N-1)+1], preCompIS[4*(N-1)+2], preCompIS[4*(N-1)+3], \\\n\t\t    preCompConst[12], preCompConst[13], preCompConst[14], preCompConst[15], \\\n\t\t    IS[4*(N-1)], IS[4*(N-1)+1], IS[4*(N-1)+2], IS[4*(N-1)+3]); \\\n\tfor ( i = N-1; i >= 1; i-- ) { \\\n\t\t\t  nu64(IS[4*i], IS[4*i+1], IS[4*i+2], IS[4*i+3], \\\n\t\t\t\t   preCompIS[4*i], preCompIS[4*i+1], preCompIS[4*i+2], preCompIS[4*i+3]); \\\n\t\t   sigma64(preCompIS[4*(i-1)], preCompIS[4*(i-1)+1], preCompIS[4*(i-1)+2], preCompIS[4*(i-1)+3], \\\n\t\t\t\t   preCompIS[4*i], preCompIS[4*i+1], preCompIS[4*i+2], preCompIS[4*i+3], \\\n\t\t\t\t   IS[4*(i-1)], IS[4*(i-1)+1], IS[4*(i-1)+2], IS[4*(i-1)+3]); \\\n\t} \\\n}\n\n// Encrypton and authentication procedure\nint crypto_aead_encrypt(\nunsigned char *c,unsigned long long *clen,\nconst unsigned char *m,unsigned long long mlen,\nconst unsigned char *ad,unsigned long long adlen,\nconst unsigned char *nsec,\nconst unsigned char *npub,\nconst unsigned char *k\n)\n{\n //...\n //... the code for the cipher implementation goes here,\n //... generating a ciphertext c[0],c[1],...,c[*clen-1]\n //... from a plaintext m[0],m[1],...,m[mlen-1]\n //... and associated data ad[0],ad[1],...,ad[adlen-1]\n //... and secret message number nsec[0],nsec[1],...\n //... and public message number npub[0],npub[1],...\n //... and secret key k[0],k[1],...\n //...\n\n // some 64-bit temp variables\n u_int64_t  t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13;\n // more 64-bit temp variables\n u_int64_t  x0, x1, x2, x3, y0, y1, y2, y3, z0, z1, z2, z3;\n // pointers to 64-bit variables\n u_int64_t  *c64, *m64, *ad64, *nsec64, *npub64, *k64;\n // counter ctr is a 64-bit variable in all variants of PiCipher\n u_int64_t  ctr = 0x0000000000000000ull;\n // an array for storing some temporal values for the Tag computation\n u_int64_t  tempTag[CRYPTO_ABYTES/W] = {0};\n // an array for the Common Internal State\n u_int64_t  CIS[IS_SIZE] = {0};\n // pointers that look at the used data arrays as arrays of bytes\n u_int8_t   *InternalState8, *CommonInternalState8, *tempTag8;\n // variables for dealing with various lengths of the plaintext and associated data\n int        LastMessageChunkLength, LastADChunkLength;\n // different iterator variables\n unsigned long long i, j, jj, ii, b, i1, j1, a;\n\n c64    = (u_int64_t *) c;\n m64    = (u_int64_t *) m;\n ad64   = (u_int64_t *) ad;\n nsec64 = (u_int64_t *) nsec;\n npub64 = (u_int64_t *) npub;\n k64    = (u_int64_t *) k;\n InternalState8       = (u_int8_t *) IS;\n CommonInternalState8 = (u_int8_t *) CIS;\n tempTag8             = (u_int8_t *) tempTag;\n\n // phase 1: Initialization\n for (i = 0; i < IS_SIZE; i++ ) {\n\t IS[i] = 0;\n }\n // injection of the key\n for ( i = 0; i < CRYPTO_KEYBYTES; i++ ) {\n\t InternalState8[i] = k[i];\n }\n // injection of the nonce (public message number - PMN)\n for ( j = 0; j < CRYPTO_NPUBBYTES; j++ ) {\n\t InternalState8[i++] = npub[j];\n }\n // appending a single 1 to the concatenated value of the key and PMN\n InternalState8[i] = 0x01;\n\n // applying the permutation function pi\n pi();\n\n // initialization of the Common Internal State (CIS), common for all parallel invocations of pi() with different ctrs\n for ( i = 0; i < IS_SIZE; i++ ) {\n\tCIS[i] = IS[i];\n }\n\n // initialization of the ctr obtained from the first 64 bits of the capacity of CIS\n ctr = CIS[4];\n\n // phase 2: Processing the associated data\n b = 0;\n a = adlen/RATE;\n for ( j = 0; j < a; j ++ ) {\n\t // IS for the triplex component is initialized by the CIS for every AD block\n\tfor ( i = 0; i < IS_SIZE; i++ ) {\n\t\tIS[i] = CIS[i];\n\t}\n\tctr ++;\n\t// Inject ctr + j in IS\n\tIS[0] = IS[0] ^ ctr;\n\tpi();\n\t// process the AD block\n\t// Inject the AD block\n\tfor ( i = 0; i < N; i += 2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\tIS[i*WORDS_CHUNK+i1] = IS[i*WORDS_CHUNK+i1] ^ ad64[b];\n\t\t\tb++;\n\t\t}\n\t}\n\tpi();\n\t// Collect the tag for this block\n\t// Sum of the tags componentwise, where the length of one component is W\n\tjj = 0;\n\tfor ( i = 0; i < N; i+=2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\ttempTag[jj] = tempTag[jj] + IS[i*WORDS_CHUNK+i1];\n\t\t\tjj++;\n\t\t}\n\t}\n }\n // if the last AD block is not the full block, we process it byte by byte\n LastADChunkLength = adlen % RATE;\n if ( LastADChunkLength ) {\n\t b = b * W;\n\t i1 = 0;\n\t for ( i = 0; i < IS_SIZE; i++ ) {\n\t\tIS[i] = CIS[i];\n\t }\n\t ctr++;\n\t IS[0] = IS[0] ^ ctr;\n\t pi();\n\t for ( i = 0; i < LastADChunkLength; i++ ) {\n\t\t InternalState8[i1] = InternalState8[i1++] ^ ad[b+i];\n\t\t if( i1 % (WORDS_CHUNK*W) == 0 ) i1 += WORDS_CHUNK*W;\n\t }\n\t // padding with 10*\n\t InternalState8[LastADChunkLength] = InternalState8[LastADChunkLength] ^ 0x01;\n\t pi();\n\t //updating the tag\n\t jj = 0;\n\t for ( i = 0; i < N; i+=2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\ttempTag[jj] = tempTag[jj] + IS[i*WORDS_CHUNK+i1];\n\t\t\tjj++;\n\t\t}\n\t }\n }\n\n // updating the Common Internal State by injection of the tag (tempTag) obtained from the associated data\n jj = 0;\n for ( i = 0; i < N; i+=2 ) {\n\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\tIS[i*WORDS_CHUNK+i1] = CIS[i*WORDS_CHUNK+i1] ^ tempTag[jj];\n\t\tIS[(i+1)*WORDS_CHUNK+i1] = CIS[(i+1)*WORDS_CHUNK+i1];\n\t\tjj++;\n\t}\n }\n pi();\n for ( i = 0; i < IS_SIZE; i++ ) {\n\tCIS[i] = IS[i];\n }\n\n // phase 3: Processing the secret messge number\n if ( CRYPTO_NSECBYTES > 0 ) {\n\tfor ( i = 0; i < IS_SIZE; i++ ) {\n\t\tIS[i] = CIS[i];\n\t}\n\tctr++;\n\tIS[0] = IS[0] ^ ctr;\n\tpi();\n\t// encrypt the SMN\n\t// Inject the SMN\n\tb = 0;\n\tfor ( i = 0; i < N; i+=2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\tc64[b] = IS[i*WORDS_CHUNK+i1] = IS[i*WORDS_CHUNK+i1] ^ nsec64[b];\n\t\t\tb++;\n\t\t}\n\t}\n\tpi();\n\n\t// updating the Common Internal State from the encrypted SMN\n\tfor ( i = 0; i < IS_SIZE; i++ ) {\n\t\tCIS[i] = IS[i];\n\t}\n\t// Collect the tag from this encryption and update the tempTag\n\tjj = 0;\n\tfor ( i = 0; i < N; i+=2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\ttempTag[jj] = tempTag[jj] + IS[i*WORDS_CHUNK+i1];\n\t\t\tjj++;\n\t\t}\n\t}\n }\n\n //phase 4: Processing the message\n b = 0;\n for ( j = 0; j < mlen/RATE ; j ++ ) {\n\tfor ( i = 0; i < IS_SIZE; i++ ) {\n\t\tIS[i] = CIS[i];\n\t}\n\tctr++;\n\tIS[0] = IS[0] ^ ctr;\n\tpi();\n\t// encrypt the message m\n\t// Inject a block of m\n\tfor ( i = 0; i < N; i+=2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\tc64[bSMN+b] = IS[i*WORDS_CHUNK+i1] = IS[i*WORDS_CHUNK+i1] ^ m64[b];\n\t\t\tb++;\n\t\t}\n\t}\n\tpi();\n\t// Collect the tag from this encryption and update the tempTag\n\tjj = 0;\n\tfor ( i = 0; i < N; i += 2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\ttempTag[jj] = tempTag[jj] + IS[i*WORDS_CHUNK+i1];\n\t\t\tjj++;\n\t\t}\n\t}\n }\n // if the last message block is not the full block, we process it byte by byte\n LastMessageChunkLength = mlen % RATE;\n if ( LastMessageChunkLength ) {\n\t b = b * W;\n\t i1 = 0;\n\t for ( i = 0; i < IS_SIZE; i++ ) {\n\t\tIS[i] = CIS[i];\n\t }\n\t ctr++;\n\t IS[0] = IS[0] ^ ctr;\n\t pi();\n\t for ( i = 0; i < LastMessageChunkLength; i++ ) {\n\t\t c[CRYPTO_NSECBYTES+b+i] = InternalState8[i1] = InternalState8[i1++] ^ m[b+i];\n\t\t if( i1 % (WORDS_CHUNK*W) == 0 ) i1 += WORDS_CHUNK*W;\n\t }\n\t // padding with 10*\n\t InternalState8[LastMessageChunkLength] = InternalState8[LastMessageChunkLength] ^ 0x01;\n\t pi();\n\t // updating the tag\n\t jj = 0;\n\t for ( i = 0; i < N; i+=2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\ttempTag[jj] = tempTag[jj] + IS[i*WORDS_CHUNK+i1];\n\t\t\tjj++;\n\t\t}\n\t }\n }\n\n // concatenation of the tag T to the ciphertext c\n for ( jj = 0; jj < CRYPTO_ABYTES; jj++ ) {\n\tc[CRYPTO_NSECBYTES+mlen+jj] = tempTag8[jj];\n }\n\n //updating the lenght of the ciphertext\n *clen = mlen + CRYPTO_ABYTES + CRYPTO_NSECBYTES;\n\n  return 0;\n}\n\n// Decryption and Verification procedure\nint crypto_aead_decrypt(\nunsigned char *m,unsigned long long *mlen,\nunsigned char *nsec,\nconst unsigned char *c,unsigned long long clen,\nconst unsigned char *ad,unsigned long long adlen,\nconst unsigned char *npub,\nconst unsigned char *k\n)\n{\n //...\n //... the code for the cipher implementation goes here,\n //... generating a plaintext m[0],m[1],...,m[*mlen-1]\n //... and secret message number nsec[0],nsec[1],...\n //... from a ciphertext c[0],c[1],...,c[clen-1]\n //... and associated data ad[0],ad[1],...,ad[adlen-1]\n //... and public message number npub[0],npub[1],...\n //... and secret key k[0],k[1],...\n //...\n\n // some 64-bit temp variables\n u_int64_t  t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13;\n // more 64-bit temp variables\n u_int64_t  x0, x1, x2, x3, y0, y1, y2, y3, z0, z1, z2, z3;\n // pointers to 64-bit variables\n u_int64_t  *c64, *m64, *ad64, *nsec64, *npub64, *k64;\n // an array for storing some temporal values for the Tag computation\n u_int64_t  tempTag[CRYPTO_ABYTES/W] = {0};\n // counter ctr is a 64-bit variable in all variants of PiCipher\n u_int64_t  ctr = 0x0000000000000000ull;\n // an array for the Common Internal State\n u_int64_t  CIS[IS_SIZE]={0};\n // pointers that look at the used data arrays as arrays of bytes\n u_int8_t   *InternalState8, *CommonInternalState8, *tempTag8;\n // variables for dealing with various lengths of the plaintext and associated data\n int LastMessageChunkLength, LastADChunkLength;\n // different iterator variables\n unsigned long long i, j, jj, ii, b, i1, j1, a;\n\n c64    = (u_int64_t *) c;\n m64    = (u_int64_t *) m;\n ad64   = (u_int64_t *) ad;\n nsec64 = (u_int64_t *) nsec;\n npub64 = (u_int64_t *) npub;\n k64    = (u_int64_t *) k;\n InternalState8 = (u_int8_t *) IS;\n CommonInternalState8 = (u_int8_t *) CIS;\n tempTag8 = (u_int8_t *) tempTag;\n\n // phase 1: Initialization\n for (i = 0; i < IS_SIZE; i++ ) {\n\t IS[i] = 0;\n }\n // injection of the key\n for ( i = 0; i < CRYPTO_KEYBYTES; i++ ) {\n\t InternalState8[i] = k[i];\n }\n // injection of the nonce (public message number - PMN)\n for ( j = 0; j < CRYPTO_NPUBBYTES; j++ ) {\n\t InternalState8[i++] = npub[j];\n }\n // appending a single 1 to the concatenated value of the key and PMN\n InternalState8[i] = 0x01;\n\n // applying the permutation function pi\n pi();\n\n // initialization of the Common Internal State (CIS), common for all parallel invocations of pi() with different ctrs\n for ( i = 0; i < IS_SIZE; i++ ) {\n\tCIS[i] = IS[i];\n }\n\n // initialization of the ctr obtained from the first 64 bits of the capacity of CIS\n ctr = CIS[4];\n\n // phase 2: Processing the associated data\n b = 0;\n a = adlen/RATE;\n for ( j = 0; j < a; j ++ ) {\n\t // IS for the triplex component is initialized by the CIS for every AD block\n\tfor ( i = 0; i < IS_SIZE; i++ ) {\n\t\tIS[i] = CIS[i];\n\t}\n\tctr ++;\n\t// Inject ctr + j in IS\n\tIS[0] = IS[0] ^ ctr;\n\tpi();\n\t// process the AD block\n\t// Inject the AD block\n\tfor ( i = 0; i < N; i += 2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\tIS[i*WORDS_CHUNK+i1] = IS[i*WORDS_CHUNK+i1] ^ ad64[b];\n\t\t\tb++;\n\t\t}\n\t}\n\tpi();\n\t// Collect the tag for this block\n\t// Sum of the tags componentwise, where the length of one component is W\n\tjj = 0;\n\tfor ( i = 0; i < N; i+=2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\ttempTag[jj] = tempTag[jj] + IS[i*WORDS_CHUNK+i1];\n\t\t\tjj++;\n\t\t}\n\t}\n }\n // if the last AD block is not the full block, we process it byte by byte\n LastADChunkLength = adlen % RATE;\n if ( LastADChunkLength ) {\n\t b = b * W;\n\t i1 = 0;\n\t for ( i = 0; i < IS_SIZE; i++ ) {\n\t\tIS[i] = CIS[i];\n\t }\n\t ctr++;\n\t IS[0] = IS[0] ^ ctr;\n\t pi();\n\t for ( i = 0; i < LastADChunkLength; i++ ) {\n\t\t InternalState8[i1] = InternalState8[i1++] ^ ad[b+i];\n\t\t if( i1 % (WORDS_CHUNK*W) == 0 ) i1 += WORDS_CHUNK*W;\n\t }\n\t // padding with 10*\n\t InternalState8[LastADChunkLength] = InternalState8[LastADChunkLength] ^ 0x01;\n\t pi();\n\t //updating the tag\n\t jj = 0;\n\t for ( i = 0; i < N; i+=2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\ttempTag[jj] = tempTag[jj] + IS[i*WORDS_CHUNK+i1];\n\t\t\tjj++;\n\t\t}\n\t }\n }\n\n // updating the Common Internal State by injection of the tag (tempTag) obtained from the associated data\n jj = 0;\n for ( i = 0; i < N; i+=2 ) {\n\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\tIS[i*WORDS_CHUNK+i1] = CIS[i*WORDS_CHUNK+i1] ^ tempTag[jj];\n\t\tIS[(i+1)*WORDS_CHUNK+i1] = CIS[(i+1)*WORDS_CHUNK+i1];\n\t\tjj++;\n\t}\n }\n pi();\n for ( i = 0; i < IS_SIZE; i++ ) {\n\tCIS[i] = IS[i];\n }\n\n\n // phase 3: Processing the secret messge number\n if ( CRYPTO_NSECBYTES > 0 ) {\n\tfor ( i = 0; i < IS_SIZE; i++ ) {\n\t\tIS[i] = CIS[i];\n\t}\n\tctr++;\n\tIS[0] = IS[0] ^ ctr;\n\tpi();\n\t// decrypt the SMN\n\t// Inject the SMN\n\tb = 0;\n\tfor ( i = 0; i < N; i+=2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\tnsec64[b] = IS[i*WORDS_CHUNK+i1] ^ c64[b];\n\t\t\tIS[i*WORDS_CHUNK+i1] = c64[b];\n\t\t\tb++;\n\t\t}\n\t}\n\tpi();\n\n\t// updating the Common Internal State after decrypting the SMN\n\tfor ( i = 0; i < IS_SIZE; i++ ) {\n\t\tCIS[i] = IS[i];\n\t}\n\t// Collect the tag from this encryption and update the tempTag\n\tjj = 0;\n\tfor ( i = 0; i < N; i+=2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\ttempTag[jj] = tempTag[jj] + IS[i*WORDS_CHUNK+i1];\n\t\t\tjj++;\n\t\t}\n\t}\n }\n\n //phase 4: Processing the ciphertext\n b = 0;\n for ( j = 0; j < (clen-CRYPTO_ABYTES-CRYPTO_NSECBYTES)/RATE; j ++ ) {\n\tfor ( i = 0; i < IS_SIZE; i++ ) {\n\t\tIS[i] = CIS[i];\n\t}\n\tctr ++;\n\tIS[0] = IS[0] ^ ctr;\n\tpi();\n\t// decrypt the ciphertext c\n\tfor ( i = 0; i < N; i+=2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t        // XOR the IS_bitrate (InternalState[0], InternalSate[2], ...) with the c to obtain m\n\t\t\tm64[b] = IS[i*WORDS_CHUNK+i1] ^ c64[bSMN+b];\n\t\t\t// in order to proceed for tag computation, put the ciphertext data in the InternalState\n\t\t\tIS[i*WORDS_CHUNK+i1] = c64[bSMN+b];\n\t\t\tb++;\n\t\t}\n\t}\n\tpi();\n\t// Collect the tag from this decryption and update the tempTag\n\tjj = 0;\n\tfor ( i = 0; i < N; i+=2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\ttempTag[jj] = tempTag[jj] + IS[i*WORDS_CHUNK+i1];\n\t\t\tjj++;\n\t\t}\n\t}\n }\n // if the last ciphertext block is not the full block, we process it byte by byte\n LastMessageChunkLength = (clen-CRYPTO_ABYTES-CRYPTO_NSECBYTES) % RATE;\n if ( LastMessageChunkLength ) {\n\t b = b * W;\n\t i1 = 0;\n\t for ( i = 0; i < IS_SIZE; i++ ) {\n\t\tIS[i] = CIS[i];\n\t }\n\t ctr ++;\n\t IS[0] = IS[0] ^ ctr;\n\t pi();\n\n\t for ( i = 0; i < LastMessageChunkLength; i++ ) {\n\t \t m[b+i] = InternalState8[i1] ^ c[CRYPTO_NSECBYTES+b+i];\n\t \t InternalState8[i1++] = c[CRYPTO_NSECBYTES+b+i];\n\t\t if( i1 % (WORDS_CHUNK*W) == 0 ) i1 += WORDS_CHUNK*W;\n\t }\n\t // padding with 10*\n\t InternalState8[LastMessageChunkLength] = InternalState8[LastMessageChunkLength] ^ 0x01;\n\t pi();\n\t // updating the tag\n\t jj = 0;\n\t for ( i = 0; i < N; i+=2 ) {\n\t\tfor ( i1 = 0; i1 < WORDS_CHUNK; i1++ ) {\n\t\t\ttempTag[jj] = tempTag[jj] + IS[i*WORDS_CHUNK+i1];\n\t\t\tjj++;\n\t\t}\n\t }\n }\n\n //updating the lenght of the message\n *mlen = clen-CRYPTO_ABYTES-CRYPTO_NSECBYTES;\n\n // tag verification\n for ( ii = (*mlen + CRYPTO_NSECBYTES); ii < clen; ii ++ ) {\n\t if ( c[ii] != tempTag8[ii-(*mlen + CRYPTO_NSECBYTES)] )\n\t\treturn -1;\n }\n\n return 0;\n}\n\n} // namespace Pi64cipher256v1tworounds_raw\n"
        },
        {
            "file_name": "polawisv1_decode_POLAWIS.cpp",
            "content": "namespace Polawisv1_raw {\nint numRounds = -1;\n\n//POLAWIS 1.0\n//15-04-2014, Wysokinski Arkadiusz, e-mail: polawis@sedkomp.com.pl\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <gmp.h>\n\n#define jak 32\n#define rp 301 //297 //301\n#define ch 256\n#define rund 8\n\n    int rount(double number){ return (number >= 0) ? (int)(number + 0.5) : (int)(number - 0.5); }\n\nint main(int argc, char *argv[])\n{\tmpz_t apods;\n    mpz_init(apods);\n    char *pp , *klg[6], *kluczc, *komc;\n    int dm, mm,m, dbg=1, dz=1, auth=1;\n\nm=jak;\n\n{mpz_ui_pow_ui(apods,ch,m); if (rp < 0) \n{mpz_sub_ui(apods,apods,abs(rp));} else {mpz_add_ui(apods,apods,rp);} mm=m;}\n\n    FILE *in = stdin; FILE *out = stdout; FILE *klucz = klucz;  FILE *kom = kom;\n    unsigned b4 = 1, e4 = 1 , kl[2*rund*m], tab_wy[6*m], tab[6*m];\n    int j=rund, dj=8, i, ii, h=254, k=0, stan, length=0, dtab_wy[6*m], dkl[32], mli=0,lll=0, warunek;\n    double dklpom[8], de[8], dc[2*rund*m], w=1000000.1, dtab[6*m], dx1, dx2, dx3, dx4, dc2, dc3, dc1, dc4, db4, dy1, dy2, dy3, dy4, dz2, dz3;\n    long int  min, max, inne=0, suma=0, tab_chr[256];\n    long int  mind, maxd, inned=0, sumad=0, tab_chrd[256];\n    mpz_t  k1g, k2g, k3g, k4g, d2g, d3g, d1g, d4g;\n    mpz_t  x1g, x2g, x3g, x4g, c2g, c3g, c1g, c4g;\n    mpz_t klpomg[rund], cg[2*rund];\n  \nmpz_init(k1g); mpz_init(k2g); mpz_init(k3g); mpz_init(k4g); \nmpz_init(d1g); mpz_init(d2g); mpz_init(d3g); mpz_init(d4g); \nmpz_init(x1g); mpz_init(x2g); mpz_init(x3g); mpz_init(x4g); \nmpz_init(c1g); mpz_init(c2g); mpz_init(c3g); mpz_init(c4g); \nfor (i=0;i<(2*rund);i++) {mpz_init(cg[i]);}\nfor (i=0;i<(rund);i++) {mpz_init(klpomg[i]);}\n\n#include <sys/time.h>\nstruct timeval tv1,tv2;\nstruct timeval tvdiff;\nstruct timezone tz;\nvoid timediff(struct timeval* a,struct timeval* b,struct timeval* result)\n{    (result)->tv_sec  = (a)->tv_sec  - (b)->tv_sec;\n    (result)->tv_usec = (a)->tv_usec - (b)->tv_usec;\n    if((result)->tv_usec < 0)\n    {   --(result)->tv_sec; (result)->tv_usec += 1000000;    }\t}\n\nfor (i=0;i<256;i++) {tab_chr[i]=0; }\nfor (i=0;i<256;i++) {tab_chrd[i]=0; }\n\nmpz_t wy; mpz_t wy_p;\nmpz_init(wy); mpz_init(wy_p);\n\nvoid char_to_int_gmp(int poz){\nint l=0, ll; \n\tmpz_set_ui(wy,0);\n\tmpz_set_ui(wy_p,1);\n\t    for (ll=m-1;ll>=0;ll--) {\n\t\tmpz_ui_pow_ui(wy_p,ch,ll);\n\t\tmpz_mul_ui(wy_p,wy_p,tab[(poz*m+l)]);\n\t        mpz_add(wy,wy,wy_p);\n\t    l++;}\n\tmpz_mod(wy,wy,apods);\n}\n\nmpz_t wep; mpz_t we_p; mpz_t we_p2;\nmpz_init(wep); mpz_init(we_p); mpz_init(we_p2);\n\nvoid int_to_chargg(mpz_t we, int poz){\nint l,ll;\n    mpz_set(wep,we);\n\tmpz_ui_pow_ui(we_p,ch,m-1);\n\tmpz_tdiv_q(we_p2,wep,we_p);\n\ttab_wy[(poz*m+0)]=mpz_get_ui(we_p2);\n\t    l=0; \n\t\tfor (ll=m-1;ll>1;ll--) {l++;\n    \t\tmpz_ui_pow_ui(we_p,ch,ll);\n\t\tmpz_mod(we_p,wep,we_p);\n\t        mpz_ui_pow_ui(we_p2,ch,ll-1);\n\t\tmpz_tdiv_q(we_p,we_p,we_p2);\n\t\ttab_wy[(poz*m+l)]=mpz_get_ui(we_p);\n\t\t}\n\tmpz_mod_ui(we_p,wep,ch);\n\ttab_wy[(poz*m+l+1)]=mpz_get_ui(we_p); }\n\nkluczc=\"./.key_gmp.txt\";\nkomc=\"./.komchr.txt\";\nwhile (argc != 1)\n    {\n      if (strcmp (argv[1], \"-k\") == 0)\n\t{\n\t    kluczc=argv[2];\n\t  argv++;\n\t  argc--;\n\t}\n      if (strcmp (argv[1], \"-m\") == 0)\n\t{\n\t    komc=argv[2];\n\t  argv++;\n\t  argc--;\n\t}\n      if (strcmp (argv[1], \"-s\") == 0)\n\t{\n\tdbg=0;\n\t  argv++;\n\t  argc--;\n\t}\n      if (strcmp (argv[1], \"-z\") == 0)\n\t{\n\tdz=0;\n\t  argv++;\n\t  argc--;\n\t}\n      else\n\t{  argv++;\n\t  argc--; }\n    }\n\nkom = fopen( komc, \"a+\" );\t    \nif (dbg) {  fprintf(kom,\"\\n--start dekoding-- \\n\");\n\t    fprintf(kom,\"(%i:=%ibits)p= 2^%i+(%i) \\n\",m,m*8,m*8,rp);\n\t    }\n    /* first, record the start time */\n    if(gettimeofday(&tv1,&tz)!=0)\n        fprintf(kom,\"\\nWarning : could not gettimeofday() !\");\n\nklucz = fopen( kluczc , \"rb\" );\t\nwhile ( ((getc(klucz)) != EOF) ) {k++;}\nif (k<(rund*2*m)) {length++; goto koniec;}\nfclose(klucz);\n\nklucz = fopen( kluczc , \"rb\" );\t\nfread(kl,m,2*rund,klucz);\t\n        for (i=0; i<2*rund; i++){\nif (m>35) {mpz_import (cg[i], 1, 1, m*8*2, 0, 0, &kl[i]);}\nelse {\nif (m<=4) {mpz_import (cg[i], 1, 1, m*1*1, 0, 0, &kl[i]);}\nelse { mpz_import (cg[i], 1, 1, m*8*1, 0, 0, &kl[i]);}\n}\nmpz_mod(cg[i],cg[i],apods);\n}\nfclose(klucz);\n\ndm=m/4;\nklucz = fopen( kluczc, \"rb\" );\t\nfread(kl,4,2*rund*dm,klucz);\t\n\nfor (i=0; i<2*dj; i++)\n{\ndc[i]=0;\nfor (ii=0;ii<dm;ii++) {  \ndc[i]=dc[i]+kl[i+(ii*2*dj)]/(100000000.0*dm);}\n} \n\ndb4=256.000000000000001;\nde[0]=db4; de[1]=db4/2; de[2]=64; de[3]=32; de[4]=16; de[5]=8; de[6]=4; de[7]=2;\n\nmpz_set(c1g,cg[0]);\nmpz_mul_ui(c1g,c1g,2); mpz_mod(c1g,c1g,apods);\n\nif ( (mpz_cmp_ui(c1g,0)==0) )\n{ goto koniec;}\n\n{   \nif (dz) {\n    fread(dtab,1*sizeof(double),6,in);\n\n    dc2=dtab[4]; dc3=dtab[5]; dx1=dtab[0]; dx2=dtab[1]; dx3=dtab[2]; dx4=dtab[3];\nfor (i=dj;i>0;i--) {\n    dc1=dc[2*i-2]; dc4=dc[2*i-1];\n\n    dy1=dx1*dc1-dx2*dc2-dx3*dc3-dx4*dc4; dy2=dx2*dc1+dx1*dc2-dx4*dc3+dx3*dc4;\n    dy3=dx3*dc1+dx4*dc2+dx1*dc3-dx2*dc4; dy4=2*dx4*dc1+2*dx1*dc4-db4;\n    dz2=dx2*dc1+dx1*dc2+dx4*dc3-dx3*dc4; dz3=dx3*dc1-dx4*dc2+dx1*dc3+dx2*dc4;\n\ndx1=dy1; dx2=dy2; dx3=dy3; dx4=dy4; dc2=dz2; dc3=dz3;\ndklpom[i-1]=dx1;\n}\t\n\nfor (i=dj;i>1;i--) { dc[2*i-1]=dklpom[i-1]/w; }\n\n    dtab_wy[0]=rount(dy1); dtab_wy[1]=rount(dy2);\n    dtab_wy[2]=rount(dy3); dtab_wy[3]=rount(dy4);\n    dtab_wy[4]=rount(dz2); dtab_wy[5]=rount(dz3);\n\nif (dbg) { for (i=0;i<6;i++) {fprintf(kom,\":%i:\",dtab_wy[i]);} }\n\nif (dbg) { \nif ((dtab_wy[0]!=0)||(dtab_wy[1]!=0)||(dtab_wy[2]!=0)||(dtab_wy[3]!=0)||(dtab_wy[4]!=0)||(dtab_wy[5]!=0) ) \n{fprintf(kom,\" INVALID  KEY \\n\");} else { fprintf(kom,\" KEY OK\\n\");} }\n\nif ((dtab_wy[0]!=0)||(dtab_wy[1]!=0)||(dtab_wy[2]!=0)||(dtab_wy[3]!=0)||(dtab_wy[4]!=0)||(dtab_wy[5]!=0) ) \n{ goto koniec;}\n} //end if\n\n    fread(dtab,1*sizeof(double),6,in);\n\n    dc2=dtab[4]; dc3=dtab[5]; dx1=dtab[0]; dx2=dtab[1]; dx3=dtab[2]; dx4=dtab[3];\nfor (i=dj;i>0;i--) {\n    dc1=dc[2*i-2]; dc4=dc[2*i-1];\n\n    dy1=dx1*dc1-dx2*dc2-dx3*dc3-dx4*dc4; dy2=dx2*dc1+dx1*dc2-dx4*dc3+dx3*dc4;\n    dy3=dx3*dc1+dx4*dc2+dx1*dc3-dx2*dc4; dy4=2*dx4*dc1+2*dx1*dc4-db4;\n    dz2=dx2*dc1+dx1*dc2+dx4*dc3-dx3*dc4; dz3=dx3*dc1-dx4*dc2+dx1*dc3+dx2*dc4;\n\ndx1=dy1; dx2=dy2; dx3=dy3; dx4=dy4; dc2=dz2; dc3=dz3;\ndklpom[i-1]=dx1;\n}\t\nfor (i=dj;i>1;i--) { dc[2*i-1]=dklpom[i-1]/w; }\n\n    dtab_wy[0]=rount(dy1); dtab_wy[1]=rount(dy2);\n    dtab_wy[2]=rount(dy3); dtab_wy[3]=rount(dy4);\n    dtab_wy[4]=rount(dz2); dtab_wy[5]=rount(dz3);\n    }\n\nif (dbg) { for (i=0;i<6;i++) {fprintf(kom,\":%i:\",dtab_wy[i]);} fprintf(kom,\"\\n\"); }\n\n//differ header start\nfor (k=0; k<(6*m); k++) {tab[k]=getchar(); }\n\nchar_to_int_gmp(4); mpz_set(d2g,wy);\nchar_to_int_gmp(5); mpz_set(d3g,wy);\nchar_to_int_gmp(0); mpz_set(k1g,wy);\nchar_to_int_gmp(1); mpz_set(k2g,wy);\nchar_to_int_gmp(2); mpz_set(k3g,wy);\nchar_to_int_gmp(3); mpz_set(k4g,wy);\n\nfor (i=j;i>0;i--) {\n    mpz_set(d1g,cg[2*i-2]); mpz_set(d4g,cg[2*i-1]); \n\n       mpz_mul(x1g,k1g,d1g); mpz_mod(x1g,x1g,apods);\n    mpz_submul(x1g,k2g,d2g); mpz_mod(x1g,x1g,apods);\n    mpz_submul(x1g,k3g,d3g); mpz_mod(x1g,x1g,apods);\n    mpz_submul(x1g,k4g,d4g); mpz_mod(x1g,x1g,apods);\n       mpz_mul(x2g,k2g,d1g); mpz_mod(x2g,x2g,apods);\n    mpz_addmul(x2g,k1g,d2g); mpz_mod(x2g,x2g,apods);\n    mpz_submul(x2g,k4g,d3g); mpz_mod(x2g,x2g,apods);\n    mpz_addmul(x2g,k3g,d4g); mpz_mod(x2g,x2g,apods);\n       mpz_mul(x3g,k3g,d1g); mpz_mod(x3g,x3g,apods);\n    mpz_addmul(x3g,k4g,d2g); mpz_mod(x3g,x3g,apods);\n    mpz_addmul(x3g,k1g,d3g); mpz_mod(x3g,x3g,apods);\n    mpz_submul(x3g,k2g,d4g); mpz_mod(x3g,x3g,apods);\n       mpz_mul(x4g,k4g,d1g); mpz_mod(x4g,x4g,apods);\n    mpz_addmul(x4g,k4g,d1g); mpz_mod(x4g,x4g,apods);\n    mpz_addmul(x4g,k1g,d4g); mpz_mod(x4g,x4g,apods);\n    mpz_addmul(x4g,k1g,d4g); mpz_mod(x4g,x4g,apods);\n    mpz_sub_ui(x4g,x4g,e4); mpz_mod(x4g,x4g,apods);\n       mpz_mul(c2g,k2g,d1g); mpz_mod(c2g,c2g,apods);\n    mpz_addmul(c2g,k1g,d2g); mpz_mod(c2g,c2g,apods);\n    mpz_addmul(c2g,k4g,d3g); mpz_mod(c2g,c2g,apods);\n    mpz_submul(c2g,k3g,d4g); mpz_mod(c2g,c2g,apods);\n       mpz_mul(c3g,k3g,d1g); mpz_mod(c3g,c3g,apods);\n    mpz_submul(c3g,k4g,d2g); mpz_mod(c3g,c3g,apods);\n    mpz_addmul(c3g,k1g,d3g); mpz_mod(c3g,c3g,apods);\n    mpz_addmul(c3g,k2g,d4g); mpz_mod(c3g,c3g,apods);\n\nmpz_set(klpomg[i-1],x1g);\nmpz_set(k1g,x1g); mpz_set(k2g,x2g); mpz_set(k3g,x3g); mpz_set(k4g,x4g); mpz_set(d2g,c2g); mpz_set(d3g,c3g);\n}\t\nfor (i=j;i>1;i--) { mpz_set(cg[2*i-2],klpomg[i-1]); }\n//header end\n\ntab[0]=getchar();\nwhile( !feof(in) )\n{\nfor (k=1; k<(6*m); k++) {tab[k]=getchar(); }\n\nchar_to_int_gmp(4); mpz_set(d2g,wy);\nchar_to_int_gmp(5); mpz_set(d3g,wy);\nchar_to_int_gmp(0); mpz_set(k1g,wy);\nchar_to_int_gmp(1); mpz_set(k2g,wy);\nchar_to_int_gmp(2); mpz_set(k3g,wy);\nchar_to_int_gmp(3); mpz_set(k4g,wy);\n\nif (tab[0]==h) { warunek=(tab[0]==h);for (i=1;i<(6*m);i++) {warunek=(warunek && (tab[i]==h));} }\nelse {warunek=0;}\n\nif ( warunek )\n    {\n    lll++;\n\n//addition R\n\nif (dz) {\n    fread(dtab,1*sizeof(double),6,in);\n\n    dc2=dtab[4]; dc3=dtab[5]; dx1=dtab[0]; dx2=dtab[1]; dx3=dtab[2]; dx4=dtab[3];\nfor (i=dj;i>0;i--) {\n    dc1=dc[2*i-2]; dc4=dc[2*i-1];\n\n    dy1=dx1*dc1-dx2*dc2-dx3*dc3-dx4*dc4; dy2=dx2*dc1+dx1*dc2-dx4*dc3+dx3*dc4;\n    dy3=dx3*dc1+dx4*dc2+dx1*dc3-dx2*dc4; dy4=2*dx4*dc1+2*dx1*dc4-db4;\n    dz2=dx2*dc1+dx1*dc2+dx4*dc3-dx3*dc4; dz3=dx3*dc1-dx4*dc2+dx1*dc3+dx2*dc4;\n\ndx1=dy1; dx2=dy2; dx3=dy3; dx4=dy4; dc2=dz2; dc3=dz3;\ndklpom[i-1]=dx1;\n}\t\n\nfor (i=dj;i>1;i--) { dc[2*i-1]=dklpom[i-1]/w; }\n\n    dtab_wy[0]=rount(dy1); dtab_wy[1]=rount(dy2);\n    dtab_wy[2]=rount(dy3); dtab_wy[3]=rount(dy4);\n    dtab_wy[4]=rount(dz2); dtab_wy[5]=rount(dz3);\n\nif (dbg) { for (i=0;i<6;i++) {fprintf(kom,\":%i:\",dtab_wy[i]);} }\n\nif (dbg) { \nif ((dtab_wy[0]!=0)||(dtab_wy[1]!=0)||(dtab_wy[2]!=0)||(dtab_wy[3]!=0)||(dtab_wy[4]!=0)||(dtab_wy[5]!=0) ) \n{auth=0; fprintf(kom,\" INVALID  KEY, end on R\\n\");} else { fprintf(kom,\" KEY OK, end on R\\n\");} }\n\nif ((dtab_wy[0]!=0)||(dtab_wy[1]!=0)||(dtab_wy[2]!=0)||(dtab_wy[3]!=0)||(dtab_wy[4]!=0)||(dtab_wy[5]!=0) ) \n{ goto koniec;}\n}\n//addition end\n\n//addition Zp\nfor (k=0; k<(6*m); k++) {tab[k]=getchar(); }\n\nchar_to_int_gmp(4); mpz_set(d2g,wy);\nchar_to_int_gmp(5); mpz_set(d3g,wy);\nchar_to_int_gmp(0); mpz_set(k1g,wy);\nchar_to_int_gmp(1); mpz_set(k2g,wy);\nchar_to_int_gmp(2); mpz_set(k3g,wy);\nchar_to_int_gmp(3); mpz_set(k4g,wy);\n\nfor (i=j;i>0;i--) {\n    mpz_set(d1g,cg[2*i-2]); mpz_set(d4g,cg[2*i-1]); \n\n       mpz_mul(x1g,k1g,d1g); mpz_mod(x1g,x1g,apods);\n    mpz_submul(x1g,k2g,d2g); mpz_mod(x1g,x1g,apods);\n    mpz_submul(x1g,k3g,d3g); mpz_mod(x1g,x1g,apods);\n    mpz_submul(x1g,k4g,d4g); mpz_mod(x1g,x1g,apods);\n       mpz_mul(x2g,k2g,d1g); mpz_mod(x2g,x2g,apods);\n    mpz_addmul(x2g,k1g,d2g); mpz_mod(x2g,x2g,apods);\n    mpz_submul(x2g,k4g,d3g); mpz_mod(x2g,x2g,apods);\n    mpz_addmul(x2g,k3g,d4g); mpz_mod(x2g,x2g,apods);\n       mpz_mul(x3g,k3g,d1g); mpz_mod(x3g,x3g,apods);\n    mpz_addmul(x3g,k4g,d2g); mpz_mod(x3g,x3g,apods);\n    mpz_addmul(x3g,k1g,d3g); mpz_mod(x3g,x3g,apods);\n    mpz_submul(x3g,k2g,d4g); mpz_mod(x3g,x3g,apods);\n       mpz_mul(x4g,k4g,d1g); mpz_mod(x4g,x4g,apods);\n    mpz_addmul(x4g,k4g,d1g); mpz_mod(x4g,x4g,apods);\n    mpz_addmul(x4g,k1g,d4g); mpz_mod(x4g,x4g,apods);\n    mpz_addmul(x4g,k1g,d4g); mpz_mod(x4g,x4g,apods);\n    mpz_sub_ui(x4g,x4g,e4); mpz_mod(x4g,x4g,apods);\n       mpz_mul(c2g,k2g,d1g); mpz_mod(c2g,c2g,apods);\n    mpz_addmul(c2g,k1g,d2g); mpz_mod(c2g,c2g,apods);\n    mpz_addmul(c2g,k4g,d3g); mpz_mod(c2g,c2g,apods);\n    mpz_submul(c2g,k3g,d4g); mpz_mod(c2g,c2g,apods);\n       mpz_mul(c3g,k3g,d1g); mpz_mod(c3g,c3g,apods);\n    mpz_submul(c3g,k4g,d2g); mpz_mod(c3g,c3g,apods);\n    mpz_addmul(c3g,k1g,d3g); mpz_mod(c3g,c3g,apods);\n    mpz_addmul(c3g,k2g,d4g); mpz_mod(c3g,c3g,apods);\n\nmpz_set(klpomg[i-1],x1g);\nmpz_set(k1g,x1g); mpz_set(k2g,x2g); mpz_set(k3g,x3g); mpz_set(k4g,x4g); mpz_set(d2g,c2g); mpz_set(d3g,c3g);\n}\t\nfor (i=j;i>1;i--) { mpz_set(cg[2*i-2],klpomg[i-1]); }\n\n    dtab_wy[0]=mpz_get_ui(x1g); dtab_wy[1]=mpz_get_ui(x2g);\n    dtab_wy[2]=mpz_get_ui(x3g); dtab_wy[3]=mpz_get_ui(x4g);\n    dtab_wy[4]=mpz_get_ui(c2g); dtab_wy[5]=mpz_get_ui(c3g);\n\nif (dbg) { for (i=0;i<6;i++) {fprintf(kom,\":%i:\",dtab_wy[i]);} }\n\nif (dbg) { \nif ((dtab_wy[0]!=0)||(dtab_wy[1]!=0)||(dtab_wy[2]!=0)||(dtab_wy[3]!=0)||(dtab_wy[4]!=0)||(dtab_wy[5]!=0) ) \n{auth=0; fprintf(kom,\" INVALID  KEY, end on Zp\\n\");} else { fprintf(kom,\" KEY OK, end on Zp\\n\");} }\n\nif ((dtab_wy[0]!=0)||(dtab_wy[1]!=0)||(dtab_wy[2]!=0)||(dtab_wy[3]!=0)||(dtab_wy[4]!=0)||(dtab_wy[5]!=0) ) \n{ goto koniec;}\n//addition Zp end\n\n    fread(dtab,1*sizeof(double),(6*m),in);\n\nfor (ii=0;ii<m;ii++) {\n    dc2=dtab[4+6*ii]; dc3=dtab[5+6*ii]; dx1=dtab[0+6*ii]; \n    dx2=dtab[1+6*ii]; dx3=dtab[2+6*ii]; dx4=dtab[3+6*ii];\n\nfor (i=dj;i>0;i--) {\n    dc1=dc[2*i-2]; dc4=dc[2*i-1];\n\n    dy1=dx1*dc1-dx2*dc2-dx3*dc3-dx4*dc4; dy2=dx2*dc1+dx1*dc2-dx4*dc3+dx3*dc4;\n    dy3=dx3*dc1+dx4*dc2+dx1*dc3-dx2*dc4; dy4=2*dx4*dc1+2*dx1*dc4-de[i-1];\n    dz2=dx2*dc1+dx1*dc2+dx4*dc3-dx3*dc4; dz3=dx3*dc1-dx4*dc2+dx1*dc3+dx2*dc4;\n\ndx1=dy1; dx2=dy2; dx3=dy3; dx4=dy4; dc2=dz2; dc3=dz3;\ndklpom[i-1]=dx1;\n}\t\n\nfor (i=dj;i>1;i--) { dc[2*i-1]=dklpom[i-1]/w; }\n\n    dtab_wy[0+6*ii]=rount(dy1); dtab_wy[1+6*ii]=rount(dy2)-11;\n    dtab_wy[2+6*ii]=rount(dy3)-3; dtab_wy[3+6*ii]=rount(dy4);\n    dtab_wy[4+6*ii]=rount(dz2)-5; dtab_wy[5+6*ii]=rount(dz3)-7;\n} //end for 2\n\n        for (i=0;i<(6*m);i++) {\ttab_chrd[tab[i]]++;\t}\n\n    i=0;\n    while ( (i<(6*m)) && (dtab_wy[i]!=EOF) ) {fputc(dtab_wy[i],out);\n    \ttab_chr[dtab_wy[i]]++;\n     i++;}\n    }\nelse\n    {\nmli++;\nfor (i=j;i>0;i--) {\n    mpz_set(d1g,cg[2*i-2]); mpz_set(d4g,cg[2*i-1]); \n\n       mpz_mul(x1g,k1g,d1g);\n    mpz_submul(x1g,k2g,d2g);\n    mpz_submul(x1g,k3g,d3g);\n    mpz_submul(x1g,k4g,d4g); mpz_mod(x1g,x1g,apods);\n       mpz_mul(x2g,k2g,d1g);\n    mpz_addmul(x2g,k1g,d2g);\n    mpz_submul(x2g,k4g,d3g);\n    mpz_addmul(x2g,k3g,d4g); mpz_mod(x2g,x2g,apods);\n       mpz_mul(x3g,k3g,d1g);\n    mpz_addmul(x3g,k4g,d2g);\n    mpz_addmul(x3g,k1g,d3g);\n    mpz_submul(x3g,k2g,d4g); mpz_mod(x3g,x3g,apods);\n       mpz_mul(x4g,k4g,d1g);\n    mpz_addmul(x4g,k4g,d1g);\n    mpz_addmul(x4g,k1g,d4g);\n    mpz_addmul(x4g,k1g,d4g);\n    mpz_sub_ui(x4g,x4g,e4); mpz_mod(x4g,x4g,apods);\n       mpz_mul(c2g,k2g,d1g);\n    mpz_addmul(c2g,k1g,d2g);\n    mpz_addmul(c2g,k4g,d3g);\n    mpz_submul(c2g,k3g,d4g); mpz_mod(c2g,c2g,apods);\n       mpz_mul(c3g,k3g,d1g);\n    mpz_submul(c3g,k4g,d2g);\n    mpz_addmul(c3g,k1g,d3g);\n    mpz_addmul(c3g,k2g,d4g); mpz_mod(c3g,c3g,apods);\n\nmpz_set(klpomg[i-1],x1g);\nmpz_set(k1g,x1g); mpz_set(k2g,x2g); mpz_set(k3g,x3g); mpz_set(k4g,x4g); mpz_set(d2g,c2g); mpz_set(d3g,c3g);\n}\t\nfor (i=j;i>1;i--) { mpz_set(cg[2*i-1],klpomg[i-1]); }\n\nint_to_chargg(c2g,4);\nint_to_chargg(c3g,5);\nint_to_chargg(x1g,0);\nint_to_chargg(x2g,1);\nint_to_chargg(x3g,2);\nint_to_chargg(x4g,3);\n\n        for (i=0;i<(6*m);i++) {putchar(tab_wy[i]);\n\ttab_chr[tab_wy[i]]++;\n\ttab_chrd[tab[i]]++;\t}\n\t\n    }//end else BAD\ntab[0]=getchar();\n} //endwhile\n\n    if(gettimeofday(&tv2,&tz)!=0)\n     fprintf(kom,\"\\nWarning : could not gettimeofday() !\"); \n\n    if (dbg) { fprintf(kom,\"\\ngettimeofday()=%i\",tv2); }\n\n    timediff(&tv2,&tv1,&tvdiff);\n\nif (dbg) { fprintf(kom,\"\\nProcess DEKODING took (including I/O): %f sec\",(tvdiff.tv_sec+0.000001*tvdiff.tv_usec)); }\n    \nif (dbg) { fprintf(kom,\"\\nProcess DEKODING took (including I/O): %f kB/sec\",0.001*((8*12+6*m+mli*6*m+(lll)*(6*9*m+6*(m+8)))/(tvdiff.tv_sec + 0.000001*tvdiff.tv_usec))); }\n\nif (dbg) {\nfor (i=0;i<256;i++) {\nsumad=sumad+tab_chrd[i]; }\nmind=tab_chrd[0];\nmaxd=tab_chrd[0];\nfor (i=0;i<256;i++) \n{\nif (tab_chrd[i]>maxd) {maxd=tab_chrd[i];}\nif (tab_chrd[i]<mind) {mind=tab_chrd[i];}\n}\nfprintf(kom,\"\\nStatistics for cipher characters(ZpQ): (%i%s%i) difference %i that is %f %% (%i) s:=%i\",mind,\"<\",maxd,maxd-mind,100.0*(maxd-mind)/maxd, inned, sumad);\n\nfor (i=0;i<256;i++) {\nsuma=suma+tab_chr[i]; }\nmin=tab_chr[0];\nmax=tab_chr[0];\nfor (i=0;i<256;i++) \n{\nif (tab_chr[i]>max) {max=tab_chr[i];}\nif (tab_chr[i]<min) {min=tab_chr[i];}\n}\nfprintf(kom,\"\\nStatistics for plaintext  characters : (%i%s%i) difference %i that is %f %% (%i) s:=%i\",min,\"<\",max,max-min,100.0*(max-min)/max, inne, suma);\n}\n\nkoniec:\nmpz_mul_ui(c1g,c1g,2); mpz_mod(c1g,c1g,apods);\nif ( (mpz_cmp_ui(c1g,0)==0) ) { fprintf(kom,\"\\n BAD KEY !!! \\n\"); }\nif ( (length!=0) ) { fprintf(kom,\"\\n BAD LENGTH KEY !!! \\n\"); }\n\nif (dbg) { \n\t    if (auth==0) fprintf(kom,\"\\n AUTHORIZATION BAD!!!\");\n\t    fprintf(kom,\"\\n--end dekod--\\n\"); }\n\tfclose(kom);\n\tfclose(klucz);\n\tfclose(in); \n\tfclose(out);\n\nmpz_clear(k1g); mpz_clear(k2g); mpz_clear(k3g); mpz_clear(k4g); \nmpz_clear(d1g); mpz_clear(d2g); mpz_clear(d3g); mpz_clear(d4g); \nmpz_clear(x1g); mpz_clear(x2g); mpz_clear(x3g); mpz_clear(x4g); \nmpz_clear(c1g); mpz_clear(c2g); mpz_clear(c3g); mpz_clear(c4g); \nfor (i=0;i<(2*rund);i++) {mpz_clear(cg[i]);}\nfor (i=0;i<(rund);i++) {mpz_clear(klpomg[i]);}\n\nmpz_clear(wy); mpz_clear(wy_p);\nmpz_clear(wep); mpz_clear(we_p); mpz_clear(we_p2);\nmpz_clear(apods); \n} //endmain\n\n} // namespace Polawisv1_raw\n"
        },
        {
            "file_name": "polawisv1_encode_POLAWIS.cpp",
            "content": "namespace Polawisv1_raw {\nint numRounds = -1;\n\n//POLAWIS 1.0\n//15-04-2014, Wysokinski Arkadiusz, e-mail: polawis@sedkomp.com.pl\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <gmp.h>\n\n#define jak 32 \n#define rp 301 //297 //301\n#define ch 256\n#define rund 8\n\nint main(int argc, char *argv[])\n{\n\tmpz_t apods,qg,q1g;\n    mpz_init(apods); mpz_init(qg); mpz_init(q1g);\n    mpz_t rop;\n    mpz_init(rop);\n\n    char *pp, *qq, *qq1, *klg[6], *komc, *kluczc;\n    int dm, mm, m, dbg=1;\n\nm=jak;\n\n{mpz_ui_pow_ui(apods,ch,m); if (rp < 0) \n{mpz_sub_ui(apods,apods,abs(rp));} else {mpz_add_ui(apods,apods,rp);} mm=m;}\n\n    mpz_ui_pow_ui(q1g,ch,m); mpz_sub_ui(q1g,q1g,1); qq1=mpz_get_str(NULL,10,q1g);\n    if (mpz_cmp(apods,q1g) > 0) {mpz_set(qg,q1g);} else {mpz_set(qg,apods);\n    mpz_sub_ui(qg,qg,1); } \n    qq=mpz_get_str(NULL,10,qg); \n    pp=mpz_get_str(NULL,10,apods); \n\nmpz_t hd1, hd2;\nmpz_init(hd1); mpz_init(hd2);\n\nmpz_t dhd1, dhd2;\nmpz_init(dhd1); mpz_init(dhd2);\n\n  FILE *in = stdin;  FILE *out = stdout; FILE *klucz = klucz; FILE *kom = kom;\n    double fproc, modf;\n    \n    unsigned tab[6*m], kl[2*rund*m];\n    double dklpom[8], de[8], dc[2*rund*m], dtab[6*m], w=1000000.1, dx1, dx2, dx3, dx4, dc1, dc2, dc3, dc4, da1, da2, da3, da4, db2, db3, db4;\n    int dkl[32], dz=1;\n    int tab_we[6*m];\n    int   e4 = 1, b4 = 1, problem=0, prob=0;\n    int j=rund, dj=8, i=0, ii, h=254, z=1, k=0, length=0;\n    int mli=0, lli=0, lll=0, llt0=0, llt1=0, llt2=0, llt3=0, llt4=0, llt5=0, llt6=0, llt7=0, llt8=0, llt9=0, llt10=0, llt11=0, llt12=0, llt13=0;\n    unsigned modi, hamdchr=0, hamdi, hamdmin=8, hamdmax=0, hamdit[9];\n    double  hamd=0;\n    unsigned dhamdchr=0, dhamdi, dhamdit[33], dhamdmin=0, dhamdmax=0;\n    double  dhamd=0;\n    int  stime;\n    long ltime;\n  long int  min, max, inne=0, suma=0, tab_chr[256];\n  long int  mind, maxd, inned=0, sumad=0, tab_chrd[256];\n    mpz_t  k1g, k2g, k3g, k4g, d2g, d3g, d1g, d4g;\n    mpz_t  x1g, x2g, x3g, x4g, c2g, c3g, c1g, c4g;\n    mpz_t  klpomg[rund+1], cg[2*rund+1], modig, lig, mng;\n    mpz_t  pa2b2, pa3b3, pa4b4, m2d1;\n    \nmpz_init(k1g); mpz_init(k2g); mpz_init(k3g); mpz_init(k4g); \nmpz_init(d1g); mpz_init(d2g); mpz_init(d3g); mpz_init(d4g); \nmpz_init(x1g); mpz_init(x2g); mpz_init(x3g); mpz_init(x4g); \nmpz_init(c1g); mpz_init(c2g); mpz_init(c3g); mpz_init(c4g); \nfor (i=0;i<=(2*rund);i++) {mpz_init(cg[i]);}\nfor (i=0;i<=(rund);i++) {mpz_init(klpomg[i]);}\nmpz_init(modig); mpz_init(lig); mpz_init(mng);\nmpz_init(pa2b2); mpz_init(pa3b3); mpz_init(pa4b4); mpz_init(m2d1);\n\nmpz_t wy; mpz_t wy_p;\nmpz_init(wy); mpz_init(wy_p);\n\nvoid char_to_int_gmp(int poz){\nint l=0, ll; \n\tmpz_set_ui(wy,0);\n\tmpz_set_ui(wy_p,1);\n\t    for (ll=m-1;ll>=0;ll--) {\n\t\tmpz_ui_pow_ui(wy_p,ch,ll);\n\t\tmpz_mul_ui(wy_p,wy_p,tab_we[(poz*m+l)]);\n\t        mpz_add(wy,wy,wy_p);\n\t    l++;}\n}\n\nmpz_t wep; mpz_t we_p; mpz_t we_p2;\nmpz_init(wep); mpz_init(we_p); mpz_init(we_p2);\n\nvoid int_to_chargg(mpz_t we, int poz){\nint l,ll;\n    mpz_set(wep,we);\n\tmpz_ui_pow_ui(we_p,ch,m-1);\n\tmpz_tdiv_q(we_p2,wep,we_p);\n\ttab[(poz*m+0)]=mpz_get_ui(we_p2);\n\t    l=0; \n\t\tfor (ll=m-1;ll>1;ll--) {l++;\n    \t\tmpz_ui_pow_ui(we_p,ch,ll);\n\t\tmpz_mod(we_p,wep,we_p);\n\t        mpz_ui_pow_ui(we_p2,ch,ll-1);\n\t\tmpz_tdiv_q(we_p,we_p,we_p2);\n\t\ttab[(poz*m+l)]=mpz_get_ui(we_p);\n\t\t}\n\tmpz_mod_ui(we_p,wep,ch);\n\ttab[(poz*m+l+1)]=mpz_get_ui(we_p); }\n\n        ltime = time(NULL);\n\t  stime = (unsigned) ltime/2;\n//\t    srand(stime);\n    gmp_randstate_t state;\n    gmp_randinit_default(state);\n    gmp_randseed_ui(state,stime);\n\nfor (i=0;i<256;i++) {tab_chr[i]=0; }\nfor (i=0;i<256;i++) {tab_chrd[i]=0; }\n\nfor (i=0; i<=8; i++) {hamdit[i]=0;}\n\nfor (i=0; i<=8*4; i++) {dhamdit[i]=0;}\n\n#include <sys/time.h>\n\nstruct timeval tv1,tv2;\nstruct timeval tvdiff;\nstruct timezone tz;\n\nvoid timediff(struct timeval* a,struct timeval* b,struct timeval* result)\n{    (result)->tv_sec  = (a)->tv_sec  - (b)->tv_sec;\n    (result)->tv_usec = (a)->tv_usec - (b)->tv_usec;\n\n    if((result)->tv_usec < 0)\n    {\n        --(result)->tv_sec;\n        (result)->tv_usec += 1000000;\n    }\n} \n\nkluczc=\"./.key_gmp.txt\";\nkomc=\"./.komchr.txt\";\nwhile (argc != 1)\n    {\n      if (strcmp (argv[1], \"-k\") == 0)\n\t{\n\t    kluczc=argv[2];\n\t  argv++;\n\t  argc--;\n\t}\n      if (strcmp (argv[1], \"-m\") == 0)\n\t{\n\t    komc=argv[2];\n\t  argv++;\n\t  argc--;\n\t}\n      if (strcmp (argv[1], \"-s\") == 0)\n\t{\n\tdbg=0;\n\t  argv++;\n\t  argc--;\n\t}\n      if (strcmp (argv[1], \"-z\") == 0)\n\t{\n\tdz=0;\n\t  argv++;\n\t  argc--;\n\t}\n      else\n\t{  argv++;\n\t  argc--; }\n    }\n\nkom = fopen( komc, \"a+\" );\t    \nif (dbg) { fprintf(kom,\"\\n -START KODING- \\n\");\n\t    fprintf(kom,\"(%i:=%ibit)p=2^%i+(%i);\\n p=%s;\\n q=%s;\\nq1=%s; \\n\",m,m*8,m*8,rp,pp,qq,qq1);\n\t     }\n    /* first, record the start time */\n    if(gettimeofday(&tv1,&tz)!=0)\n        fprintf(kom,\"\\nWarning : could not gettimeofday() !\");\n\n    if (dbg) { fprintf(kom,\"\\ngettimeofday()=%i\",tv1);}\n\nklucz = fopen( kluczc, \"rb\" );\t\nwhile ( ((getc(klucz)) != EOF) ) {k++;}\nif (k<(rund*2*m)) {length++; goto koniec;}\nfclose(klucz);\n\nklucz = fopen( kluczc, \"rb\" );\t\nfread(kl,m,2*rund,klucz);\t\n        for (i=0; i<2*rund; i++){\nif (m>35) {mpz_import (cg[i], 1, 1, m*8*2, 0, 0, &kl[i]);}\nelse {\nif (m<=4) {mpz_import (cg[i], 1, 1, m*1*1, 0, 0, &kl[i]);}\nelse { mpz_import (cg[i], 1, 1, m*8*1, 0, 0, &kl[i]);}\n}\nmpz_mod(cg[i],cg[i],apods);\n}\nfclose(klucz);\n\ndm=m/4;\nklucz = fopen( kluczc, \"rb\" );\t\nfread(kl,4,2*rund*dm,klucz);\t\nfor (i=0; i<2*dj; i++)\n{\ndc[i]=0;\nfor (ii=0;ii<dm;ii++) {  \ndc[i]=dc[i]+kl[i+(ii*2*dj)]/(100000000.0*dm);}\n} \ndb4=256.000000000000001; \nde[0]=db4; de[1]=db4/2; de[2]=64; de[3]=32; de[4]=16; de[5]=8; de[6]=4; de[7]=2;\n\nif (dz) {\n\tfor (i=0; i<(6*m); i++) { tab_we[i]=0; }\n\tda3=tab_we[2]; da4=tab_we[3]; db2=tab_we[4]; \n\tdb3=tab_we[5]; da1=tab_we[0]; da2=tab_we[1];\n\nfor (i=0;i<dj;i++) { dc1=dc[2*i+0]; dc4=dc[2*i+1];\n\n\t    dc2=(dc1*(da3-db3)+dc4*(da2+db2))/(da4+db4); \n\t    dc3=(dc4*(da3+db3)-dc1*(da2-db2))/(da4+db4);\ndx1=(2*da1*dc1+dc2*(da2+db2)+dc3*(da3+db3)+dc4*(da4+db4))/(2*(dc1*dc1+dc2*dc2+dc3*dc3+dc4*dc4));\n\t    dx2=((da2+db2)/(2*dc1))-((dc2/dc1)*dx1);\n\t    dx3=((da3+db3)/(2*dc1))-((dc3/dc1)*dx1);\n\t    dx4=((da4+db4)/(2*dc1))-((dc4/dc1)*dx1);\n\nda1=dx1; da2=dx2; da3=dx3; da4=dx4; db2=dc2; db3=dc3;\ndklpom[i]=dx1;\n} //end for\nfor (i=1;i<dj;i++) { dc[2*i+1]=dklpom[i-1]/w; }\n\ndtab[0]=dx1; dtab[1]=dx2; dtab[2]=dx3; dtab[3]=dx4;\ndtab[4]=dc2; dtab[5]=dc3;\n\nfwrite(dtab,1*sizeof(double),6,out);\n} //end if\n\nfor (i=0;i<(6*m);i++) {mpz_urandomb(rop,state,8); tab_we[i]=(mpz_get_ui(rop)); }\n\n\tda3=tab_we[2]; da4=tab_we[3]; db2=tab_we[4]; \n\tdb3=tab_we[5]; da1=tab_we[0]; da2=tab_we[1];\n\nfor (i=0;i<dj;i++) { dc1=dc[2*i+0]; dc4=dc[2*i+1];\n\t\t    dc2=(dc1*(da3-db3)+dc4*(da2+db2))/(da4+db4); \n\t\t    dc3=(dc4*(da3+db3)-dc1*(da2-db2))/(da4+db4);\ndx1=(2*da1*dc1+dc2*(da2+db2)+dc3*(da3+db3)+dc4*(da4+db4))/(2*(dc1*dc1+dc2*dc2+dc3*dc3+dc4*dc4));\n\t\t    dx2=((da2+db2)/(2*dc1))-((dc2/dc1)*dx1);\n\t\t    dx3=((da3+db3)/(2*dc1))-((dc3/dc1)*dx1);\n\t\t    dx4=((da4+db4)/(2*dc1))-((dc4/dc1)*dx1);\n\nda1=dx1; da2=dx2; da3=dx3; da4=dx4; db2=dc2; db3=dc3;\ndklpom[i]=dx1; } //end for\nfor (i=1;i<dj;i++) { dc[2*i+1]=dklpom[i-1]/w; }\n\ndtab[0]=dx1; dtab[1]=dx2; dtab[2]=dx3; dtab[3]=dx4;dtab[4]=dc2; dtab[5]=dc3;\nfwrite(dtab,1*sizeof(double),6,out);\n\n//differ header/key start\nmpz_set(c1g,cg[0]);\nmpz_mul_ui(c1g,c1g,2); mpz_mod(c1g,c1g,apods);\nif ( (mpz_cmp_ui(c1g,0)==0) )\n{ llt4++; goto koniec;}\nelse {\n\ndo {\nfor (i=0;i<(6*m);i++) {mpz_urandomb(rop,state,m); tab_we[i]=(mpz_get_ui(rop)); }\n\nfor (ii=0;ii<(m-1);ii++) {\nfor (i=0; i<6; i++) { tab_we[m*i+ii]=0; } }\n\nchar_to_int_gmp(4); mpz_set(c2g,wy);\nchar_to_int_gmp(5); mpz_set(c3g,wy);\nchar_to_int_gmp(0); mpz_set(x1g,wy);\nchar_to_int_gmp(1); mpz_set(x2g,wy);\nchar_to_int_gmp(2); mpz_set(x3g,wy);\nchar_to_int_gmp(3); mpz_set(x4g,wy);\n\nmpz_set(d1g,cg[0]); mpz_set(d4g,cg[1]);\nmpz_set(c1g,cg[0]); mpz_set(c4g,cg[1]);\n\n       mpz_sub(lig,x3g,c3g); \n       mpz_mul(lig,lig,d1g); mpz_mod(lig,lig,apods);\n       mpz_add(mng,x2g,c2g); \n       mpz_mul(mng,mng,d4g); mpz_mod(mng,mng,apods);\n       mpz_add(lig,lig,mng); \n       mpz_add_ui(mng,x4g,e4);\n\t   mpz_invert(mng,mng,apods);\n\t   mpz_mul(d2g,lig,mng); mpz_mod(d2g,d2g,apods);\n\n       mpz_sub(lig,x2g,c2g); \n       mpz_mul(lig,lig,d1g); mpz_mod(lig,lig,apods);\n       mpz_add(mng,x3g,c3g); \n       mpz_mul(mng,mng,d4g); mpz_mod(mng,mng,apods);\n       mpz_sub(lig,mng,lig);  \n       mpz_add_ui(mng,x4g,e4);\n\t   mpz_invert(mng,mng,apods);\n\t   mpz_mul(d3g,lig,mng); mpz_mod(d3g,d3g,apods);\n\n\tmpz_mul(modig,c1g,c1g);    mpz_mod(modig,modig,apods);\n\tmpz_addmul(modig,c2g,c2g); mpz_mod(modig,modig,apods);\n\tmpz_addmul(modig,c3g,c3g); mpz_mod(modig,modig,apods);\n\tmpz_addmul(modig,c4g,c4g); mpz_mod(modig,modig,apods);\n\t    mpz_mul_ui(modig,modig,2); mpz_mod(modig,modig,apods);\n\nmpz_add_ui(wy,x4g,e4); mpz_mod(wy,wy,apods);\nmpz_mul_ui(wy_p,d1g,2); mpz_mod(wy_p,wy_p,apods);\n\n} while ( !( (mpz_cmp_ui(modig,0)!=0) && (mpz_cmp_ui(wy,0)!=0) && (mpz_cmp_ui(d1g,0)!=0) && (mpz_cmp_ui(wy_p,0)!=0) ) );\t\n}\nfor (i=0;i<j;i++) { \nmpz_set(d1g,cg[2*i+0]); mpz_set(d4g,cg[2*i+1]);\nmpz_set(c1g,cg[2*i+0]); mpz_set(c4g,cg[2*i+1]);\n\n       mpz_sub(lig,x3g,c3g); \n       mpz_mul(lig,lig,d1g); mpz_mod(lig,lig,apods);\n       mpz_add(mng,x2g,c2g); \n       mpz_mul(mng,mng,d4g); mpz_mod(mng,mng,apods);\n       mpz_add(lig,lig,mng); \n       mpz_add_ui(mng,x4g,e4);\n\t   mpz_invert(mng,mng,apods);\n\t   mpz_mul(d2g,lig,mng); mpz_mod(d2g,d2g,apods);\n\n       mpz_sub(lig,x2g,c2g);\n       mpz_mul(lig,lig,d1g); mpz_mod(lig,lig,apods);\n       mpz_add(mng,x3g,c3g); \n       mpz_mul(mng,mng,d4g); mpz_mod(mng,mng,apods);\n       mpz_sub(lig,mng,lig); \n       mpz_add_ui(mng,x4g,e4);\n\t   mpz_invert(mng,mng,apods);\n\t   mpz_mul(d3g,lig,mng); mpz_mod(d3g,d3g,apods);\n\n\tmpz_mul(modig,d1g,d1g); mpz_mod(modig,modig,apods);\n\tmpz_addmul(modig,d2g,d2g); mpz_mod(modig,modig,apods);\n\tmpz_addmul(modig,d3g,d3g); mpz_mod(modig,modig,apods);\n\tmpz_addmul(modig,d4g,d4g); mpz_mod(modig,modig,apods);\n\t    mpz_mul_ui(modig,modig,2); mpz_mod(modig,modig,apods);\n\tmpz_mul_ui(lig,x1g,2);  mpz_mod(lig,lig,apods);\n\tmpz_mul(lig,lig,d1g);   mpz_mod(lig,lig,apods);\n\tmpz_add(mng,x2g,c2g); \n\tmpz_addmul(lig,mng,d2g);mpz_mod(lig,lig,apods);\n\tmpz_add(mng,x3g,c3g); \n\tmpz_addmul(lig,mng,d3g); mpz_mod(lig,lig,apods);\n\tmpz_add_ui(mng,x4g,e4);\n\tmpz_addmul(lig,mng,d4g);mpz_mod(lig,lig,apods);\n\t   mpz_invert(mng,modig,apods); mpz_mod(mng,mng,apods);\n\t   mpz_mul(k1g,lig,mng); mpz_mod(k1g,k1g,apods);\n\t\n\tmpz_add(lig,x2g,c2g); \n\tmpz_mul_ui(mng,d1g,2);  mpz_mod(mng,mng,apods);\n        mpz_invert(mng,mng,apods); \n        mpz_mul(k2g,lig,mng); mpz_mod(k2g,k2g,apods);\t\n        mpz_invert(lig,d1g,apods);\n        mpz_mul(lig,d2g,lig);mpz_mod(lig,lig,apods);\t\n\tmpz_mul(lig,lig,k1g);    mpz_mod(lig,lig,apods);\n\t    mpz_sub(k2g,k2g,lig);   mpz_mod(k2g,k2g,apods);\n\n\tmpz_add(lig,x3g,c3g); \n\tmpz_mul_ui(mng,d1g,2);  mpz_mod(mng,mng,apods);\n        mpz_invert(mng,mng,apods); \n        mpz_mul(k3g,lig,mng); mpz_mod(k3g,k3g,apods);\t\n        mpz_invert(lig,d1g,apods);\n        mpz_mul(lig,d3g,lig);mpz_mod(lig,lig,apods);\t\n\tmpz_mul(lig,lig,k1g);    mpz_mod(lig,lig,apods);\n\t    mpz_sub(k3g,k3g,lig);   mpz_mod(k3g,k3g,apods);\n    \n\tmpz_add_ui(lig,x4g,e4); \n\tmpz_mul_ui(mng,d1g,2);  mpz_mod(mng,mng,apods);\n        mpz_invert(mng,mng,apods); \n        mpz_mul(k4g,lig,mng); mpz_mod(k4g,k4g,apods);\t\n        mpz_invert(lig,d1g,apods);\n        mpz_mul(lig,d4g,lig);mpz_mod(lig,lig,apods);\t\n\tmpz_mul(lig,lig,k1g);    mpz_mod(lig,lig,apods);\n\t    mpz_sub(k4g,k4g,lig);   mpz_mod(k4g,k4g,apods);\n\nmpz_set(c2g,d2g); mpz_set(c3g,d3g);\nmpz_set(x1g,k1g); mpz_set(x2g,k2g); mpz_set(x3g,k3g); mpz_set(x4g,k4g);\n\nmpz_set(klpomg[i],x1g);\n} //end for\n\nfor (i=1;i<j;i++) { mpz_set(cg[2*i+0],klpomg[i-1]); }\n\nint_to_chargg(d2g,4);\nint_to_chargg(d3g,5);\nint_to_chargg(k1g,0);\nint_to_chargg(k2g,1);\nint_to_chargg(k3g,2);\nint_to_chargg(k4g,3);\n\nfor (i=0; i<(6*m); i++) { putchar(tab[i]);}\n//header end\n\nk=0;\nwhile ( !feof(in) )\n{\nwhile ( ((tab_we[k]=getchar()) != EOF) && ( k<((6*m)-1) )) {k++;}\nmpz_set(d1g,cg[0]); mpz_set(d4g,cg[1]);\nmpz_set(c1g,cg[0]); mpz_set(c4g,cg[1]);\n\nchar_to_int_gmp(4); mpz_set(c2g,wy);\nchar_to_int_gmp(5); mpz_set(c3g,wy);\nchar_to_int_gmp(0); mpz_set(x1g,wy);\nchar_to_int_gmp(1); mpz_set(x2g,wy);\nchar_to_int_gmp(2); mpz_set(x3g,wy);\nchar_to_int_gmp(3); mpz_set(x4g,wy);\n\n       mpz_sub(lig,x3g,c3g); \n       mpz_mul(lig,lig,d1g);\n       mpz_add(mng,x2g,c2g); \n       mpz_mul(mng,mng,d4g);\n       mpz_add(lig,lig,mng); \n       mpz_add_ui(mng,x4g,e4);\n\t   mpz_invert(mng,mng,apods);\n\t   mpz_mul(d2g,lig,mng); mpz_mod(d2g,d2g,apods);\n\n       mpz_sub(lig,x2g,c2g);\n       mpz_mul(lig,lig,d1g);\n       mpz_add(mng,x3g,c3g);\n       mpz_mul(mng,mng,d4g);\n       mpz_sub(lig,mng,lig); \n       mpz_add_ui(mng,x4g,e4);\n\t   mpz_invert(mng,mng,apods);\n\t   mpz_mul(d3g,lig,mng); mpz_mod(d3g,d3g,apods);\n\n\tmpz_mul(modig,c1g,c1g);\n\tmpz_addmul(modig,c2g,c2g);\n\tmpz_addmul(modig,c3g,c3g);\n\tmpz_addmul(modig,c4g,c4g);\n\t    mpz_mul_ui(modig,modig,2); mpz_mod(modig,modig,apods);\n\nmpz_add_ui(wy,x4g,e4); mpz_mod(wy,wy,apods);\nmpz_mul_ui(wy_p,c1g,2); mpz_mod(wy_p,wy_p,apods);\nif ( ((tab_we[k])==EOF) || (mpz_cmp_ui(modig,0)==0) || (mpz_cmp_ui(wy_p,0)==0) || (mpz_cmp_ui(wy,0)==0) ||  (mpz_cmp(x1g,qg)>0) || (mpz_cmp(x2g,qg)>0) || (mpz_cmp(x3g,qg)>0) || (mpz_cmp(x4g,qg)>0) || (mpz_cmp(c2g,qg)>0) || (mpz_cmp(c3g,qg)>0) ) {\n\nif ( (mpz_cmp_ui(wy_p,0)==0) ) \n{ llt4++; goto koniec;}\nif ( (mpz_cmp_ui(wy,0)==0) ) \n{ llt5++; }\nif ( (mpz_cmp_ui(modig,0)==0) ) \n{ llt6++; }\nif ( (tab_we[k]==EOF) ) \n{ llt7++; }\n\nif ( (mpz_cmp(x1g,qg)>0) ) \n{ llt8++; }\nif ( (mpz_cmp(x2g,qg)>0) ) \n{ llt9++; }\nif ( (mpz_cmp(x3g,qg)>0) ) \n{ llt10++; }\nif ( (mpz_cmp(x4g,qg)>0) ) \n{ llt11++; }\nif ( (mpz_cmp(c2g,qg)>0) ) \n{ llt12++; }\nif ( (mpz_cmp(c3g,qg)>0) ) \n{ llt13++; }\n\nlli++;\n{ goto licznadQR; }\n}\n\nelse {\n\nfor (i=0;i<j;i++) { \nmpz_set(d1g,cg[2*i+0]); mpz_set(d4g,cg[2*i+1]);\nmpz_set(c1g,cg[2*i+0]); mpz_set(c4g,cg[2*i+1]);\n\nmpz_add(pa2b2,x2g,c2g);\nmpz_add(pa3b3,x3g,c3g);\nmpz_add_ui(pa4b4,x4g,e4); \nmpz_mul_ui(m2d1,d1g,2);\n\n       mpz_sub(lig,x3g,c3g);\n       mpz_mul(lig,lig,d1g);\n       mpz_mul(mng,pa2b2,d4g);\n       mpz_add(lig,lig,mng);\n\t   mpz_invert(mng,pa4b4,apods);\n\t   mpz_mul(d2g,lig,mng); mpz_mod(d2g,d2g,apods);\n\n       mpz_sub(lig,x2g,c2g);\n       mpz_mul(lig,lig,d1g);\n       mpz_mul(mng,pa3b3,d4g);\n       mpz_sub(lig,mng,lig);\n\t   mpz_invert(mng,pa4b4,apods);\n\t   mpz_mul(d3g,lig,mng); mpz_mod(d3g,d3g,apods);\n\n\tmpz_mul(modig,c1g,c1g);\n\tmpz_addmul(modig,c2g,c2g);\n\tmpz_addmul(modig,c3g,c3g);\n\tmpz_addmul(modig,c4g,c4g);\n\t    mpz_mul_ui(modig,modig,2); mpz_mod(modig,modig,apods);\n\n\tmpz_mul(modig,d1g,d1g);\n\tmpz_addmul(modig,d2g,d2g);\n\tmpz_addmul(modig,d3g,d3g);\n\tmpz_addmul(modig,d4g,d4g);\n\t    mpz_mul_ui(modig,modig,2);\n\tmpz_mul_ui(lig,x1g,2);\n\tmpz_mul(lig,lig,d1g);\n\tmpz_addmul(lig,pa2b2,d2g);\n\tmpz_addmul(lig,pa3b3,d3g);\n\tmpz_addmul(lig,pa4b4,d4g);\n\t   mpz_invert(mng,modig,apods);\n\t   mpz_mul(k1g,lig,mng); mpz_mod(k1g,k1g,apods);\n\n        mpz_invert(mng,m2d1,apods); \n        mpz_mul(k2g,pa2b2,mng);\n        mpz_invert(lig,d1g,apods);\n        mpz_mul(lig,d2g,lig);\n\tmpz_mul(lig,lig,k1g);\n\t    mpz_sub(k2g,k2g,lig);   mpz_mod(k2g,k2g,apods);\n\n        mpz_invert(mng,m2d1,apods); \n        mpz_mul(k3g,pa3b3,mng);\n        mpz_invert(lig,d1g,apods);\n        mpz_mul(lig,d3g,lig);\n\tmpz_mul(lig,lig,k1g);\n\t    mpz_sub(k3g,k3g,lig);   mpz_mod(k3g,k3g,apods);\n\n        mpz_invert(mng,m2d1,apods); \n        mpz_mul(k4g,pa4b4,mng);\n        mpz_invert(lig,d1g,apods);\n        mpz_mul(lig,d4g,lig);\n\tmpz_mul(lig,lig,k1g);\n\t    mpz_sub(k4g,k4g,lig);   mpz_mod(k4g,k4g,apods);\n\nmpz_set(c2g,d2g); mpz_set(c3g,d3g);\nmpz_set(x1g,k1g); mpz_set(x2g,k2g); mpz_set(x3g,k3g); mpz_set(x4g,k4g);\n\nmpz_set(klpomg[i],x1g);\n\nmpz_add_ui(wy,x4g,e4); mpz_mod(wy,wy,apods);\nmpz_mul_ui(wy_p,c1g,2); mpz_mod(wy_p,wy_p,apods);\n\nif ( (mpz_cmp_ui(wy_p,0)==0) ) \n{ llt0++; goto licznadQR; }\n\nif ( (mpz_cmp_ui(c1g,0)==0) ) \n{ llt3++; goto licznadQR; }\n\nif ( (mpz_cmp_ui(wy,0)==0) ) \n{ llt1++;  goto licznadQR; }\n\nif ( (mpz_cmp_ui(modig,0)==0) ) \n{ llt2++;  goto licznadQR; }\n} //end for\n\nint_to_chargg(d2g,4);\nint_to_chargg(d3g,5);\nint_to_chargg(k1g,0);\nint_to_chargg(k2g,1);\nint_to_chargg(k3g,2);\nint_to_chargg(k4g,3);\n\nif ( (mpz_cmp(k1g,q1g)>0) || (mpz_cmp(k2g,q1g)>0) || (mpz_cmp(k3g,q1g)>0) || (mpz_cmp(k4g,q1g)>0) || (mpz_cmp(d2g,q1g)>0) || (mpz_cmp(d3g,q1g)>0) )\n{\nprob++;\nlicznadQR:\nlll++;\nfor (i=0; i<(6*m); i++) { putchar(h); }\n\n//additional R\nif (dz) {\n\tda3=0; da4=0; db2=0; \n\tdb3=0; da1=0; da2=0;\n\nfor (i=0;i<dj;i++) { dc1=dc[2*i+0]; dc4=dc[2*i+1];\n\n\t    dc2=(dc1*(da3-db3)+dc4*(da2+db2))/(da4+db4); \n\t    dc3=(dc4*(da3+db3)-dc1*(da2-db2))/(da4+db4);\ndx1=(2*da1*dc1+dc2*(da2+db2)+dc3*(da3+db3)+dc4*(da4+db4))/(2*(dc1*dc1+dc2*dc2+dc3*dc3+dc4*dc4));\n\t    dx2=((da2+db2)/(2*dc1))-((dc2/dc1)*dx1);\n\t    dx3=((da3+db3)/(2*dc1))-((dc3/dc1)*dx1);\n\t    dx4=((da4+db4)/(2*dc1))-((dc4/dc1)*dx1);\n\nda1=dx1; da2=dx2; da3=dx3; da4=dx4; db2=dc2; db3=dc3;\ndklpom[i]=dx1;\n} //end for\nfor (i=1;i<dj;i++) { dc[2*i+1]=dklpom[i-1]/w; }\n\ndtab[0]=dx1; dtab[1]=dx2; dtab[2]=dx3; dtab[3]=dx4;\ndtab[4]=dc2; dtab[5]=dc3;\n\nfwrite(dtab,1*sizeof(double),6,out);\n} //end if\n\n//additional end\n\n//additional Zp\nmpz_set_ui(wy,0);\n\nmpz_set(c2g,wy);\nmpz_set(c3g,wy);\nmpz_set(x1g,wy);\nmpz_set(x2g,wy);\nmpz_set(x3g,wy);\nmpz_set(x4g,wy);\n\nmpz_set(d1g,cg[0]); mpz_set(d4g,cg[1]);\nmpz_set(c1g,cg[0]); mpz_set(c4g,cg[1]);\n\nfor (i=0;i<j;i++) { \nmpz_set(d1g,cg[2*i+0]); mpz_set(d4g,cg[2*i+1]);\nmpz_set(c1g,cg[2*i+0]); mpz_set(c4g,cg[2*i+1]);\n\n       mpz_sub(lig,x3g,c3g); \n       mpz_mul(lig,lig,d1g); mpz_mod(lig,lig,apods);\n       mpz_add(mng,x2g,c2g); \n       mpz_mul(mng,mng,d4g); mpz_mod(mng,mng,apods);\n       mpz_add(lig,lig,mng); \n       mpz_add_ui(mng,x4g,e4);\n\t   mpz_invert(mng,mng,apods);\n\t   mpz_mul(d2g,lig,mng); mpz_mod(d2g,d2g,apods);\n\n       mpz_sub(lig,x2g,c2g);\n       mpz_mul(lig,lig,d1g); mpz_mod(lig,lig,apods);\n       mpz_add(mng,x3g,c3g); \n       mpz_mul(mng,mng,d4g); mpz_mod(mng,mng,apods);\n       mpz_sub(lig,mng,lig); \n       mpz_add_ui(mng,x4g,e4);\n\t   mpz_invert(mng,mng,apods);\n\t   mpz_mul(d3g,lig,mng); mpz_mod(d3g,d3g,apods);\n\n\tmpz_mul(modig,d1g,d1g); mpz_mod(modig,modig,apods);\n\tmpz_addmul(modig,d2g,d2g); mpz_mod(modig,modig,apods);\n\tmpz_addmul(modig,d3g,d3g); mpz_mod(modig,modig,apods);\n\tmpz_addmul(modig,d4g,d4g); mpz_mod(modig,modig,apods);\n\t    mpz_mul_ui(modig,modig,2); mpz_mod(modig,modig,apods);\n\tmpz_mul_ui(lig,x1g,2);  mpz_mod(lig,lig,apods);\n\tmpz_mul(lig,lig,d1g);   mpz_mod(lig,lig,apods);\n\tmpz_add(mng,x2g,c2g); \n\tmpz_addmul(lig,mng,d2g);mpz_mod(lig,lig,apods);\n\tmpz_add(mng,x3g,c3g); \n\tmpz_addmul(lig,mng,d3g); mpz_mod(lig,lig,apods);\n\tmpz_add_ui(mng,x4g,e4);\n\tmpz_addmul(lig,mng,d4g);mpz_mod(lig,lig,apods);\n\t   mpz_invert(mng,modig,apods); mpz_mod(mng,mng,apods);\n\t   mpz_mul(k1g,lig,mng); mpz_mod(k1g,k1g,apods);\n\t\n\tmpz_add(lig,x2g,c2g); \n\tmpz_mul_ui(mng,d1g,2);  mpz_mod(mng,mng,apods);\n        mpz_invert(mng,mng,apods); \n        mpz_mul(k2g,lig,mng); mpz_mod(k2g,k2g,apods);\t\n        mpz_invert(lig,d1g,apods);\n        mpz_mul(lig,d2g,lig);mpz_mod(lig,lig,apods);\t\n\tmpz_mul(lig,lig,k1g);    mpz_mod(lig,lig,apods);\n\t    mpz_sub(k2g,k2g,lig);   mpz_mod(k2g,k2g,apods);\n\n\tmpz_add(lig,x3g,c3g); \n\tmpz_mul_ui(mng,d1g,2);  mpz_mod(mng,mng,apods);\n        mpz_invert(mng,mng,apods); \n        mpz_mul(k3g,lig,mng); mpz_mod(k3g,k3g,apods);\t\n        mpz_invert(lig,d1g,apods);\n        mpz_mul(lig,d3g,lig);mpz_mod(lig,lig,apods);\t\n\tmpz_mul(lig,lig,k1g);    mpz_mod(lig,lig,apods);\n\t    mpz_sub(k3g,k3g,lig);   mpz_mod(k3g,k3g,apods);\n    \n\tmpz_add_ui(lig,x4g,e4); \n\tmpz_mul_ui(mng,d1g,2);  mpz_mod(mng,mng,apods);\n        mpz_invert(mng,mng,apods); \n        mpz_mul(k4g,lig,mng); mpz_mod(k4g,k4g,apods);\t\n        mpz_invert(lig,d1g,apods);\n        mpz_mul(lig,d4g,lig);mpz_mod(lig,lig,apods);\t\n\tmpz_mul(lig,lig,k1g);    mpz_mod(lig,lig,apods);\n\t    mpz_sub(k4g,k4g,lig);   mpz_mod(k4g,k4g,apods);\n\nmpz_set(c2g,d2g); mpz_set(c3g,d3g);\nmpz_set(x1g,k1g); mpz_set(x2g,k2g); mpz_set(x3g,k3g); mpz_set(x4g,k4g);\n\nmpz_set(klpomg[i],x1g);\n} //end for\n\nfor (i=1;i<j;i++) { mpz_set(cg[2*i+0],klpomg[i-1]); }\n\nint_to_chargg(d2g,4);\nint_to_chargg(d3g,5);\nint_to_chargg(k1g,0);\nint_to_chargg(k2g,1);\nint_to_chargg(k3g,2);\nint_to_chargg(k4g,3);\n\nfor (i=0; i<(6*m); i++) { putchar(tab[i]);}\n\n//additional Zp end\n\nfor (ii=0;ii<m;ii++) {\n\tda3=tab_we[2+6*ii]+3; da4=tab_we[3+6*ii]; db2=tab_we[4+6*ii]+5; \n\tdb3=tab_we[5+6*ii]+7; da1=tab_we[0+6*ii]; da2=tab_we[1+6*ii]+11;\n\nfor (i=0;i<dj;i++) { dc1=dc[2*i+0]; dc4=dc[2*i+1];\ndb4=de[i];\n\t\t    dc2=(dc1*(da3-db3)+dc4*(da2+db2))/(da4+db4); \n\t\t    dc3=(dc4*(da3+db3)-dc1*(da2-db2))/(da4+db4);\ndx1=(2*da1*dc1+dc2*(da2+db2)+dc3*(da3+db3)+dc4*(da4+db4))/(2*(dc1*dc1+dc2*dc2+dc3*dc3+dc4*dc4));\n\t\t    dx2=((da2+db2)/(2*dc1))-((dc2/dc1)*dx1);\n\t\t    dx3=((da3+db3)/(2*dc1))-((dc3/dc1)*dx1);\n\t\t    dx4=((da4+db4)/(2*dc1))-((dc4/dc1)*dx1);\n\nda1=dx1; da2=dx2; da3=dx3; da4=dx4; db2=dc2; db3=dc3;\ndklpom[i]=dx1;\n} //end for\nfor (i=1;i<dj;i++) { dc[2*i+1]=dklpom[i-1]/w; }\n\ndtab[0+6*ii]=dx1; dtab[1+6*ii]=dx2; dtab[2+6*ii]=dx3; \ndtab[3+6*ii]=dx4; dtab[4+6*ii]=dc2; dtab[5+6*ii]=dc3;\n} //end for 2\n\nfwrite(dtab,1*sizeof(double),(6*m),out); //over R\n\nconst c=1000000000;\nfor (i=0; i<(6*m); i++) { \nif (tab_we[i]*c==dtab[i]*c) {dhamdchr++;}\nmpz_set_ui(dhd1,tab_we[i]*c);\nmpz_set_ui(dhd2,(int)dtab[i]*c);\ndhamdi=mpz_hamdist(dhd1,dhd2);\ndhamd=dhamd+dhamdi;\nif (dhamdi>dhamdmax) {dhamdmax=dhamdi;}\nif (dhamdi<dhamdmin) {dhamdmin=dhamdi;}\ndhamdit[dhamdi]++;\n\ntab_chrd[tab_we[i]]++;\n\t }\n}//end if BAD\nelse\n{\nmli++;\n\nfor (i=1;i<j;i++) { mpz_set(cg[2*i+1],klpomg[i-1]); }\n\nfor (i=0; i<(6*m); i++) { putchar(tab[i]);\n\nif (tab_we[i]==tab[i]) {hamdchr++;}\nmpz_set_ui(hd1,tab_we[i]);\nmpz_set_ui(hd2,tab[i]);\nhamdi=mpz_hamdist(hd1,hd2);\nhamd=hamd+hamdi;\nif (hamdi>hamdmax) {hamdmax=hamdi;}\nif (hamdi<hamdmin) {hamdmin=hamdi;}\nhamdit[hamdi]++;\n\ntab_chr[tab[i]]++;\ntab_chrd[tab_we[i]]++;\n\t}\n}\n} //end else BAD\nk=0; \n} //endwhile\n\nif (dbg) { \nfproc=100.0*(lll)/(lll+mli);\nfprintf(kom,\"\\n%i; :%i: :%i: :%2.12f\\% (%i)\\n.(2*c1=0:%i) (a4+b4=0:%i) (2*suma^2=0:%i) (EOF:%i)...(x1:%i).(x2:%i).(x3:%i).(x4:%i)..(c2:%i).(c3:%i)\", lll, lli, mli, fproc, prob ,llt4,llt5,llt6,llt7,llt8,llt9,llt10,llt11,llt12,llt13);\nfprintf(kom,\"\\n..(2*c1=0:%i) (c1=0:%i) (a4+b4=0:%i) (2*suma^2=0:%i).\\n\",llt0,llt3,llt1,llt2);\n\nfprintf(kom,\"Length ciphertext = %i B\\n\",dz*4*12+4*12+6*m+mli*6*m+(lll)*(6*9*m+6*(m+8)));\nfprintf(kom,\"Excess ciphertext = %i B\\n\",dz*4*12+4*12+6*m+mli*0+(lll)*(6*9*m+6*(m+8)));\nfprintf(kom,\"Excess ciphertext = %f %%\\n\",100.0*(dz*4*12+4*12+6*m+(lll)*(6*9*m+6*(m+8)))/(dz*4*12+4*12+6*m+mli*6*m+(lll)*(6*9*m+6*(m+8))));\n\t}\n\n    if(gettimeofday(&tv2,&tz)!=0)\n        fprintf(kom,\"\\nWarning : could not gettimeofday() !\");\n\n    timediff(&tv2,&tv1,&tvdiff);\n\nif (dbg) { \n    fprintf(kom,\"Process ENKODING took (including I/O): %f sec\",(tvdiff.tv_sec+0.000001*tvdiff.tv_usec));\n    fprintf(kom,\"\\nProcess ENKODING took (including I/O): %f kB/sec\",0.001*(dz*4*12+4*12+6*m+mli*6*m+(lll)*(6*9*m+6*(m+8)))/(tvdiff.tv_sec+0.000001*tvdiff.tv_usec));   \n\t}\n\nif (dbg) { \nfprintf(kom,\"\\nNormalized HammingDistance (bit)  = %f (min:%i max:%i)\",hamd/(6.0*mli*8*m),hamdmin,hamdmax);\nfprintf(kom,\"--> (RQ-int)  = %f (min:%i max:%i)\",dhamd/(6.0*lll*32*m),dhamdmin,dhamdmax);\nfor (i=0; i<=8; i++) {fprintf(kom,\"\\n %i -> %-51i --> %-10i -> %-10i -> %-10i -> %-10i\",i,hamdit[i],dhamdit[i],dhamdit[i+8],dhamdit[i+16],dhamdit[i+24] );}\nfprintf(kom,\"\\nNormalized HammingDistance (char) = %-22f\",1-hamdchr/(6.0*mli*m));\nfprintf(kom,\"--> (RQ-double) = %f\",1-dhamdchr/(6.0*lll*32*m));\n\nfor (i=0;i<256;i++) { sumad=sumad+tab_chrd[i]; }\nmind=tab_chrd[0];\nmaxd=tab_chrd[0];\nfor (i=0;i<256;i++) \n{\nif (tab_chrd[i]>maxd) {maxd=tab_chrd[i];}\nif (tab_chrd[i]<mind) {mind=tab_chrd[i];}\n}\nfprintf(kom,\"\\nStatistics for plaintext  characters : (%i%s%i) difference %i that is %f %% (%i) s:=%i\",mind,\"<\",maxd,maxd-mind,100.0*(maxd-mind)/maxd, inned, sumad);\n\nfor (i=0;i<256;i++) { suma=suma+tab_chr[i]; }\nmin=tab_chr[0];\nmax=tab_chr[0];\nfor (i=0;i<256;i++) \n{\nif (tab_chr[i]>max) {max=tab_chr[i];}\nif (tab_chr[i]<min) {min=tab_chr[i];}\n}\nfprintf(kom,\"\\nStatistics for cipher characters (Zp): (%i%s%i) difference %i that is %f %% (%i) s:=%i\",min,\"<\",max,max-min,100.0*(max-min)/max, inne, suma);\t}\nkoniec:\nif ( (mpz_cmp_ui(wy_p,0)==0) ) { fprintf(kom,\"\\n BAD KEY!!! \\n\"); }\nif ( (length!=0) ) { fprintf(kom,\"\\n BAD LENGTH KEY!!! \\n\"); }\n\nif (dbg) { fprintf(kom,\"\\n -END KODING- \\n\"); }\n    \n  fclose(kom);\n  fclose(klucz);\n  fclose( in );\n  fclose( out );\n\n    gmp_randclear(state);\n    mpz_clear(rop);\n\nmpz_clear(wy); mpz_clear(wy_p);\nmpz_clear(wep); mpz_clear(we_p); mpz_clear(we_p2);\n//mpz_clear(k1g);\nmpz_clear(k2g); mpz_clear(k3g); mpz_clear(k4g); \nmpz_clear(d1g); mpz_clear(d2g); mpz_clear(d3g); mpz_clear(d4g); \nmpz_clear(x1g); mpz_clear(x2g); mpz_clear(x3g); mpz_clear(x4g); \nmpz_clear(c1g); mpz_clear(c2g); mpz_clear(c3g); mpz_clear(c4g); \nfor (i=0;i<(2*rund);i++) {mpz_clear(cg[i]);}\nfor (i=0;i<(rund);i++) {mpz_clear(klpomg[i]);}\nmpz_clear(modig);\nmpz_clear(pa2b2); mpz_clear(pa3b3); mpz_clear(pa4b4); mpz_clear(m2d1);\n\nmpz_clear(qg); mpz_clear(q1g);\nmpz_clear(hd1); mpz_clear(hd2);\nmpz_clear(dhd1); mpz_clear(dhd2);\n} //endmain\n\n} // namespace Polawisv1_raw\n"
        },
        {
            "file_name": "pomelo.c",
            "content": "// PHC submission:  POMELO\n// Designed by:     Hongjun Wu\n//                  Email: wuhongjun@gmail.com\n// This code was written by Hongjun Wu on March 31, 2014.\n// This code was corrected by Hongjun Wu on April 5, 2014\n// The corrections are: the loading of salt into the state\n//                      the shifting constants in function G and H.\n//                      the order of operations in function F\n\n\n// t_cost is a non-negative integer not larger than 20;\n// m_cost is a non-negative integer not larger than 18;\n// it is recommended that:  8 <= t_cost + m_cost <= 20;\n// one may use the parameters: m_cost = 12; t_cost = 1;\n\n#include <stdlib.h>\n#include <string.h>\n\n#define F(S,i)  {         \\\n    i1 = (i - 1)  & mask; \\\n    i2 = (i - 3)  & mask; \\\n    i3 = (i - 17) & mask; \\\n    i4 = (i - 41) & mask; \\\n    S[i] += ((S[i1] ^ S[i2]) + S[i3]) ^ S[i4]; \\\n    S[i] = (S[i] << 17) ^ (S[i] >> 47);        \\\n}\n\nint PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost);\n\nint PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost)\n{\n    unsigned long long i, j, temp;\n    unsigned long long i1,i2,i3,i4;\n    unsigned long long *S;\n    unsigned long long mask, index;\n    unsigned long long state_size;\n\n    //Step 1:  Initialize the state S.\n    state_size = 8192 << m_cost;\n    S = (unsigned long long *)calloc(state_size, 1);\n\n    mask = state_size/8 - 1;     //mask is used for modulation: modulo size_size/8\n\n    //Step 2:  Load the password, salt, input/output sizes into the state S\n    // load password into S\n    for (i = 0; i < inlen; i++)   ((unsigned char*)S)[i] = ((unsigned char*)in)[i];\n    for (i = inlen; i < 128; i++) ((unsigned char*)S)[i] = 0;\n    // load salt into S\n    for (i = 0; i < saltlen; i++)       ((unsigned char*)S)[i+128] = ((unsigned char*)salt)[i];\n    for (i = 128+saltlen; i < 160; i++) ((unsigned char*)S)[i] = 0;\n\n    ((unsigned char*)S)[160] = inlen;   // load password length (in bytes) into S;\n    ((unsigned char*)S)[161] = saltlen; // load salt length (in bytes) into S;\n    ((unsigned char*)S)[162] = outlen;  // load output length (in bytes into S)\n\n    //Step 3: Expand the data into the whole state.\n    for (i = 41; i < state_size/8; i++)\n    {\n        F(S,i);\n    }\n\n    //Step 4: update the state using F and G\n    //       (involving deterministic random memory accesses)\n    temp = 1;\n    for (j = 0; j < (1 << t_cost); j++)\n    {\n       for (i = 0; i < state_size/8; i++)\n       {\n           F(S,i);\n\n           // function G(S, i, j)\n           if ( (i & 3) == 3 )\n           {\n               index     = (temp + (temp >> 32)) & mask;\n               S[i]     ^= S[index] << 1;\n               S[index] ^= S[i] << 3;\n           }\n\n           temp = temp + (temp << 2);   // temp = temp*5;\n       }\n    }\n\n    // Step 5: update the state using F\n    for (i = 0; i < state_size/8; i++)\n    {\n        F(S,i);\n    }\n\n    //Step 6: update the state using F and H\n    //       (involving password-dependent random memory accesses)\n    for (j = 0; j < (1 << t_cost); j++)\n    {\n       for (i = 0; i < state_size/8; i++)\n       {\n           F(S,i);\n\n           // function H(S, i)\n           if ( (i & 3) == 3 )\n           {\n               i1 = (i - 1)  & mask;\n               index = S[i1] & mask;\n               S[i]     ^= S[index] << 1;\n               S[index] ^= S[i] << 3;\n           }\n       }\n    }\n\n    // Step 7: update the state using F\n    for (i = 0; i < state_size/8; i++)\n    {\n        F(S,i);\n    }\n\n    //Step 8: generate the output\n    if (outlen > 128)   // the maximum output size is 128 bytes; otherwise, no output.\n    {\n        memset(S, 0, state_size); // clear the memory\n        free(S);                  // free the memory\n        return 1;     // there is no output if the output size is more than 128 bytes.\n    }\n\n    memcpy(out, ((unsigned char*)S)+state_size-outlen, outlen);\n    memset(S, 0, state_size);  //clear the memory\n    free(S);                   // free the memory\n\n    return 0;\n}\n"
        },
        {
            "file_name": "ppaev11_encrypt.cpp",
            "content": "/* ++AE v1.1 reference source code for CAESAR (Recommended Parameter Set )  3rd revision 20140702 */\n#include \"ppaev11_encrypt.h\"\n// CHANGE including common AES API\n// #include \"crypto_core_aes128encrypt.h\"\n// #include \"crypto_core_aes128decrypt.h\"\n#include \"../../common/api.h\"\n#include <string.h>\n\n#define encAES(out,in,k) CaesarCommon::crypto_core_aes128encrypt(out,in,k,0)\n#define decAES(out,in,k) CaesarCommon::crypto_core_aes128decrypt(out,in,k,0)\n\n// CHANGE namespace moved due to includes\nnamespace Ppaev11_raw {\nint numRounds = -1;\n\nstatic inline void ull_to_block( unsigned char *, unsigned long long );\n// CHANGE const added to function declaration\n//static inline void xor_blocks(   unsigned char *, unsigned char *, unsigned char * );\nstatic inline void xor_blocks(   unsigned char *, unsigned char *, const unsigned char * );\nstatic inline void add_blocks(   unsigned char *, unsigned char *, unsigned char * );\nstatic inline void subs_blocks(  unsigned char *, unsigned char *, unsigned char * );\n\n\n// CHANGE const added to function declaration\n//static void gen_ivs( unsigned char *, unsigned char *, unsigned char *,    unsigned char * );\nstatic void gen_ivs( unsigned char *, unsigned char *, const unsigned char *, const unsigned char * );\n// CHANGE const added to function declaration\n//static void gen_icv( unsigned char *, unsigned char *, unsigned long long, unsigned long long, unsigned char *, unsigned char * );\nstatic void gen_icv( unsigned char *, const unsigned char *, unsigned long long, unsigned long long, unsigned char *, unsigned char * );\n// CHANGE const added to function declaration\n//static void gtag_ad( unsigned char *, unsigned char *, unsigned long long, unsigned char *,    unsigned char * );\nstatic void gtag_ad( unsigned char *, const unsigned char *, unsigned long long, unsigned char *,    unsigned char * );\n// CHANGE const added to function declaration\n//static void encppae( unsigned char *, unsigned char *, unsigned char *,    unsigned char *,    unsigned char * );\nstatic void encppae( unsigned char *, unsigned char *, unsigned char *, const unsigned char *,    unsigned char * );\n// CHANGE const added to function declaration\n//static void decppae( unsigned char *, unsigned char *, unsigned char *,    unsigned char *,    unsigned char * );\nstatic void decppae( unsigned char *, unsigned char *, unsigned char *, const unsigned char *,    unsigned char * );\n\n/* --------- ++AE CAESAR encrypt and decrypt AEAD procedures  */\nint crypto_aead_encrypt(\n   unsigned char *c,        unsigned long long *clen, // clen input value is ignored. Don't use it as such. Anyway, it's assumed that c points a reserved memory space with at least CRYPTO_MAXPBYTES bytes available\n   const unsigned char *m,  unsigned long long  mlen, // from the example provided for aesgcm it is assumed that sizeof( unsigned long long )==8  in the benchmarking platform\n   const unsigned char *ad, unsigned long long adlen,\n   const unsigned char *nsec,                         // Unused by ++AE, but kept in the prototype.\n   const unsigned char *npub,                         // S nonce counter\n   const unsigned char *k                             // k!=NULL only for the first session call: the key will be preset and (fresh) IVs generated\n)                                                     // WARNING: arguments validity are not checked\n{\n   static unsigned char _k[16], _IVa[16], _IVb[16];   // space to keep preset key and to chain IVs between calls\n   unsigned char icv[16], lb[16], b[16];\n   int i, w;\n\n   if ( k!=0 ) {                                      // If first session call then generate fresh IVs and save key. Otherwise we just chain IVs\n      memcpy( _k, k, 16 ); gen_ivs( _IVa, _IVb, npub, k );  // It would be the right place to preset AES key to avoid rekeying for every block\n      }\t                                              // Fresh IVs generated . Note: mandatory after an auth. failure\n\n   gen_icv( icv, npub, mlen, adlen, _IVa, _IVb );     // Let's compute the ICV for this message\n   gtag_ad( _IVa, ad, adlen, _k, icv );               // AD tag calculated on IVa (and using initial value as input)\n\n   for ( *clen = mlen + 16; mlen; mlen -= 16, m += 16, c +=16 ) {      // ++AE plaintext encryption\n      if ( (w=mlen)<16 ) {                            // it's time to padd P last block\n         for ( i=0; i<16; i++ ) b[(w+i)%16] = icv[i];\n         memcpy( icv, b, 16 );                        // ICV = ICV>>w (w=mlen)\n         memcpy( lb, m, w ); memset( lb+w, 0, 16-w );\n         for ( i=0; i<16; i++ ) lb[i] ^= icv[i];      // xor and padding with rotated ICV\n         mlen = 16; m = lb;\n      }\n      encppae( c, _IVa, _IVb, m, _k );                // One block ++AE encryption with IVa and IVb chainning ...\n   }\n\n   encppae( b, _IVa, _IVb, icv, _k );                 // Let's generate the tag block ... but reduced\n   memcpy( c, b+(16-w), w );                          // by the (16-w) tag/padding bytes added in previous cryptogram block\n   return 0;\n}\n\nint crypto_aead_decrypt(\n   unsigned char *m,        unsigned long long *mlen,\n   unsigned char *nsec,\n   const unsigned char *c,  unsigned long long clen,\n   const unsigned char *ad, unsigned long long adlen,\n   const unsigned char *npub,\n   const unsigned char *k\n)\n{\n   static unsigned char d_k[16], d_IVa[16], d_IVb[16];\n   unsigned char         icv[16], b1[16], b2[16];\n   int                   i;\n\n   if ( k!=0 ) {                                          // Note: mandatory after an auth. failure\n      memcpy( d_k, k, 16 ); gen_ivs( d_IVa, d_IVb, npub, d_k );\n      }\n\n   gen_icv( icv, npub, *mlen=clen-16, adlen, d_IVa, d_IVb );\n   gtag_ad( d_IVa, ad, adlen, d_k, icv );\n\n   for ( ; clen>16; m+=16, c+=16 ) {\n      decppae( b1, d_IVa, d_IVb, c, d_k );\n      if ( (clen-=16) < 16 ) {                            // ICV Padding shall be removed in this last block\n         for ( i=0; i<16; i++ ) b1[i] ^= (b2[i] = icv[((16-clen)+i)%16]);\n         for ( i=clen; i<16; i++ ) if ( b1[i] ) return -1;\n         for ( i=0; i<16; i++ ) icv[i] = b2[i];\n      }\n      memcpy( m, b1, (clen<16)? clen : 16 );\n   }\n\n   encppae( b1, d_IVa, d_IVb, icv, d_k );                 // Let's generate the last tag block MDC\"\n   if ( memcmp( b1+(16-clen), c, clen ) ) return -1;      // it's w lsB shall match the tail cryptogram bytes\n\n   return 0;                                              // NOTE: after an auth. failure \"fresh\" synchro shall be applied\n}\n\n// --------- ++AE auxiliary encapsulated procedures\n// CHANGE const added to function declaration\n//static void gen_ivs( unsigned char *iva, unsigned char *ivb, unsigned char *s, unsigned char *k )\nstatic void gen_ivs( unsigned char *iva, unsigned char *ivb, const unsigned char *s, const unsigned char *k )\n{\n   unsigned char b[16];\n\n   memset( b, 0, 8 ); memcpy( b+8, s, 8 );\n   encAES( iva, b, k ); encAES( ivb, iva, k );\n}\n\n// CHANGE const added to function declaration\n//static void gen_icv( unsigned char *icv,   unsigned char *npub, unsigned long long n,\nstatic void gen_icv( unsigned char *icv, const unsigned char *npub, unsigned long long n,\n                     unsigned long long m, unsigned char *iva,  unsigned char *ivb )\n{\n   unsigned char s[16], b1[16], b2[16];\n\n   memset( s, 0, 8 ); memcpy( s+8, npub, 8 );\n   ull_to_block( b1, n+m );\n   xor_blocks( b2, b1, ivb );\n   xor_blocks( b1,  s, iva );\n   add_blocks( icv, b1, b2 );                      // ICV = (IVa xor S) + (IVb xor (N+M))\n}\n\n// CHANGE const added to function declaration\n//static void gtag_ad( unsigned char *iva, unsigned char *ad, unsigned long long adlen,\nstatic void gtag_ad( unsigned char *iva, const unsigned char *ad, unsigned long long adlen,\n                     unsigned char *k,   unsigned char *icv )\n{\n   unsigned char x[16], lb[16], b[16];\n   int           i;\n\n   for ( ; adlen; adlen -= 16, ad += 16 ) {\n      if ( adlen<=16 ) {                                        // its time to padd AD last block.\n         for ( i=0; i<adlen   ; i++ ) lb[i] = ad[i] ^ icv[16-adlen+i]; // xor q msB from AD with q lsB from ICV (eq. to ICV>>q and xor)\n         for ( i=0; i<16-adlen; i++ ) lb[adlen+i]=icv[i];       // pad (p-q) lsB of AD with msB from ICV (q = adlen)\n         ad = lb; adlen = 16;\n      }\n      encAES( x, ad, k );\n      add_blocks( b,   x, iva );\n      xor_blocks( iva, x, b   );\n   }\n}\n\nstatic void encppae( unsigned char *c, unsigned char *iva, unsigned char *ivb,\n// CHANGE const added to function declaration\n//                     unsigned char *m, unsigned char *k )\n                     const unsigned char *m, unsigned char *k )\n{\n   unsigned char b[16], I[16];\n\n   xor_blocks( I, iva, m );\n   add_blocks( b, iva, ivb );\n   add_blocks( iva, I,   b );\n   xor_blocks( b, iva, ivb );\n   encAES( c, b, k );\n   memcpy( ivb, I, 16 );\n}\n\nstatic void decppae( unsigned char *m, unsigned char *iva, unsigned char *ivb,\n// CHANGE const added to function declaration\n//                     unsigned char *c, unsigned char *k )\n                     const unsigned char *c, unsigned char *k )\n{\n   unsigned char b[16], Q[16];\n\n   decAES( b, c, k );\n   xor_blocks ( Q, ivb,   b );\n   add_blocks ( b, iva, ivb );\n   subs_blocks( ivb, Q,   b );\n   xor_blocks ( m, iva, ivb );\n   memcpy( iva, Q, 16 );\n}\n\n// Aux block manipulation primitives\nstatic inline void ull_to_block( unsigned char *b, unsigned long long u )\n{\n   int i;\n   for ( i=15; i>=0; i-- ) { b[i] = u; u >>= 8; };\n}\n\n// CHANGE const added to function declaration\n//static inline void xor_blocks( unsigned char *r, unsigned char *a, unsigned char *b )\nstatic inline void xor_blocks( unsigned char *r, unsigned char *a, const unsigned char *b )\n{                                                             // r = a^b\n   int i;\n   for ( i=0; i<16; i++ ) r[i] = a[i] ^ b[i];\n}\n\nstatic inline void add_blocks( unsigned char *r, unsigned char *a, unsigned char *b )\n{                                                             // r = a+b\n   unsigned char c[16];\n   int           i;\n\n   for ( i=15, c[15]=0; i>=0; i-- ) {                     // not an efficient implementation but portable and legible\n      r[i] = a[i] + b[i] + c[i];\n      if ( i )  c[i-1] = ( (r[i]-c[i]) < a[i] )? 1 : 0;       // a or b ... it's the same\n   }\n}\n\nstatic inline void subs_blocks( unsigned char *r, unsigned char *a, unsigned char *b )\n{                                                             // r = a-b\n   unsigned char c[16];\n   int           i;\n\n   for ( i=15, c[15]=0; i>=0; i-- ) {                     // not an efficient implementation but portable and legible\n      r[i] = a[i] - (b[i] + c[i]);\n      if ( i )  c[i-1] = ( (r[i]+c[i]) > a[i] )? 1 : 0;       // a or b ... it's the same\n   }\n}\n\n\n} // namespace Ppaev11_raw\n"
        },
        {
            "file_name": "primatesv1hanuman120_encrypt.cpp",
            "content": "//  -----------------------------------------------------------------------------\n//                             Design Information\n//  -----------------------------------------------------------------------------\n//\n//           Description: PRIMATEs v1 - Hanuman-120 instantiation.\n//\n//    Authors: Elena Andreeva, Beg\u00ef\u00bf\u00bdl Bilgin, Andrey Bogdanov, Atul Luykx,\n//            Florian Mendel, Bart Mennink, Nicky Mouha, Qingju Wang,\n//                             and Kan Yasuda\n//\n//    Please contact primates@esat.kuleuven.be\n//              regarding any questions/comments of this reference code\n//\n//  -----------------------------------------------------------------------------\n\n#include \"primatesv1hanuman120_primate.h\"\n#include \"primatesv1hanuman120_parameters.h\"\n#include <stdlib.h>\n#include \"primatesv1hanuman120_encrypt.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Primatesv1hanuman120_raw {\nint numRounds = -1;\n\nint crypto_aead_encrypt(\n    unsigned char *c,unsigned long long *clen,\n    const unsigned char *m,unsigned long long mlen,\n    const unsigned char *ad,unsigned long long adlen,\n    const unsigned char *nsec,\n    const unsigned char *npub,\n    const unsigned char *k\n )\n {\n    /*...\n    ... generating a ciphertext c[0],c[1],...,c[*clen-1]\n    ... from a plaintext m[0],m[1],...,m[mlen-1]\n    ... and associated data ad[0],ad[1],...,ad[adlen-1]\n    ... and secret message number nsec[0],nsec[1],...\n    ... and public message number npub[0],npub[1],...\n    ... and secret key k[0],k[1],...\n    ...*/\n    unsigned char V[StateSize]; //the state represented in Elements\n    //Temp variables represented as elements\n    unsigned char key[KeySizeElements];\n    unsigned char nonce[NonceSizeElements];\n    unsigned char tag[TagSizeElements];\n    unsigned char data[RateSizeElements];\n    unsigned char cipher[RateSizeElements];\n\n    Bytes2Element(key,k,0,KeySizeElements); //representing k  as elements\n    Bytes2Element(nonce,npub,0,NonceSizeElements); //representing npub as elements\n\n    // V <-- p_1(O||K||N)\n    InitializeState(V,key,nonce);\n    p_1(V);\n\n    if(adlen!=0)\n    {\n        // for i=1 to u-1\n        if(adlen>RateSizeBytes)\n        {\n            for(unsigned long long i=0; i<adlen-RateSizeBytes; i=i+RateSizeBytes)\n            {\n                Bytes2Element(data,ad,i,RateSizeElements); // representing a block of ad as elements\n                // V <-- p_4 (A[i]^V_r || V_c)\n                for(int j=0; j<RateSizeElements; j++)\n                    V[j]^=data[j];\n                p_4(V);\n            }\n        }\n        // V <-- A[u]^v_r || V_c\n        int l = adlen%RateSizeBytes;\n        if(l==0){ //do padding with spill over\n            Bytes2Element(data,ad,adlen-RateSizeBytes,RateSizeElements); // representing last block of ad as elements\n            for(int i=0; i<RateSizeElements; i++)\n                V[i]^=data[i];\n            V[RateSizeElements]^=16; //padding spills over to capacity\n        }\n        else{ //do standard padding\n            unsigned char dataP[RateSizeBytes];\n            for(int i=0; i< l; i++)\n                dataP[i]=ad[adlen-l+i];\n            dataP[l]=128; //padding over bytes\n            for(int i=l+1; i<RateSizeBytes; i++)\n                dataP[i]=0;\n            Bytes2Element(data,dataP,0,RateSizeElements); // representing last padded block of ad as elements\n            for(int i=0; i<RateSizeElements; i++)\n                V[i]^=data[i];\n        }\n        // V <-- p_1(V)\n        p_1(V);\n    }\n    //for i=1 to w-1 (except the last block which needs padding)\n    if(mlen>RateSizeBytes)\n    {\n        for(unsigned long long i=0; i<mlen-RateSizeBytes; i=i+RateSizeBytes)\n        {\n            Bytes2Element(data,m,i,RateSizeElements); //representing a block of m as elements\n            // C[i] <-- M[i]^V_r\n            for(int j=0; j<RateSizeElements; j++)\n                cipher[j]=V[j]^data[j];\n            Element2Bytes(c,cipher,i,RateSizeBytes); //representing a block of c as bytes\n            //V <-- p_1 (C[i] || V_c)\n            for(int j=0; j<RateSizeElements; j++)\n                V[j]=cipher[j];\n            p_1(V);\n        }\n    }\n\n    //for i=w\n    int l = mlen%RateSizeBytes;\n    // C[i] <-- M[i]^V_r\n    if((l==0) && (mlen!=0)){ //do padding with spill over\n        Bytes2Element(data,m,mlen-RateSizeBytes,RateSizeElements); // representing last block of m as elements\n        for(int i=0; i<RateSizeElements; i++)\n            cipher[i]=V[i]^data[i];\n        Element2Bytes(c,cipher,mlen-RateSizeBytes,RateSizeBytes); //representing last block of c as bytes\n        V[RateSizeElements]^=16; //padding spills over to capacity\n    }\n    else{ //do standard padding\n        unsigned char dataP[RateSizeBytes];\n        for(int i=0; i< l; i++)\n            dataP[i]=m[mlen-l+i];\n        dataP[l]=128; //padding over bytes\n        for(int i=l+1; i<RateSizeBytes; i++)\n            dataP[i]=0;\n        Bytes2Element(data,dataP,0,RateSizeElements);  // representing last block of m as elements\n        for(int i=0; i<RateSizeElements; i++)\n            cipher[i]=V[i]^data[i];\n        unsigned char ct[RateSizeBytes];\n        Element2Bytes(ct,cipher,0,RateSizeBytes); //representing last block of c as bytes\n        for(int i=0; i< l; i++)\n            c[mlen-l+i]=ct[i]; //storing only l bytes of c\n    }\n    //V <-- p_1 (C[i] || V_c)\n    for(int j=0; j<RateSizeElements; j++)\n        V[j]=cipher[j];\n    p_1(V);\n\n    // T <-- (V_c)_c/2 ^ K\n    for(int i=0; i<TagSizeElements; i++)\n        tag[i]=V[RateSizeElements+i]^key[i];\n    Element2Bytes(c,tag,mlen,TagSizeBytes) ;\n    *clen=mlen+TagSizeBytes;\n\n    return 0;\n}\n\nint crypto_aead_decrypt(\n    unsigned char *m,unsigned long long *mlen,\n    unsigned char *nsec,\n    const unsigned char *c,unsigned long long clen,\n    const unsigned char *ad,unsigned long long adlen,\n    const unsigned char *npub,\n    const unsigned char *k\n)\n{\n    /*\n    ... generating a plaintext m[0],m[1],...,m[*mlen-1]\n    ... and secret message number nsec[0],nsec[1],...\n    ... from a ciphertext c[0],c[1],...,c[clen-1]\n    ... and associated data ad[0],ad[1],...,ad[adlen-1]\n    ... and public message number npub[0],npub[1],...\n    ... and secret key k[0],k[1],...\n    ...\n    */\n    unsigned char V[StateSize]; //the state represented in Elements\n    //Temp variables represented as elements\n    unsigned char key[KeySizeElements];\n    unsigned char nonce[NonceSizeElements];\n    unsigned char tag[TagSizeElements];\n    unsigned char data[RateSizeElements];\n    unsigned char cipher[RateSizeElements];\n\n    *mlen=clen-TagSizeBytes;\n\n    if(clen<TagSizeBytes) return -1; //invalid ciphertext\n\n    //a temporary array for message\n    unsigned char *mT = (unsigned char*) malloc(clen-TagSizeBytes);\n    if (mT == NULL) return -2; // memory allocation failure\n\n    Bytes2Element(key,k,0,KeySizeElements); //representing k as elements\n    Bytes2Element(nonce,npub,0,NonceSizeElements); //representing npub as elements\n\n    // V <-- p_1(O||K||N)\n    InitializeState(V,key,nonce);\n    p_1(V);\n\n    if(adlen!=0)\n    {\n        // for i=1 to u-1\n        if(adlen>RateSizeBytes)\n        {\n            for(unsigned long long i=0; i<adlen-RateSizeBytes; i=i+RateSizeBytes)\n            {\n                Bytes2Element(data,ad,i,RateSizeElements); // representing a block of ad as elements\n                // V <-- p_4 (A[i]^V_r || V_c)\n                for(int j=0; j<RateSizeElements; j++)\n                    V[j]^=data[j];\n                p_4(V);\n            }\n        }\n        // V <-- A[u]^v_r || V_c\n        int l = adlen%RateSizeBytes;\n        if(l==0){ //do padding with spill over\n            Bytes2Element(data,ad,adlen-RateSizeBytes,RateSizeElements);\n            for(int i=0; i<RateSizeElements; i++)\n                V[i]^=data[i];\n            V[RateSizeElements]^=16; //padding spills over to capacity\n        }\n        else{ //do standard padding\n            unsigned char dataP[RateSizeBytes];\n            for(int i=0; i< l; i++)\n                dataP[i]=ad[adlen-l+i];\n            dataP[l]=128; //padding over bytes\n            for(int i=l+1; i<RateSizeBytes; i++)\n                dataP[i]=0;\n            Bytes2Element(data,dataP,0,RateSizeElements);\n            for(int i=0; i<RateSizeElements; i++)\n                V[i]^=data[i];\n        }\n        // V <-- p_1(V)\n        p_1(V);\n    }\n\n    //for i=1 to w-1 (except the last block which needs padding)\n    if(clen-TagSizeBytes>RateSizeBytes)\n    {\n        for(unsigned long long i=0; i<clen-(TagSizeBytes+RateSizeBytes); i=i+RateSizeBytes)\n        {\n            Bytes2Element(cipher,c,i,RateSizeElements); //representing a block of c as elements\n            // M[i] <-- C[i]^V_r\n            for(int j=0; j<RateSizeElements; j++)\n                data[j]=V[j]^cipher[j];\n            Element2Bytes(mT,data,i,RateSizeBytes); //representing m as bytes\n            //V <-- p_1 (C[i] || V_c)\n            for(int j=0; j<RateSizeElements; j++)\n                V[j]=cipher[j];\n            p_1(V);\n        }\n    }\n    //for i=w\n    int l = clen%RateSizeBytes;\n    // M[w] <-- C[w]^V_r\n    // V <-- M[w]||10* ^ V\n    if((l==0) && ((clen-TagSizeBytes)!=0)){ //do padding with spill over\n        Bytes2Element(cipher,c,clen-(TagSizeBytes+RateSizeBytes),RateSizeElements);\n        for(int i=0; i<RateSizeElements; i++){\n            data[i]=V[i]^cipher[i];\n            V[i]=cipher[i];\n        }\n        Element2Bytes(mT,data,clen-(TagSizeBytes+RateSizeBytes),RateSizeBytes); //representing last block m as bytes\n        V[RateSizeElements]^=16; //padding spills over to capacity\n    }\n    else{ //do standard padding\n        unsigned char cipherP[RateSizeElements];\n        unsigned char mtmp[RateSizeBytes];\n        for(int i=0; i< RateSizeElements; i++)\n            cipherP[i]=V[i];\n        Element2Bytes(mtmp,cipherP,0,RateSizeBytes);\n        for(int i=0; i< l; i++)\n            mT[clen-TagSizeBytes-l+i]=mtmp[i]^c[clen-TagSizeBytes-l+i];\n        unsigned char dataP[RateSizeBytes];\n        for(int i=0; i< l; i++)\n            dataP[i]=mT[clen-TagSizeBytes-l+i];\n        dataP[l]=128; //padding over bytes\n        for(int i=l+1; i<RateSizeBytes; i++)\n            dataP[i]=0;\n        Bytes2Element(data,dataP,0,RateSizeElements);\n        for(int i=0; i<RateSizeElements; i++)\n            V[i]^=data[i];\n    }\n    //V <-- p_1 (V)\n    p_1(V);\n\n    // T <-- (V_c)_c/2 ^ K\n    for(int i=0; i<TagSizeElements; i++)\n        tag[i]=V[RateSizeElements+i]^key[i];\n    unsigned char tagT[TagSizeBytes];\n    Element2Bytes(tagT,tag,0,TagSizeBytes) ;\n\n    unsigned char cor=0;\n    for(int i=0; i<TagSizeBytes; i++) //check if tags match\n        cor = cor || (tagT[i]^c[clen-TagSizeBytes+i]);\n\n    if(cor==0) //if tags match release the message\n        for(unsigned long long i=0; i<clen-TagSizeBytes; i++)\n            m[i]=mT[i];\n\n    free(mT);\n    if(cor==0) return 0;\n    else return -1;\n}\n} // namespace Primatesv1hanuman120_raw\n"
        },
        {
            "file_name": "proest256otrv1_encrypt.cpp",
            "content": "#include \"proest256otrv1_encrypt.h\"\n#include \"../../common/api.h\"\n#include \"proest256otrv1_api.h\"\n#include \"proest256otrv1_proest256.h\"\n#include \"proest256otrv1_zerobytes.h\"\n#include \"proest256otrv1_otr.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Proest256otrv1_raw {\nint numRounds = -1;\n\n// Xor two blocks\nstatic void xor_block(unsigned char *r, const unsigned char *x, const unsigned char *y)\n{\n    int i;\n    for (i = 0; i < OTR_BLOCKBYTES; i++)\n        r[i] = x[i] ^ y[i];\n}\n\n// Do 10* padding, xlen has to be <= OTR_BLOCKBYTES\nstatic void padblock(unsigned char *r, const unsigned char *x, int xlen)\n{\n  int i;\n  for(i=0;i<xlen;i++)\n    r[i] = x[i];\n  if (xlen < OTR_BLOCKBYTES)\n  {\n    r[xlen] = 0x80;\n    for (i = xlen+1; i < OTR_BLOCKBYTES; ++i)\n      r[i] = 0;\n  }\n}\n\nstatic void pad2block(unsigned char *r, const unsigned char *x, int xlen)\n{\n  int i;\n  for(i=0;i<xlen;i++)\n    r[i] = x[i];\n  if (xlen < 2*OTR_BLOCKBYTES)\n  {\n    r[xlen] = 0x80;\n    for (i = xlen+1; i < 2*OTR_BLOCKBYTES; ++i)\n      r[i] = 0;\n  }\n}\n\n\n// Encrypt single block using Proest in single-key Even-Mansour\nstatic void encrypt_block(unsigned char *r, const unsigned char *x, const unsigned char *k)\n{\n    proest_ctx y;\n    xor_block(r, x, k);\n    proest_readstate(&y, r);\n    proest_permute(&y);\n    proest_writestate(r, &y);\n    xor_block(r, r, k);\n}\n\nstatic void feistel(unsigned char *c, const unsigned char *m, const unsigned char *l, const unsigned char *delta, const unsigned char *k)\n{\n  unsigned char buf[OTR_BLOCKBYTES];\n  int i;\n\n  xor_block(buf, m, l);\n  encrypt_block(buf, buf, k);\n  xor_block(buf, buf, m+OTR_BLOCKBYTES);\n  xor_block(c+OTR_BLOCKBYTES, l, delta);\n  xor_block(c+OTR_BLOCKBYTES, c+OTR_BLOCKBYTES, buf);\n  encrypt_block(c+OTR_BLOCKBYTES,c+OTR_BLOCKBYTES,k);\n  for(i=0;i<OTR_BLOCKBYTES;i++)\n  {\n    c[i+OTR_BLOCKBYTES] ^= m[i];\n    c[i] = buf[i];\n  }\n}\n\nstatic void feistelback(unsigned char *m, const unsigned char *c, const unsigned char *l, const unsigned char *delta, const unsigned char *k)\n{\n  unsigned char buf[OTR_BLOCKBYTES];\n  int i;\n\n  xor_block(buf, c, l);\n  xor_block(buf, buf, delta);\n  encrypt_block(buf,buf,k);\n  xor_block(buf, buf, c+OTR_BLOCKBYTES);\n  xor_block(m+OTR_BLOCKBYTES, l, buf);\n  encrypt_block(m+OTR_BLOCKBYTES,m+OTR_BLOCKBYTES,k);\n  for(i=0;i<OTR_BLOCKBYTES;i++)\n  {\n    m[i+OTR_BLOCKBYTES] ^= c[i];\n    m[i] = buf[i];\n  }\n}\n\n\n// Multiplication by x\nstatic void mulx(unsigned char *r, const unsigned char *x)\n{\n    int i;\n  unsigned char red0, red1;\n  unsigned char t[OTR_BLOCKBYTES];\n  for(i=0;i<OTR_BLOCKBYTES;i++)\n    t[i] = x[i];\n\n  red0  = -(t[OTR_BLOCKBYTES-1] >> 7);\n  red1  = 0x01 & red0;\n  red0 &= 0x25;\n\n    for (i = 1; i < OTR_BLOCKBYTES; ++i)\n    r[i] = (t[i] << 1) | (t[i-1] >> 7);\n  r[0]  = (t[0] << 1) ^ red0;\n  r[1] ^= red1;\n}\n\n\n// Multiplication by (x+1)\nstatic void mulxp1(unsigned char *r, const unsigned char *x)\n{\n  int i;\n  unsigned char red0, red1;\n  unsigned char t[OTR_BLOCKBYTES];\n\n  red0  = -(x[OTR_BLOCKBYTES-1] >> 7);\n  red1  = 0x01 & red0;\n  red0 &= 0x25;\n    for (i = 1; i < OTR_BLOCKBYTES; ++i)\n    t[i] = (x[i] << 1) | (x[i-1] >> 7);\n  t[0]  = (x[0] << 1) ^ red0;\n  t[1] ^= red1;\n    for (i = 0; i < OTR_BLOCKBYTES; ++i)\n    r[i] = t[i] ^ x[i];\n}\n\n\nstatic void otr_process_ad(unsigned char *ta,\n    const unsigned char *ad, unsigned long long adlen,\n    const unsigned char *k)\n{\n  unsigned char buf[OTR_BLOCKBYTES];\n  unsigned char xi[OTR_BLOCKBYTES];\n  unsigned char q[OTR_BLOCKBYTES];\n  unsigned char gamma[OTR_BLOCKBYTES];\n  int i;\n\n  if(!adlen)\n  {\n    for(i=0;i<OTR_BLOCKBYTES;i++)\n      ta[i] = 0;\n    return;\n  }\n\n  for(i=0;i<OTR_BLOCKBYTES;i++)\n    gamma[i] = 0;\n  encrypt_block(gamma, gamma, k);\n\n  mulx(q, gamma);\n  mulx(q, q);\n\n  for(i=0;i<OTR_BLOCKBYTES;i++)\n    xi[i] = 0;\n\n  while(adlen > OTR_BLOCKBYTES)\n  {\n    xor_block(buf, q, ad);\n    encrypt_block(buf,buf,k);\n    xor_block(xi, xi, buf);\n    mulx(q, q);\n\n    ad    += OTR_BLOCKBYTES;\n    adlen -= OTR_BLOCKBYTES;\n  }\n  padblock(buf, ad, adlen);\n  xor_block(xi, xi, buf);\n\n  if(adlen != OTR_BLOCKBYTES)\n  {\n    xor_block(buf, xi, q);\n    xor_block(buf, buf, gamma);\n    encrypt_block(ta, buf, k);\n  }\n  else\n  {\n    xor_block(buf, xi, q);\n    mulx(q, gamma);\n    xor_block(buf, buf, q);\n    encrypt_block(ta, buf, k);\n  }\n}\n\n\nint crypto_aead_encrypt(\n    unsigned char *c, \t\t\tunsigned long long *clen,\n    const unsigned char *m, \tunsigned long long mlen,\n    const unsigned char *ad, \tunsigned long long adlen,\n    const unsigned char *nsec,\n    const unsigned char *npub,\n    const unsigned char *k\n)\n{\n\n  unsigned char key[CRYPTO_KEYBYTES];\n  unsigned char ta[OTR_BLOCKBYTES];\n  unsigned char te[OTR_BLOCKBYTES];\n  unsigned char l[OTR_BLOCKBYTES];\n  unsigned char delta[OTR_BLOCKBYTES];\n  unsigned char sigma[OTR_BLOCKBYTES];\n  unsigned char buf[2*OTR_BLOCKBYTES];\n  unsigned long long i;\n\n  *clen = 0;\n\n  for(i=0;i<CRYPTO_KEYBYTES;i++)\n    key[i] = k[i];\n\n  // Init sigma, l and delta\n  for(i=0;i<OTR_BLOCKBYTES;i++)\n    sigma[i] = 0;\n  padblock(delta,npub,CRYPTO_NPUBBYTES);\n  encrypt_block(delta,delta,key);\n  mulx(l,delta);\n  mulx(l,l);\n\n  // Compute TA\n  otr_process_ad(ta, ad, adlen, key);\n\n  // Process full double-blocks\n  while(mlen >= 2*OTR_BLOCKBYTES)\n  {\n    xor_block(sigma, sigma, m+OTR_BLOCKBYTES);\n    feistel(c, m, l, delta, key);\n    mulx(l,l);\n\n    m     += 2*OTR_BLOCKBYTES;\n    c     += 2*OTR_BLOCKBYTES;\n    mlen  -= 2*OTR_BLOCKBYTES;\n    *clen += 2*OTR_BLOCKBYTES;\n  }\n\n  if(mlen >= OTR_BLOCKBYTES)\n  {\n    pad2block(buf,m,mlen);\n    xor_block(sigma, sigma, buf+OTR_BLOCKBYTES);\n    feistel(c, buf, l, delta, key);\n    mulx(l,l);\n    c     += 2*OTR_BLOCKBYTES;\n    *clen += 2*OTR_BLOCKBYTES;\n    xor_block(l, l, delta);\n  }\n  else\n  {\n    padblock(buf,m,mlen);\n    xor_block(sigma, sigma, buf);\n    encrypt_block(buf+OTR_BLOCKBYTES, l, key);\n    xor_block(c,buf,buf+OTR_BLOCKBYTES);\n\n    *clen += OTR_BLOCKBYTES;\n    c     += OTR_BLOCKBYTES;\n  }\n\n  // Compute TE\n  mulxp1(l,l);\n\n  xor_block(te, sigma, l);\n  xor_block(te, te, delta);\n  encrypt_block(te, te, key);\n\n  for(i=0;i<OTR_TAGBYTES;i++)\n    c[i] = te[i] ^ ta[i];\n  *clen += OTR_TAGBYTES;\n\n  zerobytes(key, CRYPTO_KEYBYTES);\n\n  return 0;\n}\n\n\nint crypto_aead_decrypt(\n    unsigned char *m, \t\tunsigned long long *mlen,\n    unsigned char *nsec,\n    const unsigned char *c, \tunsigned long long clen,\n    const unsigned char *ad,\tunsigned long long adlen,\n    const unsigned char *npub,\n    const unsigned char *k\n    )\n{\n  unsigned char key[CRYPTO_KEYBYTES];\n  unsigned char ta[OTR_BLOCKBYTES];\n  unsigned char te[OTR_BLOCKBYTES];\n  unsigned char l[OTR_BLOCKBYTES];\n  unsigned char delta[OTR_BLOCKBYTES];\n  unsigned char sigma[OTR_BLOCKBYTES];\n  unsigned char buf[2*OTR_BLOCKBYTES];\n  unsigned long long i;\n\n  if(clen < CRYPTO_ABYTES) return -1;\n  if((clen-OTR_TAGBYTES) & (OTR_BLOCKBYTES-1)) return -1;\n\n  *mlen = 0;\n\n  for(i=0;i<CRYPTO_KEYBYTES;i++)\n    key[i] = k[i];\n\n  // Compute TA\n  otr_process_ad(ta, ad, adlen, key);\n\n  // Init sigma, l and delta\n  for(i=0;i<OTR_BLOCKBYTES;i++)\n    sigma[i] = 0;\n  padblock(delta,npub,CRYPTO_NPUBBYTES);\n  encrypt_block(delta,delta,key);\n  mulx(l,delta);\n  mulx(l,l);\n\n  // Process full double-blocks\n  while(clen-OTR_TAGBYTES >= 2*OTR_BLOCKBYTES)\n  {\n    feistelback(m, c, l, delta, key);\n    xor_block(sigma, sigma, m+OTR_BLOCKBYTES);\n    mulx(l,l);\n\n    m     += 2*OTR_BLOCKBYTES;\n    c     += 2*OTR_BLOCKBYTES;\n    clen  -= 2*OTR_BLOCKBYTES;\n    *mlen += 2*OTR_BLOCKBYTES;\n  }\n\n  if(clen-OTR_TAGBYTES) // clen == OTR_BLOCKBYTES\n  {\n    encrypt_block(buf, l, key);\n    xor_block(m,c,buf);\n    xor_block(sigma, sigma, m);\n\n    *mlen += OTR_BLOCKBYTES;\n    m     += OTR_BLOCKBYTES;\n    c     += OTR_BLOCKBYTES;\n  }\n  else\n  {\n    xor_block(l, l, delta);\n  }\n\n  // Compute TE\n  mulxp1(l,l);\n  xor_block(te, sigma, l);\n  xor_block(te, te, delta);\n  encrypt_block(te, te, key);\n\n  for(i=0;i<OTR_TAGBYTES;i++)\n    te[i] ^= ta[i];\n\n  //remove padding\n  while((*mlen) > 0)\n  {\n    (*mlen)--;\n    m--;\n    if((*m) == 0x80) break;\n    if((*m) != 0x00) return -1;\n  }\n\n  zerobytes(key, CRYPTO_KEYBYTES);\n\n// CHANGE namespace added\n//  return crypto_verify_32(te, c);\n  return CaesarCommon::crypto_verify_32(te, c);\n}\n\n} // namespace Proest256otrv1_raw\n"
        },
        {
            "file_name": "pufferfish.c",
            "content": "/* PHC Candidate pufferfish - optimized implementation.\n   Authored by Jeremi Gosney, 2014\n   Placed in the public domain.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"../common/common.h\"\n#include \"../common/itoa64.h\"\n#include \"../common/api.h\"\n#include \"sha512.h\"\n#include \"pufferfish.h\"\n\n\nvoid *pufferfish (const char *pass, size_t passlen, char *settings, size_t outlen, bool raw)\n{\n\n\tstatic unsigned char *out;\n\n\tlong t_cost = 0, m_cost = 0, sbox_words, log2_sbox_words, count = 0;\n\tuint64_t state[8], tmpbuf[8], salt_hash[8], key_hash[8];\n\tuint64_t L = 0, R = 0, LL = 0, RR = 0;\n\tuint64_t *S[4], P[18];\n\n\tint i, j, settingslen, saltlen, blockcnt, bytes = 0, pos = 0;\n\n\tchar *sptr;\n\tchar tcost_str[5] = { '0', 'x', 0 };\n\tchar mcost_str[11] = { '0', 'x', 0 };\n\n\tunsigned char *rawbuf;\n\tunsigned char decoded[255] = { 0 };\n\tunsigned char rawsalt[255] = { 0 };\n\n\tuint64_t ctext[4] = { 0x4472616220617320, 0x6120666f6f6c2c20, 0x616c6f6f66206173, 0x206120626172642e };\n\n\n\tif (strncmp (PUF_ID, settings, PUF_ID_LEN))\n\t\treturn NULL;\n\n\tsettingslen = strlen (settings);\n\tsptr = settings + PUF_ID_LEN;\n\n\twhile (*sptr++ != '$' && pos < settingslen) pos++;\n\n\tsettingslen = pos + PUF_ID_LEN + 1;\n\n\tbytes = decode64 (decoded, pos, settings + PUF_ID_LEN);\n\tsaltlen = bytes - 4;\n\n\tmemcpy (tcost_str + 2, decoded, 2);\n\tt_cost = strtol (tcost_str, NULL, 16);\n\n\tmemcpy (mcost_str + 2, decoded + 2, 2);\n\tm_cost = strtol (mcost_str, NULL, 16);\n\n\tmemcpy (rawsalt, decoded + 4, saltlen);\n\n\tlog2_sbox_words = m_cost + 5;\n\t sbox_words = 1 << log2_sbox_words;\n\t m_cost = 1 << m_cost;\n\n\tpf_sha512 ((const unsigned char *) rawsalt, saltlen, salt_hash);\n\n\t pf_hmac_sha512 ((const unsigned char *) salt_hash, DIGEST_LEN, (const unsigned char *) pass, passlen, state);\n\n\t for (i = 0; i < 4; i++)\n\t {\n\t\t  S[i] = (uint64_t *) alloca (sbox_words * sizeof (uint64_t));\n\n\t\t  for (j=0; j < sbox_words; j+=8)\n\t\t  {\n\t\t\t   pf_sha512 ((const unsigned char *) state, DIGEST_LEN, S[i]+j);\n\n\t\t\t   state[0] = S[i][j+0];\n\t\t\t   state[1] = S[i][j+1];\n\t\t\t   state[2] = S[i][j+2];\n\t\t\t   state[3] = S[i][j+3];\n\t\t\t   state[4] = S[i][j+4];\n\t\t\t   state[5] = S[i][j+5];\n\t\t\t   state[6] = S[i][j+6];\n\t\t\t   state[7] = S[i][j+7];\n\t\t  }\n\t }\n\n\t pf_hmac_sha512 ((const unsigned char *) state, DIGEST_LEN, (const unsigned char *) pass, passlen, key_hash);\n\n\t P[ 0] = 0x243f6a8885a308d3 ^ key_hash[0];\n\t P[ 1] = 0x13198a2e03707344 ^ key_hash[1];\n\t P[ 2] = 0xa4093822299f31d0 ^ key_hash[2];\n\t P[ 3] = 0x082efa98ec4e6c89 ^ key_hash[3];\n\t P[ 4] = 0x452821e638d01377 ^ key_hash[4];\n\t P[ 5] = 0xbe5466cf34e90c6c ^ key_hash[5];\n\t P[ 6] = 0xc0ac29b7c97c50dd ^ key_hash[6];\n\t P[ 7] = 0x3f84d5b5b5470917 ^ key_hash[7];\n\t P[ 8] = 0x9216d5d98979fb1b ^ key_hash[0];\n\t P[ 9] = 0xd1310ba698dfb5ac ^ key_hash[1];\n\t P[10] = 0x2ffd72dbd01adfb7 ^ key_hash[2];\n\t P[11] = 0xb8e1afed6a267e96 ^ key_hash[3];\n\t P[12] = 0xba7c9045f12c7f99 ^ key_hash[4];\n\t P[13] = 0x24a19947b3916cf7 ^ key_hash[5];\n\t P[14] = 0x0801f2e2858efc16 ^ key_hash[6];\n\t P[15] = 0x636920d871574e69 ^ key_hash[7];\n\t P[16] = 0xa458fea3f4933d7e ^ key_hash[0];\n\t P[17] = 0x0d95748f728eb658 ^ key_hash[1];\n\n\t KEYCIPHER (salt_hash[0], salt_hash[1], P[ 0], P[ 1]);\n\t KEYCIPHER (salt_hash[2], salt_hash[3], P[ 2], P[ 3]);\n\t KEYCIPHER (salt_hash[4], salt_hash[5], P[ 4], P[ 5]);\n\t KEYCIPHER (salt_hash[6], salt_hash[7], P[ 6], P[ 7]);\n\t KEYCIPHER (salt_hash[0], salt_hash[1], P[ 8], P[ 9]);\n\t KEYCIPHER (salt_hash[2], salt_hash[3], P[10], P[11]);\n\t KEYCIPHER (salt_hash[4], salt_hash[5], P[12], P[13]);\n\t KEYCIPHER (salt_hash[6], salt_hash[7], P[14], P[15]);\n\t KEYCIPHER (salt_hash[0], salt_hash[1], P[16], P[17]);\n\n\t for (i = 0; i < sbox_words; i+=2)\n\t\t  KEYCIPHER (salt_hash[i&7], salt_hash[(i+1)&7], S[0][i], S[0][i+1]);\n\t for (i = 0; i < sbox_words; i+=2)\n\t\t  KEYCIPHER (salt_hash[i&7], salt_hash[(i+1)&7], S[1][i], S[1][i+1]);\n\t for (i = 0; i < sbox_words; i+=2)\n\t\t  KEYCIPHER (salt_hash[i&7], salt_hash[(i+1)&7], S[2][i], S[2][i+1]);\n\t for (i = 0; i < sbox_words; i+=2)\n\t\t  KEYCIPHER (salt_hash[i&7], salt_hash[(i+1)&7], S[3][i], S[3][i+1]);\n\n\t count = 1 << t_cost;\n\t do\n\t {\n\t\t  L = R = 0; EXPANDKEY (salt_hash);\n\t\t  L = R = 0; EXPANDKEY (key_hash);\n\t }\n\t while (--count);\n\n\tblockcnt = (outlen + DIGEST_LEN - 1) / DIGEST_LEN;\n\trawbuf = (unsigned char *) calloc (blockcnt * DIGEST_LEN, sizeof (unsigned char));\n\n\tfor (i = 0; i < blockcnt; i++)\n\t{\n\t\t count = 64;\n\t \tdo\n\t\t {\n\t\t\tL = ctext[0];\n\t \t\tR = ctext[1];\n\t\t  \tENCIPHER;\n\t\t\tctext[0] = L;\n\t \t\tctext[1] = R;\n\t\t\tL = ctext[2];\n\t \t\tR = ctext[3];\n\t\t  \tENCIPHER;\n\t\t\tctext[2] = L;\n\t \t\tctext[3] = R;\n\t\t }\n\t \twhile (--count);\n\n\t\tctext[0] = __builtin_bswap64 (ctext[0]);\n\t \tctext[1] = __builtin_bswap64 (ctext[1]);\n\t\tctext[2] = __builtin_bswap64 (ctext[2]);\n\t \tctext[3] = __builtin_bswap64 (ctext[3]);\n\n\t\tpf_sha512 ((const unsigned char *) ctext, 32, tmpbuf);\n\t\tmemcpy (rawbuf + (i * DIGEST_LEN), (unsigned char *) tmpbuf, 64);\n\t}\n\n\tif (raw == true)\n\t{\n\t\tout = (unsigned char *) calloc (blockcnt * DIGEST_LEN, sizeof (unsigned char));\n\t\tmemcpy (out, rawbuf, outlen);\n\t}\n\telse\n\t{\n\t\tout = (unsigned char *) calloc (settingslen + 1 + (blockcnt * DIGEST_LEN * 2), sizeof (unsigned char));\n\t\tmemcpy (out, settings, settingslen);\n\t\tencode64 ((char *) &out[settingslen], rawbuf, outlen);\n\t}\n\n\tmemset (ctext, 0, 32);\n\tfree (rawbuf);\n\n\treturn out;\n}\n"
        },
        {
            "file_name": "RaceCond.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"CommonDef.h\"\n\n#define\tCYCLE_NUM\t100000\n#define\tTHREAD_NUM\t4\n\nBYTE\t\t\tsharedValue=0;\nvolatile BOOL\tsharedOkToGo;\nvolatile BOOL\tsharedStop;\n\nDWORD\tconcThread_param[THREAD_NUM];\nHANDLE\tconcThread_semaphores1[THREAD_NUM];\nHANDLE\tconcThread_semaphores2[THREAD_NUM];\n\nvoid concThread(void *param)\n{\n\tDWORD\tthreadN=*((DWORD *) param);\n\n\twhile(TRUE)\n\t\t{\n\t\tDWORD\t\t\tindex;\n\n\t\t// 1. synch\n\t\tWaitForSingleObject(concThread_semaphores1[threadN],INFINITE);\n\t\tReleaseSemaphore(concThread_semaphores2[threadN],1,NULL);\n\n\t\tif(sharedStop)\n\t\t\t{ _endthread(); }\n\n\t\t// start \"sharedValue\" concurrent modify\n\t\twhile(!sharedOkToGo);\n\n\t\tfor(index=0;index<(CYCLE_NUM/128);index++)\n\t\t\t{\n\t\t\tLARGE_INTEGER\tli;\n\n\t\t\tQueryPerformanceCounter(&li);\n\n\t\t\tif(threadN%2)\n\t\t\t\t{\n\t\t\t\t__asm\n\t\t\t\t\t{\n\t\t\t\t\tmovzx ecx,byte ptr [li]\n\t\t\t\t\tjecxz LOOP0_PREHEAD\n\t\t\t\t\tjmp LOOP0_HEAD\n\n\t\t\t\t\tLOOP0_PREHEAD:\n\t\t\t\t\tinc ecx\n\t\t\t\t\tLOOP0_HEAD:\n\t\t\t\t\tdec sharedValue\n\t\t\t\t\tloop LOOP0_HEAD\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t__asm\n\t\t\t\t\t{\n\t\t\t\t\tmovzx ecx,byte ptr [li]\n\t\t\t\t\tjecxz LOOP1_PREHEAD\n\t\t\t\t\tjmp LOOP1_HEAD\n\n\t\t\t\t\tLOOP1_PREHEAD:\n\t\t\t\t\tinc ecx\n\t\t\t\t\tLOOP1_HEAD:\n\t\t\t\t\tinc sharedValue\n\t\t\t\t\tloop LOOP1_HEAD\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tReleaseSemaphore(concThread_semaphores2[threadN],1,NULL);\n\t\t}\n}\n\nvoid GenerateEntropy(const DWORD len,BYTE *outBuf,perc_callback_t backFunc,void *desc)\n{\n\tDWORD\ttLen=len;\n\tDWORD\tindex;\n\n\tsharedOkToGo=FALSE;\n\tsharedStop=FALSE;\n\n\tmemset(outBuf,0,len);\n\tmemset(concThread_semaphores1,0,THREAD_NUM*sizeof(HANDLE));\n\tmemset(concThread_semaphores2,0,THREAD_NUM*sizeof(HANDLE));\n\n\t// N semaphores : starting count=0\n\tfor(index=0;index<THREAD_NUM;index++)\n\t\t{\n\t\tif(\t(!(concThread_semaphores1[index]=CreateSemaphore(NULL,0,1,NULL)))||\n\t\t\t(!(concThread_semaphores2[index]=CreateSemaphore(NULL,0,1,NULL))) )\n\t\t\t{\n\t\t\tfor(index=0;index<THREAD_NUM;index++)\n\t\t\t\t{\n\t\t\t\tif(concThread_semaphores1[index])\n\t\t\t\t\t{ CloseHandle(concThread_semaphores1[index]); }\n\t\t\t\tif(concThread_semaphores2[index])\n\t\t\t\t\t{ CloseHandle(concThread_semaphores2[index]); }\n\t\t\t\t}\n\t\t\n\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t// problem: thread creation time >> CPU bound time\n\t// solution: create and leave it running until buf end\n\tfor(index=0;index<THREAD_NUM;index++)\n\t\t{\n\t\tconcThread_param[index]=index;\n\n\t\t_beginthread(concThread,NULL,(void *) &concThread_param[index]);\n\t\t}\n\n\twhile(tLen)\n\t\t{\n\t\tDWORD\tindex;\n\n\t\tsharedOkToGo=FALSE;\n\t\t\n\t\tfor(index=0;index<THREAD_NUM;index++)\n\t\t\t{ ReleaseSemaphore(concThread_semaphores1[index],1,NULL); }\n\t\tWaitForMultipleObjects(THREAD_NUM,concThread_semaphores2,TRUE,INFINITE);\n\n\t\t// start \"sharedValue\" concurrent modify\n\t\tsharedOkToGo=TRUE;\n\n\t\tWaitForMultipleObjects(THREAD_NUM,concThread_semaphores2,TRUE,INFINITE);\n\n\t\tif(backFunc)\n\t\t\t{ backFunc(desc,(BYTE) ((((float) (len-tLen))/((float) len))*((float) 100))); }\n\n\t\t*outBuf=sharedValue;\n\t\toutBuf++;\n\t\ttLen--;\n\t\t}\n\n\tsharedStop=TRUE;\n\n\tfor(index=0;index<THREAD_NUM;index++)\n\t\t{ ReleaseSemaphore(concThread_semaphores1[index],1,NULL); }\n\tWaitForMultipleObjects(THREAD_NUM,concThread_semaphores2,TRUE,INFINITE);\n\n\tfor(index=0;index<THREAD_NUM;index++)\n\t\t{\n\t\tCloseHandle(concThread_semaphores1[index]);\n\t\tCloseHandle(concThread_semaphores2[index]);\n\t\t}\n}\n"
        },
        {
            "file_name": "RandomCipher.cpp",
            "content": "#include \"EACglobals.h\"\n#include \"generators/IRndGen.h\"\n#include \"RandomCipher.h\"\n\n#define CRYPTO_ABYTES 16\n\nRandomCipher::RandomCipher() : CaesarInterface(CAESAR_RANDOM, -1, 0, 0, 0, CRYPTO_ABYTES) { }\n\nRandomCipher::~RandomCipher() { }\n\nint RandomCipher::encrypt(bits_t *c, length_t *clen, const bits_t *m, length_t mlen,\n                       const bits_t *ad, length_t adlen, const bits_t *nsec, const bits_t *npub,\n                       const bits_t *k) {\n    // copy plaintext to ciphertext\n    memcpy(c, m, mlen);\n    // set ciphertext length as plaintext length + tag length\n    *clen = mlen + CRYPTO_ABYTES;\n    // get random data for tag\n    for (int byte = 0; byte < CRYPTO_ABYTES; byte++) {\n        rndGen->getRandomFromInterval(255, c + mlen + byte);\n    }\n    return STAT_OK;\n}\n\nint RandomCipher::decrypt(bits_t *m, length_t *outputmlen, bits_t *nsec,\n                       const bits_t *c, length_t clen, const bits_t *ad, length_t adlen,\n                       const bits_t *npub, const bits_t *k) {\n    // copy ciphertext to plaintext\n    memcpy(m, c, clen - CRYPTO_ABYTES);\n    // set messaage length as ciphertext length - tag length\n    *outputmlen = clen - CRYPTO_ABYTES;\n    return STAT_OK;\n}\n\nstd::string RandomCipher::shortDescription() const {\n    return \"Random stream -- reference case\";\n}\n"
        },
        {
            "file_name": "raviyoylav1_encrypt.cpp",
            "content": "#include \"raviyoylav1_encrypt.h\"\n#include \"raviyoylav1_api.h\"\n#include <stdio.h>\n#include <string.h>\n\n// CHANGE namespace moved due to includes\nnamespace Raviyoylav1_raw {\nint numRounds = -1;\n\ntypedef unsigned char u8;\ntypedef unsigned long long u64;\n\nstatic void store64to8x8(u8 *Bytes, u64 Block)\n{ int i; for (i = 7; i >= 0; i--) {Bytes[i] = (u8)Block; Block >>= 8; }}\n\nvoid revolve_all(u8 * state,  u8 * carry)\n{\n    int i;\n\n    for(i = 0; i < 256; i++)\n    {\n        if(state[(i+2)%256]>state[(i+3)%256])\n            * carry ^= state[(i+1)%256];\n        else\n            * carry ^= ~state[(i+1)%256];\n\n        state[i] ^= * carry;\n    }\n}\n\nvoid evolve(u8 * state)\n{\n    int i, j;\n\n    for(i = 0; i < 256; i++)\n    {\n        for(j = 0; j < 256; j++)\n        {\n            if(state[(j + 1) % 256] > state[(j + 3) % 256])\n                state[j % 256] ^=  state[(j + 1) % 256];\n            else\n                state[j % 256] ^=  ~state[(j + 1) % 256];\n\n            if(state[(j + 2) % 256] > state[(j + 3) % 256])\n                state[j % 256] ^=  state[(j + 2) % 256];\n            else\n                state[j % 256] ^=  ~state[(j + 2) % 256];\n\n            if(state[(j + 3) % 256] % 2 == 1)\n                state[j % 256] ^=  state[(j + 3) % 256];\n            else\n                state[j % 256] ^=  ~state[(j + 3) % 256];\n        }\n    }\n}\n\nint crypto_aead_encrypt\n(\n    u8 *c,u64 *clen,\n    const u8 *m,u64 mlen,\n    const u8 *ad,u64 adlen,\n    const u8 *nsec,\n    const u8 *npub,\n    const u8 *k\n)\n{\n    u8 ignite[1028] = {0};\n    u8 ping[256], pong[256], sing[256], song[256];\n    u8 carry = 'a', mixer = 'b';\n    u64 i, j;\n\n    memmove(ignite, k, CRYPTO_KEYBYTES);\n    memmove(ignite + CRYPTO_KEYBYTES, npub, CRYPTO_NPUBBYTES);\n    store64to8x8(ignite + (CRYPTO_KEYBYTES + CRYPTO_NPUBBYTES), mlen);\n    store64to8x8(ignite + (CRYPTO_KEYBYTES + CRYPTO_NPUBBYTES + 8), adlen);\n    *clen = mlen + CRYPTO_ABYTES;\n\n    for(i = 0; i < 8; i++)\n    {\n        for(j = 0; j < 1028; j++)\n        {\n            if(ignite[(j+2)%1028]>ignite[(j+3)%1028])\n                carry ^= ignite[(j+1)%1028];\n            else\n                carry ^= ~ignite[(j+1)%1028];\n\n            ignite[j] ^= carry;\n            carry += mixer;\n        }\n    }\n\n    for(i = 0; i < 256; i++)\n    {\n        ping[i] = ignite[i];\n        pong[i] = ignite[i + 256];\n        sing[i] = ignite[i + 512];\n        song[i] = ignite[i + 768];\n    }\n\n    for(i = 0; i < mlen; i++)\n    {\n        if(ping[(i+2)%256]>ping[(i+3)%256])\n            ignite[1024] ^= ping[(i+1)%256];\n        else\n            ignite[1024] ^= ~ping[(i+1)%256];\n\n        ping[i%256] ^= ignite[1024];\n\n        if(pong[(i+2)%256]>pong[(i+3)%256])\n            ignite[1025] ^= pong[(i+1)%256];\n        else\n            ignite[1025] ^= ~pong[(i+1)%256];\n\n        pong[i%256] ^= ignite[1025];\n\n        if(sing[(i+2)%256]>sing[(i+3)%256])\n            ignite[1026] ^= sing[(i+1)%256];\n        else\n            ignite[1026] ^= ~sing[(i+1)%256];\n\n        sing[i%256] ^= ignite[1026];\n\n        c[i] = m[i] ^ ping[i%256] ^ pong[i%256] ^ sing[i%256];\n    }\n\n    for(i = 0; i < adlen; i++)\n    {\n        song[i%256] ^= ad[i];\n        if(i%256 == 0 && i > 0)\n            revolve_all(song, &ignite[1027]);\n    }\n    revolve_all(song, &ignite[1027]);\n\n    for(i = 0; i < mlen; i++)\n    {\n        song[i%256] ^= c[i];\n        if(i%256 == 0 && i > 0)\n            revolve_all(song, &ignite[1027]);\n    }\n    revolve_all(song, &ignite[1027]);\n\n    evolve(song);\n\n    memmove(c + mlen, song + 128, CRYPTO_ABYTES);\n\n    return 0;\n}\n\nint crypto_aead_decrypt\n(\n    u8 *m,u64 *mlen,\n    u8 *nsec,\n    const u8 *c,u64 clen,\n    const u8 *ad,u64 adlen,\n    const u8 *npub,\n    const u8 *k\n)\n{\n    u8 ignite[1028] = {0};\n    u8 ping[256], pong[256], sing[256], song[256];\n    u8 carry = 'a', mixer = 'b';\n    u64 i, j;\n\n    *mlen = clen - CRYPTO_ABYTES;\n    memmove(ignite, k, CRYPTO_KEYBYTES);\n    memmove(ignite + CRYPTO_KEYBYTES, npub, CRYPTO_NPUBBYTES);\n    store64to8x8(ignite + (CRYPTO_KEYBYTES + CRYPTO_NPUBBYTES), *mlen);\n    store64to8x8(ignite + (CRYPTO_KEYBYTES + CRYPTO_NPUBBYTES + 8), adlen);\n\n    for(i = 0; i < 8; i++)\n    {\n        for(j = 0; j < 1028; j++)\n        {\n            if(ignite[(j+2)%1028]>ignite[(j+3)%1028])\n                carry ^= ignite[(j+1)%1028];\n            else\n                carry ^= ~ignite[(j+1)%1028];\n\n            ignite[j] ^= carry;\n            carry += mixer;\n        }\n    }\n\n    for(i = 0; i < 256; i++)\n    {\n        ping[i] = ignite[i];\n        pong[i] = ignite[i + 256];\n        sing[i] = ignite[i + 512];\n        song[i] = ignite[i + 768];\n    }\n\n    for(i = 0; i < adlen; i++)\n    {\n        song[i%256] ^= ad[i];\n        if(i%256 == 0 && i > 0)\n            revolve_all(song, &ignite[1027]);\n    }\n    revolve_all(song, &ignite[1027]);\n\n    for(i = 0; i < *mlen; i++)\n    {\n        song[i%256] ^= c[i];\n        if(i%256 == 0 && i > 0)\n            revolve_all(song, &ignite[1027]);\n    }\n    revolve_all(song, &ignite[1027]);\n\n    evolve(song);\n\n    if(memcmp(song + 128, c + *mlen, CRYPTO_ABYTES) != 0)\n        return -1;\n\n    for(i = 0; i < *mlen; i++)\n    {\n        if(ping[(i+2)%256]>ping[(i+3)%256])\n            ignite[1024] ^= ping[(i+1)%256];\n        else\n            ignite[1024] ^= ~ping[(i+1)%256];\n\n        ping[i%256] ^= ignite[1024];\n\n        if(pong[(i+2)%256]>pong[(i+3)%256])\n            ignite[1025] ^= pong[(i+1)%256];\n        else\n            ignite[1025] ^= ~pong[(i+1)%256];\n\n        pong[i%256] ^= ignite[1025];\n\n        if(sing[(i+2)%256]>sing[(i+3)%256])\n            ignite[1026] ^= sing[(i+1)%256];\n        else\n            ignite[1026] ^= ~sing[(i+1)%256];\n\n        sing[i%256] ^= ignite[1026];\n\n        m[i] = c[i] ^ ping[i%256] ^ pong[i%256] ^ sing[i%256];\n    }\n\n    return 0;\n}\n\n} // namespace Raviyoylav1_raw\n"
        },
        {
            "file_name": "Rc6.cpp",
            "content": "#include \"stdafx.h\"\n\n#  pragma intrinsic(_lrotr,_lrotl)\n\n#  define rotr(x,n) _lrotr(x,n)\n#  define rotl(x,n) _lrotl(x,n)\n\n#define bswap(x)    (rotl(x, 8) & 0x00ff00ff | rotr(x, 8) & 0xff00ff00)\n\n#define byte(x,n)   ((BYTE)((x) >> (8 * n)))\n\n#ifdef  BLOCK_SWAP\n#define BYTE_SWAP\n#define WORD_SWAP\n#endif\n\n#ifdef  BYTE_SWAP\n#define io_swap(x)  bswap(x)\n#else\n#define io_swap(x)  (x)\n#endif\n\n#ifdef  WORD_SWAP\n\n#define get_block(x)                            \\\n    ((DWORD *)(x))[0] = io_swap(in_blk[3]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_blk[2]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_blk[1]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_blk[0])\n\n#define put_block(x)                            \\\n    out_blk[3] = io_swap(((DWORD *)(x))[0]);    \\\n    out_blk[2] = io_swap(((DWORD *)(x))[1]);    \\\n    out_blk[1] = io_swap(((DWORD *)(x))[2]);    \\\n    out_blk[0] = io_swap(((DWORD *)(x))[3])\n\n#define get_key(x,len)                          \\\n    ((DWORD *)(x))[4] = ((DWORD *)(x))[5] =     \\\n    ((DWORD *)(x))[6] = ((DWORD *)(x))[7] = 0;  \\\n    switch((((len) + 63) / 64)) {               \\\n    case 2:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[0]);     \\\n    break;                                      \\\n    case 3:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[5]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[0]);     \\\n    break;                                      \\\n    case 4:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[7]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[6]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[5]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[6] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[7] = io_swap(in_key[0]);     \\\n    }\n\n#else\n\n#define get_block(x)                            \\\n    ((DWORD *)(x))[0] = io_swap(in_blk[0]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_blk[1]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_blk[2]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_blk[3])\n\n#define put_block(x)                            \\\n    out_blk[0] = io_swap(((DWORD *)(x))[0]);    \\\n    out_blk[1] = io_swap(((DWORD *)(x))[1]);    \\\n    out_blk[2] = io_swap(((DWORD *)(x))[2]);    \\\n    out_blk[3] = io_swap(((DWORD *)(x))[3])\n\n#define get_key(x,len)                          \\\n    ((DWORD *)(x))[4] = ((DWORD *)(x))[5] =     \\\n    ((DWORD *)(x))[6] = ((DWORD *)(x))[7] = 0;  \\\n    switch((((len) + 63) / 64)) {               \\\n    case 4:                                     \\\n    ((DWORD *)(x))[6] = io_swap(in_key[6]);     \\\n    ((DWORD *)(x))[7] = io_swap(in_key[7]);     \\\n    case 3:                                     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[5]);     \\\n    case 2:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[0]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[3]);     \\\n    }\n\n#endif\n\n#define f_rnd(i,a,b,c,d)                    \\\n        u = rotl(d * (d + d + 1), 5);       \\\n        t = rotl(b * (b + b + 1), 5);       \\\n        a = rotl(a ^ t, u) + l_key[i];      \\\n        c = rotl(c ^ u, t) + l_key[i + 1]\n\n#define i_rnd(i,a,b,c,d)                    \\\n        u = rotl(d * (d + d + 1), 5);       \\\n        t = rotl(b * (b + b + 1), 5);       \\\n        c = rotr(c - l_key[i + 1], t) ^ u;  \\\n        a = rotr(a - l_key[i], u) ^ t\n\nvoid Rc6_set_key(DWORD *l_key,const DWORD *in_key, const DWORD key_len)\n{\n\tDWORD  i, j, k, a, b, l[8], t;\n\n    l_key[0] = 0xb7e15163;\n\n    for(k = 1; k < 44; ++k)\n        \n        l_key[k] = l_key[k - 1] + 0x9e3779b9;\n\n    for(k = 0; k < key_len / 32; ++k)\n\n        l[k] = in_key[k];\n\n    t = (key_len / 32) - 1; // t = (key_len / 32);\n\n    a = b = i = j = 0;\n\n    for(k = 0; k < 132; ++k)\n    {   a = rotl(l_key[i] + a + b, 3); b += a;\n        b = rotl(l[j] + b, b);\n        l_key[i] = a; l[j] = b;\n        i = (i == 43 ? 0 : i + 1); // i = (i + 1) % 44;  \n        j = (j == t ? 0 : j + 1);  // j = (j + 1) % t;\n    }\n}\n\nvoid Rc6_encrypt(const DWORD *l_key,const DWORD *in_blk, DWORD *out_blk)\n{\n\tDWORD  a,b,c,d,t,u;\n\n    a = in_blk[0]; b = in_blk[1] + l_key[0];\n    c = in_blk[2]; d = in_blk[3] + l_key[1];\n\n    f_rnd( 2,a,b,c,d); f_rnd( 4,b,c,d,a);\n    f_rnd( 6,c,d,a,b); f_rnd( 8,d,a,b,c);\n    f_rnd(10,a,b,c,d); f_rnd(12,b,c,d,a);\n    f_rnd(14,c,d,a,b); f_rnd(16,d,a,b,c);\n    f_rnd(18,a,b,c,d); f_rnd(20,b,c,d,a);\n    f_rnd(22,c,d,a,b); f_rnd(24,d,a,b,c);\n    f_rnd(26,a,b,c,d); f_rnd(28,b,c,d,a);\n    f_rnd(30,c,d,a,b); f_rnd(32,d,a,b,c);\n    f_rnd(34,a,b,c,d); f_rnd(36,b,c,d,a);\n    f_rnd(38,c,d,a,b); f_rnd(40,d,a,b,c);\n\n    out_blk[0] = a + l_key[42]; out_blk[1] = b;\n    out_blk[2] = c + l_key[43]; out_blk[3] = d;\n}\n\nvoid Rc6_decrypt(const DWORD *l_key,const DWORD *in_blk, DWORD *out_blk)\n{\n\tDWORD  a,b,c,d,t,u;\n\n    d = in_blk[3]; c = in_blk[2] - l_key[43]; \n    b = in_blk[1]; a = in_blk[0] - l_key[42];\n\n    i_rnd(40,d,a,b,c); i_rnd(38,c,d,a,b);\n    i_rnd(36,b,c,d,a); i_rnd(34,a,b,c,d);\n    i_rnd(32,d,a,b,c); i_rnd(30,c,d,a,b);\n    i_rnd(28,b,c,d,a); i_rnd(26,a,b,c,d);\n    i_rnd(24,d,a,b,c); i_rnd(22,c,d,a,b);\n    i_rnd(20,b,c,d,a); i_rnd(18,a,b,c,d);\n    i_rnd(16,d,a,b,c); i_rnd(14,c,d,a,b);\n    i_rnd(12,b,c,d,a); i_rnd(10,a,b,c,d);\n    i_rnd( 8,d,a,b,c); i_rnd( 6,c,d,a,b);\n    i_rnd( 4,b,c,d,a); i_rnd( 2,a,b,c,d);\n\n    out_blk[3] = d - l_key[1]; out_blk[2] = c; \n    out_blk[1] = b - l_key[0]; out_blk[0] = a; \n}\n"
        },
        {
            "file_name": "rig.cpp",
            "content": "\n\n/*\n  Implementation of the 'Rig' Password Hashing Scheme\n\t\n   March 31, 2014\n\n  Author: Arpan Jati (arpanj@iiitd.ac.in)\n */\n\n\n#include <malloc.h>\n#include <math.h>\n#include <memory.h>\n#include \"rig.h\"\n\nstatic inline uint64_t rotr64( const uint64_t w, const unsigned c )\n{\n\treturn ( w >> c ) | ( w << ( 64 - c ) );\n}\n\n#define G(a,b,c,d) \\\n\tdo { \\\n\ta = a + b ; \\\n\td = rotr64(d ^ a, 32); \\\n\tc = c + d; \\\n\tb = rotr64(b ^ c, 24); \\\n\ta = a + b ; \\\n\td = rotr64(d ^ a, 16); \\\n\tc = c + d; \\\n\tb = rotr64(b ^ c, 63); \\\n\t} while(0)\n\n#define ROUND_BL  \\\n\tdo { \\\n\tG(v[ 0],v[ 4],v[ 8],v[12]); \\\n\tG(v[ 1],v[ 5],v[ 9],v[13]); \\\n\tG(v[ 2],v[ 6],v[10],v[14]); \\\n\tG(v[ 3],v[ 7],v[11],v[15]); \\\n\tG(v[ 0],v[ 5],v[10],v[15]); \\\n\tG(v[ 1],v[ 6],v[11],v[12]); \\\n\tG(v[ 2],v[ 7],v[ 8],v[13]); \\\n\tG(v[ 3],v[ 4],v[ 9],v[14]); \\\n\t} while(0)\n\n\nvoid PERFORM_BLAKE_STATE(byte* in, u32 inLength, byte* out)\n{\n\tu64 v[16]; u64 d[8];\n\tmemset(v, 0, sizeof(u64)*16);\n\tmemcpy(v, in, inLength);\n\n\tROUND_BL;\n\n\tfor(int i=0;i<8;i++)\n\t{\n\t\td[i] = v[i] ^ v[i+8];\n\t}\n\n\tmemcpy(out, d, HASH_LEN_BYTES_OUT);\n}\n\nint PerformLayer_Zero(byte *ChainingValue, AlphaData* AlphaSet, HashData* KeySet, COUNT_TYPE M, COUNT_TYPE & Count)\n{\n\tCOUNT_TYPE i = 0, j = 0;\n\n\tbyte Input[LAYER_LENGTH];\n\tbyte Temp[HASH_LEN_BYTES_OUT];\n\tbyte ChainingValue_IN[HASH_LEN_BYTES_OUT];\n\n\tmemcpy(ChainingValue_IN, ChainingValue, HASH_LEN_BYTES_OUT);\n\n\tint longsInHlen = (int)ceil((float)HASH_LEN_BYTES_OUT / 8);\n\n\tmemset(AlphaSet, 0, sizeof(AlphaData) * M);\n\n\tfor (i = 0; i < M; i++)\n\t{\n\t\tbyte Count_Bytes[CNT_LEN_BYTES];\n\t\tLongToBytes((++Count), Count_Bytes);\n\n\t\tif (i == 0)\n\t\t{ \n\t\t\tmemcpy(Temp, PI_CONST, HASH_LEN_BYTES_OUT);\n\t\t}\n\n\t\tfor(j=0; j<longsInHlen; j++)\n\t\t{\n\t\t\t((u64*)AlphaSet[i])[j] = ((u64*)ChainingValue_IN)[j] ^ ((u64*)Temp)[j];\n\t\t}\n\n\t\tmemcpy(Input, Count_Bytes, CNT_LEN_BYTES);\n\t\tmemcpy(Input + CNT_LEN_BYTES, AlphaSet[i], HASH_LEN_BYTES_OUT);\n\t\tmemcpy(Input + CNT_LEN_BYTES + HASH_LEN_BYTES_OUT, Temp, HASH_LEN_BYTES_KS);\n\n\t\tmemcpy(KeySet[i], Temp, HASH_LEN_BYTES_KS);\n\n\t\tPERFORM_BLAKE_STATE(Input, LAYER_LENGTH, Temp);\n\t}\n\n\tmemcpy(ChainingValue, Temp, HASH_LEN_BYTES_OUT);\n\n\treturn SUCCESS;\n}\n\n\nint Perform_Layer(AlphaData* AlphaSet, HashData* KeySet, byte* ChainingValue, COUNT_TYPE M, COUNT_TYPE m_cost, COUNT_TYPE & Count)\n{\n\tCOUNT_TYPE i = 0, j = 0;\n\tint k = 0;\n\tu64 address = 0;\n\n\tbyte Input[LAYER_LENGTH];\t\n\tbyte Temp[HASH_LEN_BYTES_OUT];\n\n\tint longsInHlen = (int)ceil((double)HASH_LEN_BYTES_OUT / 8);\n\tint longsInKeySet = (int)ceil((double)HASH_LEN_BYTES_KS / 8);\n\n\tfor (i = 0; i < M; i++)\n\t{\n\t\tbyte Count_Bytes[CNT_LEN_BYTES];\n\t\tLongToBytes((++Count), Count_Bytes);\n\n\t\taddress = BitReverse64(i) >> (64 - m_cost);\n\n\t\tif (i == 0) \n\t\t{\n\t\t\tmemcpy(Temp, ChainingValue, HASH_LEN_BYTES_OUT); \n\t\t}\n\n\t\tfor(j=0; j < longsInHlen; j++)\n\t\t{\n\t\t\t((u64*)AlphaSet[i])[j] ^=  ((u64*)Temp)[j];\n\t\t}\n\n\t\tfor(j=0; j < longsInKeySet; j++)\n\t\t{\n\t\t\t((u64*)KeySet[address])[j] ^= ((u64*)Temp)[j];\n\t\t}\n\n\t\tmemcpy(Input, Count_Bytes, CNT_LEN_BYTES); // Count\n\t\tmemcpy(Input + CNT_LEN_BYTES, AlphaSet[i], HASH_LEN_BYTES_OUT); // ALPHA\t\t\n\t\tmemcpy(Input + CNT_LEN_BYTES + HASH_LEN_BYTES_OUT, KeySet[address], HASH_LEN_BYTES_KS);\n\n\t\tPERFORM_BLAKE_STATE((unsigned char*)Input, LAYER_LENGTH, Temp);\n\t}\n\n\tmemcpy(ChainingValue, Temp, HASH_LEN_BYTES_OUT);\n\n\treturn SUCCESS;\n}\n\n\nint GenerateAlpha(byte* Password, int PasswordLength, byte* Salt, int SaltLength, COUNT_TYPE t_cost, COUNT_TYPE OutputBits, byte* Alpha)\n{\n\tint count = 0;\n\n\tint bytes_length = PasswordLength + SaltLength + (CNT_LEN_BYTES*2);\n\n\tbyte* bytes = (byte*)malloc(bytes_length);\n\n\tbyte _T[CNT_LEN_BYTES];\n\t//byte _M[CNT_LEN_BYTES];\n\tbyte _OutputBits[CNT_LEN_BYTES];\n\tLongToBytes(t_cost, _T);\n\t//LongToBytes(m_cost, _M);\n\tLongToBytes(OutputBits, _OutputBits);\n\n\tmemset(bytes, 0, bytes_length);\n\n\tmemcpy(bytes, Password, PasswordLength);\n\tmemcpy(bytes + PasswordLength, Salt, SaltLength);\n\tmemcpy(bytes + PasswordLength + SaltLength, _T, CNT_LEN_BYTES);\n\tmemcpy(bytes + PasswordLength + SaltLength + CNT_LEN_BYTES, _OutputBits, CNT_LEN_BYTES);\n\t//memcpy(bytes + PasswordLength + SaltLength + (CNT_LEN_BYTES * 2), _OutputBits, CNT_LEN_BYTES);\n\n\n\tHASH(bytes, bytes_length, Alpha);\n\tfree(bytes);\n\n\treturn SUCCESS;\n}\n\nint PHS_FULL(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, COUNT_TYPE t_cost, COUNT_TYPE m_cost)\n{\n\tint ret = SUCCESS;\n\tint M_LOOP =0;\n\n\tif (t_cost < 1) return ERROR_TIME_LESS;\n\tif (m_cost < 1) return ERROR_COST_LESS;\n\tif (m_cost > 31) return ERROR_COST_MORE;\n\tif ((saltlen > 256) || (saltlen < 0)) return ERROR_SALTLEN_INVALID;\n\n\tbyte* alpha = (byte *)malloc(HASH_LEN_BYTES_OUT);\n\n\tbyte _salt[SALT_LEN_BYTES];\n\n\tfor (int i = 0; i < SALT_LEN_BYTES; i++)\n\t{\n\t\t_salt[i] = ((byte*)salt)[i];\n\t}\n\n\tret = GenerateAlpha((byte*)in, inlen, _salt, (int)saltlen, (int)t_cost, (int)(outlen*8), alpha);\n\n\tif (ret != SUCCESS) return ret;\n\n\tu64 __M = (u64)pow((float)2, (int)m_cost);\n\n\tbyte ChainingValue[HASH_LEN_BYTES_OUT];\n\tmemcpy(ChainingValue, alpha, HASH_LEN_BYTES_OUT);\n\n\tHashData* KeySet = (HashData*)malloc((size_t)(HASH_LEN_BYTES_KS * __M));\n\tAlphaData* AlphaSet = (AlphaData*)malloc((size_t)(HASH_LEN_BYTES_OUT * __M));\n\n\tCOUNT_TYPE Count = 0;\n\n\tfor(M_LOOP=1; M_LOOP < m_cost; M_LOOP++)\n\t{\t\t\t\n\t\tu64 M = (u64)pow((float)2, (int)M_LOOP);\n\n\t\tret = PerformLayer_Zero(ChainingValue, AlphaSet, KeySet, M, Count);\n\t\tif (ret != SUCCESS) return ret;\n\n\t\tfor (unsigned int i = 0; i < t_cost; i++)\n\t\t{\n\t\t\tret = Perform_Layer(AlphaSet, KeySet, ChainingValue, M, M_LOOP, Count);\n\t\t\tif (ret != SUCCESS) return ret;\n\t\t}\n\n\t\tbyte CNT[CNT_LEN_BYTES];\n\t\tLongToBytes(++Count, CNT);\n\n\t\tbyte _M[CNT_LEN_BYTES];\n\t\tLongToBytes(M, _M);\n\n\t\tbyte *H3_in = (byte *)malloc(CNT_LEN_BYTES*2 + HASH_LEN_BYTES_OUT + saltlen);\n\n\t\tmemcpy(H3_in, CNT, CNT_LEN_BYTES);\n\t\tmemcpy(H3_in + CNT_LEN_BYTES , ChainingValue, HASH_LEN_BYTES_OUT);\n\t\tmemcpy(H3_in +  CNT_LEN_BYTES + HASH_LEN_BYTES_OUT, salt, saltlen);\n\t\tmemcpy(H3_in +  CNT_LEN_BYTES + HASH_LEN_BYTES_OUT + saltlen, _M, CNT_LEN_BYTES);\t\n\n\t\t//printf(\"\\n\\n %d\", M);\n\n\t\tHASH(H3_in, CNT_LEN_BYTES*2 + HASH_LEN_BYTES_OUT + saltlen, ChainingValue);\n\n\t\tfree(H3_in);\n\t}\n\n\tfree(KeySet);\n\tfree(AlphaSet);\n\tfree(alpha);\n\t\n\tif (outlen <= HASH_LEN_BYTES_OUT)\n\t{\n\t\tfor (u32 i = 0; i < outlen; i++)\n\t\t{\n\t\t\t((byte*)out)[i] = ChainingValue[i];\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn ERROR_INVALID_OUT_HLEN;\n\t}\n\n\treturn SUCCESS;\n}\n\nint PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost)\n{\n\treturn PHS_FULL(out, outlen, in, inlen, salt, saltlen, t_cost, m_cost);\n}\n\nconst char * GetError(int Error)\n{\n\tswitch (Error)\n\t{\n\n\tcase ERROR_TIME_LESS:\n\t\treturn \"Time Cost should be greater than 0\";\n\n\tcase ERROR_COST_LESS:\n\t\treturn \"Memory cost should be greater than 0\";\n\n\tcase ERROR_COST_MORE:\n\t\treturn \"Memory cost should be less than or equal to 32\";\n\n\tcase ERROR_SALTLEN_INVALID:\n\t\treturn \"Salt Length should be greater than 0, and less than 256 bytes\";\n\n\tcase ERROR_COST_MULTIPLE:\n\t\treturn \"Memory Cost is not a power of 2\";\n\n\tcase ERROR_INVALID_OUT_HLEN:\n\t\treturn \"Invalid Output Hash Length\";\n\n\tdefault:\n\t\treturn \"Undefined Error\";\n\n\t}\n}\n\n\nvoid LongToBytes(COUNT_TYPE val, byte* b)\n{\n#ifndef COUNT_32\t\n\tb[7] = (byte)((val >> 40) & 0xff);\n\tb[6] = (byte)((val >> 36) & 0xff);\n\tb[5] = (byte)((val >> 32) & 0xff);\n\tb[4] = (byte)((val >> 28) & 0xff);\n#endif\n\n\tb[3] = (byte)((val >> 24) & 0xff);\n\tb[2] = (byte)((val >> 16) & 0xff);\n\tb[1] = (byte)((val >> 8) & 0xff);\n\tb[0] = (byte)((val >> 0) & 0xff);\n}\n"
        },
        {
            "file_name": "Rijndael.cpp",
            "content": "#include \"stdafx.h\"\n\n#define FULL_UNROLL\n\n#include \"Rijndael.h\"\n\n#define KEYLENGTH(keybits) ((keybits)/8)\n#define NROUNDS(keybits)   ((keybits)/32+6)\n\nconst DWORD Te0[256] =\n{\n  0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,\n  0xfff2f20dU, 0xd66b6bbdU, 0xde6f6fb1U, 0x91c5c554U,\n  0x60303050U, 0x02010103U, 0xce6767a9U, 0x562b2b7dU,\n  0xe7fefe19U, 0xb5d7d762U, 0x4dababe6U, 0xec76769aU,\n  0x8fcaca45U, 0x1f82829dU, 0x89c9c940U, 0xfa7d7d87U,\n  0xeffafa15U, 0xb25959ebU, 0x8e4747c9U, 0xfbf0f00bU,\n  0x41adadecU, 0xb3d4d467U, 0x5fa2a2fdU, 0x45afafeaU,\n  0x239c9cbfU, 0x53a4a4f7U, 0xe4727296U, 0x9bc0c05bU,\n  0x75b7b7c2U, 0xe1fdfd1cU, 0x3d9393aeU, 0x4c26266aU,\n  0x6c36365aU, 0x7e3f3f41U, 0xf5f7f702U, 0x83cccc4fU,\n  0x6834345cU, 0x51a5a5f4U, 0xd1e5e534U, 0xf9f1f108U,\n  0xe2717193U, 0xabd8d873U, 0x62313153U, 0x2a15153fU,\n  0x0804040cU, 0x95c7c752U, 0x46232365U, 0x9dc3c35eU,\n  0x30181828U, 0x379696a1U, 0x0a05050fU, 0x2f9a9ab5U,\n  0x0e070709U, 0x24121236U, 0x1b80809bU, 0xdfe2e23dU,\n  0xcdebeb26U, 0x4e272769U, 0x7fb2b2cdU, 0xea75759fU,\n  0x1209091bU, 0x1d83839eU, 0x582c2c74U, 0x341a1a2eU,\n  0x361b1b2dU, 0xdc6e6eb2U, 0xb45a5aeeU, 0x5ba0a0fbU,\n  0xa45252f6U, 0x763b3b4dU, 0xb7d6d661U, 0x7db3b3ceU,\n  0x5229297bU, 0xdde3e33eU, 0x5e2f2f71U, 0x13848497U,\n  0xa65353f5U, 0xb9d1d168U, 0x00000000U, 0xc1eded2cU,\n  0x40202060U, 0xe3fcfc1fU, 0x79b1b1c8U, 0xb65b5bedU,\n  0xd46a6abeU, 0x8dcbcb46U, 0x67bebed9U, 0x7239394bU,\n  0x944a4adeU, 0x984c4cd4U, 0xb05858e8U, 0x85cfcf4aU,\n  0xbbd0d06bU, 0xc5efef2aU, 0x4faaaae5U, 0xedfbfb16U,\n  0x864343c5U, 0x9a4d4dd7U, 0x66333355U, 0x11858594U,\n  0x8a4545cfU, 0xe9f9f910U, 0x04020206U, 0xfe7f7f81U,\n  0xa05050f0U, 0x783c3c44U, 0x259f9fbaU, 0x4ba8a8e3U,\n  0xa25151f3U, 0x5da3a3feU, 0x804040c0U, 0x058f8f8aU,\n  0x3f9292adU, 0x219d9dbcU, 0x70383848U, 0xf1f5f504U,\n  0x63bcbcdfU, 0x77b6b6c1U, 0xafdada75U, 0x42212163U,\n  0x20101030U, 0xe5ffff1aU, 0xfdf3f30eU, 0xbfd2d26dU,\n  0x81cdcd4cU, 0x180c0c14U, 0x26131335U, 0xc3ecec2fU,\n  0xbe5f5fe1U, 0x359797a2U, 0x884444ccU, 0x2e171739U,\n  0x93c4c457U, 0x55a7a7f2U, 0xfc7e7e82U, 0x7a3d3d47U,\n  0xc86464acU, 0xba5d5de7U, 0x3219192bU, 0xe6737395U,\n  0xc06060a0U, 0x19818198U, 0x9e4f4fd1U, 0xa3dcdc7fU,\n  0x44222266U, 0x542a2a7eU, 0x3b9090abU, 0x0b888883U,\n  0x8c4646caU, 0xc7eeee29U, 0x6bb8b8d3U, 0x2814143cU,\n  0xa7dede79U, 0xbc5e5ee2U, 0x160b0b1dU, 0xaddbdb76U,\n  0xdbe0e03bU, 0x64323256U, 0x743a3a4eU, 0x140a0a1eU,\n  0x924949dbU, 0x0c06060aU, 0x4824246cU, 0xb85c5ce4U,\n  0x9fc2c25dU, 0xbdd3d36eU, 0x43acacefU, 0xc46262a6U,\n  0x399191a8U, 0x319595a4U, 0xd3e4e437U, 0xf279798bU,\n  0xd5e7e732U, 0x8bc8c843U, 0x6e373759U, 0xda6d6db7U,\n  0x018d8d8cU, 0xb1d5d564U, 0x9c4e4ed2U, 0x49a9a9e0U,\n  0xd86c6cb4U, 0xac5656faU, 0xf3f4f407U, 0xcfeaea25U,\n  0xca6565afU, 0xf47a7a8eU, 0x47aeaee9U, 0x10080818U,\n  0x6fbabad5U, 0xf0787888U, 0x4a25256fU, 0x5c2e2e72U,\n  0x381c1c24U, 0x57a6a6f1U, 0x73b4b4c7U, 0x97c6c651U,\n  0xcbe8e823U, 0xa1dddd7cU, 0xe874749cU, 0x3e1f1f21U,\n  0x964b4bddU, 0x61bdbddcU, 0x0d8b8b86U, 0x0f8a8a85U,\n  0xe0707090U, 0x7c3e3e42U, 0x71b5b5c4U, 0xcc6666aaU,\n  0x904848d8U, 0x06030305U, 0xf7f6f601U, 0x1c0e0e12U,\n  0xc26161a3U, 0x6a35355fU, 0xae5757f9U, 0x69b9b9d0U,\n  0x17868691U, 0x99c1c158U, 0x3a1d1d27U, 0x279e9eb9U,\n  0xd9e1e138U, 0xebf8f813U, 0x2b9898b3U, 0x22111133U,\n  0xd26969bbU, 0xa9d9d970U, 0x078e8e89U, 0x339494a7U,\n  0x2d9b9bb6U, 0x3c1e1e22U, 0x15878792U, 0xc9e9e920U,\n  0x87cece49U, 0xaa5555ffU, 0x50282878U, 0xa5dfdf7aU,\n  0x038c8c8fU, 0x59a1a1f8U, 0x09898980U, 0x1a0d0d17U,\n  0x65bfbfdaU, 0xd7e6e631U, 0x844242c6U, 0xd06868b8U,\n  0x824141c3U, 0x299999b0U, 0x5a2d2d77U, 0x1e0f0f11U,\n  0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,\n};\n\nconst DWORD Te1[256] =\n{\n  0xa5c66363U, 0x84f87c7cU, 0x99ee7777U, 0x8df67b7bU,\n  0x0dfff2f2U, 0xbdd66b6bU, 0xb1de6f6fU, 0x5491c5c5U,\n  0x50603030U, 0x03020101U, 0xa9ce6767U, 0x7d562b2bU,\n  0x19e7fefeU, 0x62b5d7d7U, 0xe64dababU, 0x9aec7676U,\n  0x458fcacaU, 0x9d1f8282U, 0x4089c9c9U, 0x87fa7d7dU,\n  0x15effafaU, 0xebb25959U, 0xc98e4747U, 0x0bfbf0f0U,\n  0xec41adadU, 0x67b3d4d4U, 0xfd5fa2a2U, 0xea45afafU,\n  0xbf239c9cU, 0xf753a4a4U, 0x96e47272U, 0x5b9bc0c0U,\n  0xc275b7b7U, 0x1ce1fdfdU, 0xae3d9393U, 0x6a4c2626U,\n  0x5a6c3636U, 0x417e3f3fU, 0x02f5f7f7U, 0x4f83ccccU,\n  0x5c683434U, 0xf451a5a5U, 0x34d1e5e5U, 0x08f9f1f1U,\n  0x93e27171U, 0x73abd8d8U, 0x53623131U, 0x3f2a1515U,\n  0x0c080404U, 0x5295c7c7U, 0x65462323U, 0x5e9dc3c3U,\n  0x28301818U, 0xa1379696U, 0x0f0a0505U, 0xb52f9a9aU,\n  0x090e0707U, 0x36241212U, 0x9b1b8080U, 0x3ddfe2e2U,\n  0x26cdebebU, 0x694e2727U, 0xcd7fb2b2U, 0x9fea7575U,\n  0x1b120909U, 0x9e1d8383U, 0x74582c2cU, 0x2e341a1aU,\n  0x2d361b1bU, 0xb2dc6e6eU, 0xeeb45a5aU, 0xfb5ba0a0U,\n  0xf6a45252U, 0x4d763b3bU, 0x61b7d6d6U, 0xce7db3b3U,\n  0x7b522929U, 0x3edde3e3U, 0x715e2f2fU, 0x97138484U,\n  0xf5a65353U, 0x68b9d1d1U, 0x00000000U, 0x2cc1ededU,\n  0x60402020U, 0x1fe3fcfcU, 0xc879b1b1U, 0xedb65b5bU,\n  0xbed46a6aU, 0x468dcbcbU, 0xd967bebeU, 0x4b723939U,\n  0xde944a4aU, 0xd4984c4cU, 0xe8b05858U, 0x4a85cfcfU,\n  0x6bbbd0d0U, 0x2ac5efefU, 0xe54faaaaU, 0x16edfbfbU,\n  0xc5864343U, 0xd79a4d4dU, 0x55663333U, 0x94118585U,\n  0xcf8a4545U, 0x10e9f9f9U, 0x06040202U, 0x81fe7f7fU,\n  0xf0a05050U, 0x44783c3cU, 0xba259f9fU, 0xe34ba8a8U,\n  0xf3a25151U, 0xfe5da3a3U, 0xc0804040U, 0x8a058f8fU,\n  0xad3f9292U, 0xbc219d9dU, 0x48703838U, 0x04f1f5f5U,\n  0xdf63bcbcU, 0xc177b6b6U, 0x75afdadaU, 0x63422121U,\n  0x30201010U, 0x1ae5ffffU, 0x0efdf3f3U, 0x6dbfd2d2U,\n  0x4c81cdcdU, 0x14180c0cU, 0x35261313U, 0x2fc3ececU,\n  0xe1be5f5fU, 0xa2359797U, 0xcc884444U, 0x392e1717U,\n  0x5793c4c4U, 0xf255a7a7U, 0x82fc7e7eU, 0x477a3d3dU,\n  0xacc86464U, 0xe7ba5d5dU, 0x2b321919U, 0x95e67373U,\n  0xa0c06060U, 0x98198181U, 0xd19e4f4fU, 0x7fa3dcdcU,\n  0x66442222U, 0x7e542a2aU, 0xab3b9090U, 0x830b8888U,\n  0xca8c4646U, 0x29c7eeeeU, 0xd36bb8b8U, 0x3c281414U,\n  0x79a7dedeU, 0xe2bc5e5eU, 0x1d160b0bU, 0x76addbdbU,\n  0x3bdbe0e0U, 0x56643232U, 0x4e743a3aU, 0x1e140a0aU,\n  0xdb924949U, 0x0a0c0606U, 0x6c482424U, 0xe4b85c5cU,\n  0x5d9fc2c2U, 0x6ebdd3d3U, 0xef43acacU, 0xa6c46262U,\n  0xa8399191U, 0xa4319595U, 0x37d3e4e4U, 0x8bf27979U,\n  0x32d5e7e7U, 0x438bc8c8U, 0x596e3737U, 0xb7da6d6dU,\n  0x8c018d8dU, 0x64b1d5d5U, 0xd29c4e4eU, 0xe049a9a9U,\n  0xb4d86c6cU, 0xfaac5656U, 0x07f3f4f4U, 0x25cfeaeaU,\n  0xafca6565U, 0x8ef47a7aU, 0xe947aeaeU, 0x18100808U,\n  0xd56fbabaU, 0x88f07878U, 0x6f4a2525U, 0x725c2e2eU,\n  0x24381c1cU, 0xf157a6a6U, 0xc773b4b4U, 0x5197c6c6U,\n  0x23cbe8e8U, 0x7ca1ddddU, 0x9ce87474U, 0x213e1f1fU,\n  0xdd964b4bU, 0xdc61bdbdU, 0x860d8b8bU, 0x850f8a8aU,\n  0x90e07070U, 0x427c3e3eU, 0xc471b5b5U, 0xaacc6666U,\n  0xd8904848U, 0x05060303U, 0x01f7f6f6U, 0x121c0e0eU,\n  0xa3c26161U, 0x5f6a3535U, 0xf9ae5757U, 0xd069b9b9U,\n  0x91178686U, 0x5899c1c1U, 0x273a1d1dU, 0xb9279e9eU,\n  0x38d9e1e1U, 0x13ebf8f8U, 0xb32b9898U, 0x33221111U,\n  0xbbd26969U, 0x70a9d9d9U, 0x89078e8eU, 0xa7339494U,\n  0xb62d9b9bU, 0x223c1e1eU, 0x92158787U, 0x20c9e9e9U,\n  0x4987ceceU, 0xffaa5555U, 0x78502828U, 0x7aa5dfdfU,\n  0x8f038c8cU, 0xf859a1a1U, 0x80098989U, 0x171a0d0dU,\n  0xda65bfbfU, 0x31d7e6e6U, 0xc6844242U, 0xb8d06868U,\n  0xc3824141U, 0xb0299999U, 0x775a2d2dU, 0x111e0f0fU,\n  0xcb7bb0b0U, 0xfca85454U, 0xd66dbbbbU, 0x3a2c1616U,\n};\n\nconst DWORD Te2[256] =\n{\n  0x63a5c663U, 0x7c84f87cU, 0x7799ee77U, 0x7b8df67bU,\n  0xf20dfff2U, 0x6bbdd66bU, 0x6fb1de6fU, 0xc55491c5U,\n  0x30506030U, 0x01030201U, 0x67a9ce67U, 0x2b7d562bU,\n  0xfe19e7feU, 0xd762b5d7U, 0xabe64dabU, 0x769aec76U,\n  0xca458fcaU, 0x829d1f82U, 0xc94089c9U, 0x7d87fa7dU,\n  0xfa15effaU, 0x59ebb259U, 0x47c98e47U, 0xf00bfbf0U,\n  0xadec41adU, 0xd467b3d4U, 0xa2fd5fa2U, 0xafea45afU,\n  0x9cbf239cU, 0xa4f753a4U, 0x7296e472U, 0xc05b9bc0U,\n  0xb7c275b7U, 0xfd1ce1fdU, 0x93ae3d93U, 0x266a4c26U,\n  0x365a6c36U, 0x3f417e3fU, 0xf702f5f7U, 0xcc4f83ccU,\n  0x345c6834U, 0xa5f451a5U, 0xe534d1e5U, 0xf108f9f1U,\n  0x7193e271U, 0xd873abd8U, 0x31536231U, 0x153f2a15U,\n  0x040c0804U, 0xc75295c7U, 0x23654623U, 0xc35e9dc3U,\n  0x18283018U, 0x96a13796U, 0x050f0a05U, 0x9ab52f9aU,\n  0x07090e07U, 0x12362412U, 0x809b1b80U, 0xe23ddfe2U,\n  0xeb26cdebU, 0x27694e27U, 0xb2cd7fb2U, 0x759fea75U,\n  0x091b1209U, 0x839e1d83U, 0x2c74582cU, 0x1a2e341aU,\n  0x1b2d361bU, 0x6eb2dc6eU, 0x5aeeb45aU, 0xa0fb5ba0U,\n  0x52f6a452U, 0x3b4d763bU, 0xd661b7d6U, 0xb3ce7db3U,\n  0x297b5229U, 0xe33edde3U, 0x2f715e2fU, 0x84971384U,\n  0x53f5a653U, 0xd168b9d1U, 0x00000000U, 0xed2cc1edU,\n  0x20604020U, 0xfc1fe3fcU, 0xb1c879b1U, 0x5bedb65bU,\n  0x6abed46aU, 0xcb468dcbU, 0xbed967beU, 0x394b7239U,\n  0x4ade944aU, 0x4cd4984cU, 0x58e8b058U, 0xcf4a85cfU,\n  0xd06bbbd0U, 0xef2ac5efU, 0xaae54faaU, 0xfb16edfbU,\n  0x43c58643U, 0x4dd79a4dU, 0x33556633U, 0x85941185U,\n  0x45cf8a45U, 0xf910e9f9U, 0x02060402U, 0x7f81fe7fU,\n  0x50f0a050U, 0x3c44783cU, 0x9fba259fU, 0xa8e34ba8U,\n  0x51f3a251U, 0xa3fe5da3U, 0x40c08040U, 0x8f8a058fU,\n  0x92ad3f92U, 0x9dbc219dU, 0x38487038U, 0xf504f1f5U,\n  0xbcdf63bcU, 0xb6c177b6U, 0xda75afdaU, 0x21634221U,\n  0x10302010U, 0xff1ae5ffU, 0xf30efdf3U, 0xd26dbfd2U,\n  0xcd4c81cdU, 0x0c14180cU, 0x13352613U, 0xec2fc3ecU,\n  0x5fe1be5fU, 0x97a23597U, 0x44cc8844U, 0x17392e17U,\n  0xc45793c4U, 0xa7f255a7U, 0x7e82fc7eU, 0x3d477a3dU,\n  0x64acc864U, 0x5de7ba5dU, 0x192b3219U, 0x7395e673U,\n  0x60a0c060U, 0x81981981U, 0x4fd19e4fU, 0xdc7fa3dcU,\n  0x22664422U, 0x2a7e542aU, 0x90ab3b90U, 0x88830b88U,\n  0x46ca8c46U, 0xee29c7eeU, 0xb8d36bb8U, 0x143c2814U,\n  0xde79a7deU, 0x5ee2bc5eU, 0x0b1d160bU, 0xdb76addbU,\n  0xe03bdbe0U, 0x32566432U, 0x3a4e743aU, 0x0a1e140aU,\n  0x49db9249U, 0x060a0c06U, 0x246c4824U, 0x5ce4b85cU,\n  0xc25d9fc2U, 0xd36ebdd3U, 0xacef43acU, 0x62a6c462U,\n  0x91a83991U, 0x95a43195U, 0xe437d3e4U, 0x798bf279U,\n  0xe732d5e7U, 0xc8438bc8U, 0x37596e37U, 0x6db7da6dU,\n  0x8d8c018dU, 0xd564b1d5U, 0x4ed29c4eU, 0xa9e049a9U,\n  0x6cb4d86cU, 0x56faac56U, 0xf407f3f4U, 0xea25cfeaU,\n  0x65afca65U, 0x7a8ef47aU, 0xaee947aeU, 0x08181008U,\n  0xbad56fbaU, 0x7888f078U, 0x256f4a25U, 0x2e725c2eU,\n  0x1c24381cU, 0xa6f157a6U, 0xb4c773b4U, 0xc65197c6U,\n  0xe823cbe8U, 0xdd7ca1ddU, 0x749ce874U, 0x1f213e1fU,\n  0x4bdd964bU, 0xbddc61bdU, 0x8b860d8bU, 0x8a850f8aU,\n  0x7090e070U, 0x3e427c3eU, 0xb5c471b5U, 0x66aacc66U,\n  0x48d89048U, 0x03050603U, 0xf601f7f6U, 0x0e121c0eU,\n  0x61a3c261U, 0x355f6a35U, 0x57f9ae57U, 0xb9d069b9U,\n  0x86911786U, 0xc15899c1U, 0x1d273a1dU, 0x9eb9279eU,\n  0xe138d9e1U, 0xf813ebf8U, 0x98b32b98U, 0x11332211U,\n  0x69bbd269U, 0xd970a9d9U, 0x8e89078eU, 0x94a73394U,\n  0x9bb62d9bU, 0x1e223c1eU, 0x87921587U, 0xe920c9e9U,\n  0xce4987ceU, 0x55ffaa55U, 0x28785028U, 0xdf7aa5dfU,\n  0x8c8f038cU, 0xa1f859a1U, 0x89800989U, 0x0d171a0dU,\n  0xbfda65bfU, 0xe631d7e6U, 0x42c68442U, 0x68b8d068U,\n  0x41c38241U, 0x99b02999U, 0x2d775a2dU, 0x0f111e0fU,\n  0xb0cb7bb0U, 0x54fca854U, 0xbbd66dbbU, 0x163a2c16U,\n};\n\nconst DWORD Te3[256] =\n{\n  0x6363a5c6U, 0x7c7c84f8U, 0x777799eeU, 0x7b7b8df6U,\n  0xf2f20dffU, 0x6b6bbdd6U, 0x6f6fb1deU, 0xc5c55491U,\n  0x30305060U, 0x01010302U, 0x6767a9ceU, 0x2b2b7d56U,\n  0xfefe19e7U, 0xd7d762b5U, 0xababe64dU, 0x76769aecU,\n  0xcaca458fU, 0x82829d1fU, 0xc9c94089U, 0x7d7d87faU,\n  0xfafa15efU, 0x5959ebb2U, 0x4747c98eU, 0xf0f00bfbU,\n  0xadadec41U, 0xd4d467b3U, 0xa2a2fd5fU, 0xafafea45U,\n  0x9c9cbf23U, 0xa4a4f753U, 0x727296e4U, 0xc0c05b9bU,\n  0xb7b7c275U, 0xfdfd1ce1U, 0x9393ae3dU, 0x26266a4cU,\n  0x36365a6cU, 0x3f3f417eU, 0xf7f702f5U, 0xcccc4f83U,\n  0x34345c68U, 0xa5a5f451U, 0xe5e534d1U, 0xf1f108f9U,\n  0x717193e2U, 0xd8d873abU, 0x31315362U, 0x15153f2aU,\n  0x04040c08U, 0xc7c75295U, 0x23236546U, 0xc3c35e9dU,\n  0x18182830U, 0x9696a137U, 0x05050f0aU, 0x9a9ab52fU,\n  0x0707090eU, 0x12123624U, 0x80809b1bU, 0xe2e23ddfU,\n  0xebeb26cdU, 0x2727694eU, 0xb2b2cd7fU, 0x75759feaU,\n  0x09091b12U, 0x83839e1dU, 0x2c2c7458U, 0x1a1a2e34U,\n  0x1b1b2d36U, 0x6e6eb2dcU, 0x5a5aeeb4U, 0xa0a0fb5bU,\n  0x5252f6a4U, 0x3b3b4d76U, 0xd6d661b7U, 0xb3b3ce7dU,\n  0x29297b52U, 0xe3e33eddU, 0x2f2f715eU, 0x84849713U,\n  0x5353f5a6U, 0xd1d168b9U, 0x00000000U, 0xeded2cc1U,\n  0x20206040U, 0xfcfc1fe3U, 0xb1b1c879U, 0x5b5bedb6U,\n  0x6a6abed4U, 0xcbcb468dU, 0xbebed967U, 0x39394b72U,\n  0x4a4ade94U, 0x4c4cd498U, 0x5858e8b0U, 0xcfcf4a85U,\n  0xd0d06bbbU, 0xefef2ac5U, 0xaaaae54fU, 0xfbfb16edU,\n  0x4343c586U, 0x4d4dd79aU, 0x33335566U, 0x85859411U,\n  0x4545cf8aU, 0xf9f910e9U, 0x02020604U, 0x7f7f81feU,\n  0x5050f0a0U, 0x3c3c4478U, 0x9f9fba25U, 0xa8a8e34bU,\n  0x5151f3a2U, 0xa3a3fe5dU, 0x4040c080U, 0x8f8f8a05U,\n  0x9292ad3fU, 0x9d9dbc21U, 0x38384870U, 0xf5f504f1U,\n  0xbcbcdf63U, 0xb6b6c177U, 0xdada75afU, 0x21216342U,\n  0x10103020U, 0xffff1ae5U, 0xf3f30efdU, 0xd2d26dbfU,\n  0xcdcd4c81U, 0x0c0c1418U, 0x13133526U, 0xecec2fc3U,\n  0x5f5fe1beU, 0x9797a235U, 0x4444cc88U, 0x1717392eU,\n  0xc4c45793U, 0xa7a7f255U, 0x7e7e82fcU, 0x3d3d477aU,\n  0x6464acc8U, 0x5d5de7baU, 0x19192b32U, 0x737395e6U,\n  0x6060a0c0U, 0x81819819U, 0x4f4fd19eU, 0xdcdc7fa3U,\n  0x22226644U, 0x2a2a7e54U, 0x9090ab3bU, 0x8888830bU,\n  0x4646ca8cU, 0xeeee29c7U, 0xb8b8d36bU, 0x14143c28U,\n  0xdede79a7U, 0x5e5ee2bcU, 0x0b0b1d16U, 0xdbdb76adU,\n  0xe0e03bdbU, 0x32325664U, 0x3a3a4e74U, 0x0a0a1e14U,\n  0x4949db92U, 0x06060a0cU, 0x24246c48U, 0x5c5ce4b8U,\n  0xc2c25d9fU, 0xd3d36ebdU, 0xacacef43U, 0x6262a6c4U,\n  0x9191a839U, 0x9595a431U, 0xe4e437d3U, 0x79798bf2U,\n  0xe7e732d5U, 0xc8c8438bU, 0x3737596eU, 0x6d6db7daU,\n  0x8d8d8c01U, 0xd5d564b1U, 0x4e4ed29cU, 0xa9a9e049U,\n  0x6c6cb4d8U, 0x5656faacU, 0xf4f407f3U, 0xeaea25cfU,\n  0x6565afcaU, 0x7a7a8ef4U, 0xaeaee947U, 0x08081810U,\n  0xbabad56fU, 0x787888f0U, 0x25256f4aU, 0x2e2e725cU,\n  0x1c1c2438U, 0xa6a6f157U, 0xb4b4c773U, 0xc6c65197U,\n  0xe8e823cbU, 0xdddd7ca1U, 0x74749ce8U, 0x1f1f213eU,\n  0x4b4bdd96U, 0xbdbddc61U, 0x8b8b860dU, 0x8a8a850fU,\n  0x707090e0U, 0x3e3e427cU, 0xb5b5c471U, 0x6666aaccU,\n  0x4848d890U, 0x03030506U, 0xf6f601f7U, 0x0e0e121cU,\n  0x6161a3c2U, 0x35355f6aU, 0x5757f9aeU, 0xb9b9d069U,\n  0x86869117U, 0xc1c15899U, 0x1d1d273aU, 0x9e9eb927U,\n  0xe1e138d9U, 0xf8f813ebU, 0x9898b32bU, 0x11113322U,\n  0x6969bbd2U, 0xd9d970a9U, 0x8e8e8907U, 0x9494a733U,\n  0x9b9bb62dU, 0x1e1e223cU, 0x87879215U, 0xe9e920c9U,\n  0xcece4987U, 0x5555ffaaU, 0x28287850U, 0xdfdf7aa5U,\n  0x8c8c8f03U, 0xa1a1f859U, 0x89898009U, 0x0d0d171aU,\n  0xbfbfda65U, 0xe6e631d7U, 0x4242c684U, 0x6868b8d0U,\n  0x4141c382U, 0x9999b029U, 0x2d2d775aU, 0x0f0f111eU,\n  0xb0b0cb7bU, 0x5454fca8U, 0xbbbbd66dU, 0x16163a2cU,\n};\n\nconst DWORD Te4[256] =\n{\n  0x63636363U, 0x7c7c7c7cU, 0x77777777U, 0x7b7b7b7bU,\n  0xf2f2f2f2U, 0x6b6b6b6bU, 0x6f6f6f6fU, 0xc5c5c5c5U,\n  0x30303030U, 0x01010101U, 0x67676767U, 0x2b2b2b2bU,\n  0xfefefefeU, 0xd7d7d7d7U, 0xababababU, 0x76767676U,\n  0xcacacacaU, 0x82828282U, 0xc9c9c9c9U, 0x7d7d7d7dU,\n  0xfafafafaU, 0x59595959U, 0x47474747U, 0xf0f0f0f0U,\n  0xadadadadU, 0xd4d4d4d4U, 0xa2a2a2a2U, 0xafafafafU,\n  0x9c9c9c9cU, 0xa4a4a4a4U, 0x72727272U, 0xc0c0c0c0U,\n  0xb7b7b7b7U, 0xfdfdfdfdU, 0x93939393U, 0x26262626U,\n  0x36363636U, 0x3f3f3f3fU, 0xf7f7f7f7U, 0xccccccccU,\n  0x34343434U, 0xa5a5a5a5U, 0xe5e5e5e5U, 0xf1f1f1f1U,\n  0x71717171U, 0xd8d8d8d8U, 0x31313131U, 0x15151515U,\n  0x04040404U, 0xc7c7c7c7U, 0x23232323U, 0xc3c3c3c3U,\n  0x18181818U, 0x96969696U, 0x05050505U, 0x9a9a9a9aU,\n  0x07070707U, 0x12121212U, 0x80808080U, 0xe2e2e2e2U,\n  0xebebebebU, 0x27272727U, 0xb2b2b2b2U, 0x75757575U,\n  0x09090909U, 0x83838383U, 0x2c2c2c2cU, 0x1a1a1a1aU,\n  0x1b1b1b1bU, 0x6e6e6e6eU, 0x5a5a5a5aU, 0xa0a0a0a0U,\n  0x52525252U, 0x3b3b3b3bU, 0xd6d6d6d6U, 0xb3b3b3b3U,\n  0x29292929U, 0xe3e3e3e3U, 0x2f2f2f2fU, 0x84848484U,\n  0x53535353U, 0xd1d1d1d1U, 0x00000000U, 0xededededU,\n  0x20202020U, 0xfcfcfcfcU, 0xb1b1b1b1U, 0x5b5b5b5bU,\n  0x6a6a6a6aU, 0xcbcbcbcbU, 0xbebebebeU, 0x39393939U,\n  0x4a4a4a4aU, 0x4c4c4c4cU, 0x58585858U, 0xcfcfcfcfU,\n  0xd0d0d0d0U, 0xefefefefU, 0xaaaaaaaaU, 0xfbfbfbfbU,\n  0x43434343U, 0x4d4d4d4dU, 0x33333333U, 0x85858585U,\n  0x45454545U, 0xf9f9f9f9U, 0x02020202U, 0x7f7f7f7fU,\n  0x50505050U, 0x3c3c3c3cU, 0x9f9f9f9fU, 0xa8a8a8a8U,\n  0x51515151U, 0xa3a3a3a3U, 0x40404040U, 0x8f8f8f8fU,\n  0x92929292U, 0x9d9d9d9dU, 0x38383838U, 0xf5f5f5f5U,\n  0xbcbcbcbcU, 0xb6b6b6b6U, 0xdadadadaU, 0x21212121U,\n  0x10101010U, 0xffffffffU, 0xf3f3f3f3U, 0xd2d2d2d2U,\n  0xcdcdcdcdU, 0x0c0c0c0cU, 0x13131313U, 0xececececU,\n  0x5f5f5f5fU, 0x97979797U, 0x44444444U, 0x17171717U,\n  0xc4c4c4c4U, 0xa7a7a7a7U, 0x7e7e7e7eU, 0x3d3d3d3dU,\n  0x64646464U, 0x5d5d5d5dU, 0x19191919U, 0x73737373U,\n  0x60606060U, 0x81818181U, 0x4f4f4f4fU, 0xdcdcdcdcU,\n  0x22222222U, 0x2a2a2a2aU, 0x90909090U, 0x88888888U,\n  0x46464646U, 0xeeeeeeeeU, 0xb8b8b8b8U, 0x14141414U,\n  0xdedededeU, 0x5e5e5e5eU, 0x0b0b0b0bU, 0xdbdbdbdbU,\n  0xe0e0e0e0U, 0x32323232U, 0x3a3a3a3aU, 0x0a0a0a0aU,\n  0x49494949U, 0x06060606U, 0x24242424U, 0x5c5c5c5cU,\n  0xc2c2c2c2U, 0xd3d3d3d3U, 0xacacacacU, 0x62626262U,\n  0x91919191U, 0x95959595U, 0xe4e4e4e4U, 0x79797979U,\n  0xe7e7e7e7U, 0xc8c8c8c8U, 0x37373737U, 0x6d6d6d6dU,\n  0x8d8d8d8dU, 0xd5d5d5d5U, 0x4e4e4e4eU, 0xa9a9a9a9U,\n  0x6c6c6c6cU, 0x56565656U, 0xf4f4f4f4U, 0xeaeaeaeaU,\n  0x65656565U, 0x7a7a7a7aU, 0xaeaeaeaeU, 0x08080808U,\n  0xbabababaU, 0x78787878U, 0x25252525U, 0x2e2e2e2eU,\n  0x1c1c1c1cU, 0xa6a6a6a6U, 0xb4b4b4b4U, 0xc6c6c6c6U,\n  0xe8e8e8e8U, 0xddddddddU, 0x74747474U, 0x1f1f1f1fU,\n  0x4b4b4b4bU, 0xbdbdbdbdU, 0x8b8b8b8bU, 0x8a8a8a8aU,\n  0x70707070U, 0x3e3e3e3eU, 0xb5b5b5b5U, 0x66666666U,\n  0x48484848U, 0x03030303U, 0xf6f6f6f6U, 0x0e0e0e0eU,\n  0x61616161U, 0x35353535U, 0x57575757U, 0xb9b9b9b9U,\n  0x86868686U, 0xc1c1c1c1U, 0x1d1d1d1dU, 0x9e9e9e9eU,\n  0xe1e1e1e1U, 0xf8f8f8f8U, 0x98989898U, 0x11111111U,\n  0x69696969U, 0xd9d9d9d9U, 0x8e8e8e8eU, 0x94949494U,\n  0x9b9b9b9bU, 0x1e1e1e1eU, 0x87878787U, 0xe9e9e9e9U,\n  0xcecececeU, 0x55555555U, 0x28282828U, 0xdfdfdfdfU,\n  0x8c8c8c8cU, 0xa1a1a1a1U, 0x89898989U, 0x0d0d0d0dU,\n  0xbfbfbfbfU, 0xe6e6e6e6U, 0x42424242U, 0x68686868U,\n  0x41414141U, 0x99999999U, 0x2d2d2d2dU, 0x0f0f0f0fU,\n  0xb0b0b0b0U, 0x54545454U, 0xbbbbbbbbU, 0x16161616U,\n};\n\nconst DWORD Td0[256] =\n{\n  0x51f4a750U, 0x7e416553U, 0x1a17a4c3U, 0x3a275e96U,\n  0x3bab6bcbU, 0x1f9d45f1U, 0xacfa58abU, 0x4be30393U,\n  0x2030fa55U, 0xad766df6U, 0x88cc7691U, 0xf5024c25U,\n  0x4fe5d7fcU, 0xc52acbd7U, 0x26354480U, 0xb562a38fU,\n  0xdeb15a49U, 0x25ba1b67U, 0x45ea0e98U, 0x5dfec0e1U,\n  0xc32f7502U, 0x814cf012U, 0x8d4697a3U, 0x6bd3f9c6U,\n  0x038f5fe7U, 0x15929c95U, 0xbf6d7aebU, 0x955259daU,\n  0xd4be832dU, 0x587421d3U, 0x49e06929U, 0x8ec9c844U,\n  0x75c2896aU, 0xf48e7978U, 0x99583e6bU, 0x27b971ddU,\n  0xbee14fb6U, 0xf088ad17U, 0xc920ac66U, 0x7dce3ab4U,\n  0x63df4a18U, 0xe51a3182U, 0x97513360U, 0x62537f45U,\n  0xb16477e0U, 0xbb6bae84U, 0xfe81a01cU, 0xf9082b94U,\n  0x70486858U, 0x8f45fd19U, 0x94de6c87U, 0x527bf8b7U,\n  0xab73d323U, 0x724b02e2U, 0xe31f8f57U, 0x6655ab2aU,\n  0xb2eb2807U, 0x2fb5c203U, 0x86c57b9aU, 0xd33708a5U,\n  0x302887f2U, 0x23bfa5b2U, 0x02036abaU, 0xed16825cU,\n  0x8acf1c2bU, 0xa779b492U, 0xf307f2f0U, 0x4e69e2a1U,\n  0x65daf4cdU, 0x0605bed5U, 0xd134621fU, 0xc4a6fe8aU,\n  0x342e539dU, 0xa2f355a0U, 0x058ae132U, 0xa4f6eb75U,\n  0x0b83ec39U, 0x4060efaaU, 0x5e719f06U, 0xbd6e1051U,\n  0x3e218af9U, 0x96dd063dU, 0xdd3e05aeU, 0x4de6bd46U,\n  0x91548db5U, 0x71c45d05U, 0x0406d46fU, 0x605015ffU,\n  0x1998fb24U, 0xd6bde997U, 0x894043ccU, 0x67d99e77U,\n  0xb0e842bdU, 0x07898b88U, 0xe7195b38U, 0x79c8eedbU,\n  0xa17c0a47U, 0x7c420fe9U, 0xf8841ec9U, 0x00000000U,\n  0x09808683U, 0x322bed48U, 0x1e1170acU, 0x6c5a724eU,\n  0xfd0efffbU, 0x0f853856U, 0x3daed51eU, 0x362d3927U,\n  0x0a0fd964U, 0x685ca621U, 0x9b5b54d1U, 0x24362e3aU,\n  0x0c0a67b1U, 0x9357e70fU, 0xb4ee96d2U, 0x1b9b919eU,\n  0x80c0c54fU, 0x61dc20a2U, 0x5a774b69U, 0x1c121a16U,\n  0xe293ba0aU, 0xc0a02ae5U, 0x3c22e043U, 0x121b171dU,\n  0x0e090d0bU, 0xf28bc7adU, 0x2db6a8b9U, 0x141ea9c8U,\n  0x57f11985U, 0xaf75074cU, 0xee99ddbbU, 0xa37f60fdU,\n  0xf701269fU, 0x5c72f5bcU, 0x44663bc5U, 0x5bfb7e34U,\n  0x8b432976U, 0xcb23c6dcU, 0xb6edfc68U, 0xb8e4f163U,\n  0xd731dccaU, 0x42638510U, 0x13972240U, 0x84c61120U,\n  0x854a247dU, 0xd2bb3df8U, 0xaef93211U, 0xc729a16dU,\n  0x1d9e2f4bU, 0xdcb230f3U, 0x0d8652ecU, 0x77c1e3d0U,\n  0x2bb3166cU, 0xa970b999U, 0x119448faU, 0x47e96422U,\n  0xa8fc8cc4U, 0xa0f03f1aU, 0x567d2cd8U, 0x223390efU,\n  0x87494ec7U, 0xd938d1c1U, 0x8ccaa2feU, 0x98d40b36U,\n  0xa6f581cfU, 0xa57ade28U, 0xdab78e26U, 0x3fadbfa4U,\n  0x2c3a9de4U, 0x5078920dU, 0x6a5fcc9bU, 0x547e4662U,\n  0xf68d13c2U, 0x90d8b8e8U, 0x2e39f75eU, 0x82c3aff5U,\n  0x9f5d80beU, 0x69d0937cU, 0x6fd52da9U, 0xcf2512b3U,\n  0xc8ac993bU, 0x10187da7U, 0xe89c636eU, 0xdb3bbb7bU,\n  0xcd267809U, 0x6e5918f4U, 0xec9ab701U, 0x834f9aa8U,\n  0xe6956e65U, 0xaaffe67eU, 0x21bccf08U, 0xef15e8e6U,\n  0xbae79bd9U, 0x4a6f36ceU, 0xea9f09d4U, 0x29b07cd6U,\n  0x31a4b2afU, 0x2a3f2331U, 0xc6a59430U, 0x35a266c0U,\n  0x744ebc37U, 0xfc82caa6U, 0xe090d0b0U, 0x33a7d815U,\n  0xf104984aU, 0x41ecdaf7U, 0x7fcd500eU, 0x1791f62fU,\n  0x764dd68dU, 0x43efb04dU, 0xccaa4d54U, 0xe49604dfU,\n  0x9ed1b5e3U, 0x4c6a881bU, 0xc12c1fb8U, 0x4665517fU,\n  0x9d5eea04U, 0x018c355dU, 0xfa877473U, 0xfb0b412eU,\n  0xb3671d5aU, 0x92dbd252U, 0xe9105633U, 0x6dd64713U,\n  0x9ad7618cU, 0x37a10c7aU, 0x59f8148eU, 0xeb133c89U,\n  0xcea927eeU, 0xb761c935U, 0xe11ce5edU, 0x7a47b13cU,\n  0x9cd2df59U, 0x55f2733fU, 0x1814ce79U, 0x73c737bfU,\n  0x53f7cdeaU, 0x5ffdaa5bU, 0xdf3d6f14U, 0x7844db86U,\n  0xcaaff381U, 0xb968c43eU, 0x3824342cU, 0xc2a3405fU,\n  0x161dc372U, 0xbce2250cU, 0x283c498bU, 0xff0d9541U,\n  0x39a80171U, 0x080cb3deU, 0xd8b4e49cU, 0x6456c190U,\n  0x7bcb8461U, 0xd532b670U, 0x486c5c74U, 0xd0b85742U,\n};\n\nconst DWORD Td1[256] =\n{\n  0x5051f4a7U, 0x537e4165U, 0xc31a17a4U, 0x963a275eU,\n  0xcb3bab6bU, 0xf11f9d45U, 0xabacfa58U, 0x934be303U,\n  0x552030faU, 0xf6ad766dU, 0x9188cc76U, 0x25f5024cU,\n  0xfc4fe5d7U, 0xd7c52acbU, 0x80263544U, 0x8fb562a3U,\n  0x49deb15aU, 0x6725ba1bU, 0x9845ea0eU, 0xe15dfec0U,\n  0x02c32f75U, 0x12814cf0U, 0xa38d4697U, 0xc66bd3f9U,\n  0xe7038f5fU, 0x9515929cU, 0xebbf6d7aU, 0xda955259U,\n  0x2dd4be83U, 0xd3587421U, 0x2949e069U, 0x448ec9c8U,\n  0x6a75c289U, 0x78f48e79U, 0x6b99583eU, 0xdd27b971U,\n  0xb6bee14fU, 0x17f088adU, 0x66c920acU, 0xb47dce3aU,\n  0x1863df4aU, 0x82e51a31U, 0x60975133U, 0x4562537fU,\n  0xe0b16477U, 0x84bb6baeU, 0x1cfe81a0U, 0x94f9082bU,\n  0x58704868U, 0x198f45fdU, 0x8794de6cU, 0xb7527bf8U,\n  0x23ab73d3U, 0xe2724b02U, 0x57e31f8fU, 0x2a6655abU,\n  0x07b2eb28U, 0x032fb5c2U, 0x9a86c57bU, 0xa5d33708U,\n  0xf2302887U, 0xb223bfa5U, 0xba02036aU, 0x5ced1682U,\n  0x2b8acf1cU, 0x92a779b4U, 0xf0f307f2U, 0xa14e69e2U,\n  0xcd65daf4U, 0xd50605beU, 0x1fd13462U, 0x8ac4a6feU,\n  0x9d342e53U, 0xa0a2f355U, 0x32058ae1U, 0x75a4f6ebU,\n  0x390b83ecU, 0xaa4060efU, 0x065e719fU, 0x51bd6e10U,\n  0xf93e218aU, 0x3d96dd06U, 0xaedd3e05U, 0x464de6bdU,\n  0xb591548dU, 0x0571c45dU, 0x6f0406d4U, 0xff605015U,\n  0x241998fbU, 0x97d6bde9U, 0xcc894043U, 0x7767d99eU,\n  0xbdb0e842U, 0x8807898bU, 0x38e7195bU, 0xdb79c8eeU,\n  0x47a17c0aU, 0xe97c420fU, 0xc9f8841eU, 0x00000000U,\n  0x83098086U, 0x48322bedU, 0xac1e1170U, 0x4e6c5a72U,\n  0xfbfd0effU, 0x560f8538U, 0x1e3daed5U, 0x27362d39U,\n  0x640a0fd9U, 0x21685ca6U, 0xd19b5b54U, 0x3a24362eU,\n  0xb10c0a67U, 0x0f9357e7U, 0xd2b4ee96U, 0x9e1b9b91U,\n  0x4f80c0c5U, 0xa261dc20U, 0x695a774bU, 0x161c121aU,\n  0x0ae293baU, 0xe5c0a02aU, 0x433c22e0U, 0x1d121b17U,\n  0x0b0e090dU, 0xadf28bc7U, 0xb92db6a8U, 0xc8141ea9U,\n  0x8557f119U, 0x4caf7507U, 0xbbee99ddU, 0xfda37f60U,\n  0x9ff70126U, 0xbc5c72f5U, 0xc544663bU, 0x345bfb7eU,\n  0x768b4329U, 0xdccb23c6U, 0x68b6edfcU, 0x63b8e4f1U,\n  0xcad731dcU, 0x10426385U, 0x40139722U, 0x2084c611U,\n  0x7d854a24U, 0xf8d2bb3dU, 0x11aef932U, 0x6dc729a1U,\n  0x4b1d9e2fU, 0xf3dcb230U, 0xec0d8652U, 0xd077c1e3U,\n  0x6c2bb316U, 0x99a970b9U, 0xfa119448U, 0x2247e964U,\n  0xc4a8fc8cU, 0x1aa0f03fU, 0xd8567d2cU, 0xef223390U,\n  0xc787494eU, 0xc1d938d1U, 0xfe8ccaa2U, 0x3698d40bU,\n  0xcfa6f581U, 0x28a57adeU, 0x26dab78eU, 0xa43fadbfU,\n  0xe42c3a9dU, 0x0d507892U, 0x9b6a5fccU, 0x62547e46U,\n  0xc2f68d13U, 0xe890d8b8U, 0x5e2e39f7U, 0xf582c3afU,\n  0xbe9f5d80U, 0x7c69d093U, 0xa96fd52dU, 0xb3cf2512U,\n  0x3bc8ac99U, 0xa710187dU, 0x6ee89c63U, 0x7bdb3bbbU,\n  0x09cd2678U, 0xf46e5918U, 0x01ec9ab7U, 0xa8834f9aU,\n  0x65e6956eU, 0x7eaaffe6U, 0x0821bccfU, 0xe6ef15e8U,\n  0xd9bae79bU, 0xce4a6f36U, 0xd4ea9f09U, 0xd629b07cU,\n  0xaf31a4b2U, 0x312a3f23U, 0x30c6a594U, 0xc035a266U,\n  0x37744ebcU, 0xa6fc82caU, 0xb0e090d0U, 0x1533a7d8U,\n  0x4af10498U, 0xf741ecdaU, 0x0e7fcd50U, 0x2f1791f6U,\n  0x8d764dd6U, 0x4d43efb0U, 0x54ccaa4dU, 0xdfe49604U,\n  0xe39ed1b5U, 0x1b4c6a88U, 0xb8c12c1fU, 0x7f466551U,\n  0x049d5eeaU, 0x5d018c35U, 0x73fa8774U, 0x2efb0b41U,\n  0x5ab3671dU, 0x5292dbd2U, 0x33e91056U, 0x136dd647U,\n  0x8c9ad761U, 0x7a37a10cU, 0x8e59f814U, 0x89eb133cU,\n  0xeecea927U, 0x35b761c9U, 0xede11ce5U, 0x3c7a47b1U,\n  0x599cd2dfU, 0x3f55f273U, 0x791814ceU, 0xbf73c737U,\n  0xea53f7cdU, 0x5b5ffdaaU, 0x14df3d6fU, 0x867844dbU,\n  0x81caaff3U, 0x3eb968c4U, 0x2c382434U, 0x5fc2a340U,\n  0x72161dc3U, 0x0cbce225U, 0x8b283c49U, 0x41ff0d95U,\n  0x7139a801U, 0xde080cb3U, 0x9cd8b4e4U, 0x906456c1U,\n  0x617bcb84U, 0x70d532b6U, 0x74486c5cU, 0x42d0b857U,\n};\n\nconst DWORD Td2[256] =\n{\n  0xa75051f4U, 0x65537e41U, 0xa4c31a17U, 0x5e963a27U,\n  0x6bcb3babU, 0x45f11f9dU, 0x58abacfaU, 0x03934be3U,\n  0xfa552030U, 0x6df6ad76U, 0x769188ccU, 0x4c25f502U,\n  0xd7fc4fe5U, 0xcbd7c52aU, 0x44802635U, 0xa38fb562U,\n  0x5a49deb1U, 0x1b6725baU, 0x0e9845eaU, 0xc0e15dfeU,\n  0x7502c32fU, 0xf012814cU, 0x97a38d46U, 0xf9c66bd3U,\n  0x5fe7038fU, 0x9c951592U, 0x7aebbf6dU, 0x59da9552U,\n  0x832dd4beU, 0x21d35874U, 0x692949e0U, 0xc8448ec9U,\n  0x896a75c2U, 0x7978f48eU, 0x3e6b9958U, 0x71dd27b9U,\n  0x4fb6bee1U, 0xad17f088U, 0xac66c920U, 0x3ab47dceU,\n  0x4a1863dfU, 0x3182e51aU, 0x33609751U, 0x7f456253U,\n  0x77e0b164U, 0xae84bb6bU, 0xa01cfe81U, 0x2b94f908U,\n  0x68587048U, 0xfd198f45U, 0x6c8794deU, 0xf8b7527bU,\n  0xd323ab73U, 0x02e2724bU, 0x8f57e31fU, 0xab2a6655U,\n  0x2807b2ebU, 0xc2032fb5U, 0x7b9a86c5U, 0x08a5d337U,\n  0x87f23028U, 0xa5b223bfU, 0x6aba0203U, 0x825ced16U,\n  0x1c2b8acfU, 0xb492a779U, 0xf2f0f307U, 0xe2a14e69U,\n  0xf4cd65daU, 0xbed50605U, 0x621fd134U, 0xfe8ac4a6U,\n  0x539d342eU, 0x55a0a2f3U, 0xe132058aU, 0xeb75a4f6U,\n  0xec390b83U, 0xefaa4060U, 0x9f065e71U, 0x1051bd6eU,\n  0x8af93e21U, 0x063d96ddU, 0x05aedd3eU, 0xbd464de6U,\n  0x8db59154U, 0x5d0571c4U, 0xd46f0406U, 0x15ff6050U,\n  0xfb241998U, 0xe997d6bdU, 0x43cc8940U, 0x9e7767d9U,\n  0x42bdb0e8U, 0x8b880789U, 0x5b38e719U, 0xeedb79c8U,\n  0x0a47a17cU, 0x0fe97c42U, 0x1ec9f884U, 0x00000000U,\n  0x86830980U, 0xed48322bU, 0x70ac1e11U, 0x724e6c5aU,\n  0xfffbfd0eU, 0x38560f85U, 0xd51e3daeU, 0x3927362dU,\n  0xd9640a0fU, 0xa621685cU, 0x54d19b5bU, 0x2e3a2436U,\n  0x67b10c0aU, 0xe70f9357U, 0x96d2b4eeU, 0x919e1b9bU,\n  0xc54f80c0U, 0x20a261dcU, 0x4b695a77U, 0x1a161c12U,\n  0xba0ae293U, 0x2ae5c0a0U, 0xe0433c22U, 0x171d121bU,\n  0x0d0b0e09U, 0xc7adf28bU, 0xa8b92db6U, 0xa9c8141eU,\n  0x198557f1U, 0x074caf75U, 0xddbbee99U, 0x60fda37fU,\n  0x269ff701U, 0xf5bc5c72U, 0x3bc54466U, 0x7e345bfbU,\n  0x29768b43U, 0xc6dccb23U, 0xfc68b6edU, 0xf163b8e4U,\n  0xdccad731U, 0x85104263U, 0x22401397U, 0x112084c6U,\n  0x247d854aU, 0x3df8d2bbU, 0x3211aef9U, 0xa16dc729U,\n  0x2f4b1d9eU, 0x30f3dcb2U, 0x52ec0d86U, 0xe3d077c1U,\n  0x166c2bb3U, 0xb999a970U, 0x48fa1194U, 0x642247e9U,\n  0x8cc4a8fcU, 0x3f1aa0f0U, 0x2cd8567dU, 0x90ef2233U,\n  0x4ec78749U, 0xd1c1d938U, 0xa2fe8ccaU, 0x0b3698d4U,\n  0x81cfa6f5U, 0xde28a57aU, 0x8e26dab7U, 0xbfa43fadU,\n  0x9de42c3aU, 0x920d5078U, 0xcc9b6a5fU, 0x4662547eU,\n  0x13c2f68dU, 0xb8e890d8U, 0xf75e2e39U, 0xaff582c3U,\n  0x80be9f5dU, 0x937c69d0U, 0x2da96fd5U, 0x12b3cf25U,\n  0x993bc8acU, 0x7da71018U, 0x636ee89cU, 0xbb7bdb3bU,\n  0x7809cd26U, 0x18f46e59U, 0xb701ec9aU, 0x9aa8834fU,\n  0x6e65e695U, 0xe67eaaffU, 0xcf0821bcU, 0xe8e6ef15U,\n  0x9bd9bae7U, 0x36ce4a6fU, 0x09d4ea9fU, 0x7cd629b0U,\n  0xb2af31a4U, 0x23312a3fU, 0x9430c6a5U, 0x66c035a2U,\n  0xbc37744eU, 0xcaa6fc82U, 0xd0b0e090U, 0xd81533a7U,\n  0x984af104U, 0xdaf741ecU, 0x500e7fcdU, 0xf62f1791U,\n  0xd68d764dU, 0xb04d43efU, 0x4d54ccaaU, 0x04dfe496U,\n  0xb5e39ed1U, 0x881b4c6aU, 0x1fb8c12cU, 0x517f4665U,\n  0xea049d5eU, 0x355d018cU, 0x7473fa87U, 0x412efb0bU,\n  0x1d5ab367U, 0xd25292dbU, 0x5633e910U, 0x47136dd6U,\n  0x618c9ad7U, 0x0c7a37a1U, 0x148e59f8U, 0x3c89eb13U,\n  0x27eecea9U, 0xc935b761U, 0xe5ede11cU, 0xb13c7a47U,\n  0xdf599cd2U, 0x733f55f2U, 0xce791814U, 0x37bf73c7U,\n  0xcdea53f7U, 0xaa5b5ffdU, 0x6f14df3dU, 0xdb867844U,\n  0xf381caafU, 0xc43eb968U, 0x342c3824U, 0x405fc2a3U,\n  0xc372161dU, 0x250cbce2U, 0x498b283cU, 0x9541ff0dU,\n  0x017139a8U, 0xb3de080cU, 0xe49cd8b4U, 0xc1906456U,\n  0x84617bcbU, 0xb670d532U, 0x5c74486cU, 0x5742d0b8U,\n};\n\nconst DWORD Td3[256] =\n{\n  0xf4a75051U, 0x4165537eU, 0x17a4c31aU, 0x275e963aU,\n  0xab6bcb3bU, 0x9d45f11fU, 0xfa58abacU, 0xe303934bU,\n  0x30fa5520U, 0x766df6adU, 0xcc769188U, 0x024c25f5U,\n  0xe5d7fc4fU, 0x2acbd7c5U, 0x35448026U, 0x62a38fb5U,\n  0xb15a49deU, 0xba1b6725U, 0xea0e9845U, 0xfec0e15dU,\n  0x2f7502c3U, 0x4cf01281U, 0x4697a38dU, 0xd3f9c66bU,\n  0x8f5fe703U, 0x929c9515U, 0x6d7aebbfU, 0x5259da95U,\n  0xbe832dd4U, 0x7421d358U, 0xe0692949U, 0xc9c8448eU,\n  0xc2896a75U, 0x8e7978f4U, 0x583e6b99U, 0xb971dd27U,\n  0xe14fb6beU, 0x88ad17f0U, 0x20ac66c9U, 0xce3ab47dU,\n  0xdf4a1863U, 0x1a3182e5U, 0x51336097U, 0x537f4562U,\n  0x6477e0b1U, 0x6bae84bbU, 0x81a01cfeU, 0x082b94f9U,\n  0x48685870U, 0x45fd198fU, 0xde6c8794U, 0x7bf8b752U,\n  0x73d323abU, 0x4b02e272U, 0x1f8f57e3U, 0x55ab2a66U,\n  0xeb2807b2U, 0xb5c2032fU, 0xc57b9a86U, 0x3708a5d3U,\n  0x2887f230U, 0xbfa5b223U, 0x036aba02U, 0x16825cedU,\n  0xcf1c2b8aU, 0x79b492a7U, 0x07f2f0f3U, 0x69e2a14eU,\n  0xdaf4cd65U, 0x05bed506U, 0x34621fd1U, 0xa6fe8ac4U,\n  0x2e539d34U, 0xf355a0a2U, 0x8ae13205U, 0xf6eb75a4U,\n  0x83ec390bU, 0x60efaa40U, 0x719f065eU, 0x6e1051bdU,\n  0x218af93eU, 0xdd063d96U, 0x3e05aeddU, 0xe6bd464dU,\n  0x548db591U, 0xc45d0571U, 0x06d46f04U, 0x5015ff60U,\n  0x98fb2419U, 0xbde997d6U, 0x4043cc89U, 0xd99e7767U,\n  0xe842bdb0U, 0x898b8807U, 0x195b38e7U, 0xc8eedb79U,\n  0x7c0a47a1U, 0x420fe97cU, 0x841ec9f8U, 0x00000000U,\n  0x80868309U, 0x2bed4832U, 0x1170ac1eU, 0x5a724e6cU,\n  0x0efffbfdU, 0x8538560fU, 0xaed51e3dU, 0x2d392736U,\n  0x0fd9640aU, 0x5ca62168U, 0x5b54d19bU, 0x362e3a24U,\n  0x0a67b10cU, 0x57e70f93U, 0xee96d2b4U, 0x9b919e1bU,\n  0xc0c54f80U, 0xdc20a261U, 0x774b695aU, 0x121a161cU,\n  0x93ba0ae2U, 0xa02ae5c0U, 0x22e0433cU, 0x1b171d12U,\n  0x090d0b0eU, 0x8bc7adf2U, 0xb6a8b92dU, 0x1ea9c814U,\n  0xf1198557U, 0x75074cafU, 0x99ddbbeeU, 0x7f60fda3U,\n  0x01269ff7U, 0x72f5bc5cU, 0x663bc544U, 0xfb7e345bU,\n  0x4329768bU, 0x23c6dccbU, 0xedfc68b6U, 0xe4f163b8U,\n  0x31dccad7U, 0x63851042U, 0x97224013U, 0xc6112084U,\n  0x4a247d85U, 0xbb3df8d2U, 0xf93211aeU, 0x29a16dc7U,\n  0x9e2f4b1dU, 0xb230f3dcU, 0x8652ec0dU, 0xc1e3d077U,\n  0xb3166c2bU, 0x70b999a9U, 0x9448fa11U, 0xe9642247U,\n  0xfc8cc4a8U, 0xf03f1aa0U, 0x7d2cd856U, 0x3390ef22U,\n  0x494ec787U, 0x38d1c1d9U, 0xcaa2fe8cU, 0xd40b3698U,\n  0xf581cfa6U, 0x7ade28a5U, 0xb78e26daU, 0xadbfa43fU,\n  0x3a9de42cU, 0x78920d50U, 0x5fcc9b6aU, 0x7e466254U,\n  0x8d13c2f6U, 0xd8b8e890U, 0x39f75e2eU, 0xc3aff582U,\n  0x5d80be9fU, 0xd0937c69U, 0xd52da96fU, 0x2512b3cfU,\n  0xac993bc8U, 0x187da710U, 0x9c636ee8U, 0x3bbb7bdbU,\n  0x267809cdU, 0x5918f46eU, 0x9ab701ecU, 0x4f9aa883U,\n  0x956e65e6U, 0xffe67eaaU, 0xbccf0821U, 0x15e8e6efU,\n  0xe79bd9baU, 0x6f36ce4aU, 0x9f09d4eaU, 0xb07cd629U,\n  0xa4b2af31U, 0x3f23312aU, 0xa59430c6U, 0xa266c035U,\n  0x4ebc3774U, 0x82caa6fcU, 0x90d0b0e0U, 0xa7d81533U,\n  0x04984af1U, 0xecdaf741U, 0xcd500e7fU, 0x91f62f17U,\n  0x4dd68d76U, 0xefb04d43U, 0xaa4d54ccU, 0x9604dfe4U,\n  0xd1b5e39eU, 0x6a881b4cU, 0x2c1fb8c1U, 0x65517f46U,\n  0x5eea049dU, 0x8c355d01U, 0x877473faU, 0x0b412efbU,\n  0x671d5ab3U, 0xdbd25292U, 0x105633e9U, 0xd647136dU,\n  0xd7618c9aU, 0xa10c7a37U, 0xf8148e59U, 0x133c89ebU,\n  0xa927eeceU, 0x61c935b7U, 0x1ce5ede1U, 0x47b13c7aU,\n  0xd2df599cU, 0xf2733f55U, 0x14ce7918U, 0xc737bf73U,\n  0xf7cdea53U, 0xfdaa5b5fU, 0x3d6f14dfU, 0x44db8678U,\n  0xaff381caU, 0x68c43eb9U, 0x24342c38U, 0xa3405fc2U,\n  0x1dc37216U, 0xe2250cbcU, 0x3c498b28U, 0x0d9541ffU,\n  0xa8017139U, 0x0cb3de08U, 0xb4e49cd8U, 0x56c19064U,\n  0xcb84617bU, 0x32b670d5U, 0x6c5c7448U, 0xb85742d0U,\n};\n\nconst DWORD Td4[256] =\n{\n  0x52525252U, 0x09090909U, 0x6a6a6a6aU, 0xd5d5d5d5U,\n  0x30303030U, 0x36363636U, 0xa5a5a5a5U, 0x38383838U,\n  0xbfbfbfbfU, 0x40404040U, 0xa3a3a3a3U, 0x9e9e9e9eU,\n  0x81818181U, 0xf3f3f3f3U, 0xd7d7d7d7U, 0xfbfbfbfbU,\n  0x7c7c7c7cU, 0xe3e3e3e3U, 0x39393939U, 0x82828282U,\n  0x9b9b9b9bU, 0x2f2f2f2fU, 0xffffffffU, 0x87878787U,\n  0x34343434U, 0x8e8e8e8eU, 0x43434343U, 0x44444444U,\n  0xc4c4c4c4U, 0xdedededeU, 0xe9e9e9e9U, 0xcbcbcbcbU,\n  0x54545454U, 0x7b7b7b7bU, 0x94949494U, 0x32323232U,\n  0xa6a6a6a6U, 0xc2c2c2c2U, 0x23232323U, 0x3d3d3d3dU,\n  0xeeeeeeeeU, 0x4c4c4c4cU, 0x95959595U, 0x0b0b0b0bU,\n  0x42424242U, 0xfafafafaU, 0xc3c3c3c3U, 0x4e4e4e4eU,\n  0x08080808U, 0x2e2e2e2eU, 0xa1a1a1a1U, 0x66666666U,\n  0x28282828U, 0xd9d9d9d9U, 0x24242424U, 0xb2b2b2b2U,\n  0x76767676U, 0x5b5b5b5bU, 0xa2a2a2a2U, 0x49494949U,\n  0x6d6d6d6dU, 0x8b8b8b8bU, 0xd1d1d1d1U, 0x25252525U,\n  0x72727272U, 0xf8f8f8f8U, 0xf6f6f6f6U, 0x64646464U,\n  0x86868686U, 0x68686868U, 0x98989898U, 0x16161616U,\n  0xd4d4d4d4U, 0xa4a4a4a4U, 0x5c5c5c5cU, 0xccccccccU,\n  0x5d5d5d5dU, 0x65656565U, 0xb6b6b6b6U, 0x92929292U,\n  0x6c6c6c6cU, 0x70707070U, 0x48484848U, 0x50505050U,\n  0xfdfdfdfdU, 0xededededU, 0xb9b9b9b9U, 0xdadadadaU,\n  0x5e5e5e5eU, 0x15151515U, 0x46464646U, 0x57575757U,\n  0xa7a7a7a7U, 0x8d8d8d8dU, 0x9d9d9d9dU, 0x84848484U,\n  0x90909090U, 0xd8d8d8d8U, 0xababababU, 0x00000000U,\n  0x8c8c8c8cU, 0xbcbcbcbcU, 0xd3d3d3d3U, 0x0a0a0a0aU,\n  0xf7f7f7f7U, 0xe4e4e4e4U, 0x58585858U, 0x05050505U,\n  0xb8b8b8b8U, 0xb3b3b3b3U, 0x45454545U, 0x06060606U,\n  0xd0d0d0d0U, 0x2c2c2c2cU, 0x1e1e1e1eU, 0x8f8f8f8fU,\n  0xcacacacaU, 0x3f3f3f3fU, 0x0f0f0f0fU, 0x02020202U,\n  0xc1c1c1c1U, 0xafafafafU, 0xbdbdbdbdU, 0x03030303U,\n  0x01010101U, 0x13131313U, 0x8a8a8a8aU, 0x6b6b6b6bU,\n  0x3a3a3a3aU, 0x91919191U, 0x11111111U, 0x41414141U,\n  0x4f4f4f4fU, 0x67676767U, 0xdcdcdcdcU, 0xeaeaeaeaU,\n  0x97979797U, 0xf2f2f2f2U, 0xcfcfcfcfU, 0xcecececeU,\n  0xf0f0f0f0U, 0xb4b4b4b4U, 0xe6e6e6e6U, 0x73737373U,\n  0x96969696U, 0xacacacacU, 0x74747474U, 0x22222222U,\n  0xe7e7e7e7U, 0xadadadadU, 0x35353535U, 0x85858585U,\n  0xe2e2e2e2U, 0xf9f9f9f9U, 0x37373737U, 0xe8e8e8e8U,\n  0x1c1c1c1cU, 0x75757575U, 0xdfdfdfdfU, 0x6e6e6e6eU,\n  0x47474747U, 0xf1f1f1f1U, 0x1a1a1a1aU, 0x71717171U,\n  0x1d1d1d1dU, 0x29292929U, 0xc5c5c5c5U, 0x89898989U,\n  0x6f6f6f6fU, 0xb7b7b7b7U, 0x62626262U, 0x0e0e0e0eU,\n  0xaaaaaaaaU, 0x18181818U, 0xbebebebeU, 0x1b1b1b1bU,\n  0xfcfcfcfcU, 0x56565656U, 0x3e3e3e3eU, 0x4b4b4b4bU,\n  0xc6c6c6c6U, 0xd2d2d2d2U, 0x79797979U, 0x20202020U,\n  0x9a9a9a9aU, 0xdbdbdbdbU, 0xc0c0c0c0U, 0xfefefefeU,\n  0x78787878U, 0xcdcdcdcdU, 0x5a5a5a5aU, 0xf4f4f4f4U,\n  0x1f1f1f1fU, 0xddddddddU, 0xa8a8a8a8U, 0x33333333U,\n  0x88888888U, 0x07070707U, 0xc7c7c7c7U, 0x31313131U,\n  0xb1b1b1b1U, 0x12121212U, 0x10101010U, 0x59595959U,\n  0x27272727U, 0x80808080U, 0xececececU, 0x5f5f5f5fU,\n  0x60606060U, 0x51515151U, 0x7f7f7f7fU, 0xa9a9a9a9U,\n  0x19191919U, 0xb5b5b5b5U, 0x4a4a4a4aU, 0x0d0d0d0dU,\n  0x2d2d2d2dU, 0xe5e5e5e5U, 0x7a7a7a7aU, 0x9f9f9f9fU,\n  0x93939393U, 0xc9c9c9c9U, 0x9c9c9c9cU, 0xefefefefU,\n  0xa0a0a0a0U, 0xe0e0e0e0U, 0x3b3b3b3bU, 0x4d4d4d4dU,\n  0xaeaeaeaeU, 0x2a2a2a2aU, 0xf5f5f5f5U, 0xb0b0b0b0U,\n  0xc8c8c8c8U, 0xebebebebU, 0xbbbbbbbbU, 0x3c3c3c3cU,\n  0x83838383U, 0x53535353U, 0x99999999U, 0x61616161U,\n  0x17171717U, 0x2b2b2b2bU, 0x04040404U, 0x7e7e7e7eU,\n  0xbabababaU, 0x77777777U, 0xd6d6d6d6U, 0x26262626U,\n  0xe1e1e1e1U, 0x69696969U, 0x14141414U, 0x63636363U,\n  0x55555555U, 0x21212121U, 0x0c0c0c0cU, 0x7d7d7d7dU,\n};\n\nconst DWORD rcon[] =\n{\n  0x01000000, 0x02000000, 0x04000000, 0x08000000,\n  0x10000000, 0x20000000, 0x40000000, 0x80000000,\n  0x1B000000, 0x36000000,\n  /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */\n};\n\n#define GETDWORD(plaintext) (((DWORD)(plaintext)[0] << 24) ^ \\\n                    ((DWORD)(plaintext)[1] << 16) ^ \\\n                    ((DWORD)(plaintext)[2] <<  8) ^ \\\n                    ((DWORD)(plaintext)[3]))\n\n#define PUTDWORD(ciphertext, st) { (ciphertext)[0] = (BYTE)((st) >> 24); \\\n                         (ciphertext)[1] = (BYTE)((st) >> 16); \\\n                         (ciphertext)[2] = (BYTE)((st) >>  8); \\\n                         (ciphertext)[3] = (BYTE)(st); }\n\n/**\n * Expand the cipher key into the encryption key schedule.\n *\n * @return the number of rounds for the given cipher key size.\n */\nint Rijndael_set_key_encrypt(DWORD *rk,const BYTE *key,const int keybits)\n{\n  int i = 0;\n  DWORD temp;\n\n  rk[0] = GETDWORD(key     );\n  rk[1] = GETDWORD(key +  4);\n  rk[2] = GETDWORD(key +  8);\n  rk[3] = GETDWORD(key + 12);\n  if (keybits == 128)\n  {\n    for (;;)\n    {\n      temp  = rk[3];\n      rk[4] = rk[0] ^\n        (Te4[(temp >> 16) & 0xff] & 0xff000000) ^\n        (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^\n        (Te4[(temp      ) & 0xff] & 0x0000ff00) ^\n        (Te4[(temp >> 24)       ] & 0x000000ff) ^\n        rcon[i];\n      rk[5] = rk[1] ^ rk[4];\n      rk[6] = rk[2] ^ rk[5];\n      rk[7] = rk[3] ^ rk[6];\n      if (++i == 10)\n        return 10;\n      rk += 4;\n    }\n  }\n  rk[4] = GETDWORD(key + 16);\n  rk[5] = GETDWORD(key + 20);\n  if (keybits == 192)\n  {\n    for (;;)\n    {\n      temp = rk[ 5];\n      rk[ 6] = rk[ 0] ^\n        (Te4[(temp >> 16) & 0xff] & 0xff000000) ^\n        (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^\n        (Te4[(temp      ) & 0xff] & 0x0000ff00) ^\n        (Te4[(temp >> 24)       ] & 0x000000ff) ^\n        rcon[i];\n      rk[ 7] = rk[ 1] ^ rk[ 6];\n      rk[ 8] = rk[ 2] ^ rk[ 7];\n      rk[ 9] = rk[ 3] ^ rk[ 8];\n      if (++i == 8)\n        return 12;\n      rk[10] = rk[ 4] ^ rk[ 9];\n      rk[11] = rk[ 5] ^ rk[10];\n      rk += 6;\n    }\n  }\n  rk[6] = GETDWORD(key + 24);\n  rk[7] = GETDWORD(key + 28);\n  if (keybits == 256)\n  {\n    for (;;)\n    {\n      temp = rk[ 7];\n      rk[ 8] = rk[ 0] ^\n        (Te4[(temp >> 16) & 0xff] & 0xff000000) ^\n        (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^\n        (Te4[(temp      ) & 0xff] & 0x0000ff00) ^\n        (Te4[(temp >> 24)       ] & 0x000000ff) ^\n        rcon[i];\n      rk[ 9] = rk[ 1] ^ rk[ 8];\n      rk[10] = rk[ 2] ^ rk[ 9];\n      rk[11] = rk[ 3] ^ rk[10];\n      if (++i == 7)\n        return 14;\n      temp = rk[11];\n      rk[12] = rk[ 4] ^\n        (Te4[(temp >> 24)       ] & 0xff000000) ^\n        (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(temp >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(temp      ) & 0xff] & 0x000000ff);\n      rk[13] = rk[ 5] ^ rk[12];\n      rk[14] = rk[ 6] ^ rk[13];\n      rk[15] = rk[ 7] ^ rk[14];\n      rk += 8;\n    }\n  }\n  return 0;\n}\n\n/**\n * Expand the cipher key into the decryption key schedule.\n *\n * @return the number of rounds for the given cipher key size.\n */\nint Rijndael_set_key_decrypt(DWORD *rk,const BYTE *key,const int keybits)\n{\n  int nrounds, i, j;\n  DWORD temp;\n\n  /* expand the cipher key: */\n  nrounds = Rijndael_set_key_encrypt(rk, key, keybits);\n  /* invert the order of the round keys: */\n  for (i = 0, j = 4*nrounds; i < j; i += 4, j -= 4)\n  {\n    temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;\n    temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\n    temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\n    temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\n  }\n  /* apply the inverse MixColumn transform to all round keys but the first and the last: */\n  for (i = 1; i < nrounds; i++)\n  {\n    rk += 4;\n    rk[0] =\n      Td0[Te4[(rk[0] >> 24)       ] & 0xff] ^\n      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^\n      Td2[Te4[(rk[0] >>  8) & 0xff] & 0xff] ^\n      Td3[Te4[(rk[0]      ) & 0xff] & 0xff];\n    rk[1] =\n      Td0[Te4[(rk[1] >> 24)       ] & 0xff] ^\n      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^\n      Td2[Te4[(rk[1] >>  8) & 0xff] & 0xff] ^\n      Td3[Te4[(rk[1]      ) & 0xff] & 0xff];\n    rk[2] =\n      Td0[Te4[(rk[2] >> 24)       ] & 0xff] ^\n      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^\n      Td2[Te4[(rk[2] >>  8) & 0xff] & 0xff] ^\n      Td3[Te4[(rk[2]      ) & 0xff] & 0xff];\n    rk[3] =\n      Td0[Te4[(rk[3] >> 24)       ] & 0xff] ^\n      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^\n      Td2[Te4[(rk[3] >>  8) & 0xff] & 0xff] ^\n      Td3[Te4[(rk[3]      ) & 0xff] & 0xff];\n  }\n  return nrounds;\n}\n\nvoid Rijndael_encrypt(const DWORD *rk,const int nrounds,const BYTE *plaintext,BYTE *ciphertext)\n{\n  DWORD s0, s1, s2, s3, t0, t1, t2, t3;\n  #ifndef FULL_UNROLL\n    int r;\n  #endif /* ?FULL_UNROLL */\n  /*\n   * map byte array block to cipher state\n   * and add initial round key:\n  */\n  s0 = GETDWORD(plaintext     ) ^ rk[0];\n  s1 = GETDWORD(plaintext +  4) ^ rk[1];\n  s2 = GETDWORD(plaintext +  8) ^ rk[2];\n  s3 = GETDWORD(plaintext + 12) ^ rk[3];\n  #ifdef FULL_UNROLL\n    /* round 1: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 4];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 5];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 6];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 7];\n    /* round 2: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 8];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 9];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];\n    /* round 3: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[12];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[13];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[14];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[15];\n    /* round 4: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[16];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[17];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[18];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[19];\n    /* round 5: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[20];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[21];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[22];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[23];\n    /* round 6: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[24];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[25];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[26];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[27];\n    /* round 7: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[28];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[29];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[30];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[31];\n    /* round 8: */\n    s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[32];\n    s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[33];\n    s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[34];\n    s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[35];\n    /* round 9: */\n    t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[36];\n    t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[37];\n    t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[38];\n    t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[39];\n    if (nrounds > 10)\n    {\n      /* round 10: */\n      s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[40];\n      s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[41];\n      s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[42];\n      s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[43];\n      /* round 11: */\n      t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[44];\n      t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[45];\n      t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[46];\n      t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[47];\n      if (nrounds > 12)\n      {\n        /* round 12: */\n        s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[48];\n        s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[49];\n        s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[50];\n        s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[51];\n        /* round 13: */\n        t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[52];\n        t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[53];\n        t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[54];\n        t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[55];\n      }\n    }\n    rk += nrounds << 2;\n  #else  /* !FULL_UNROLL */\n    /*\n    * nrounds - 1 full rounds:\n    */\n    r = nrounds >> 1;\n    for (;;)\n    {\n      t0 =\n        Te0[(s0 >> 24)       ] ^\n        Te1[(s1 >> 16) & 0xff] ^\n        Te2[(s2 >>  8) & 0xff] ^\n        Te3[(s3      ) & 0xff] ^\n        rk[4];\n      t1 =\n        Te0[(s1 >> 24)       ] ^\n        Te1[(s2 >> 16) & 0xff] ^\n        Te2[(s3 >>  8) & 0xff] ^\n        Te3[(s0      ) & 0xff] ^\n        rk[5];\n      t2 =\n        Te0[(s2 >> 24)       ] ^\n        Te1[(s3 >> 16) & 0xff] ^\n        Te2[(s0 >>  8) & 0xff] ^\n        Te3[(s1      ) & 0xff] ^\n        rk[6];\n      t3 =\n        Te0[(s3 >> 24)       ] ^\n        Te1[(s0 >> 16) & 0xff] ^\n        Te2[(s1 >>  8) & 0xff] ^\n        Te3[(s2      ) & 0xff] ^\n        rk[7];\n        rk += 8;\n        if (--r == 0)\n            break;\n      s0 =\n        Te0[(t0 >> 24)       ] ^\n        Te1[(t1 >> 16) & 0xff] ^\n        Te2[(t2 >>  8) & 0xff] ^\n        Te3[(t3      ) & 0xff] ^\n        rk[0];\n      s1 =\n        Te0[(t1 >> 24)       ] ^\n        Te1[(t2 >> 16) & 0xff] ^\n        Te2[(t3 >>  8) & 0xff] ^\n        Te3[(t0      ) & 0xff] ^\n        rk[1];\n      s2 =\n        Te0[(t2 >> 24)       ] ^\n        Te1[(t3 >> 16) & 0xff] ^\n        Te2[(t0 >>  8) & 0xff] ^\n        Te3[(t1      ) & 0xff] ^\n        rk[2];\n      s3 =\n        Te0[(t3 >> 24)       ] ^\n        Te1[(t0 >> 16) & 0xff] ^\n        Te2[(t1 >>  8) & 0xff] ^\n        Te3[(t2      ) & 0xff] ^\n        rk[3];\n     }\n #endif /* ?FULL_UNROLL */\n  /*\n  * apply last round and\n  * map cipher state to byte array block:\n  */\n  s0 =\n    (Te4[(t0 >> 24)       ] & 0xff000000) ^\n    (Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n    (Te4[(t2 >>  8) & 0xff] & 0x0000ff00) ^\n    (Te4[(t3      ) & 0xff] & 0x000000ff) ^\n    rk[0];\n  PUTDWORD(ciphertext     , s0);\n  s1 =\n    (Te4[(t1 >> 24)       ] & 0xff000000) ^\n    (Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n    (Te4[(t3 >>  8) & 0xff] & 0x0000ff00) ^\n    (Te4[(t0      ) & 0xff] & 0x000000ff) ^\n    rk[1];\n  PUTDWORD(ciphertext +  4, s1);\n  s2 =\n    (Te4[(t2 >> 24)       ] & 0xff000000) ^\n    (Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n    (Te4[(t0 >>  8) & 0xff] & 0x0000ff00) ^\n    (Te4[(t1      ) & 0xff] & 0x000000ff) ^\n    rk[2];\n  PUTDWORD(ciphertext +  8, s2);\n  s3 =\n    (Te4[(t3 >> 24)       ] & 0xff000000) ^\n    (Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n    (Te4[(t1 >>  8) & 0xff] & 0x0000ff00) ^\n    (Te4[(t2      ) & 0xff] & 0x000000ff) ^\n    rk[3];\n  PUTDWORD(ciphertext + 12, s3);\n}\n\nvoid Rijndael_decrypt(const DWORD *rk,const int nrounds,const BYTE *ciphertext,BYTE *plaintext)\n{\n  DWORD s0, s1, s2, s3, t0, t1, t2, t3;\n  #ifndef FULL_UNROLL\n    int r;\n  #endif /* ?FULL_UNROLL */\n\n  /*\n  * map byte array block to cipher state\n  * and add initial round key:\n  */\n    s0 = GETDWORD(ciphertext     ) ^ rk[0];\n    s1 = GETDWORD(ciphertext +  4) ^ rk[1];\n    s2 = GETDWORD(ciphertext +  8) ^ rk[2];\n    s3 = GETDWORD(ciphertext + 12) ^ rk[3];\n  #ifdef FULL_UNROLL\n    /* round 1: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[ 4];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[ 5];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[ 6];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[ 7];\n    /* round 2: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[ 8];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[ 9];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[10];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[11];\n    /* round 3: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[12];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[13];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[14];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[15];\n    /* round 4: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[16];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[17];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[18];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[19];\n    /* round 5: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[20];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[21];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[22];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[23];\n    /* round 6: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[24];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[25];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[26];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[27];\n    /* round 7: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[28];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[29];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[30];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[31];\n    /* round 8: */\n    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[32];\n    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[33];\n    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[34];\n    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[35];\n    /* round 9: */\n    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[36];\n    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[37];\n    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[38];\n    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[39];\n    if (nrounds > 10)\n    {\n      /* round 10: */\n      s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[40];\n      s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[41];\n      s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[42];\n      s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[43];\n      /* round 11: */\n      t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[44];\n      t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[45];\n      t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[46];\n      t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[47];\n      if (nrounds > 12)\n      {\n        /* round 12: */\n        s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[48];\n        s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[49];\n        s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[50];\n        s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[51];\n        /* round 13: */\n        t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[52];\n        t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[53];\n        t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[54];\n        t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[55];\n      }\n    }\n    rk += nrounds << 2;\n  #else  /* !FULL_UNROLL */\n    /*\n    * nrounds - 1 full rounds:\n    */\n    r = nrounds >> 1;\n    for (;;)\n    {\n      t0 =\n        Td0[(s0 >> 24)       ] ^\n        Td1[(s3 >> 16) & 0xff] ^\n        Td2[(s2 >>  8) & 0xff] ^\n        Td3[(s1      ) & 0xff] ^\n        rk[4];\n      t1 =\n        Td0[(s1 >> 24)       ] ^\n        Td1[(s0 >> 16) & 0xff] ^\n        Td2[(s3 >>  8) & 0xff] ^\n        Td3[(s2      ) & 0xff] ^\n        rk[5];\n      t2 =\n        Td0[(s2 >> 24)       ] ^\n        Td1[(s1 >> 16) & 0xff] ^\n        Td2[(s0 >>  8) & 0xff] ^\n        Td3[(s3      ) & 0xff] ^\n        rk[6];\n      t3 =\n        Td0[(s3 >> 24)       ] ^\n        Td1[(s2 >> 16) & 0xff] ^\n        Td2[(s1 >>  8) & 0xff] ^\n        Td3[(s0      ) & 0xff] ^\n        rk[7];\n      rk += 8;\n      if (--r == 0)\n          break;\n      s0 =\n        Td0[(t0 >> 24)       ] ^\n        Td1[(t3 >> 16) & 0xff] ^\n        Td2[(t2 >>  8) & 0xff] ^\n        Td3[(t1      ) & 0xff] ^\n        rk[0];\n      s1 =\n        Td0[(t1 >> 24)       ] ^\n        Td1[(t0 >> 16) & 0xff] ^\n        Td2[(t3 >>  8) & 0xff] ^\n        Td3[(t2      ) & 0xff] ^\n        rk[1];\n      s2 =\n        Td0[(t2 >> 24)       ] ^\n        Td1[(t1 >> 16) & 0xff] ^\n        Td2[(t0 >>  8) & 0xff] ^\n        Td3[(t3      ) & 0xff] ^\n        rk[2];\n      s3 =\n        Td0[(t3 >> 24)       ] ^\n        Td1[(t2 >> 16) & 0xff] ^\n        Td2[(t1 >>  8) & 0xff] ^\n        Td3[(t0      ) & 0xff] ^\n        rk[3];\n    }\n  #endif /* ?FULL_UNROLL */\n  /*\n  * apply last round and\n  * map cipher state to byte array block:\n  */\n  s0 =\n    (Td4[(t0 >> 24)       ] & 0xff000000) ^\n    (Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n    (Td4[(t2 >>  8) & 0xff] & 0x0000ff00) ^\n    (Td4[(t1      ) & 0xff] & 0x000000ff) ^\n    rk[0];\n  PUTDWORD(plaintext     , s0);\n  s1 =\n    (Td4[(t1 >> 24)       ] & 0xff000000) ^\n    (Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n    (Td4[(t3 >>  8) & 0xff] & 0x0000ff00) ^\n    (Td4[(t2      ) & 0xff] & 0x000000ff) ^\n    rk[1];\n  PUTDWORD(plaintext +  4, s1);\n  s2 =\n    (Td4[(t2 >> 24)       ] & 0xff000000) ^\n    (Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n    (Td4[(t0 >>  8) & 0xff] & 0x0000ff00) ^\n    (Td4[(t3      ) & 0xff] & 0x000000ff) ^\n    rk[2];\n  PUTDWORD(plaintext +  8, s2);\n  s3 =\n    (Td4[(t3 >> 24)       ] & 0xff000000) ^\n    (Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n    (Td4[(t1 >>  8) & 0xff] & 0x0000ff00) ^\n    (Td4[(t0      ) & 0xff] & 0x000000ff) ^\n    rk[3];\n  PUTDWORD(plaintext + 12, s3);\n}\n"
        },
        {
            "file_name": "Saferp.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"Saferp_data.h\"\n\n#define BLOCK_SWAP\n\n#  pragma intrinsic(_lrotr,_lrotl)\n\n#  define rotr(x,n) _lrotr(x,n)\n#  define rotl(x,n) _lrotl(x,n)\n\n#define bswap(x)    (rotl(x, 8) & 0x00ff00ff | rotr(x, 8) & 0xff00ff00)\n\n#define byte(x,n)   ((BYTE)((x) >> (8 * n)))\n\n#ifdef  BLOCK_SWAP\n#define BYTE_SWAP\n#define WORD_SWAP\n#endif\n\n#ifdef  BYTE_SWAP\n#define io_swap(x)  bswap(x)\n#else\n#define io_swap(x)  (x)\n#endif\n\n#ifdef  WORD_SWAP\n\n#define get_block(x)                            \\\n    ((DWORD *)(x))[0] = io_swap(in_blk[3]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_blk[2]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_blk[1]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_blk[0])\n\n#define put_block(x)                            \\\n    out_blk[3] = io_swap(((DWORD *)(x))[0]);    \\\n    out_blk[2] = io_swap(((DWORD *)(x))[1]);    \\\n    out_blk[1] = io_swap(((DWORD *)(x))[2]);    \\\n    out_blk[0] = io_swap(((DWORD *)(x))[3])\n\n#define get_key(x,len)                          \\\n    ((DWORD *)(x))[4] = ((DWORD *)(x))[5] =     \\\n    ((DWORD *)(x))[6] = ((DWORD *)(x))[7] = 0;  \\\n    switch((((len) + 63) / 64)) {               \\\n    case 2:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[0]);     \\\n    break;                                      \\\n    case 3:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[5]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[0]);     \\\n    break;                                      \\\n    case 4:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[7]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[6]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[5]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[6] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[7] = io_swap(in_key[0]);     \\\n    }\n\n#else\n\n#define get_block(x)                            \\\n    ((DWORD *)(x))[0] = io_swap(in_blk[0]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_blk[1]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_blk[2]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_blk[3])\n\n#define put_block(x)                            \\\n    out_blk[0] = io_swap(((DWORD *)(x))[0]);    \\\n    out_blk[1] = io_swap(((DWORD *)(x))[1]);    \\\n    out_blk[2] = io_swap(((DWORD *)(x))[2]);    \\\n    out_blk[3] = io_swap(((DWORD *)(x))[3])\n\n#define get_key(x,len)                          \\\n    ((DWORD *)(x))[4] = ((DWORD *)(x))[5] =     \\\n    ((DWORD *)(x))[6] = ((DWORD *)(x))[7] = 0;  \\\n    switch((((len) + 63) / 64)) {               \\\n    case 4:                                     \\\n    ((DWORD *)(x))[6] = io_swap(in_key[6]);     \\\n    ((DWORD *)(x))[7] = io_swap(in_key[7]);     \\\n    case 3:                                     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[5]);     \\\n    case 2:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[0]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[3]);     \\\n    }\n\n#endif\n\nconst BYTE  expf[256] =\n{     1,  45, 226, 147, 190,  69,  21, 174, 120,   3, 135, 164, 184,  56, 207,  63, \n      8, 103,   9, 148, 235,  38, 168, 107, 189,  24,  52,  27, 187, 191, 114, 247, \n     64,  53,  72, 156,  81,  47,  59,  85, 227, 192, 159, 216, 211, 243, 141, 177, \n    255, 167,  62, 220, 134, 119, 215, 166,  17, 251, 244, 186, 146, 145, 100, 131, \n    241,  51, 239, 218,  44, 181, 178,  43, 136, 209, 153, 203, 140, 132,  29,  20, \n    129, 151, 113, 202,  95, 163, 139,  87,  60, 130, 196,  82,  92,  28, 232, 160, \n      4, 180, 133,  74, 246,  19,  84, 182, 223,  12,  26, 142, 222, 224,  57, 252, \n     32, 155,  36,  78, 169, 152, 158, 171, 242,  96, 208, 108, 234, 250, 199, 217, \n      0, 212,  31, 110,  67, 188, 236,  83, 137, 254, 122,  93,  73, 201,  50, 194, \n    249, 154, 248, 109,  22, 219,  89, 150,  68, 233, 205, 230,  70,  66, 143,  10, \n    193, 204, 185, 101, 176, 210, 198, 172,  30,  65,  98,  41,  46,  14, 116,  80, \n      2,  90, 195,  37, 123, 138,  42,  91, 240,   6,  13,  71, 111, 112, 157, 126, \n     16, 206,  18,  39, 213,  76,  79, 214, 121,  48, 104,  54, 117, 125, 228, 237, \n    128, 106, 144,  55, 162,  94, 118, 170, 197, 127,  61, 175, 165, 229,  25,  97, \n    253,  77, 124, 183,  11, 238, 173,  75,  34, 245, 231, 115,  35,  33, 200,   5, \n    225, 102, 221, 179,  88, 105,  99,  86,  15, 161,  49, 149,  23,   7,  58,  40 \n};\n\nconst BYTE logf[512] = \n{\n    128,   0, 176,   9,  96, 239, 185, 253,  16,  18, 159, 228, 105, 186, 173, 248, \n    192,  56, 194, 101,  79,   6, 148, 252,  25, 222, 106,  27,  93,  78, 168, 130, \n    112, 237, 232, 236, 114, 179,  21, 195, 255, 171, 182,  71,  68,   1, 172,  37, \n    201, 250, 142,  65,  26,  33, 203, 211,  13, 110, 254,  38,  88, 218,  50,  15, \n     32, 169, 157, 132, 152,   5, 156, 187,  34, 140,  99, 231, 197, 225, 115, 198, \n    175,  36,  91, 135, 102,  39, 247,  87, 244, 150, 177, 183,  92, 139, 213,  84, \n    121, 223, 170, 246,  62, 163, 241,  17, 202, 245, 209,  23, 123, 147, 131, 188, \n    189,  82,  30, 235, 174, 204, 214,  53,   8, 200, 138, 180, 226, 205, 191, 217, \n    208,  80,  89,  63,  77,  98,  52,  10,  72, 136, 181,  86,  76,  46, 107, 158, \n    210,  61,  60,   3,  19, 251, 151,  81, 117,  74, 145, 113,  35, 190, 118,  42, \n     95, 249, 212,  85,  11, 220,  55,  49,  22, 116, 215, 119, 167, 230,   7, 219, \n    164,  47,  70, 243,  97,  69, 103, 227,  12, 162,  59,  28, 133,  24,   4,  29, \n     41, 160, 143, 178,  90, 216, 166, 126, 238, 141,  83,  75, 161, 154, 193,  14, \n    122,  73, 165,  44, 129, 196, 199,  54,  43, 127,  67, 149,  51, 242, 108, 104, \n    109, 240,   2,  40, 206, 221, 155, 234,  94, 153, 124,  20, 134, 207, 229,  66, \n    184,  64, 120,  45,  58, 233, 100,  31, 146, 144, 125,  57, 111, 224, 137,  48,\n\n    128,   0, 176,   9,  96, 239, 185, 253,  16,  18, 159, 228, 105, 186, 173, 248, \n    192,  56, 194, 101,  79,   6, 148, 252,  25, 222, 106,  27,  93,  78, 168, 130, \n    112, 237, 232, 236, 114, 179,  21, 195, 255, 171, 182,  71,  68,   1, 172,  37, \n    201, 250, 142,  65,  26,  33, 203, 211,  13, 110, 254,  38,  88, 218,  50,  15, \n     32, 169, 157, 132, 152,   5, 156, 187,  34, 140,  99, 231, 197, 225, 115, 198, \n    175,  36,  91, 135, 102,  39, 247,  87, 244, 150, 177, 183,  92, 139, 213,  84, \n    121, 223, 170, 246,  62, 163, 241,  17, 202, 245, 209,  23, 123, 147, 131, 188, \n    189,  82,  30, 235, 174, 204, 214,  53,   8, 200, 138, 180, 226, 205, 191, 217, \n    208,  80,  89,  63,  77,  98,  52,  10,  72, 136, 181,  86,  76,  46, 107, 158, \n    210,  61,  60,   3,  19, 251, 151,  81, 117,  74, 145, 113,  35, 190, 118,  42, \n     95, 249, 212,  85,  11, 220,  55,  49,  22, 116, 215, 119, 167, 230,   7, 219, \n    164,  47,  70, 243,  97,  69, 103, 227,  12, 162,  59,  28, 133,  24,   4,  29, \n     41, 160, 143, 178,  90, 216, 166, 126, 238, 141,  83,  75, 161, 154, 193,  14, \n    122,  73, 165,  44, 129, 196, 199,  54,  43, 127,  67, 149,  51, 242, 108, 104, \n    109, 240,   2,  40, 206, 221, 155, 234,  94, 153, 124,  20, 134, 207, 229,  66, \n    184,  64, 120,  45,  58, 233, 100,  31, 146, 144, 125,  57, 111, 224, 137,  48\n};\n\nvoid Saferp_set_key(SAFERP_DATA *pSpd,const DWORD *in_key,const DWORD key_len)\n{\n\tBYTE  by, lk[33];\n    DWORD  i, j, k, l, m;\n\n    get_key(lk, key_len);\n\n    pSpd->k_bytes = key_len / 8; lk[pSpd->k_bytes] = 0;\n\n    for(i = 0; i < pSpd->k_bytes; ++i)\n    {\n        lk[pSpd->k_bytes] ^= lk[i]; pSpd->l_key[i] = lk[i];\n    }\n\n    for(i = 0; i < pSpd->k_bytes; ++i)\n    {\n        for(j = 0; j <= pSpd->k_bytes; ++j)\n        {\n            by = lk[j]; lk[j] = by << 3 | by >> 5;\n        }\n\n        k = 17 * i + 35; l = 16 * i + 16; m = i + 1;\n\n        if(i < 16)\n        {\n            for(j = 0; j < 16; ++j)\n            {\n                pSpd->l_key[l + j] = lk[m] + expf[expf[(k + j) & 255]];\n\n                m = (m == pSpd->k_bytes ? 0 : m + 1);\n            }\n        }\n        else\n        {\n            for(j = 0; j < 16; ++j)\n            {\n                pSpd->l_key[l + j] = lk[m] + expf[(k + j) & 255];\n\n                m = (m == pSpd->k_bytes ? 0 : m + 1);\n            }\n        }\n    }\n}\n\nvoid do_fr(BYTE *x, BYTE *kp)\n{\n\tBYTE  t;\n\n    x[ 0] = expf[x[ 0] ^ kp[ 0]] + kp[16];\n    x[ 1] = logf[x[ 1] + kp[ 1]] ^ kp[17]; \n    x[ 2] = logf[x[ 2] + kp[ 2]] ^ kp[18]; \n    x[ 3] = expf[x[ 3] ^ kp[ 3]] + kp[19];\n\n    x[ 4] = expf[x[ 4] ^ kp[ 4]] + kp[20];\n    x[ 5] = logf[x[ 5] + kp[ 5]] ^ kp[21]; \n    x[ 6] = logf[x[ 6] + kp[ 6]] ^ kp[22]; \n    x[ 7] = expf[x[ 7] ^ kp[ 7]] + kp[23];\n \n    x[ 8] = expf[x[ 8] ^ kp[ 8]] + kp[24];\n    x[ 9] = logf[x[ 9] + kp[ 9]] ^ kp[25]; \n    x[10] = logf[x[10] + kp[10]] ^ kp[26]; \n    x[11] = expf[x[11] ^ kp[11]] + kp[27];\n\n    x[12] = expf[x[12] ^ kp[12]] + kp[28];\n    x[13] = logf[x[13] + kp[13]] ^ kp[29]; \n    x[14] = logf[x[14] + kp[14]] ^ kp[30]; \n    x[15] = expf[x[15] ^ kp[15]] + kp[31];\n\n    x[ 1] += x[ 0]; x[ 0] += x[ 1];\n    x[ 3] += x[ 2]; x[ 2] += x[ 3];\n    x[ 5] += x[ 4]; x[ 4] += x[ 5];\n    x[ 7] += x[ 6]; x[ 6] += x[ 7];\n    x[ 9] += x[ 8]; x[ 8] += x[ 9];\n    x[11] += x[10]; x[10] += x[11];\n    x[13] += x[12]; x[12] += x[13];\n    x[15] += x[14]; x[14] += x[15];\n\n    x[ 7] += x[ 0]; x[ 0] += x[ 7];\n    x[ 1] += x[ 2]; x[ 2] += x[ 1];\n    x[ 3] += x[ 4]; x[ 4] += x[ 3];\n    x[ 5] += x[ 6]; x[ 6] += x[ 5];\n    x[11] += x[ 8]; x[ 8] += x[11];\n    x[ 9] += x[10]; x[10] += x[ 9];\n    x[15] += x[12]; x[12] += x[15];\n    x[13] += x[14]; x[14] += x[13];\n\n    x[ 3] += x[ 0]; x[ 0] += x[ 3];\n    x[15] += x[ 2]; x[ 2] += x[15];\n    x[ 7] += x[ 4]; x[ 4] += x[ 7];\n    x[ 1] += x[ 6]; x[ 6] += x[ 1];\n    x[ 5] += x[ 8]; x[ 8] += x[ 5];\n    x[13] += x[10]; x[10] += x[13];\n    x[11] += x[12]; x[12] += x[11];\n    x[ 9] += x[14]; x[14] += x[ 9];\n\n    x[13] += x[ 0]; x[ 0] += x[13];\n    x[ 5] += x[ 2]; x[ 2] += x[ 5];\n    x[ 9] += x[ 4]; x[ 4] += x[ 9];\n    x[11] += x[ 6]; x[ 6] += x[11];\n    x[15] += x[ 8]; x[ 8] += x[15];\n    x[ 1] += x[10]; x[10] += x[ 1];\n    x[ 3] += x[12]; x[12] += x[ 3];\n    x[ 7] += x[14]; x[14] += x[ 7];\n\n    t = x[0]; x[0] = x[14]; x[14] = x[12]; x[12] = x[10]; x[10] = x[2]; \n    x[2] = x[8]; x[8] = x[4]; x[4] = t;\n\n    t = x[1]; x[1] = x[7]; x[7] = x[11]; x[11] = x[5]; x[5] = x[13]; x[13] = t; \n    \n    t = x[15]; x[15] = x[3]; x[3] = t;\n}\n\nvoid do_ir(BYTE *x, const BYTE *kp)\n{\n\tBYTE  t;\n\n    t = x[3]; x[3] = x[15]; x[15] = t; \n\n    t = x[13]; x[13] = x[5]; x[5] = x[11]; x[11] = x[7]; x[7] = x[1]; x[1] = t; \n\n    t = x[4]; x[4] = x[8]; x[8] = x[2]; x[2] = x[10]; \n    x[10] = x[12]; x[12] = x[14]; x[14] = x[0]; x[0] = t; \n\n    x[14] -= x[ 7]; x[ 7] -= x[14]; \n    x[12] -= x[ 3]; x[ 3] -= x[12];\n    x[10] -= x[ 1]; x[ 1] -= x[10];\n    x[ 8] -= x[15]; x[15] -= x[ 8];\n    x[ 6] -= x[11]; x[11] -= x[ 6]; \n    x[ 4] -= x[ 9]; x[ 9] -= x[ 4];\n    x[ 2] -= x[ 5]; x[ 5] -= x[ 2]; \n    x[ 0] -= x[13]; x[13] -= x[ 0]; \n\n    x[14] -= x[ 9]; x[ 9] -= x[14]; \n    x[12] -= x[11]; x[11] -= x[12]; \n    x[10] -= x[13]; x[13] -= x[10]; \n    x[ 8] -= x[ 5]; x[ 5] -= x[ 8]; \n    x[ 6] -= x[ 1]; x[ 1] -= x[ 6]; \n    x[ 4] -= x[ 7]; x[ 7] -= x[ 4]; \n    x[ 2] -= x[15]; x[15] -= x[ 2]; \n    x[ 0] -= x[ 3]; x[ 3] -= x[ 0]; \n\n    x[14] -= x[13]; x[13] -= x[14]; \n    x[12] -= x[15]; x[15] -= x[12]; \n    x[10] -= x[ 9]; x[ 9] -= x[10]; \n    x[ 8] -= x[11]; x[11] -= x[ 8];     \n    x[ 6] -= x[ 5]; x[ 5] -= x[ 6]; \n    x[ 4] -= x[ 3]; x[ 3] -= x[ 4]; \n    x[ 2] -= x[ 1]; x[ 1] -= x[ 2]; \n    x[ 0] -= x[ 7]; x[ 7] -= x[ 0]; \n\n    x[14] -= x[15]; x[15] -= x[14]; \n    x[12] -= x[13]; x[13] -= x[12];\n    x[10] -= x[11]; x[11] -= x[10]; \n    x[ 8] -= x[ 9]; x[ 9] -= x[ 8]; \n    x[ 6] -= x[ 7]; x[ 7] -= x[ 6];\n    x[ 4] -= x[ 5]; x[ 5] -= x[ 4]; \n    x[ 2] -= x[ 3]; x[ 3] -= x[ 2]; \n    x[ 0] -= x[ 1]; x[ 1] -= x[ 0]; \n    \n    x[ 0] = logf[x[ 0] - kp[16] + 256] ^ kp[ 0];\n    x[ 1] = expf[x[ 1] ^ kp[17]] - kp[ 1];\n    x[ 2] = expf[x[ 2] ^ kp[18]] - kp[ 2];\n    x[ 3] = logf[x[ 3] - kp[19] + 256] ^ kp[ 3];\n\n    x[ 4] = logf[x[ 4] - kp[20] + 256] ^ kp[ 4];\n    x[ 5] = expf[x[ 5] ^ kp[21]] - kp[ 5];\n    x[ 6] = expf[x[ 6] ^ kp[22]] - kp[ 6];\n    x[ 7] = logf[x[ 7] - kp[23] + 256] ^ kp[ 7];\n\n    x[ 8] = logf[x[ 8] - kp[24] + 256] ^ kp[ 8];\n    x[ 9] = expf[x[ 9] ^ kp[25]] - kp[ 9];\n    x[10] = expf[x[10] ^ kp[26]] - kp[10];\n    x[11] = logf[x[11] - kp[27] + 256] ^ kp[11];\n\n    x[12] = logf[x[12] - kp[28] + 256] ^ kp[12];\n    x[13] = expf[x[13] ^ kp[29]] - kp[13];\n    x[14] = expf[x[14] ^ kp[30]] - kp[14];\n    x[15] = logf[x[15] - kp[31] + 256] ^ kp[15];\n}\n\nvoid Saferp_encrypt(const SAFERP_DATA *pSpd,const DWORD *in_blk, DWORD *out_blk)\n{\n\tBYTE  blk[16], *kp;\n\n    get_block(blk);\n\n    do_fr(blk, (BYTE *) pSpd->l_key);         do_fr(blk, ((BYTE *) pSpd->l_key) +  32); \n    do_fr(blk, ((BYTE *) pSpd->l_key) +  64); do_fr(blk, ((BYTE *) pSpd->l_key) +  96);\n    do_fr(blk, ((BYTE *) pSpd->l_key) + 128); do_fr(blk, ((BYTE *) pSpd->l_key) + 160);\n    do_fr(blk, ((BYTE *) pSpd->l_key) + 192); do_fr(blk, ((BYTE *) pSpd->l_key) + 224);\n    \n    if(pSpd->k_bytes > 16)\n    {\n        do_fr(blk, ((BYTE *) pSpd->l_key) + 256); do_fr(blk, ((BYTE *) pSpd->l_key) + 288); \n        do_fr(blk, ((BYTE *) pSpd->l_key) + 320); do_fr(blk, ((BYTE *) pSpd->l_key) + 352);\n    }\n\n    if(pSpd->k_bytes > 24)\n    {\n        do_fr(blk, ((BYTE *) pSpd->l_key) + 384); do_fr(blk, ((BYTE *) pSpd->l_key) + 416); \n        do_fr(blk, ((BYTE *) pSpd->l_key) + 448); do_fr(blk, ((BYTE *) pSpd->l_key) + 480);\n    }\n\n    kp = ((BYTE *) pSpd->l_key) + 16 * pSpd->k_bytes;\n\n    blk[ 0] ^= kp[ 0]; blk[ 1] += kp[ 1];\n    blk[ 2] += kp[ 2]; blk[ 3] ^= kp[ 3]; \n    blk[ 4] ^= kp[ 4]; blk[ 5] += kp[ 5];\n    blk[ 6] += kp[ 6]; blk[ 7] ^= kp[ 7]; \n    blk[ 8] ^= kp[ 8]; blk[ 9] += kp[ 9];\n    blk[10] += kp[10]; blk[11] ^= kp[11]; \n    blk[12] ^= kp[12]; blk[13] += kp[13];\n    blk[14] += kp[14]; blk[15] ^= kp[15]; \n\n    put_block(blk);\n}\n\nvoid Saferp_decrypt(const SAFERP_DATA *pSpd,const DWORD *in_blk, DWORD *out_blk)\n{\n\tBYTE  blk[16], *kp;\n\n    get_block(blk);\n\n    kp = ((BYTE *) pSpd->l_key) + 16 * pSpd->k_bytes;\n\n    blk[ 0] ^= kp[ 0]; blk[ 1] -= kp[ 1];\n    blk[ 2] -= kp[ 2]; blk[ 3] ^= kp[ 3];\n    blk[ 4] ^= kp[ 4]; blk[ 5] -= kp[ 5];\n    blk[ 6] -= kp[ 6]; blk[ 7] ^= kp[ 7];\n    blk[ 8] ^= kp[ 8]; blk[ 9] -= kp[ 9];\n    blk[10] -= kp[10]; blk[11] ^= kp[11];\n    blk[12] ^= kp[12]; blk[13] -= kp[13];\n    blk[14] -= kp[14]; blk[15] ^= kp[15];\n\n    if(pSpd->k_bytes > 24)\n    {\n        do_ir(blk, pSpd->l_key + 480); do_ir(blk, pSpd->l_key + 448); \n        do_ir(blk, pSpd->l_key + 416); do_ir(blk, pSpd->l_key + 384);\n    }\n\n    if(pSpd->k_bytes > 16)\n    {\n        do_ir(blk, pSpd->l_key + 352); do_ir(blk, pSpd->l_key + 320); \n        do_ir(blk, pSpd->l_key + 288); do_ir(blk, pSpd->l_key + 256);\n    }\n\n    do_ir(blk, pSpd->l_key + 224); do_ir(blk, pSpd->l_key + 192); \n    do_ir(blk, pSpd->l_key + 160); do_ir(blk, pSpd->l_key + 128);\n    do_ir(blk, pSpd->l_key +  96); do_ir(blk, pSpd->l_key +  64); \n    do_ir(blk, pSpd->l_key +  32); do_ir(blk, pSpd->l_key);\n\n    put_block(blk);\n}\n"
        },
        {
            "file_name": "Sc2000.cpp",
            "content": "#include \"stdafx.h\"\n\n#define T32(x)  ((x) & ONE32)\n#define ONE32 0xffffffffU\n#define ROTL32(v,n) (T32((v)<<(n))|((v)>>(32-(n))))\n\n/* S-boxes  (6-bit)(5-bit)  */\nconst DWORD S6[64] = {\n  47, 59, 25, 42, 15, 23, 28, 39, 26, 38, 36, 19, 60, 24, 29, 56,\n  37, 63, 20, 61, 55, 2, 30, 44, 9, 10, 6, 22, 53, 48, 51, 11,\n  62, 52, 35, 18, 14, 46, 0, 54, 17, 40, 27, 4, 31, 8, 5, 12,\n  3, 16, 41, 34, 33, 7, 45, 49, 50, 58, 1, 21, 43, 57, 32, 13\n};\nconst DWORD S5[32] = {\n  20, 26, 7, 31, 19, 12, 10, 15, 22, 30, 13, 14, 4, 24, 9, 18,\n  27, 11, 1, 21, 6, 16, 2, 28, 23, 5, 8, 3, 0, 17, 29, 25\n};\n\n/* Bit-slice S-Box (4-bit)*/\n/* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15*/\nconst DWORD S4[16] = { 2, 5, 10, 12, 7, 15, 1, 11, 13, 6, 0, 9, 4, 8, 3, 14 };\nconst DWORD S4i[16] = { 10, 6, 0, 14, 12, 1, 9, 4, 13, 11, 2, 7, 3, 8, 15, 5 };\n\n/* M-Table */\nconst DWORD M[32] = {\n  0xd0c19225, 0xa5a2240a, 0x1b84d250, 0xb728a4a1,\n  0x6a704902, 0x85dddbe6, 0x766ff4a4, 0xecdfe128,\n  0xafd13e94, 0xdf837d09, 0xbb27fa52, 0x695059ac,\n  0x52a1bb58, 0xcc322f1d, 0x1844565b, 0xb4a8acf6,\n  0x34235438, 0x6847a851, 0xe48c0cbb, 0xcd181136,\n  0x9a112a0c, 0x43ec6d0e, 0x87d8d27d, 0x487dc995,\n  0x90fb9b4b, 0xa1f63697, 0xfc513ed9, 0x78a37d93,\n  0x8d16c5df, 0x9e0c8bbe, 0x3c381f7c, 0xe9fb0779\n};\n\n#define _A_ 0\n#define _B_ 1\n#define _C_ 2\n#define _D_ 3\n#define _X_ 0\n#define _Y_ 1\n#define _Z_ 2\n#define _W_ 3\n/* Order Table */\nconst DWORD Order[12][4] = {\n  {_A_, _B_, _C_, _D_},\n  {_B_, _A_, _D_, _C_},\n  {_C_, _D_, _A_, _B_},\n  {_D_, _C_, _B_, _A_},\n  {_A_, _C_, _D_, _B_},\n  {_B_, _D_, _C_, _A_},\n  {_C_, _A_, _B_, _D_},\n  {_D_, _B_, _A_, _C_},\n  {_A_, _D_, _B_, _C_},\n  {_B_, _C_, _A_, _D_},\n  {_C_, _B_, _D_, _A_},\n  {_D_, _A_, _C_, _B_}\n};\n\n/* Index Table */\nconst DWORD Index[9][4] = {\n  {0, 0, 0, 0},\n  {1, 1, 1, 1},\n  {2, 2, 2, 2},\n  {0, 1, 0, 1},\n  {1, 2, 1, 2},\n  {2, 0, 2, 0},\n  {0, 2, 0, 2},\n  {1, 0, 1, 0},\n  {2, 1, 2, 1}\n};\n\nvoid S_func (DWORD a, DWORD * b)\n{\n  DWORD q, r, s, t, u, v;\n  q = (a >> 26) & 0x3F;\n  r = (a >> 21) & 0x1F;\n  s = (a >> 16) & 0x1F;\n  t = (a >> 11) & 0x1F;\n  u = (a >> 6) & 0x1F;\n  v = (a >> 0) & 0x3F;\n  q = S6[q];\n  r = S5[r];\n  s = S5[s];\n  t = S5[t];\n  u = S5[u];\n  v = S6[v];\n  *b = (q << 26);\n  *b |= (r << 21);\n  *b |= (s << 16);\n  *b |= (t << 11);\n  *b |= (u << 6);\n  *b |= (v << 0);\n  return;\n}\n\nvoid M_func (DWORD a, DWORD * b)\n{\n  int i;\n  *b = 0;\n  for (i = 31; i >= 0; i--)\n    {\n      if (a & 1)\n        *b ^= M[i];\n      a >>= 1;\n    }\n  return;\n}\n\nvoid L_func (DWORD a, DWORD b, DWORD mask, DWORD * c, DWORD * d)\n{\n  DWORD s, t;\n  DWORD imask = (mask ^ 0xFFFFFFFF);\n  s = a & mask;\n  t = b & imask;\n  *c = s ^ b;\n  *d = t ^ a;\n  return;\n}\n\nvoid F_func (DWORD a, DWORD b, DWORD mask, DWORD * c, DWORD * d)\n{\n  DWORD s, t;\n  S_func (a, &s);\n  M_func (s, &s);\n  S_func (b, &t);\n  M_func (t, &t);\n  L_func (s, t, mask, c, d);\n  return;\n}\n\nvoid R_func (DWORD a, DWORD b, DWORD c, DWORD d, DWORD mask, DWORD * e,\n        DWORD * f, DWORD * g, DWORD * h)\n{\n  DWORD s, t;\n  F_func (c, d, mask, &s, &t);\n  *e = a ^ s;\n  *f = b ^ t;\n  *g = c;\n  *h = d;\n  return;\n}\n\nvoid B_func (DWORD a, DWORD b, DWORD c, DWORD d, DWORD * e, DWORD * f, DWORD * g, DWORD * h)\n{\n  DWORD s, t;\n  DWORD m = 1;\n  int i;\n  *e = 0;\n  *f = 0;\n  *g = 0;\n  *h = 0;\n  for (i = 0; i < 32; i++)\n    {\n      /*T_func */\n      s = 0;\n      if (a & m)\n        s |= 8;\n      if (b & m)\n        s |= 4;\n      if (c & m)\n        s |= 2;\n      if (d & m)\n        s |= 1;\n      t = S4[s];\n\n      if (t & 8)\n        *e |= m;\n      if (t & 4)\n        *f |= m;\n      if (t & 2)\n        *g |= m;\n      if (t & 1)\n        *h |= m;\n      m <<= 1;\n    }\n  return;\n}\n\nvoid Bi_func (DWORD a, DWORD b, DWORD c, DWORD d, DWORD * e, DWORD * f, DWORD * g, DWORD * h)\n{\n  DWORD s, t;\n  DWORD m = 1;\n  int i;\n  *e = 0;\n  *f = 0;\n  *g = 0;\n  *h = 0;\n  for (i = 0; i < 32; i++)\n    {\n      s = 0;\n      /*T_func */\n      if (a & m)\n        s |= 8;\n      if (b & m)\n        s |= 4;\n      if (c & m)\n        s |= 2;\n      if (d & m)\n        s |= 1;\n      t = S4i[s];\n\n      if (t & 8)\n        *e |= m;\n      if (t & 4)\n        *f |= m;\n      if (t & 2)\n        *g |= m;\n      if (t & 1)\n        *h |= m;\n      m <<= 1;\n    }\n  return;\n}\n\nvoid I_func (DWORD a, DWORD b, DWORD c, DWORD d, DWORD ka, DWORD kb,\n        DWORD kc, DWORD kd, DWORD * e, DWORD * f, DWORD * g, DWORD * h)\n{\n  *e = a ^ ka;\n  *f = b ^ kb;\n  *g = c ^ kc;\n  *h = d ^ kd;\n  return;\n}\n\nDWORD make_one_imkey (DWORD k1, DWORD k2, DWORD i, DWORD j)\n{\n  DWORD ka, kb, m;\n  ka = k1;\n  S_func (ka, &ka);\n  M_func (ka, &ka);\n  kb = k2;\n  S_func (kb, &kb);\n  M_func (kb, &kb);\n  m = 4 * i + j;\n  S_func (m, &m);\n  M_func (m, &m);\n  ka += m;\n  ka &= 0xFFFFFFFF;\n  kb *= (i + 1);\n  kb &= 0xFFFFFFFF;\n  ka ^= kb;\n  S_func (ka, &ka);\n  M_func (ka, &ka);\n  return (ka);\n}\n\nvoid make_imkeys (const DWORD * ukey, DWORD keylength, DWORD imkey[4][3])\n{\n  DWORD kl, k2, k3, k4, k5, k6, k7, k8;\n  DWORD i;\n  kl = ukey[0];\n  k2 = ukey[1];\n  k3 = ukey[2];\n  k4 = ukey[3];\n\n  k5 = ukey[4];\n  k6 = ukey[5];\n  k7 = ukey[6];\n  k8 = ukey[7];\n\n  for (i = 0; i < 3; i++)\n    {\n      imkey[_A_][i] = make_one_imkey (kl, k2, i, 0);\n      imkey[_B_][i] = make_one_imkey (k3, k4, i, 1);\n      imkey[_C_][i] = make_one_imkey (k5, k6, i, 2);\n      imkey[_D_][i] = make_one_imkey (k7, k8, i, 3);\n    }\n}\n\nDWORD make_one_ekey (DWORD imkey[4][3], DWORD t, DWORD s)\n{\n  DWORD x, y, z, w;\n  x = imkey[Order[t][_X_]][Index[s][_X_]];\n  y = imkey[Order[t][_Y_]][Index[s][_Y_]];\n  z = imkey[Order[t][_Z_]][Index[s][_Z_]];\n  w = imkey[Order[t][_W_]][Index[s][_W_]];\n  x = ROTL32 (x, 1);\n  x += y;\n  x &= 0xFFFFFFFF;\n  z = ROTL32 (z, 1);\n  z -= w;\n  z &= 0xFFFFFFFF;\n  z = ROTL32 (z, 1);\n  x ^= z;\n  return (x);\n}\n\nvoid make_ekeys (DWORD imkey[4][3], DWORD num_ekey, DWORD * ekey)\n{\n  DWORD n, t, s;\n  for (n = 0; n < num_ekey; n++)\n    {\n      t = (n + (n / 36)) % 12;\n      s = n % 9;\n      ekey[n] = make_one_ekey (imkey, t, s);\n    }\n}\n\nvoid Sc2000_set_key(DWORD *ek,const DWORD *in_key)\n{\n  DWORD imkey[4][3];\n\n  /* make intermediate key */\n  make_imkeys (in_key, 256, imkey);\n\n  /* make extend key */\n  make_ekeys (imkey, 64, ek);\n}\n\nvoid Sc2000_encrypt(const DWORD *ek,const DWORD *in,DWORD *out)\n{\n  DWORD a, b, c, d;\n  a = in[0];\n  b = in[1];\n  c = in[2];\n  d = in[3];\n  I_func (a, b, c, d, ek[0], ek[1], ek[2], ek[3], &a, &b, &c, &d);\n  B_func (a, b, c, d, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[4], ek[5], ek[6], ek[7], &a, &b, &c, &d);\n  R_func (a, b, c, d, 0x55555555, &a, &b, &c, &d);\n  R_func (c, d, a, b, 0x55555555, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[8], ek[9], ek[10], ek[11], &a, &b, &c, &d);\n  B_func (a, b, c, d, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[12], ek[13], ek[14], ek[15], &a, &b, &c, &d);\n  R_func (a, b, c, d, 0x33333333, &a, &b, &c, &d);\n  R_func (c, d, a, b, 0x33333333, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[16], ek[17], ek[18], ek[19], &a, &b, &c, &d);\n  B_func (a, b, c, d, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[20], ek[21], ek[22], ek[23], &a, &b, &c, &d);\n  R_func (a, b, c, d, 0x55555555, &a, &b, &c, &d);\n  R_func (c, d, a, b, 0x55555555, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[24], ek[25], ek[26], ek[27], &a, &b, &c, &d);\n  B_func (a, b, c, d, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[28], ek[29], ek[30], ek[31], &a, &b, &c, &d);\n  R_func (a, b, c, d, 0x33333333, &a, &b, &c, &d);\n  R_func (c, d, a, b, 0x33333333, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[32], ek[33], ek[34], ek[35], &a, &b, &c, &d);\n  B_func (a, b, c, d, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[36], ek[37], ek[38], ek[39], &a, &b, &c, &d);\n  R_func (a, b, c, d, 0x55555555, &a, &b, &c, &d);\n  R_func (c, d, a, b, 0x55555555, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[40], ek[41], ek[42], ek[43], &a, &b, &c, &d);\n  B_func (a, b, c, d, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[44], ek[45], ek[46], ek[47], &a, &b, &c, &d);\n  R_func (a, b, c, d, 0x33333333, &a, &b, &c, &d);\n  R_func (c, d, a, b, 0x33333333, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[48], ek[49], ek[50], ek[51], &a, &b, &c, &d);\n  B_func (a, b, c, d, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[52], ek[53], ek[54], ek[55], &a, &b, &c, &d);\n\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n}\n\nvoid Sc2000_decrypt(const DWORD *ek,const DWORD *in,DWORD *out)\n{\n  DWORD a, b, c, d;\n\n  a = in[0];\n  b = in[1];\n  c = in[2];\n  d = in[3];\n\n  I_func (a, b, c, d, ek[52], ek[53], ek[54], ek[55], &a, &b, &c, &d);\n  Bi_func (a, b, c, d, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[48], ek[49], ek[50], ek[51], &a, &b, &c, &d);\n  R_func (a, b, c, d, 0x33333333, &a, &b, &c, &d);\n  R_func (c, d, a, b, 0x33333333, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[44], ek[45], ek[46], ek[47], &a, &b, &c, &d);\n  Bi_func (a, b, c, d, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[40], ek[41], ek[42], ek[43], &a, &b, &c, &d);\n  R_func (a, b, c, d, 0x55555555, &a, &b, &c, &d);\n  R_func (c, d, a, b, 0x55555555, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[36], ek[37], ek[38], ek[39], &a, &b, &c, &d);\n  Bi_func (a, b, c, d, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[32], ek[33], ek[34], ek[35], &a, &b, &c, &d);\n  R_func (a, b, c, d, 0x33333333, &a, &b, &c, &d);\n  R_func (c, d, a, b, 0x33333333, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[28], ek[29], ek[30], ek[31], &a, &b, &c, &d);\n  Bi_func (a, b, c, d, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[24], ek[25], ek[26], ek[27], &a, &b, &c, &d);\n  R_func (a, b, c, d, 0x55555555, &a, &b, &c, &d);\n  R_func (c, d, a, b, 0x55555555, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[20], ek[21], ek[22], ek[23], &a, &b, &c, &d);\n  Bi_func (a, b, c, d, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[16], ek[17], ek[18], ek[19], &a, &b, &c, &d);\n  R_func (a, b, c, d, 0x33333333, &a, &b, &c, &d);\n  R_func (c, d, a, b, 0x33333333, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[12], ek[13], ek[14], ek[15], &a, &b, &c, &d);\n  Bi_func (a, b, c, d, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[8], ek[9], ek[10], ek[11], &a, &b, &c, &d);\n  R_func (a, b, c, d, 0x55555555, &a, &b, &c, &d);\n  R_func (c, d, a, b, 0x55555555, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[4], ek[5], ek[6], ek[7], &a, &b, &c, &d);\n  Bi_func (a, b, c, d, &a, &b, &c, &d);\n  I_func (a, b, c, d, ek[0], ek[1], ek[2], ek[3], &a, &b, &c, &d);\n\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n}\n"
        },
        {
            "file_name": "Scramble.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"CSPRNG.h\"\n#include \"Scramble_data.h\"\n\nvoid Scramble_build_list(CSPRNG_DATA *pCd,const DWORD count,const DWORD max,DWORD *list)\n{\n\tDWORD\ttCount=count;\n\n\twhile(tCount)\n\t\t{\n\t\tdo\n\t\t\t{\n\t\t\tlist[0]=CSPRNG_get_dword(pCd)%max;\n\t\t\tlist[1]=CSPRNG_get_dword(pCd)%max;\n\t\t\t}\n\t\twhile(list[0]==list[1]);\n\n\t\tlist+=2;\n\t\ttCount--;\n\t\t}\n}\n\nOBFUNC_RETV Scramble_seed(SCRAMBLE_DATA *pSd,const DWORD len,const BYTE *passw,DWORD nonce)\n{\n\tmemset(pSd,0,sizeof(SCRAMBLE_DATA));\n\n\t// CSPRNG <- Skein512(passw + nonce)\n\tCSPRNG_set_seed(&pSd->cd,SKEIN512_HASH,passw,nonce);\n\n\tpSd->len=len;\n\n\t// 50% scramble : (len/2)*2*sizeof(DWORD)\n\tif(pSd->list=(DWORD *) malloc(((len>>1)<<1)*sizeof(DWORD)))\n\t\t{\n\t\tScramble_build_list(&pSd->cd,len>>1,len,pSd->list);\n\t\treturn(OBFUNC_OK);\n\t\t}\n\telse\n\t\t{ return(OBFUNC_OUTOFMEM); }\n}\n\nvoid Scramble_end(SCRAMBLE_DATA *pSd)\n{\n\tTEST_AND_FREE(pSd->list)\n}\n\n#define\tREFRESH_COUNTDOWN\t10000\n\nOBFUNC_RETV Seg_scramble(SCRAMBLE_DATA *pSd,BYTE *buf,perc_callback_t pFunc,void *pDesc,test_callback_t tFunc,void *tDesc)\n{\n\tDWORD\ttot=pSd->len>>1;\t// 50%\n\tDWORD\t*pL=pSd->list;\n\tDWORD\tindex;\t\t\n\tBYTE\tlastPerc=0;\n\tWORD\trefCount=REFRESH_COUNTDOWN;\n\n\tfor(index=0;index<tot;index++)\n\t\t{\n\t\tDWORD\tidx0=*(pL++);\n\t\tDWORD\tidx1=*(pL++);\n\t\tBYTE\ttmp;\n\n\t\ttmp=buf[idx0];\n\t\tbuf[idx0]=buf[idx1];\n\t\tbuf[idx1]=tmp;\n\n\t\tif(!refCount)\n\t\t\t{\n\t\t\trefCount=REFRESH_COUNTDOWN;\n\n\t\t\tif(pFunc)\n\t\t\t\t{\n\t\t\t\ttmp=(BYTE) ((((float) index)/((float) tot))*((float) 100));\n\t\t\t\tif(tmp>lastPerc)\n\t\t\t\t\t{\n\t\t\t\t\tlastPerc=tmp;\n\t\t\t\t\tpFunc(pDesc,lastPerc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(tFunc&&tFunc(tDesc))\n\t\t\t\t{ return(OBFUNC_STOP); }\n\t\t\t}\n\n\t\trefCount--;\n\t\t}\n\n\treturn(OBFUNC_OK);\n}\n\nOBFUNC_RETV Seg_descramble(SCRAMBLE_DATA *pSd,BYTE *buf,perc_callback_t pFunc,void *pDesc,test_callback_t tFunc,void *tDesc)\n{\n\tDWORD\ttot=pSd->len>>1;\t// 50%\n\tDWORD\t*pL=&pSd->list[((pSd->len>>1)<<1)-1];\n\tDWORD\tindex;\t\t\n\tBYTE\tlastPerc=0;\n\tWORD\trefCount=REFRESH_COUNTDOWN;\n\n\tfor(index=0;index<tot;index++)\n\t\t{\n\t\tDWORD\tidx1=*(pL--);\n\t\tDWORD\tidx0=*(pL--);\n\t\tBYTE\ttmp;\n\n\t\ttmp=buf[idx0];\n\t\tbuf[idx0]=buf[idx1];\n\t\tbuf[idx1]=tmp;\n\n\t\tif(!refCount)\n\t\t\t{\n\t\t\trefCount=REFRESH_COUNTDOWN;\n\n\t\t\tif(pFunc)\n\t\t\t\t{\n\t\t\t\ttmp=(BYTE) ((((float) index)/((float) tot))*((float) 100));\n\t\t\t\tif(tmp>lastPerc)\n\t\t\t\t\t{\n\t\t\t\t\tlastPerc=tmp;\n\t\t\t\t\tpFunc(pDesc,lastPerc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(tFunc&&tFunc(tDesc))\n\t\t\t\t{ return(OBFUNC_STOP); }\n\t\t\t}\n\n\t\trefCount--;\n\t\t}\n\n\treturn(OBFUNC_OK);\n}\n"
        },
        {
            "file_name": "scream12v2_scream_cipher.cpp",
            "content": "/* LS-cipher implementation */\n\n// CHANGE crypto_uintXX typedefs\n// #include \"crypto_uint16.h\"\n// #include \"crypto_uint8.h\"\n#include <cstdint>\ntypedef uint8_t crypto_uint8;\ntypedef uint16_t crypto_uint16;\n\n#include \"scream12v2_sbox.h\"\n#include \"scream12v2_lbox.h\"\n#include \"scream12v2_params.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Scream12v2_raw {\nint numRounds = -1;\n\nvoid LS_encrypt(const crypto_uint8 input[16], const crypto_uint8 key[16], const crypto_uint8 tweak[16],\n\t\tcrypto_uint8 output[16]) {\n  crypto_uint16 data[8];\n  crypto_uint16 k[8];\n  crypto_uint16 t[8];\n  int i,j;\n\n  for (i=0; i<8; i++) {\n    data[i] = ((crypto_uint16)input[2*i+1]<<8) + input[2*i];\n    k[i] = ((crypto_uint16)  key[2*i+1]<<8) +   key[2*i];\n    t[i] = ((crypto_uint16)tweak[2*i+1]<<8) + tweak[2*i];\n  }\n    \n  /* Initial key + tweak addition */\n  for (j=0; j<8; j++) data[j] ^= k[j] ^ t[j];\n    \n  /* ---------------- Step Function ---------------- */\n  for (i=0; i<nSteps; i++) {\n        \n    /* ---------------- First Round ---------------- */\n    /* SBox layer (bitsliced) */\n    SBOX(data);\n    /* First round constant */\n    data[0] ^= ((27*(2*i)) % 256);\n    /* LBox layer (tables) */\n    for (j=0; j<8; j++)\n      data[j] = LBox2[data[j]>>8] ^ LBox1[data[j]&0xff];\n        \n    /* ---------------- Second Round -------------- */\n    /* SBox layer (bitsliced) */\n    SBOX(data);\n    /* Round constant */\n    data[0] ^= ((27*(2*i+1)) % 256);\n    /* LBox layer (tables) */\n    for (j=0; j<8; j++)\n      data[j] = LBox2[data[j]>>8] ^ LBox1[data[j]&0xff];\n        \n    /* Tweak schedule */\n    for (j=0; j<4; j++) {\n      t[j]   ^= t[j+4];\n      t[j+4] ^= t[j];\n    }\n    /* ----------- Key + Tweak Addition ---------- */\n    for (j=0; j<8; j++) data[j] ^= k[j] ^ t[j];\n  }\n\n  /* ----------- Restore initial tweak --------- */\n  for (i=nSteps%3; i<3; i++) {\n    for (j=0; j<4; j++) {\n      t[j]   ^= t[j+4];\n      t[j+4] ^= t[j];\n    }\n  }\n    \n  for (i=0; i<8; i++) {\n    output[2*i]   = data[i];\n    output[2*i+1] = data[i]>>8;\n  }\n}\n\n\nvoid LS_decrypt(const crypto_uint8 input[16], const crypto_uint8 key[16], const crypto_uint8 tweak[16],\n\t\tcrypto_uint8 output[16]) {\n  crypto_uint16 data[8];\n  crypto_uint16 k[8];\n  crypto_uint16 t[8];\n  int i,j;\n\n  for (i=0; i<8; i++) {\n    data[i] = ((crypto_uint16)input[2*i+1]<<8) + input[2*i];\n    k[i] = ((crypto_uint16)  key[2*i+1]<<8) +   key[2*i];\n    t[i] = ((crypto_uint16)tweak[2*i+1]<<8) + tweak[2*i];\n  }\n\n  /* ---------------- Step Function ---------------- */\n  for (i=nSteps-1; i>=0; i--) {\n    /* ----------- Key + Tweak Addition ---------- */\n    for (j=0; j<8; j++) data[j] ^= k[j];\n    switch(i%3) {\n    case     0:\n      for (j=0; j<4; j++) data[j] ^= t[j] ^ t[j+4];\n      for (j=4; j<8; j++) data[j] ^= t[j-4];\n      break;\n    case     1:\n      for (j=0; j<4; j++) data[j] ^= t[j+4];\n      for (j=4; j<8; j++) data[j] ^= t[j] ^ t[j-4];\n      break;\n    case     2:\n      for (j=0; j<8; j++) data[j] ^= t[j] ;\n      break;\n    }\n\n    /* ---------------- Second Round -------------- */\n    /* LBox layer (tables) */\n    for (j=0; j<8; j++)\n      data[j] = LBoxInv2[data[j]>>8] ^ LBoxInv1[data[j]&0xff];\n    /* Round constant */\n    data[0] ^= ((27*(2*i+1)) % 256);\n    /* SBox layer (bitsliced) */\n    SBOX_Inv(data);\n        \n    /* ---------------- First Round ---------------- */\n    /* LBox layer (tables) */\n    for (j=0; j<8; j++)\n      data[j] = LBoxInv2[data[j]>>8] ^ LBoxInv1[data[j]&0xff];\n    /* First round constant */\n    data[0] ^= ((27*(2*i)) % 256);\n    /* SBox layer (bitsliced) */\n    SBOX_Inv(data);\n  }\n\n  /* Final key + tweak addition */\n  for (j=0; j<8; j++) data[j] ^= k[j] ^ t[j];\n    \n  for (i=0; i<8; i++) {\n    output[2*i]   = data[i];\n    output[2*i+1] = data[i]>>8;\n  }\n}\n\n} // namespace Scream12v2_raw\n"
        },
        {
            "file_name": "seakeyakv1_KeccakParallelDuplex.cpp",
            "content": "/*\nThe Keccak sponge function, designed by Guido Bertoni, Joan Daemen,\nMicha\u00c3\u00abl Peeters and Gilles Van Assche. For more information, feedback or\nquestions, please refer to our website: http://keccak.noekeon.org/\n\nImplementation by the designers,\nhereby denoted as \"the implementer\".\n\nTo the extent possible under law, the implementer has waived all copyright\nand related or neighboring rights to the source code in this file.\nhttp://creativecommons.org/publicdomain/zero/1.0/\n*/\n\n#include <string.h>\n#include \"seakeyakv1_KeccakParallelDuplex.h\"\n#include \"seakeyakv1_ParallelKeccakFs.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Seakeyakv1_raw {\n\nint Keccak_ParallelDuplexInitializeAll(Keccak_ParallelDuplexInstances *instances, unsigned int rate, unsigned int capacity)\n{\n    unsigned int i;\n\n    if (rate+capacity != KeccakF_width)\n        return 1;\n    if ((rate <= 2) || (rate > KeccakF_width))\n        return 1;\n    KeccakF_ParallelInitialize();\n    instances->rate = rate;\n    KeccakF_ParallelStateInitializeAll(instances->states);\n    for(i=0; i<NumberOfParallelInstances; i++) {\n        instances->byteInputIndex[i] = 0;\n        instances->byteOutputIndex[i] = (instances->rate+7)/8;\n    }\n    return 0;\n}\n\nint Keccak_ParallelDuplexingAll(Keccak_ParallelDuplexInstances *instances, unsigned char delimitedSigmaEnd)\n{\n    unsigned char delimitedSigmaEnd1[1];\n    const unsigned int rho_max = instances->rate - 2;\n    unsigned int i;\n\n    if (delimitedSigmaEnd == 0)\n        return 1;\n\n    delimitedSigmaEnd1[0] = delimitedSigmaEnd;\n    // Last few bits, whose delimiter coincides with first bit of padding\n    for(i=0; i<NumberOfParallelInstances; i++)\n        KeccakF_ParallelStateXORBytesInLane(instances->states, i, instances->byteInputIndex[i]/KeccakF_laneInBytes,\n            delimitedSigmaEnd1, instances->byteInputIndex[i]%KeccakF_laneInBytes, 1);\n    // Second bit of padding\n    KeccakF_ParallelStateComplementBitAll(instances->states, instances->rate - 1);\n\n    KeccakF_ParallelStatePermuteAll(instances->states);\n\n    for(i=0; i<NumberOfParallelInstances; i++) {\n        instances->byteInputIndex[i] = 0;\n        instances->byteOutputIndex[i] = 0;\n    }\n    return 0;\n}\n\nint Keccak_ParallelDuplexing(Keccak_ParallelDuplexInstances *instances, unsigned int instanceIndex, unsigned char delimitedSigmaEnd)\n{\n    unsigned char delimitedSigmaEnd1[1];\n    const unsigned int rho_max = instances->rate - 2;\n    unsigned int i;\n\n    if (instanceIndex >= NumberOfParallelInstances)\n        return 1;\n    if (delimitedSigmaEnd == 0)\n        return 1;\n\n    delimitedSigmaEnd1[0] = delimitedSigmaEnd;\n    // Last few bits, whose delimiter coincides with first bit of padding\n    KeccakF_ParallelStateXORBytesInLane(instances->states, instanceIndex,\n        instances->byteInputIndex[instanceIndex]/KeccakF_laneInBytes,\n        delimitedSigmaEnd1, instances->byteInputIndex[instanceIndex]%KeccakF_laneInBytes, 1);\n    // Second bit of padding\n    KeccakF_ParallelStateComplementBit(instances->states, instanceIndex, instances->rate - 1);\n\n    KeccakF_ParallelStatePermute(instances->states, instanceIndex);\n\n    instances->byteInputIndex[instanceIndex] = 0;\n    instances->byteOutputIndex[instanceIndex] = 0;\n    return 0;\n}\n\n#define processInput(i, Operation) \\\n    if ((instances->byteInputIndex[i] == 0) && (localSize >= KeccakF_laneInBytes)) { \\\n        Operation##Lanes(instances->states, i, in, localSize/KeccakF_laneInBytes); \\\n        localSize = (localSize/KeccakF_laneInBytes)*KeccakF_laneInBytes; \\\n        in += localSize; \\\n        instances->byteInputIndex[i] += localSize; \\\n        inByteLen -= localSize; \\\n    } \\\n    else { \\\n        unsigned int offsetInLane = instances->byteInputIndex[i] % KeccakF_laneInBytes; \\\n        unsigned int bytesInLane = KeccakF_laneInBytes - offsetInLane; \\\n        if (bytesInLane > localSize) \\\n            bytesInLane = localSize; \\\n        Operation##BytesInLane(instances->states, i, instances->byteInputIndex[i]/KeccakF_laneInBytes, in, offsetInLane, bytesInLane); \\\n        in += bytesInLane; \\\n        instances->byteInputIndex[i] += bytesInLane; \\\n        inByteLen -= bytesInLane; \\\n    }\n\nint Keccak_ParallelDuplexingFeedPartialInterleavedInput(Keccak_ParallelDuplexInstances *instances, const unsigned char *in, unsigned int inByteLen)\n{\n    const unsigned int rho_max = instances->rate - 2;\n    const unsigned int rho_maxInBytes = rho_max/8;\n    unsigned int i;\n    unsigned int totalInputIndex = 0;\n    unsigned int localSize;\n\n    for(i=0; i<NumberOfParallelInstances; i++)\n        totalInputIndex += instances->byteInputIndex[i];\n    if (totalInputIndex+inByteLen > rho_maxInBytes*NumberOfParallelInstances)\n        return 1;\n\n    if ((totalInputIndex == 0) && ((rho_maxInBytes % KeccakF_laneInBytes) == 0) && (inByteLen == rho_maxInBytes*NumberOfParallelInstances)) {\n        KeccakF_ParallelStateXORLanesAll(instances->states, in, rho_maxInBytes/KeccakF_laneInBytes);\n        for(i=0; i<NumberOfParallelInstances; i++)\n            instances->byteInputIndex[i] = rho_maxInBytes;\n        return 0;\n    }\n\n    i = 0;\n    while((instances->byteInputIndex[i] == rho_maxInBytes) && (i < NumberOfParallelInstances))\n        i++;\n    while(inByteLen > 0) {\n        if (i >= NumberOfParallelInstances)\n            return 1;\n        localSize = inByteLen;\n        if (localSize > rho_maxInBytes)\n            localSize = rho_maxInBytes;\n        processInput(i, KeccakF_ParallelStateXOR);\n        if (instances->byteInputIndex[i] == rho_maxInBytes)\n            i++;\n    }\n    return 0;\n}\n\nint Keccak_ParallelDuplexingFeedPartialSingleInput(Keccak_ParallelDuplexInstances *instances, unsigned int instanceIndex, const unsigned char *in, unsigned int inByteLen)\n{\n    const unsigned int rho_max = instances->rate - 2;\n    unsigned int localSize;\n\n    if (instanceIndex >= NumberOfParallelInstances)\n        return 1;\n    if ((instances->byteInputIndex[instanceIndex]+inByteLen)*8 > rho_max)\n        return 1;\n\n    while(inByteLen > 0) {\n        localSize = inByteLen;\n        processInput(instanceIndex, KeccakF_ParallelStateXOR);\n    }\n    return 0;\n}\n\nint Keccak_ParallelDuplexingFeedZeroes(Keccak_ParallelDuplexInstances *instances, unsigned int instanceIndex, unsigned int inByteLen)\n{\n    const unsigned int rho_max = instances->rate - 2;\n\n    if (instanceIndex >= NumberOfParallelInstances)\n        return 1;\n    if ((instances->byteInputIndex[instanceIndex]+inByteLen)*8 > rho_max)\n        return 1;\n\n    instances->byteInputIndex[instanceIndex] += inByteLen;\n    return 0;\n}\n\nint Keccak_ParallelDuplexingOverwritePartialInterleavedInput(Keccak_ParallelDuplexInstances *instances, const unsigned char *in, unsigned int inByteLen)\n{\n    const unsigned int rho_max = instances->rate - 2;\n    const unsigned int rho_maxInBytes = rho_max/8;\n    unsigned int i;\n    unsigned int totalInputIndex = 0;\n    unsigned int localSize;\n\n    for(i=0; i<NumberOfParallelInstances; i++)\n        totalInputIndex += instances->byteInputIndex[i];\n    if (totalInputIndex+inByteLen > rho_maxInBytes*NumberOfParallelInstances)\n        return 1;\n\n    if ((totalInputIndex == 0) && ((rho_maxInBytes % KeccakF_laneInBytes) == 0) && (inByteLen == rho_maxInBytes*NumberOfParallelInstances)) {\n        KeccakF_ParallelStateOverwriteLanesAll(instances->states, in, rho_maxInBytes/KeccakF_laneInBytes);\n        for(i=0; i<NumberOfParallelInstances; i++)\n            instances->byteInputIndex[i] = rho_maxInBytes;\n        return 0;\n    }\n\n    i = 0;\n    while((instances->byteInputIndex[i] == rho_maxInBytes) && (i < NumberOfParallelInstances))\n        i++;\n    while(inByteLen > 0) {\n        if (i >= NumberOfParallelInstances)\n            return 1;\n        localSize = inByteLen;\n        if (localSize > rho_maxInBytes)\n            localSize = rho_maxInBytes;\n        processInput(i, KeccakF_ParallelStateOverwrite);\n        if (instances->byteInputIndex[i] == rho_maxInBytes)\n            i++;\n    }\n    return 0;\n}\n\nint Keccak_ParallelDuplexingOverwritePartialSingleInput(Keccak_ParallelDuplexInstances *instances,  unsigned int instanceIndex, const unsigned char *in, unsigned int inByteLen)\n{\n    const unsigned int rho_max = instances->rate - 2;\n    unsigned int localSize;\n\n    if (instanceIndex >= NumberOfParallelInstances)\n        return 1;\n    if ((instances->byteInputIndex[instanceIndex]+inByteLen)*8 > rho_max)\n        return 1;\n\n    while(inByteLen > 0) {\n        localSize = inByteLen;\n        processInput(instanceIndex, KeccakF_ParallelStateOverwrite);\n    }\n    return 0;\n}\n\nint Keccak_ParallelDuplexingOverwriteWithZeroes(Keccak_ParallelDuplexInstances *instances, unsigned int instanceIndex, unsigned int inByteLen)\n{\n    const unsigned int rho_max = instances->rate - 2;\n    unsigned int i;\n\n    if (instanceIndex >= NumberOfParallelInstances)\n        return 1;\n    if (instances->byteInputIndex[instanceIndex] != 0)\n        return 1;\n    if (inByteLen*8 > rho_max)\n        return 1;\n\n    KeccakF_ParallelStateOverwriteWithZeroes(instances->states, instanceIndex, inByteLen);\n    instances->byteInputIndex[instanceIndex] += inByteLen;\n\n    return 0;\n}\n\n#define processOutput(i, Operation) \\\n    if ((instances->byteOutputIndex[i] == 0) && (localSize >= KeccakF_laneInBytes)) { \\\n        Operation##Lanes(instances->states, i, out, localSize/KeccakF_laneInBytes); \\\n        localSize = (localSize/KeccakF_laneInBytes)*KeccakF_laneInBytes; \\\n        out += localSize; \\\n        instances->byteOutputIndex[i] += localSize; \\\n        outByteLen -= localSize; \\\n    } \\\n    else { \\\n        unsigned int offsetInLane = instances->byteOutputIndex[i] % KeccakF_laneInBytes; \\\n        unsigned int bytesInLane = KeccakF_laneInBytes - offsetInLane; \\\n        if (bytesInLane > localSize) \\\n            bytesInLane = localSize; \\\n        Operation##BytesInLane(instances->states, i, instances->byteOutputIndex[i]/KeccakF_laneInBytes, out, offsetInLane, bytesInLane); \\\n        out += bytesInLane; \\\n        instances->byteOutputIndex[i] += bytesInLane; \\\n        outByteLen -= bytesInLane; \\\n    }\n\nint Keccak_ParallelDuplexingGetFurtherInterleavedOutput(Keccak_ParallelDuplexInstances *instances, unsigned char *out, unsigned int outByteLen)\n{\n    const unsigned int rho_max = instances->rate - 2;\n    const unsigned int rho_maxInBytes = rho_max/8;\n    unsigned int i;\n    unsigned int totalOutputIndex = 0;\n    unsigned int localSize;\n\n    for(i=0; i<NumberOfParallelInstances; i++)\n        totalOutputIndex += instances->byteOutputIndex[i];\n    if (totalOutputIndex+outByteLen > rho_maxInBytes*NumberOfParallelInstances)\n        return 1;\n\n    if ((totalOutputIndex == 0) && ((rho_maxInBytes % KeccakF_laneInBytes) == 0) && (outByteLen == rho_maxInBytes*NumberOfParallelInstances)) {\n        KeccakF_ParallelStateExtractLanesAll(instances->states, out, rho_maxInBytes/KeccakF_laneInBytes);\n        for(i=0; i<NumberOfParallelInstances; i++)\n            instances->byteOutputIndex[i] = rho_maxInBytes;\n        return 0;\n    }\n\n    i = 0;\n    while((instances->byteOutputIndex[i] == rho_maxInBytes) && (i < NumberOfParallelInstances))\n        i++;\n    while(outByteLen > 0) {\n        if (i >= NumberOfParallelInstances)\n            return 1;\n        localSize = outByteLen;\n        if (localSize > rho_maxInBytes)\n            localSize = rho_maxInBytes;\n        processOutput(i, KeccakF_ParallelStateExtract);\n        if (instances->byteOutputIndex[i] == rho_maxInBytes)\n            i++;\n    }\n    return 0;\n}\n\nint Keccak_ParallelDuplexingGetFurtherSingleOutput(Keccak_ParallelDuplexInstances *instances, unsigned int instanceIndex, unsigned char *out, unsigned int outByteLen)\n{\n    const unsigned int rho_max = instances->rate - 2;\n    unsigned int localSize;\n\n    if (instanceIndex >= NumberOfParallelInstances)\n        return 1;\n    if ((instances->byteOutputIndex[instanceIndex]+outByteLen)*8 > rho_max)\n        return 1;\n\n    while(outByteLen > 0) {\n        localSize = outByteLen;\n        processOutput(instanceIndex, KeccakF_ParallelStateExtract);\n    }\n    return 0;\n}\n\nint Keccak_ParallelDuplexingGetFurtherInterleavedOutputAndXOR(Keccak_ParallelDuplexInstances *instances, unsigned char *out, unsigned int outByteLen)\n{\n    const unsigned int rho_max = instances->rate - 2;\n    const unsigned int rho_maxInBytes = rho_max/8;\n    unsigned int i;\n    unsigned int totalOutputIndex = 0;\n    unsigned int localSize;\n\n    for(i=0; i<NumberOfParallelInstances; i++)\n        totalOutputIndex += instances->byteOutputIndex[i];\n    if (totalOutputIndex+outByteLen > rho_maxInBytes*NumberOfParallelInstances)\n        return 1;\n\n    if ((totalOutputIndex == 0) && ((rho_maxInBytes % KeccakF_laneInBytes) == 0) && (outByteLen == rho_maxInBytes*NumberOfParallelInstances)) {\n        KeccakF_ParallelStateExtractAndXORLanesAll(instances->states, out, rho_maxInBytes/KeccakF_laneInBytes);\n        for(i=0; i<NumberOfParallelInstances; i++)\n            instances->byteOutputIndex[i] = rho_maxInBytes;\n        return 0;\n    }\n\n    i = 0;\n    while((instances->byteOutputIndex[i] == rho_maxInBytes) && (i < NumberOfParallelInstances))\n        i++;\n    while(outByteLen > 0) {\n        if (i >= NumberOfParallelInstances)\n            return 1;\n        localSize = outByteLen;\n        if (localSize > rho_maxInBytes)\n            localSize = rho_maxInBytes;\n        processOutput(i, KeccakF_ParallelStateExtractAndXOR);\n        if (instances->byteOutputIndex[i] == rho_maxInBytes)\n            i++;\n    }\n    return 0;\n}\n\nint Keccak_ParallelDuplexingGetFurtherSingleOutputAndXOR(Keccak_ParallelDuplexInstances *instances, unsigned int instanceIndex, unsigned char *out, unsigned int outByteLen)\n{\n    const unsigned int rho_max = instances->rate - 2;\n    unsigned int localSize;\n\n    if (instanceIndex >= NumberOfParallelInstances)\n        return 1;\n    if ((instances->byteOutputIndex[instanceIndex]+outByteLen)*8 > rho_max)\n        return 1;\n\n    while(outByteLen > 0) {\n        localSize = outByteLen;\n        processOutput(instanceIndex, KeccakF_ParallelStateExtractAndXOR);\n    }\n    return 0;\n}\n\nunsigned int Keccak_ParallelDuplexGetTotalInputIndex(Keccak_ParallelDuplexInstances *instances)\n{\n    unsigned int totalInputIndex = 0;\n    unsigned int i;\n\n    for(i=0; i<NumberOfParallelInstances; i++)\n        totalInputIndex += instances->byteInputIndex[i];\n    return totalInputIndex;\n}\n\nunsigned int Keccak_ParallelDuplexGetInputIndex(Keccak_ParallelDuplexInstances *instances, unsigned int instanceIndex)\n{\n    if (instanceIndex >= NumberOfParallelInstances)\n        return 0;\n    else\n        return instances->byteInputIndex[instanceIndex];\n}\n\nunsigned int Keccak_ParallelDuplexGetOutputIndex(Keccak_ParallelDuplexInstances *instances, unsigned int instanceIndex)\n{\n    if (instanceIndex >= NumberOfParallelInstances)\n        return 0;\n    else\n        return instances->byteOutputIndex[instanceIndex];\n}\n\n} // namespace Seakeyakv1_raw\n"
        },
        {
            "file_name": "seakeyakv1_Keyak.cpp",
            "content": "/*\nThe Keyak authenticated encryption scheme, designed by Guido Bertoni,\nJoan Daemen, Micha\u00c3\u00abl Peeters, Gilles Van Assche and Ronny Van Keer.\nFor more information, feedback or questions, please refer to our website:\nhttp://keyak.noekeon.org/\n\nImplementation by the designers,\nhereby denoted as \"the implementer\".\n\nTo the extent possible under law, the implementer has waived all copyright\nand related or neighboring rights to the source code in this file.\nhttp://creativecommons.org/publicdomain/zero/1.0/\n*/\n\n#include <string.h>\n#include \"seakeyakv1_KeccakDuplex.h\"\n#include \"seakeyakv1_Keyak.h\"\n\n#ifdef NumberOfParallelInstances\n#include \"seakeyakv1_KeccakParallelDuplex.h\"\n#endif\n\n// CHANGE namespace moved due to includes\nnamespace Seakeyakv1_raw {\n\n#define Keyak_Phase_FeedingAssociatedData   0x01\n#define Keyak_Phase_Wrapping                0x02\n#define Keyak_Phase_Unwrapping              0x04\n\n#if ((!defined(NumberOfParallelInstances)) || (NumberOfParallelInstances == 1))\nint Keyak_Initialize(Keccak_DuplexInstance* duplex, const unsigned char *key, unsigned int keySizeInBits, const unsigned char *nonce)\n{\n    unsigned char smallData[2];\n\n    if (keySizeInBits > 224)\n        return 1;\n\n    // Key pack: 0x1E, padded key to fit on 29 bytes\n    smallData[0] = 0x1E;\n    Keccak_DuplexingFeedPartialInput(duplex, smallData, 1);\n    Keccak_DuplexingFeedPartialInput(duplex, key, keySizeInBits/8);\n    if ((keySizeInBits % 8) == 0)\n        smallData[0] = 0x01;\n    else {\n        unsigned char padding = (unsigned char)1 << (keySizeInBits%8);\n        unsigned char mask = padding-1;\n        smallData[0] = (key[keySizeInBits/8] & mask) | padding;\n    }\n    Keccak_DuplexingFeedPartialInput(duplex, smallData, 1);\n    Keccak_DuplexingFeedZeroes(duplex, 0x1E - keySizeInBits/8 - 2);\n\n    // 0x01 0x00\n    smallData[0] = 0x01;\n    smallData[1] = 0x00;\n    Keccak_DuplexingFeedPartialInput(duplex, smallData, 2);\n\n    // Nonce (16 bytes)\n    Keccak_DuplexingFeedPartialInput(duplex, nonce, 16);\n\n    return 0;\n}\n#else\nint Keyak_Initialize(Keccak_ParallelDuplexInstances* duplex, const unsigned char *key, unsigned int keySizeInBits, const unsigned char *nonce)\n{\n    unsigned char data[48];\n    unsigned int i;\n\n    if (keySizeInBits > 224)\n        return 1;\n\n    memset(data, 0, sizeof(data));\n    // Key pack: 0x1E, padded key to fit on 29 bytes\n    data[0] = 0x1E;\n    memcpy(data+1, key, keySizeInBits/8);\n    if ((keySizeInBits % 8) == 0)\n        data[keySizeInBits/8+1] = 0x01;\n    else {\n        unsigned char padding = (unsigned char)1 << (keySizeInBits%8);\n        unsigned char mask = padding-1;\n        data[keySizeInBits/8+1] = (key[keySizeInBits/8] & mask) | padding;\n    }\n    data[30] = NumberOfParallelInstances;\n    memcpy(data+32, nonce, 16);\n    for(i=0; i<NumberOfParallelInstances; i++) {\n        data[31] = i;\n        Keccak_ParallelDuplexingFeedPartialSingleInput(duplex, i, data, 48);\n    }\n\n    Keccak_ParallelDuplexingAll(duplex, 0x05); // 10\n\n    return 0;\n}\n#endif\n\n#if ((!defined(NumberOfParallelInstances)) || (NumberOfParallelInstances == 1))\nint RiverKeyak_Initialize(Keyak_Instance *instance, const unsigned char *key, unsigned int keySizeInBits, const unsigned char *nonce)\n{\n    int result = Keccak_DuplexInitialize(&(instance->duplex), 548, 252);\n    if (result != 0)\n        return result;\n    instance->phase = Keyak_Phase_FeedingAssociatedData;\n    return Keyak_Initialize(&(instance->duplex), key, keySizeInBits, nonce);\n}\n\nint LakeKeyak_Initialize(Keyak_Instance *instance, const unsigned char *key, unsigned int keySizeInBits, const unsigned char *nonce)\n{\n    int result = Keccak_DuplexInitialize(&(instance->duplex), 1348, 252);\n    if (result != 0)\n        return result;\n    instance->phase = Keyak_Phase_FeedingAssociatedData;\n    return Keyak_Initialize(&(instance->duplex), key, keySizeInBits, nonce);\n}\n#else\nint ParallelKeyak_Initialize(Keyak_Instance *instance, const unsigned char *key, unsigned int keySizeInBits, const unsigned char *nonce)\n{\n    int result = Keccak_ParallelDuplexInitializeAll(&(instance->duplex), 1348, 252);\n    if (result != 0)\n        return result;\n    instance->phase = Keyak_Phase_FeedingAssociatedData;\n    return Keyak_Initialize(&(instance->duplex), key, keySizeInBits, nonce);\n}\n#endif\n\n#if ((!defined(NumberOfParallelInstances)) || (NumberOfParallelInstances == 1))\nvoid Keyak_ProcessAssociatedData(Keccak_DuplexInstance* duplex, const unsigned char *data, unsigned int dataSizeInBytes, int last, int bodyFollows)\n{\n    unsigned int rhoInBytes = (duplex->rate-4)/8;\n\n    while(dataSizeInBytes > 0) {\n        unsigned int localSize;\n\n        if (Keccak_DuplexGetInputIndex(duplex) == rhoInBytes)\n            Keccak_Duplexing(duplex, 0, 0, 0, 0, 0x04); // 00\n\n        localSize = dataSizeInBytes;\n        if (localSize > (rhoInBytes - Keccak_DuplexGetInputIndex(duplex)))\n            localSize = rhoInBytes - Keccak_DuplexGetInputIndex(duplex);\n\n        Keccak_DuplexingFeedPartialInput(duplex, data, localSize);\n        data += localSize;\n        dataSizeInBytes -= localSize;\n    }\n\n    if (last) {\n        if (bodyFollows)\n            Keccak_Duplexing(duplex, 0, 0, 0, 0, 0x06); // 01\n        else\n            Keccak_Duplexing(duplex, 0, 0, 0, 0, 0x05); // 10\n    }\n}\n#else\nvoid Keyak_ProcessAssociatedData(Keccak_ParallelDuplexInstances* duplex, const unsigned char *data, unsigned int dataSizeInBytes, int last, int bodyFollows)\n{\n    unsigned int rhoInBytes = (duplex->rate-4)/8;\n    unsigned int totalByteInputIndex = Keccak_ParallelDuplexGetTotalInputIndex(duplex);\n\n    while(dataSizeInBytes > 0) {\n        unsigned int localSize;\n\n        if (totalByteInputIndex == rhoInBytes*NumberOfParallelInstances) {\n            Keccak_ParallelDuplexingAll(duplex, 0x04); // 00\n            totalByteInputIndex = 0;\n        }\n\n        localSize = dataSizeInBytes;\n        if (localSize > (rhoInBytes*NumberOfParallelInstances - totalByteInputIndex))\n            localSize = rhoInBytes*NumberOfParallelInstances - totalByteInputIndex;\n\n        Keccak_ParallelDuplexingFeedPartialInterleavedInput(duplex, data, localSize);\n        data += localSize;\n        dataSizeInBytes -= localSize;\n        totalByteInputIndex += localSize;\n    }\n\n    if (last) {\n        if (bodyFollows)\n            Keccak_ParallelDuplexingAll(duplex, 0x06); // 01\n        else\n            Keccak_ParallelDuplexingAll(duplex, 0x05); // 10\n    }\n}\n#endif\n\nint Keyak_FeedAssociatedData(Keyak_Instance *instance, const unsigned char *data, unsigned int dataSizeInBytes)\n{\n    if ((instance->phase & Keyak_Phase_FeedingAssociatedData) == 0)\n        return 1;\n    Keyak_ProcessAssociatedData(&(instance->duplex), data, dataSizeInBytes, 0, 0);\n    instance->phase = Keyak_Phase_FeedingAssociatedData;\n\n    return 0;\n}\n\n#if ((!defined(NumberOfParallelInstances)) || (NumberOfParallelInstances == 1))\nvoid Keyak_ProcessPlaintext(Keccak_DuplexInstance* duplex, unsigned char *data, unsigned int dataSizeInBytes, int last)\n{\n    unsigned int rhoInBytes = (duplex->rate-4)/8;\n\n    while(dataSizeInBytes > 0) {\n        unsigned int localSize;\n\n        if (Keccak_DuplexGetInputIndex(duplex) == rhoInBytes)\n            Keccak_Duplexing(duplex, 0, 0, 0, 0, 0x07); // 11\n\n        localSize = dataSizeInBytes;\n        if (localSize > (rhoInBytes - Keccak_DuplexGetInputIndex(duplex)))\n            localSize = rhoInBytes - Keccak_DuplexGetInputIndex(duplex);\n\n        Keccak_DuplexingGetFurtherOutputAndXOR(duplex, data, localSize);\n        Keccak_DuplexingOverwritePartialInput(duplex, data, localSize);\n        data += localSize;\n        dataSizeInBytes -= localSize;\n    }\n\n    if (last)\n        Keccak_Duplexing(duplex, 0, 0, 0, 0, 0x05); // 10\n}\n#else\nvoid Keyak_ProcessPlaintext(Keccak_ParallelDuplexInstances* duplex, unsigned char *data, unsigned int dataSizeInBytes, int last)\n{\n    unsigned int rhoInBytes = (duplex->rate-4)/8;\n    unsigned int totalByteInputIndex = Keccak_ParallelDuplexGetTotalInputIndex(duplex);\n\n    while(dataSizeInBytes > 0) {\n        unsigned int localSize;\n\n        if (totalByteInputIndex == rhoInBytes*NumberOfParallelInstances) {\n            Keccak_ParallelDuplexingAll(duplex, 0x07); // 11\n            totalByteInputIndex = 0;\n        }\n\n        localSize = dataSizeInBytes;\n        if (localSize > (rhoInBytes*NumberOfParallelInstances - totalByteInputIndex))\n            localSize = rhoInBytes*NumberOfParallelInstances - totalByteInputIndex;\n\n        Keccak_ParallelDuplexingGetFurtherInterleavedOutputAndXOR(duplex, data, localSize);\n        Keccak_ParallelDuplexingOverwritePartialInterleavedInput(duplex, data, localSize);\n        data += localSize;\n        dataSizeInBytes -= localSize;\n        totalByteInputIndex += localSize;\n    }\n\n    if (last)\n        Keccak_ParallelDuplexingAll(duplex, 0x05); // 10\n}\n#endif\n\nint Keyak_WrapPlaintext(Keyak_Instance *instance, const unsigned char *plaintext, unsigned char *ciphertext, unsigned int dataSizeInBytes)\n{\n    if (dataSizeInBytes > 0) {\n        if ((instance->phase & Keyak_Phase_FeedingAssociatedData) != 0) {\n            Keyak_ProcessAssociatedData(&(instance->duplex), 0, 0, 1, 1);\n            instance->phase = Keyak_Phase_Wrapping;\n        }\n        if ((instance->phase & Keyak_Phase_Wrapping) == 0)\n            return 1;\n        if (plaintext != ciphertext)\n            memcpy(ciphertext, plaintext, dataSizeInBytes);\n        Keyak_ProcessPlaintext(&(instance->duplex), ciphertext, dataSizeInBytes, 0);\n        instance->phase = Keyak_Phase_Wrapping;\n    }\n\n    return 0;\n}\n\n#if ((!defined(NumberOfParallelInstances)) || (NumberOfParallelInstances == 1))\nvoid Keyak_ProcessCiphertext(Keccak_DuplexInstance* duplex, unsigned char *data, unsigned int dataSizeInBytes, int last)\n{\n    unsigned int rhoInBytes = (duplex->rate-4)/8;\n\n    while(dataSizeInBytes > 0) {\n        unsigned int localSize;\n\n        if (Keccak_DuplexGetInputIndex(duplex) == rhoInBytes)\n            Keccak_Duplexing(duplex, 0, 0, 0, 0, 0x07); // 11\n\n        localSize = dataSizeInBytes;\n        if (localSize > (rhoInBytes - Keccak_DuplexGetInputIndex(duplex)))\n            localSize = rhoInBytes - Keccak_DuplexGetInputIndex(duplex);\n\n        Keccak_DuplexingGetFurtherOutputAndXOR(duplex, data, localSize);\n        Keccak_DuplexingFeedPartialInput(duplex, data, localSize);\n        data += localSize;\n        dataSizeInBytes -= localSize;\n    }\n\n    if (last)\n        Keccak_Duplexing(duplex, 0, 0, 0, 0, 0x05); // 10\n}\n#else\nvoid Keyak_ProcessCiphertext(Keccak_ParallelDuplexInstances* duplex, unsigned char *data, unsigned int dataSizeInBytes, int last)\n{\n    unsigned int rhoInBytes = (duplex->rate-4)/8;\n    unsigned int totalByteInputIndex = Keccak_ParallelDuplexGetTotalInputIndex(duplex);\n\n    while(dataSizeInBytes > 0) {\n        unsigned int localSize;\n\n        if (totalByteInputIndex == rhoInBytes*NumberOfParallelInstances) {\n            Keccak_ParallelDuplexingAll(duplex, 0x07); // 11\n            totalByteInputIndex = 0;\n        }\n\n        localSize = dataSizeInBytes;\n        if (localSize > (rhoInBytes*NumberOfParallelInstances - totalByteInputIndex))\n            localSize = rhoInBytes*NumberOfParallelInstances - totalByteInputIndex;\n\n        Keccak_ParallelDuplexingGetFurtherInterleavedOutputAndXOR(duplex, data, localSize);\n        Keccak_ParallelDuplexingFeedPartialInterleavedInput(duplex, data, localSize);\n        data += localSize;\n        dataSizeInBytes -= localSize;\n        totalByteInputIndex += localSize;\n    }\n\n    if (last)\n        Keccak_ParallelDuplexingAll(duplex, 0x05); // 10\n}\n#endif\n\nint Keyak_UnwrapCiphertext(Keyak_Instance *instance, const unsigned char *ciphertext, unsigned char *plaintext, unsigned int dataSizeInBytes)\n{\n    if (dataSizeInBytes > 0) {\n        if ((instance->phase & Keyak_Phase_FeedingAssociatedData) != 0) {\n            Keyak_ProcessAssociatedData(&(instance->duplex), 0, 0, 1, 1);\n            instance->phase = Keyak_Phase_Unwrapping;\n        }\n        if ((instance->phase & Keyak_Phase_Unwrapping) == 0)\n            return 1;\n        if (plaintext != ciphertext)\n            memcpy(plaintext, ciphertext, dataSizeInBytes);\n        Keyak_ProcessCiphertext(&(instance->duplex), plaintext, dataSizeInBytes, 0);\n        instance->phase = Keyak_Phase_Unwrapping;\n    }\n\n    return 0;\n}\n\n#if ((!defined(NumberOfParallelInstances)) || (NumberOfParallelInstances == 1))\nvoid Keyak_ProcessTag(Keccak_DuplexInstance* duplex, unsigned char *tag, unsigned int tagSizeInBytes)\n{\n    unsigned int rhoInBytes = (duplex->rate-4)/8;\n\n    while(tagSizeInBytes > 0) {\n        unsigned int localSize;\n\n        if (Keccak_DuplexGetInputIndex(duplex) == rhoInBytes)\n            Keccak_Duplexing(duplex, 0, 0, 0, 0, 0x02); // 0\n\n        localSize = tagSizeInBytes;\n        if (localSize > (rhoInBytes - Keccak_DuplexGetInputIndex(duplex)))\n            localSize = rhoInBytes - Keccak_DuplexGetInputIndex(duplex);\n\n        Keccak_DuplexingGetFurtherOutput(duplex, tag, localSize);\n        tag += localSize;\n        tagSizeInBytes -= localSize;\n    }\n}\n#else\nvoid Keyak_ProcessTag(Keccak_ParallelDuplexInstances* duplex, unsigned char *tag, unsigned int tagSizeInBytes)\n{\n    unsigned int rhoInBytes = (duplex->rate-4)/8;\n    unsigned char buffer[32];\n    unsigned int i;\n\n    // This assumes that (P-1)*256 <= rho_max\n    for(i=1; i<NumberOfParallelInstances; i++) {\n        Keccak_ParallelDuplexingGetFurtherSingleOutput(duplex, i, buffer, 32);\n        Keccak_ParallelDuplexingFeedPartialSingleInput(duplex, 0, buffer, 32);\n    }\n    Keccak_ParallelDuplexing(duplex, 0, 0x05); // 10\n\n    while(tagSizeInBytes > 0) {\n        unsigned int localSize;\n\n        if (Keccak_ParallelDuplexGetOutputIndex(duplex, 0) == rhoInBytes)\n            Keccak_ParallelDuplexing(duplex, 0, 0x02); // 0\n\n        localSize = tagSizeInBytes;\n        if (localSize > (rhoInBytes - Keccak_ParallelDuplexGetOutputIndex(duplex, 0)))\n            localSize = rhoInBytes - Keccak_ParallelDuplexGetOutputIndex(duplex, 0);\n\n        Keccak_ParallelDuplexingGetFurtherSingleOutput(duplex, 0, tag, localSize);\n        tag += localSize;\n        tagSizeInBytes -= localSize;\n    }\n}\n#endif\n\nint Keyak_GetTag(Keyak_Instance *instance, unsigned char *tag, unsigned int tagSizeInBytes)\n{\n    if ((instance->phase & Keyak_Phase_FeedingAssociatedData) != 0)\n        Keyak_ProcessAssociatedData(&(instance->duplex), 0, 0, 1, 0);\n    else if ((instance->phase & Keyak_Phase_Wrapping) != 0)\n        Keyak_ProcessPlaintext(&(instance->duplex), 0, 0, 1);\n    else if ((instance->phase & Keyak_Phase_Unwrapping) != 0)\n        Keyak_ProcessCiphertext(&(instance->duplex), 0, 0, 1);\n    Keyak_ProcessTag(&(instance->duplex), tag, tagSizeInBytes);\n    instance->phase = Keyak_Phase_FeedingAssociatedData;\n\n    return 0;\n}\n\n#if ((!defined(NumberOfParallelInstances)) || (NumberOfParallelInstances == 1))\nvoid Keyak_ProcessForget(Keccak_DuplexInstance* duplex)\n{\n    unsigned int rhoInBytes = (duplex->rate-4)/8;\n\n    Keccak_Duplexing(duplex, 0, 0, 0, 0, 0x01);\n    Keccak_DuplexingOverwriteWithZeroes(duplex, rhoInBytes);\n    Keccak_Duplexing(duplex, 0, 0, 0, 0, 0x01);\n}\n#else\nvoid Keyak_ProcessForget(Keccak_ParallelDuplexInstances* duplex)\n{\n    unsigned int rhoInBytes = (duplex->rate-4)/8;\n    unsigned int i;\n\n    Keccak_ParallelDuplexingAll(duplex, 0x01);\n    for(i=0; i<NumberOfParallelInstances; i++)\n        Keccak_ParallelDuplexingOverwriteWithZeroes(duplex, i, rhoInBytes);\n    Keccak_ParallelDuplexingAll(duplex, 0x01);\n}\n#endif\n\nint Keyak_Forget(Keyak_Instance *instance)\n{\n    Keyak_ProcessForget(&(instance->duplex));\n    instance->phase = Keyak_Phase_FeedingAssociatedData;\n    return 0;\n}\n\n} // namespace Seakeyakv1_raw\n"
        },
        {
            "file_name": "Serpent.cpp",
            "content": "#include \"stdafx.h\"\n\n#  pragma intrinsic(_lrotr,_lrotl)\n\n#  define rotr(x,n) _lrotr(x,n)\n#  define rotl(x,n) _lrotl(x,n)\n\n#define bswap(x)    (rotl(x, 8) & 0x00ff00ff | rotr(x, 8) & 0xff00ff00)\n\n#define byte(x,n)   ((BYTE)((x) >> (8 * n)))\n\n// ??\n#define BLOCK_SWAP\n\n#ifdef  BLOCK_SWAP\n#define BYTE_SWAP\n#define WORD_SWAP\n#endif\n\n#ifdef  BYTE_SWAP\n#define io_swap(x)  bswap(x)\n#else\n#define io_swap(x)  (x)\n#endif\n\n#ifdef  WORD_SWAP\n\n#define get_block(x)                            \\\n    ((DWORD *)(x))[0] = io_swap(in_blk[3]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_blk[2]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_blk[1]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_blk[0])\n\n#define put_block(x)                            \\\n    out_blk[3] = io_swap(((DWORD *)(x))[0]);    \\\n    out_blk[2] = io_swap(((DWORD *)(x))[1]);    \\\n    out_blk[1] = io_swap(((DWORD *)(x))[2]);    \\\n    out_blk[0] = io_swap(((DWORD *)(x))[3])\n\n#define get_key(x,len)                          \\\n    ((DWORD *)(x))[4] = ((DWORD *)(x))[5] =     \\\n    ((DWORD *)(x))[6] = ((DWORD *)(x))[7] = 0;  \\\n    switch((((len) + 63) / 64)) {               \\\n    case 2:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[0]);     \\\n    break;                                      \\\n    case 3:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[5]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[0]);     \\\n    break;                                      \\\n    case 4:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[7]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[6]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[5]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[6] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[7] = io_swap(in_key[0]);     \\\n    }\n\n#else\n\n#define get_block(x)                            \\\n    ((DWORD *)(x))[0] = io_swap(in_blk[0]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_blk[1]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_blk[2]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_blk[3])\n\n#define put_block(x)                            \\\n    out_blk[0] = io_swap(((DWORD *)(x))[0]);    \\\n    out_blk[1] = io_swap(((DWORD *)(x))[1]);    \\\n    out_blk[2] = io_swap(((DWORD *)(x))[2]);    \\\n    out_blk[3] = io_swap(((DWORD *)(x))[3])\n\n#define get_key(x,len)                          \\\n    ((DWORD *)(x))[4] = ((DWORD *)(x))[5] =     \\\n    ((DWORD *)(x))[6] = ((DWORD *)(x))[7] = 0;  \\\n    switch((((len) + 63) / 64)) {               \\\n    case 4:                                     \\\n    ((DWORD *)(x))[6] = io_swap(in_key[6]);     \\\n    ((DWORD *)(x))[7] = io_swap(in_key[7]);     \\\n    case 3:                                     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[5]);     \\\n    case 2:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[0]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[3]);     \\\n    }\n\n#endif\n\n#define sb0(a,b,c,d,e,f,g,h)    \\\n    t1 = a ^ d;     \\\n    t2 = a & d;     \\\n    t3 = c ^ t1;    \\\n    t6 = b & t1;    \\\n    t4 = b ^ t3;    \\\n    t10 = ~t3;      \\\n    h = t2 ^ t4;    \\\n    t7 = a ^ t6;    \\\n    t14 = ~t7;      \\\n    t8 = c | t7;    \\\n    t11 = t3 ^ t7;  \\\n    g = t4 ^ t8;    \\\n    t12 = h & t11;  \\\n    f = t10 ^ t12;  \\\n    e = t12 ^ t14\n\n/* 15 terms */\n\n#define ib0(a,b,c,d,e,f,g,h)    \\\n    t1 = ~a;        \\\n    t2 = a ^ b;     \\\n    t3 = t1 | t2;   \\\n    t4 = d ^ t3;    \\\n    t7 = d & t2;    \\\n    t5 = c ^ t4;    \\\n    t8 = t1 ^ t7;   \\\n    g = t2 ^ t5;    \\\n    t11 = a & t4;   \\\n    t9 = g & t8;    \\\n    t14 = t5 ^ t8;  \\\n    f = t4 ^ t9;    \\\n    t12 = t5 | f;   \\\n    h = t11 ^ t12;  \\\n    e = h ^ t14\n\n/* 14 terms!  */\n\n#define sb1(a,b,c,d,e,f,g,h)    \\\n    t1 = ~a;        \\\n    t2 = b ^ t1;    \\\n    t3 = a | t2;    \\\n    t4 = d | t2;    \\\n    t5 = c ^ t3;    \\\n    g = d ^ t5;     \\\n    t7 = b ^ t4;    \\\n    t8 = t2 ^ g;    \\\n    t9 = t5 & t7;   \\\n    h = t8 ^ t9;    \\\n    t11 = t5 ^ t7;  \\\n    f = h ^ t11;    \\\n    t13 = t8 & t11; \\\n    e = t5 ^ t13\n\n/* 17 terms */\n\n#define ib1(a,b,c,d,e,f,g,h)    \\\n    t1 = a ^ d;     \\\n    t2 = a & b;     \\\n    t3 = b ^ c;     \\\n    t4 = a ^ t3;    \\\n    t5 = b | d;     \\\n    t7 = c | t1;    \\\n    h = t4 ^ t5;    \\\n    t8 = b ^ t7;    \\\n    t11 = ~t2;      \\\n    t9 = t4 & t8;   \\\n    f = t1 ^ t9;    \\\n    t13 = t9 ^ t11; \\\n    t12 = h & f;    \\\n    g = t12 ^ t13;  \\\n    t15 = a & d;    \\\n    t16 = c ^ t13;  \\\n    e = t15 ^ t16\n\n/* 16 terms */\n\n#define sb2(a,b,c,d,e,f,g,h)    \\\n    t1 = ~a;        \\\n    t2 = b ^ d;     \\\n    t3 = c & t1;    \\\n    t13 = d | t1;   \\\n    e = t2 ^ t3;    \\\n    t5 = c ^ t1;    \\\n    t6 = c ^ e;     \\\n    t7 = b & t6;    \\\n    t10 = e | t5;   \\\n    h = t5 ^ t7;    \\\n    t9 = d | t7;    \\\n    t11 = t9 & t10; \\\n    t14 = t2 ^ h;   \\\n    g = a ^ t11;    \\\n    t15 = g ^ t13;  \\\n    f = t14 ^ t15\n\n/* 16 terms */\n\n#define ib2(a,b,c,d,e,f,g,h)    \\\n    t1 = b ^ d;     \\\n    t2 = ~t1;       \\\n    t3 = a ^ c;     \\\n    t4 = c ^ t1;    \\\n    t7 = a | t2;    \\\n    t5 = b & t4;    \\\n    t8 = d ^ t7;    \\\n    t11 = ~t4;      \\\n    e = t3 ^ t5;    \\\n    t9 = t3 | t8;   \\\n    t14 = d & t11;  \\\n    h = t1 ^ t9;    \\\n    t12 = e | h;    \\\n    f = t11 ^ t12;  \\\n    t15 = t3 ^ t12; \\\n    g = t14 ^ t15\n\n/* 17 terms */\n\n#define sb3(a,b,c,d,e,f,g,h)    \\\n    t1 = a ^ c;     \\\n    t2 = d ^ t1;    \\\n    t3 = a & t2;    \\\n    t4 = d ^ t3;    \\\n    t5 = b & t4;    \\\n    g = t2 ^ t5;    \\\n    t7 = a | g;     \\\n    t8 = b | d;     \\\n    t11 = a | d;    \\\n    t9 = t4 & t7;   \\\n    f = t8 ^ t9;    \\\n    t12 = b ^ t11;  \\\n    t13 = g ^ t9;   \\\n    t15 = t3 ^ t8;  \\\n    h = t12 ^ t13;  \\\n    t16 = c & t15;  \\\n    e = t12 ^ t16\n\n/* 16 term solution that performs less well than 17 term one\n   in my environment (PPro/PII)                                  \n\n#define sb3(a,b,c,d,e,f,g,h)    \\\n    t1 = a ^ b;     \\\n    t2 = a & c;     \\\n    t3 = a | d;     \\\n    t4 = c ^ d;     \\\n    t5 = t1 & t3;   \\\n    t6 = t2 | t5;   \\\n    g = t4 ^ t6;    \\\n    t8 = b ^ t3;    \\\n    t9 = t6 ^ t8;   \\\n    t10 = t4 & t9;  \\\n    e = t1 ^ t10;   \\\n    t12 = g & e;    \\\n    f = t9 ^ t12;   \\\n    t14 = b | d;    \\\n    t15 = t4 ^ t12; \\\n    h = t14 ^ t15\n*/\n\n/* 17 terms */\n\n#define ib3(a,b,c,d,e,f,g,h)    \\\n    t1 = b ^ c;     \\\n    t2 = b | c;     \\\n    t3 = a ^ c;     \\\n    t7 = a ^ d;     \\\n    t4 = t2 ^ t3;   \\\n    t5 = d | t4;    \\\n    t9 = t2 ^ t7;   \\\n    e = t1 ^ t5;    \\\n    t8 = t1 | t5;   \\\n    t11 = a & t4;   \\\n    g = t8 ^ t9;    \\\n    t12 = e | t9;   \\\n    f = t11 ^ t12;  \\\n    t14 = a & g;    \\\n    t15 = t2 ^ t14; \\\n    t16 = e & t15;  \\\n    h = t4 ^ t16\n\n/* 15 terms */\n\n#define sb4(a,b,c,d,e,f,g,h)    \\\n    t1 = a ^ d;     \\\n    t2 = d & t1;    \\\n    t3 = c ^ t2;    \\\n    t4 = b | t3;    \\\n    h = t1 ^ t4;    \\\n    t6 = ~b;        \\\n    t7 = t1 | t6;   \\\n    e = t3 ^ t7;    \\\n    t9 = a & e;     \\\n    t10 = t1 ^ t6;  \\\n    t11 = t4 & t10; \\\n    g = t9 ^ t11;   \\\n    t13 = a ^ t3;   \\\n    t14 = t10 & g;  \\\n    f = t13 ^ t14\n\n/* 17 terms */\n\n#define ib4(a,b,c,d,e,f,g,h)    \\\n    t1 = c ^ d;     \\\n    t2 = c | d;     \\\n    t3 = b ^ t2;    \\\n    t4 = a & t3;    \\\n    f = t1 ^ t4;    \\\n    t6 = a ^ d;     \\\n    t7 = b | d;     \\\n    t8 = t6 & t7;   \\\n    h = t3 ^ t8;    \\\n    t10 = ~a;       \\\n    t11 = c ^ h;    \\\n    t12 = t10 | t11;\\\n    e = t3 ^ t12;   \\\n    t14 = c | t4;   \\\n    t15 = t7 ^ t14; \\\n    t16 = h | t10;  \\\n    g = t15 ^ t16\n\n/* 16 terms */\n\n#define sb5(a,b,c,d,e,f,g,h)    \\\n    t1 = ~a;        \\\n    t2 = a ^ b;     \\\n    t3 = a ^ d;     \\\n    t4 = c ^ t1;    \\\n    t5 = t2 | t3;   \\\n    e = t4 ^ t5;    \\\n    t7 = d & e;     \\\n    t8 = t2 ^ e;    \\\n    t10 = t1 | e;   \\\n    f = t7 ^ t8;    \\\n    t11 = t2 | t7;  \\\n    t12 = t3 ^ t10; \\\n    t14 = b ^ t7;   \\\n    g = t11 ^ t12;  \\\n    t15 = f & t12;  \\\n    h = t14 ^ t15\n\n/* 16 terms */\n\n#define ib5(a,b,c,d,e,f,g,h)    \\\n    t1 = ~c;        \\\n    t2 = b & t1;    \\\n    t3 = d ^ t2;    \\\n    t4 = a & t3;    \\\n    t5 = b ^ t1;    \\\n    h = t4 ^ t5;    \\\n    t7 = b | h;     \\\n    t8 = a & t7;    \\\n    f = t3 ^ t8;    \\\n    t10 = a | d;    \\\n    t11 = t1 ^ t7;  \\\n    e = t10 ^ t11;  \\\n    t13 = a ^ c;    \\\n    t14 = b & t10;  \\\n    t15 = t4 | t13; \\\n    g = t14 ^ t15\n\n/* 15 terms */\n\n#define sb6(a,b,c,d,e,f,g,h)    \\\n    t1 = ~a;        \\\n    t2 = a ^ d;     \\\n    t3 = b ^ t2;    \\\n    t4 = t1 | t2;   \\\n    t5 = c ^ t4;    \\\n    f = b ^ t5;     \\\n    t13 = ~t5;      \\\n    t7 = t2 | f;    \\\n    t8 = d ^ t7;    \\\n    t9 = t5 & t8;   \\\n    g = t3 ^ t9;    \\\n    t11 = t5 ^ t8;  \\\n    e = g ^ t11;    \\\n    t14 = t3 & t11; \\\n    h = t13 ^ t14\n\n/* 15 terms */\n\n#define ib6(a,b,c,d,e,f,g,h)    \\\n    t1 = ~a;        \\\n    t2 = a ^ b;     \\\n    t3 = c ^ t2;    \\\n    t4 = c | t1;    \\\n    t5 = d ^ t4;    \\\n    t13 = d & t1;   \\\n    f = t3 ^ t5;    \\\n    t7 = t3 & t5;   \\\n    t8 = t2 ^ t7;   \\\n    t9 = b | t8;    \\\n    h = t5 ^ t9;    \\\n    t11 = b | h;    \\\n    e = t8 ^ t11;   \\\n    t14 = t3 ^ t11; \\\n    g = t13 ^ t14\n\n/* 17 terms */\n\n#define sb7(a,b,c,d,e,f,g,h)    \\\n    t1 = ~c;        \\\n    t2 = b ^ c;     \\\n    t3 = b | t1;    \\\n    t4 = d ^ t3;    \\\n    t5 = a & t4;    \\\n    t7 = a ^ d;     \\\n    h = t2 ^ t5;    \\\n    t8 = b ^ t5;    \\\n    t9 = t2 | t8;   \\\n    t11 = d & t3;   \\\n    f = t7 ^ t9;    \\\n    t12 = t5 ^ f;   \\\n    t15 = t1 | t4;  \\\n    t13 = h & t12;  \\\n    g = t11 ^ t13;  \\\n    t16 = t12 ^ g;  \\\n    e = t15 ^ t16\n\n/* 17 terms */\n\n#define ib7(a,b,c,d,e,f,g,h)    \\\n    t1 = a & b;     \\\n    t2 = a | b;     \\\n    t3 = c | t1;    \\\n    t4 = d & t2;    \\\n    h = t3 ^ t4;    \\\n    t6 = ~d;        \\\n    t7 = b ^ t4;    \\\n    t8 = h ^ t6;    \\\n    t11 = c ^ t7;   \\\n    t9 = t7 | t8;   \\\n    f = a ^ t9;     \\\n    t12 = d | f;    \\\n    e = t11 ^ t12;  \\\n    t14 = a & h;    \\\n    t15 = t3 ^ f;   \\\n    t16 = e ^ t14;  \\\n    g = t15 ^ t16\n\n#define k_xor(r,a,b,c,d)    \\\n    a ^= l_key[4 * r +  8]; \\\n    b ^= l_key[4 * r +  9]; \\\n    c ^= l_key[4 * r + 10]; \\\n    d ^= l_key[4 * r + 11]\n\n#define k_set(r,a,b,c,d)    \\\n    a = l_key[4 * r +  8];  \\\n    b = l_key[4 * r +  9];  \\\n    c = l_key[4 * r + 10];  \\\n    d = l_key[4 * r + 11]\n\n#define k_get(r,a,b,c,d)    \\\n    l_key[4 * r +  8] = a;  \\\n    l_key[4 * r +  9] = b;  \\\n    l_key[4 * r + 10] = c;  \\\n    l_key[4 * r + 11] = d\n\n/* the linear transformation and its inverse    */\n\n#define rot(a,b,c,d)    \\\n    a = rotl(a, 13);    \\\n    c = rotl(c, 3);     \\\n    d ^= c ^ (a << 3);  \\\n    b ^= a ^ c;         \\\n    d = rotl(d, 7);     \\\n    b = rotl(b, 1);     \\\n    a ^= b ^ d;         \\\n    c ^= d ^ (b << 7);  \\\n    a = rotl(a, 5);     \\\n    c = rotl(c, 22)\n\n#define irot(a,b,c,d)   \\\n    c = rotr(c, 22);    \\\n    a = rotr(a, 5);     \\\n    c ^= d ^ (b << 7);  \\\n    a ^= b ^ d;         \\\n    d = rotr(d, 7);     \\\n    b = rotr(b, 1);     \\\n    d ^= c ^ (a << 3);  \\\n    b ^= a ^ c;         \\\n    c = rotr(c, 3);     \\\n    a = rotr(a, 13)\n\nvoid Serpent_set_key(DWORD *l_key,const DWORD *in_key, const DWORD key_len)\n{\n\tDWORD  i,lk,a,b,c,d,e,f,g,h;\n    DWORD  t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16;\n\n    if(key_len < 0 || key_len > 256)\n\n        return;\n\n    i = 0; lk = (key_len + 31) / 32;\n    \n    while(i < lk)\n    {\n#ifdef  BLOCK_SWAP\n        l_key[i] = io_swap(in_key[lk - i - 1]);\n#else\n        l_key[i] = in_key[i];\n#endif  \n        i++;\n    }\n\n    if(key_len < 256)\n    {\n        while(i < 8)\n\n            l_key[i++] = 0;\n\n        i = key_len / 32; lk = 1 << key_len % 32; \n\n        l_key[i] = l_key[i] & (lk - 1) | lk;\n    }\n\n    for(i = 0; i < 132; ++i)\n    {\n        lk = l_key[i] ^ l_key[i + 3] ^ l_key[i + 5] \n                                ^ l_key[i + 7] ^ 0x9e3779b9 ^ i;\n\n        l_key[i + 8] = (lk << 11) | (lk >> 21); \n    }\n\n    k_set( 0,a,b,c,d);sb3(a,b,c,d,e,f,g,h);k_get( 0,e,f,g,h);\n    k_set( 1,a,b,c,d);sb2(a,b,c,d,e,f,g,h);k_get( 1,e,f,g,h);\n    k_set( 2,a,b,c,d);sb1(a,b,c,d,e,f,g,h);k_get( 2,e,f,g,h);\n    k_set( 3,a,b,c,d);sb0(a,b,c,d,e,f,g,h);k_get( 3,e,f,g,h);\n    k_set( 4,a,b,c,d);sb7(a,b,c,d,e,f,g,h);k_get( 4,e,f,g,h);\n    k_set( 5,a,b,c,d);sb6(a,b,c,d,e,f,g,h);k_get( 5,e,f,g,h);\n    k_set( 6,a,b,c,d);sb5(a,b,c,d,e,f,g,h);k_get( 6,e,f,g,h);\n    k_set( 7,a,b,c,d);sb4(a,b,c,d,e,f,g,h);k_get( 7,e,f,g,h);\n    k_set( 8,a,b,c,d);sb3(a,b,c,d,e,f,g,h);k_get( 8,e,f,g,h);\n    k_set( 9,a,b,c,d);sb2(a,b,c,d,e,f,g,h);k_get( 9,e,f,g,h);\n    k_set(10,a,b,c,d);sb1(a,b,c,d,e,f,g,h);k_get(10,e,f,g,h);\n    k_set(11,a,b,c,d);sb0(a,b,c,d,e,f,g,h);k_get(11,e,f,g,h);\n    k_set(12,a,b,c,d);sb7(a,b,c,d,e,f,g,h);k_get(12,e,f,g,h);\n    k_set(13,a,b,c,d);sb6(a,b,c,d,e,f,g,h);k_get(13,e,f,g,h);\n    k_set(14,a,b,c,d);sb5(a,b,c,d,e,f,g,h);k_get(14,e,f,g,h);\n    k_set(15,a,b,c,d);sb4(a,b,c,d,e,f,g,h);k_get(15,e,f,g,h);\n    k_set(16,a,b,c,d);sb3(a,b,c,d,e,f,g,h);k_get(16,e,f,g,h);\n    k_set(17,a,b,c,d);sb2(a,b,c,d,e,f,g,h);k_get(17,e,f,g,h);\n    k_set(18,a,b,c,d);sb1(a,b,c,d,e,f,g,h);k_get(18,e,f,g,h);\n    k_set(19,a,b,c,d);sb0(a,b,c,d,e,f,g,h);k_get(19,e,f,g,h);\n    k_set(20,a,b,c,d);sb7(a,b,c,d,e,f,g,h);k_get(20,e,f,g,h);\n    k_set(21,a,b,c,d);sb6(a,b,c,d,e,f,g,h);k_get(21,e,f,g,h);\n    k_set(22,a,b,c,d);sb5(a,b,c,d,e,f,g,h);k_get(22,e,f,g,h);\n    k_set(23,a,b,c,d);sb4(a,b,c,d,e,f,g,h);k_get(23,e,f,g,h);\n    k_set(24,a,b,c,d);sb3(a,b,c,d,e,f,g,h);k_get(24,e,f,g,h);\n    k_set(25,a,b,c,d);sb2(a,b,c,d,e,f,g,h);k_get(25,e,f,g,h);\n    k_set(26,a,b,c,d);sb1(a,b,c,d,e,f,g,h);k_get(26,e,f,g,h);\n    k_set(27,a,b,c,d);sb0(a,b,c,d,e,f,g,h);k_get(27,e,f,g,h);\n    k_set(28,a,b,c,d);sb7(a,b,c,d,e,f,g,h);k_get(28,e,f,g,h);\n    k_set(29,a,b,c,d);sb6(a,b,c,d,e,f,g,h);k_get(29,e,f,g,h);\n    k_set(30,a,b,c,d);sb5(a,b,c,d,e,f,g,h);k_get(30,e,f,g,h);\n    k_set(31,a,b,c,d);sb4(a,b,c,d,e,f,g,h);k_get(31,e,f,g,h);\n    k_set(32,a,b,c,d);sb3(a,b,c,d,e,f,g,h);k_get(32,e,f,g,h);\n}\n\nvoid Serpent_encrypt(const DWORD *l_key,const DWORD *in_blk, DWORD *out_blk)\n{\n\tDWORD  a,b,c,d,e,f,g,h;\n    DWORD  t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16;\n    \n#ifdef  BLOCK_SWAP\n    a = io_swap(in_blk[3]); b = io_swap(in_blk[2]); \n    c = io_swap(in_blk[1]); d = io_swap(in_blk[0]);\n#else\n    a = in_blk[0]; b = in_blk[1]; c = in_blk[2]; d = in_blk[3];\n#endif\n\n    k_xor( 0,a,b,c,d); sb0(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor( 1,e,f,g,h); sb1(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor( 2,a,b,c,d); sb2(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor( 3,e,f,g,h); sb3(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor( 4,a,b,c,d); sb4(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor( 5,e,f,g,h); sb5(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor( 6,a,b,c,d); sb6(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor( 7,e,f,g,h); sb7(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor( 8,a,b,c,d); sb0(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor( 9,e,f,g,h); sb1(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor(10,a,b,c,d); sb2(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor(11,e,f,g,h); sb3(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor(12,a,b,c,d); sb4(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor(13,e,f,g,h); sb5(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor(14,a,b,c,d); sb6(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor(15,e,f,g,h); sb7(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor(16,a,b,c,d); sb0(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor(17,e,f,g,h); sb1(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor(18,a,b,c,d); sb2(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor(19,e,f,g,h); sb3(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor(20,a,b,c,d); sb4(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor(21,e,f,g,h); sb5(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor(22,a,b,c,d); sb6(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor(23,e,f,g,h); sb7(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor(24,a,b,c,d); sb0(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor(25,e,f,g,h); sb1(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor(26,a,b,c,d); sb2(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor(27,e,f,g,h); sb3(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor(28,a,b,c,d); sb4(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor(29,e,f,g,h); sb5(e,f,g,h,a,b,c,d); rot(a,b,c,d); \n    k_xor(30,a,b,c,d); sb6(a,b,c,d,e,f,g,h); rot(e,f,g,h); \n    k_xor(31,e,f,g,h); sb7(e,f,g,h,a,b,c,d); k_xor(32,a,b,c,d); \n    \n#ifdef  BLOCK_SWAP\n    out_blk[3] = io_swap(a); out_blk[2] = io_swap(b); \n    out_blk[1] = io_swap(c); out_blk[0] = io_swap(d);\n#else\n    out_blk[0] = a; out_blk[1] = b; out_blk[2] = c; out_blk[3] = d;\n#endif\n}\n\nvoid Serpent_decrypt(const DWORD *l_key,const DWORD *in_blk, DWORD *out_blk)\n{\n\tDWORD  a,b,c,d,e,f,g,h;\n    DWORD  t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16;\n    \n#ifdef  BLOCK_SWAP\n    a = io_swap(in_blk[3]); b = io_swap(in_blk[2]); \n    c = io_swap(in_blk[1]); d = io_swap(in_blk[0]);\n#else\n    a = in_blk[0]; b = in_blk[1]; c = in_blk[2]; d = in_blk[3];\n#endif\n\n    k_xor(32,a,b,c,d); ib7(a,b,c,d,e,f,g,h); k_xor(31,e,f,g,h);\n    irot(e,f,g,h); ib6(e,f,g,h,a,b,c,d); k_xor(30,a,b,c,d);\n    irot(a,b,c,d); ib5(a,b,c,d,e,f,g,h); k_xor(29,e,f,g,h);\n    irot(e,f,g,h); ib4(e,f,g,h,a,b,c,d); k_xor(28,a,b,c,d);\n    irot(a,b,c,d); ib3(a,b,c,d,e,f,g,h); k_xor(27,e,f,g,h);\n    irot(e,f,g,h); ib2(e,f,g,h,a,b,c,d); k_xor(26,a,b,c,d);\n    irot(a,b,c,d); ib1(a,b,c,d,e,f,g,h); k_xor(25,e,f,g,h);\n    irot(e,f,g,h); ib0(e,f,g,h,a,b,c,d); k_xor(24,a,b,c,d);\n    irot(a,b,c,d); ib7(a,b,c,d,e,f,g,h); k_xor(23,e,f,g,h);\n    irot(e,f,g,h); ib6(e,f,g,h,a,b,c,d); k_xor(22,a,b,c,d);\n    irot(a,b,c,d); ib5(a,b,c,d,e,f,g,h); k_xor(21,e,f,g,h);\n    irot(e,f,g,h); ib4(e,f,g,h,a,b,c,d); k_xor(20,a,b,c,d);\n    irot(a,b,c,d); ib3(a,b,c,d,e,f,g,h); k_xor(19,e,f,g,h);\n    irot(e,f,g,h); ib2(e,f,g,h,a,b,c,d); k_xor(18,a,b,c,d);\n    irot(a,b,c,d); ib1(a,b,c,d,e,f,g,h); k_xor(17,e,f,g,h);\n    irot(e,f,g,h); ib0(e,f,g,h,a,b,c,d); k_xor(16,a,b,c,d);\n    irot(a,b,c,d); ib7(a,b,c,d,e,f,g,h); k_xor(15,e,f,g,h);\n    irot(e,f,g,h); ib6(e,f,g,h,a,b,c,d); k_xor(14,a,b,c,d);\n    irot(a,b,c,d); ib5(a,b,c,d,e,f,g,h); k_xor(13,e,f,g,h);\n    irot(e,f,g,h); ib4(e,f,g,h,a,b,c,d); k_xor(12,a,b,c,d);\n    irot(a,b,c,d); ib3(a,b,c,d,e,f,g,h); k_xor(11,e,f,g,h);\n    irot(e,f,g,h); ib2(e,f,g,h,a,b,c,d); k_xor(10,a,b,c,d);\n    irot(a,b,c,d); ib1(a,b,c,d,e,f,g,h); k_xor( 9,e,f,g,h);\n    irot(e,f,g,h); ib0(e,f,g,h,a,b,c,d); k_xor( 8,a,b,c,d);\n    irot(a,b,c,d); ib7(a,b,c,d,e,f,g,h); k_xor( 7,e,f,g,h);\n    irot(e,f,g,h); ib6(e,f,g,h,a,b,c,d); k_xor( 6,a,b,c,d);\n    irot(a,b,c,d); ib5(a,b,c,d,e,f,g,h); k_xor( 5,e,f,g,h);\n    irot(e,f,g,h); ib4(e,f,g,h,a,b,c,d); k_xor( 4,a,b,c,d);\n    irot(a,b,c,d); ib3(a,b,c,d,e,f,g,h); k_xor( 3,e,f,g,h);\n    irot(e,f,g,h); ib2(e,f,g,h,a,b,c,d); k_xor( 2,a,b,c,d);\n    irot(a,b,c,d); ib1(a,b,c,d,e,f,g,h); k_xor( 1,e,f,g,h);\n    irot(e,f,g,h); ib0(e,f,g,h,a,b,c,d); k_xor( 0,a,b,c,d);\n    \n#ifdef  BLOCK_SWAP\n    out_blk[3] = io_swap(a); out_blk[2] = io_swap(b); \n    out_blk[1] = io_swap(c); out_blk[0] = io_swap(d);\n#else\n    out_blk[0] = a; out_blk[1] = b; out_blk[2] = c; out_blk[3] = d;\n#endif\n}\n"
        },
        {
            "file_name": "Sha2.c",
            "content": "/*\n ---------------------------------------------------------------------------\n Copyright (c) 2002, Dr Brian Gladman, Worcester, UK.   All rights reserved.\n\n LICENSE TERMS\n\n The free distribution and use of this software is allowed (with or without\n changes) provided that:\n\n  1. source code distributions include the above copyright notice, this\n     list of conditions and the following disclaimer;\n\n  2. binary distributions include the above copyright notice, this list\n     of conditions and the following disclaimer in their documentation.\n\n  3. the name of the copyright holder is not used to endorse products\n     built using this software without specific written permission.\n\n DISCLAIMER\n\n This software is provided 'as is' with no explicit or implied warranties\n in respect of its properties, including, but not limited to, correctness\n and/or fitness for purpose.\n ---------------------------------------------------------------------------\n Issue Date: 01/08/2005\n\n This is a byte oriented version of SHA2 that operates on arrays of bytes\n stored in memory. This code implements sha256 and sha512 but the\n latter function relies on efficient 64-bit integer operations that\n may not be very efficient on 32-bit machines\n\n The sha256 functions use a type 'sha256_ctx' to hold details of the\n current hash state and uses the following three calls:\n\n       void sha256_begin(sha256_ctx ctx[1])\n       void sha256_hash(const unsigned char data[],\n                            unsigned long len, sha256_ctx ctx[1])\n       void sha256_end(void *hval, sha256_ctx ctx[1])\n\n The first subroutine initialises a hash computation by setting up the\n context in the sha256_ctx context. The second subroutine hashes 8-bit\n bytes from array data[] into the hash state withinh sha256_ctx context,\n the number of bytes to be hashed being given by the the unsigned long\n integer len.  The third subroutine completes the hash calculation and\n places the resulting digest value in the array hval[].\n\n The sha512 function is similar and uses the interface:\n\n       void sha512_begin(sha512_ctx ctx[1]);\n       void sha512_hash(const unsigned char data[],\n                            unsigned long len, sha512_ctx ctx[1]);\n       void sha512_end(void *hval, sha512_ctx ctx[1]);\n\n My thanks to Erik Andersen <andersen@codepoet.org> for testing this code\n on big-endian systems and for his assistance with corrections\n*/\n\n#include <sys/endian.h>\n\n#define PLATFORM_BYTE_ORDER BYTE_ORDER\n#define IS_LITTLE_ENDIAN LITTLE_ENDIAN\n\n#if 0\n#define UNROLL_SHA2     /* for SHA2 loop unroll     */\n#endif\n\n#include <string.h>     /* for memcpy() etc.        */\n#include \"Sha2.h\" \n\n#if defined(__cplusplus)\nextern \"C\"\n{\n#endif\n\n#if defined( _MSC_VER ) && ( _MSC_VER > 800 )\n#pragma intrinsic(memcpy)\n#endif\n\n#if 0 && defined(_MSC_VER)\n#define rotl32 _lrotl\n#define rotr32 _lrotr\n#else\n#define rotl32(x,n)   (((x) << n) | ((x) >> (32 - n)))\n#define rotr32(x,n)   (((x) >> n) | ((x) << (32 - n)))\n#endif\n\n#if !defined(bswap_32)\n#define bswap_32(x) ((rotr32((x), 24) & 0x00ff00ff) | (rotr32((x), 8) & 0xff00ff00))\n#endif\n\n#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)\n#define SWAP_BYTES\n#else\n#undef  SWAP_BYTES\n#endif\n\n#if 0\n\n#define ch(x,y,z)       (((x) & (y)) ^ (~(x) & (z)))\n#define maj(x,y,z)      (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))\n\n#else   /* Thanks to Rich Schroeppel and Colin Plumb for the following      */\n\n#define ch(x,y,z)       ((z) ^ ((x) & ((y) ^ (z))))\n#define maj(x,y,z)      (((x) & (y)) | ((z) & ((x) ^ (y))))\n\n#endif\n\n/* round transforms for SHA256 and SHA512 compression functions */\n\n#define vf(n,i) v[(n - i) & 7]\n\n#define hf(i) (p[i & 15] += \\\n    g_1(p[(i + 14) & 15]) + p[(i + 9) & 15] + g_0(p[(i + 1) & 15]))\n\n#define v_cycle(i,j)                                \\\n    vf(7,i) += (j ? hf(i) : p[i]) + k_0[i+j]        \\\n    + s_1(vf(4,i)) + ch(vf(4,i),vf(5,i),vf(6,i));   \\\n    vf(3,i) += vf(7,i);                             \\\n    vf(7,i) += s_0(vf(0,i))+ maj(vf(0,i),vf(1,i),vf(2,i))\n\n#if _HF == 0\n\n#define SHA256_MASK (SHA256_BLOCK_SIZE - 1)\n\n#if defined(SWAP_BYTES)\n#define bsw_32(p,n) \\\n    { int _i = (n); while(_i--) ((uint32_t*)p)[_i] = bswap_32(((uint32_t*)p)[_i]); }\n#else\n#define bsw_32(p,n)\n#endif\n\n#define s_0(x)  (rotr32((x),  2) ^ rotr32((x), 13) ^ rotr32((x), 22))\n#define s_1(x)  (rotr32((x),  6) ^ rotr32((x), 11) ^ rotr32((x), 25))\n#define g_0(x)  (rotr32((x),  7) ^ rotr32((x), 18) ^ ((x) >>  3))\n#define g_1(x)  (rotr32((x), 17) ^ rotr32((x), 19) ^ ((x) >> 10))\n#define k_0     k256\n\n/* rotated SHA256 round definition. Rather than swapping variables as in    */\n/* FIPS-180, different variables are 'rotated' on each round, returning     */\n/* to their starting positions every eight rounds                           */\n\n#define q(n)  v##n\n\n#define one_cycle(a,b,c,d,e,f,g,h,k,w)  \\\n    q(h) += s_1(q(e)) + ch(q(e), q(f), q(g)) + k + w; \\\n    q(d) += q(h); q(h) += s_0(q(a)) + maj(q(a), q(b), q(c))\n\n/* SHA256 mixing data   */\n\nconst uint32_t k256[64] =\n{   0x428a2f98ul, 0x71374491ul, 0xb5c0fbcful, 0xe9b5dba5ul,\n    0x3956c25bul, 0x59f111f1ul, 0x923f82a4ul, 0xab1c5ed5ul,\n    0xd807aa98ul, 0x12835b01ul, 0x243185beul, 0x550c7dc3ul,\n    0x72be5d74ul, 0x80deb1feul, 0x9bdc06a7ul, 0xc19bf174ul,\n    0xe49b69c1ul, 0xefbe4786ul, 0x0fc19dc6ul, 0x240ca1ccul,\n    0x2de92c6ful, 0x4a7484aaul, 0x5cb0a9dcul, 0x76f988daul,\n    0x983e5152ul, 0xa831c66dul, 0xb00327c8ul, 0xbf597fc7ul,\n    0xc6e00bf3ul, 0xd5a79147ul, 0x06ca6351ul, 0x14292967ul,\n    0x27b70a85ul, 0x2e1b2138ul, 0x4d2c6dfcul, 0x53380d13ul,\n    0x650a7354ul, 0x766a0abbul, 0x81c2c92eul, 0x92722c85ul,\n    0xa2bfe8a1ul, 0xa81a664bul, 0xc24b8b70ul, 0xc76c51a3ul,\n    0xd192e819ul, 0xd6990624ul, 0xf40e3585ul, 0x106aa070ul,\n    0x19a4c116ul, 0x1e376c08ul, 0x2748774cul, 0x34b0bcb5ul,\n    0x391c0cb3ul, 0x4ed8aa4aul, 0x5b9cca4ful, 0x682e6ff3ul,\n    0x748f82eeul, 0x78a5636ful, 0x84c87814ul, 0x8cc70208ul,\n    0x90befffaul, 0xa4506cebul, 0xbef9a3f7ul, 0xc67178f2ul,\n};\n\n\nconst uint32_t i256[8] =\n{\n    0x6a09e667ul, 0xbb67ae85ul, 0x3c6ef372ul, 0xa54ff53aul,\n    0x510e527ful, 0x9b05688cul, 0x1f83d9abul, 0x5be0cd19ul\n};\n\nVOID_RETURN sha256_begin(sha256_ctx ctx[1])\n{\n    ctx->count[0] = ctx->count[1] = 0;\n    memcpy(ctx->hash, i256, 8 * sizeof(uint32_t));\n}\n\n\n/* Compile 64 bytes of hash data into SHA256 digest value   */\n/* NOTE: this routine assumes that the byte order in the    */\n/* ctx->wbuf[] at this point is such that low address bytes */\n/* in the ORIGINAL byte stream will go into the high end of */\n/* words on BOTH big and little endian systems              */\n\nVOID_RETURN sha256_compile(sha256_ctx ctx[1])\n{\n#if !defined(UNROLL_SHA2)\n\n    uint32_t j, *p = ctx->wbuf, v[8];\n\n    memcpy(v, ctx->hash, 8 * sizeof(uint32_t));\n\n    for(j = 0; j < 64; j += 16)\n    {\n        v_cycle( 0, j); v_cycle( 1, j);\n        v_cycle( 2, j); v_cycle( 3, j);\n        v_cycle( 4, j); v_cycle( 5, j);\n        v_cycle( 6, j); v_cycle( 7, j);\n        v_cycle( 8, j); v_cycle( 9, j);\n        v_cycle(10, j); v_cycle(11, j);\n        v_cycle(12, j); v_cycle(13, j);\n        v_cycle(14, j); v_cycle(15, j);\n    }\n\n    ctx->hash[0] += v[0]; ctx->hash[1] += v[1];\n    ctx->hash[2] += v[2]; ctx->hash[3] += v[3];\n    ctx->hash[4] += v[4]; ctx->hash[5] += v[5];\n    ctx->hash[6] += v[6]; ctx->hash[7] += v[7];\n\n#else\n\n    uint32_t *p = ctx->wbuf,v0,v1,v2,v3,v4,v5,v6,v7;\n\n    v0 = ctx->hash[0]; v1 = ctx->hash[1];\n    v2 = ctx->hash[2]; v3 = ctx->hash[3];\n    v4 = ctx->hash[4]; v5 = ctx->hash[5];\n    v6 = ctx->hash[6]; v7 = ctx->hash[7];\n\n    one_cycle(0,1,2,3,4,5,6,7,k256[ 0],p[ 0]);\n    one_cycle(7,0,1,2,3,4,5,6,k256[ 1],p[ 1]);\n    one_cycle(6,7,0,1,2,3,4,5,k256[ 2],p[ 2]);\n    one_cycle(5,6,7,0,1,2,3,4,k256[ 3],p[ 3]);\n    one_cycle(4,5,6,7,0,1,2,3,k256[ 4],p[ 4]);\n    one_cycle(3,4,5,6,7,0,1,2,k256[ 5],p[ 5]);\n    one_cycle(2,3,4,5,6,7,0,1,k256[ 6],p[ 6]);\n    one_cycle(1,2,3,4,5,6,7,0,k256[ 7],p[ 7]);\n    one_cycle(0,1,2,3,4,5,6,7,k256[ 8],p[ 8]);\n    one_cycle(7,0,1,2,3,4,5,6,k256[ 9],p[ 9]);\n    one_cycle(6,7,0,1,2,3,4,5,k256[10],p[10]);\n    one_cycle(5,6,7,0,1,2,3,4,k256[11],p[11]);\n    one_cycle(4,5,6,7,0,1,2,3,k256[12],p[12]);\n    one_cycle(3,4,5,6,7,0,1,2,k256[13],p[13]);\n    one_cycle(2,3,4,5,6,7,0,1,k256[14],p[14]);\n    one_cycle(1,2,3,4,5,6,7,0,k256[15],p[15]);\n\n    one_cycle(0,1,2,3,4,5,6,7,k256[16],hf( 0));\n    one_cycle(7,0,1,2,3,4,5,6,k256[17],hf( 1));\n    one_cycle(6,7,0,1,2,3,4,5,k256[18],hf( 2));\n    one_cycle(5,6,7,0,1,2,3,4,k256[19],hf( 3));\n    one_cycle(4,5,6,7,0,1,2,3,k256[20],hf( 4));\n    one_cycle(3,4,5,6,7,0,1,2,k256[21],hf( 5));\n    one_cycle(2,3,4,5,6,7,0,1,k256[22],hf( 6));\n    one_cycle(1,2,3,4,5,6,7,0,k256[23],hf( 7));\n    one_cycle(0,1,2,3,4,5,6,7,k256[24],hf( 8));\n    one_cycle(7,0,1,2,3,4,5,6,k256[25],hf( 9));\n    one_cycle(6,7,0,1,2,3,4,5,k256[26],hf(10));\n    one_cycle(5,6,7,0,1,2,3,4,k256[27],hf(11));\n    one_cycle(4,5,6,7,0,1,2,3,k256[28],hf(12));\n    one_cycle(3,4,5,6,7,0,1,2,k256[29],hf(13));\n    one_cycle(2,3,4,5,6,7,0,1,k256[30],hf(14));\n    one_cycle(1,2,3,4,5,6,7,0,k256[31],hf(15));\n\n    one_cycle(0,1,2,3,4,5,6,7,k256[32],hf( 0));\n    one_cycle(7,0,1,2,3,4,5,6,k256[33],hf( 1));\n    one_cycle(6,7,0,1,2,3,4,5,k256[34],hf( 2));\n    one_cycle(5,6,7,0,1,2,3,4,k256[35],hf( 3));\n    one_cycle(4,5,6,7,0,1,2,3,k256[36],hf( 4));\n    one_cycle(3,4,5,6,7,0,1,2,k256[37],hf( 5));\n    one_cycle(2,3,4,5,6,7,0,1,k256[38],hf( 6));\n    one_cycle(1,2,3,4,5,6,7,0,k256[39],hf( 7));\n    one_cycle(0,1,2,3,4,5,6,7,k256[40],hf( 8));\n    one_cycle(7,0,1,2,3,4,5,6,k256[41],hf( 9));\n    one_cycle(6,7,0,1,2,3,4,5,k256[42],hf(10));\n    one_cycle(5,6,7,0,1,2,3,4,k256[43],hf(11));\n    one_cycle(4,5,6,7,0,1,2,3,k256[44],hf(12));\n    one_cycle(3,4,5,6,7,0,1,2,k256[45],hf(13));\n    one_cycle(2,3,4,5,6,7,0,1,k256[46],hf(14));\n    one_cycle(1,2,3,4,5,6,7,0,k256[47],hf(15));\n\n    one_cycle(0,1,2,3,4,5,6,7,k256[48],hf( 0));\n    one_cycle(7,0,1,2,3,4,5,6,k256[49],hf( 1));\n    one_cycle(6,7,0,1,2,3,4,5,k256[50],hf( 2));\n    one_cycle(5,6,7,0,1,2,3,4,k256[51],hf( 3));\n    one_cycle(4,5,6,7,0,1,2,3,k256[52],hf( 4));\n    one_cycle(3,4,5,6,7,0,1,2,k256[53],hf( 5));\n    one_cycle(2,3,4,5,6,7,0,1,k256[54],hf( 6));\n    one_cycle(1,2,3,4,5,6,7,0,k256[55],hf( 7));\n    one_cycle(0,1,2,3,4,5,6,7,k256[56],hf( 8));\n    one_cycle(7,0,1,2,3,4,5,6,k256[57],hf( 9));\n    one_cycle(6,7,0,1,2,3,4,5,k256[58],hf(10));\n    one_cycle(5,6,7,0,1,2,3,4,k256[59],hf(11));\n    one_cycle(4,5,6,7,0,1,2,3,k256[60],hf(12));\n    one_cycle(3,4,5,6,7,0,1,2,k256[61],hf(13));\n    one_cycle(2,3,4,5,6,7,0,1,k256[62],hf(14));\n    one_cycle(1,2,3,4,5,6,7,0,k256[63],hf(15));\n\n    ctx->hash[0] += v0; ctx->hash[1] += v1;\n    ctx->hash[2] += v2; ctx->hash[3] += v3;\n    ctx->hash[4] += v4; ctx->hash[5] += v5;\n    ctx->hash[6] += v6; ctx->hash[7] += v7;\n#endif\n}\n\n/* SHA256 hash data in an array of bytes into hash buffer   */\n/* and call the hash_compile function as required.          */\n\nVOID_RETURN sha256_hash(const unsigned char data[], unsigned long len, sha256_ctx ctx[1])\n{   uint32_t pos = (uint32_t)(ctx->count[0] & SHA256_MASK),\n             space = SHA256_BLOCK_SIZE - pos;\n    const unsigned char *sp = data;\n\n    if((ctx->count[0] += len) < len)\n        ++(ctx->count[1]);\n\n    while(len >= space)     /* tranfer whole blocks while possible  */\n    {\n        memcpy(((unsigned char*)ctx->wbuf) + pos, sp, space);\n        sp += space; len -= space; space = SHA256_BLOCK_SIZE; pos = 0;\n        bsw_32(ctx->wbuf, SHA256_BLOCK_SIZE >> 2)\n        sha256_compile(ctx);\n    }\n\n    memcpy(((unsigned char*)ctx->wbuf) + pos, sp, len);\n}\n\n/* SHA256 Final padding and digest calculation  */\n\nvoid sha256_end(void *hval, sha256_ctx ctx[1])\n{   \n\n    uint32_t    i = (uint32_t)(ctx->count[0] & SHA256_MASK);\n\n    /* put bytes in the buffer in an order in which references to   */\n    /* 32-bit words will put bytes with lower addresses into the    */\n    /* top of 32 bit words on BOTH big and little endian machines   */\n    bsw_32(ctx->wbuf, (i + 3) >> 2)\n\n    /* we now need to mask valid bytes and add the padding which is */\n    /* a single 1 bit and as many zero bits as necessary. Note that */\n    /* we can always add the first padding byte here because the    */\n    /* buffer always has at least one empty slot                    */\n    ctx->wbuf[i >> 2] &= 0xffffff80 << 8 * (~i & 3);\n    ctx->wbuf[i >> 2] |= 0x00000080 << 8 * (~i & 3);\n\n    /* we need 9 or more empty positions, one for the padding byte  */\n    /* (above) and eight for the length count.  If there is not     */\n    /* enough space pad and empty the buffer                        */\n    if(i > SHA256_BLOCK_SIZE - 9)\n    {\n        if(i < 60) ctx->wbuf[15] = 0;\n        sha256_compile(ctx);\n        i = 0;\n    }\n    else    /* compute a word index for the empty buffer positions  */\n        i = (i >> 2) + 1;\n\n    while(i < 14) /* and zero pad all but last two positions        */\n        ctx->wbuf[i++] = 0;\n\n    /* the following 32-bit length fields are assembled in the      */\n    /* wrong byte order on little endian machines but this is       */\n    /* corrected later since they are only ever used as 32-bit      */\n    /* word values.                                                 */\n    ctx->wbuf[14] = (ctx->count[1] << 3) | (ctx->count[0] >> 29);\n    ctx->wbuf[15] = ctx->count[0] << 3;\n    sha256_compile(ctx);\n    bsw_32(ctx->hash,SHA256_DIGEST_SIZE>>2);\n\n    /* extract the hash value as bytes in case the hash buffer is   */\n    /* mislaigned for 32-bit words                                  */\n    for(i = 0; i < (SHA256_DIGEST_SIZE>>2); ++i)\n        ((uint32_t *)hval)[i] = ctx->hash[i];\n}\n\nVOID_RETURN sha256(void *hval, const unsigned char data[], unsigned long len)\n{   sha256_ctx  cx[1];\n\n    sha256_begin(cx);\n    sha256_hash(data, len, cx);\n    sha256_end(hval, cx);\n}\n\n#endif\n\n\n#if _HF == 1\n\n#define SHA512_MASK (SHA512_BLOCK_SIZE - 1)\n\n#define rotr64(x,n)   (((x) >> n) | ((x) << (64 - n)))\n\n#if !defined(bswap_64)\n#define bswap_64(x) (((uint64_t)(bswap_32((uint32_t)(x)))) << 32 | bswap_32((uint32_t)((x) >> 32)))\n#endif\n\n#if defined(SWAP_BYTES)\n#define bsw_64(p,n) \\\n    { int _i = (n); while(_i--) ((uint64_t*)p)[_i] = bswap_64(((uint64_t*)p)[_i]); }\n#else\n#define bsw_64(p,n)\n#endif\n\n/* SHA512 mixing function definitions   */\n\n#ifdef   s_0\n# undef  s_0\n# undef  s_1\n# undef  g_0\n# undef  g_1\n# undef  k_0\n#endif\n\n#define s_0(x)  (rotr64((x), 28) ^ rotr64((x), 34) ^ rotr64((x), 39))\n#define s_1(x)  (rotr64((x), 14) ^ rotr64((x), 18) ^ rotr64((x), 41))\n#define g_0(x)  (rotr64((x),  1) ^ rotr64((x),  8) ^ ((x) >>  7))\n#define g_1(x)  (rotr64((x), 19) ^ rotr64((x), 61) ^ ((x) >>  6))\n#define k_0     k512\n\n/* SHASHA512 mixing data    */\n\nconst uint64_t  k512[80] =\n{\n    li_64(428a2f98d728ae22), li_64(7137449123ef65cd),\n    li_64(b5c0fbcfec4d3b2f), li_64(e9b5dba58189dbbc),\n    li_64(3956c25bf348b538), li_64(59f111f1b605d019),\n    li_64(923f82a4af194f9b), li_64(ab1c5ed5da6d8118),\n    li_64(d807aa98a3030242), li_64(12835b0145706fbe),\n    li_64(243185be4ee4b28c), li_64(550c7dc3d5ffb4e2),\n    li_64(72be5d74f27b896f), li_64(80deb1fe3b1696b1),\n    li_64(9bdc06a725c71235), li_64(c19bf174cf692694),\n    li_64(e49b69c19ef14ad2), li_64(efbe4786384f25e3),\n    li_64(0fc19dc68b8cd5b5), li_64(240ca1cc77ac9c65),\n    li_64(2de92c6f592b0275), li_64(4a7484aa6ea6e483),\n    li_64(5cb0a9dcbd41fbd4), li_64(76f988da831153b5),\n    li_64(983e5152ee66dfab), li_64(a831c66d2db43210),\n    li_64(b00327c898fb213f), li_64(bf597fc7beef0ee4),\n    li_64(c6e00bf33da88fc2), li_64(d5a79147930aa725),\n    li_64(06ca6351e003826f), li_64(142929670a0e6e70),\n    li_64(27b70a8546d22ffc), li_64(2e1b21385c26c926),\n    li_64(4d2c6dfc5ac42aed), li_64(53380d139d95b3df),\n    li_64(650a73548baf63de), li_64(766a0abb3c77b2a8),\n    li_64(81c2c92e47edaee6), li_64(92722c851482353b),\n    li_64(a2bfe8a14cf10364), li_64(a81a664bbc423001),\n    li_64(c24b8b70d0f89791), li_64(c76c51a30654be30),\n    li_64(d192e819d6ef5218), li_64(d69906245565a910),\n    li_64(f40e35855771202a), li_64(106aa07032bbd1b8),\n    li_64(19a4c116b8d2d0c8), li_64(1e376c085141ab53),\n    li_64(2748774cdf8eeb99), li_64(34b0bcb5e19b48a8),\n    li_64(391c0cb3c5c95a63), li_64(4ed8aa4ae3418acb),\n    li_64(5b9cca4f7763e373), li_64(682e6ff3d6b2b8a3),\n    li_64(748f82ee5defb2fc), li_64(78a5636f43172f60),\n    li_64(84c87814a1f0ab72), li_64(8cc702081a6439ec),\n    li_64(90befffa23631e28), li_64(a4506cebde82bde9),\n    li_64(bef9a3f7b2c67915), li_64(c67178f2e372532b),\n    li_64(ca273eceea26619c), li_64(d186b8c721c0c207),\n    li_64(eada7dd6cde0eb1e), li_64(f57d4f7fee6ed178),\n    li_64(06f067aa72176fba), li_64(0a637dc5a2c898a6),\n    li_64(113f9804bef90dae), li_64(1b710b35131c471b),\n    li_64(28db77f523047d84), li_64(32caab7b40c72493),\n    li_64(3c9ebe0a15c9bebc), li_64(431d67c49c100d4c),\n    li_64(4cc5d4becb3e42b6), li_64(597f299cfc657e2a),\n    li_64(5fcb6fab3ad6faec), li_64(6c44198c4a475817)\n};\n\n/* SHA512 initialisation data   */\n\nconst uint64_t  i512[80] =\n{\n    li_64(6a09e667f3bcc908), li_64(bb67ae8584caa73b),\n    li_64(3c6ef372fe94f82b), li_64(a54ff53a5f1d36f1),\n    li_64(510e527fade682d1), li_64(9b05688c2b3e6c1f),\n    li_64(1f83d9abfb41bd6b), li_64(5be0cd19137e2179)\n};\n\nVOID_RETURN sha512_begin(sha512_ctx ctx[1])\n{\n    ctx->count[0] = ctx->count[1] = 0;\n    memcpy(ctx->hash, i512, 8 * sizeof(uint64_t));\n}\n\n/* Compile 128 bytes of hash data into SHA384/512 digest    */\n/* NOTE: this routine assumes that the byte order in the    */\n/* ctx->wbuf[] at this point is such that low address bytes */\n/* in the ORIGINAL byte stream will go into the high end of */\n/* words on BOTH big and little endian systems              */\n\nVOID_RETURN sha512_compile(sha512_ctx ctx[1])\n{   uint64_t    v[8], *p = ctx->wbuf;\n    uint32_t    j;\n\n    memcpy(v, ctx->hash, 8 * sizeof(uint64_t));\n\n    for(j = 0; j < 80; j += 16)\n    {\n        v_cycle( 0, j); v_cycle( 1, j);\n        v_cycle( 2, j); v_cycle( 3, j);\n        v_cycle( 4, j); v_cycle( 5, j);\n        v_cycle( 6, j); v_cycle( 7, j);\n        v_cycle( 8, j); v_cycle( 9, j);\n        v_cycle(10, j); v_cycle(11, j);\n        v_cycle(12, j); v_cycle(13, j);\n        v_cycle(14, j); v_cycle(15, j);\n    }\n\n    ctx->hash[0] += v[0]; ctx->hash[1] += v[1];\n    ctx->hash[2] += v[2]; ctx->hash[3] += v[3];\n    ctx->hash[4] += v[4]; ctx->hash[5] += v[5];\n    ctx->hash[6] += v[6]; ctx->hash[7] += v[7];\n}\n\n/* Compile 128 bytes of hash data into SHA512 digest value  */\n/* NOTE: this routine assumes that the byte order in the    */\n/* ctx->wbuf[] at this point is in such an order that low   */\n/* address bytes in the ORIGINAL byte stream placed in this */\n/* buffer will now go to the high end of words on BOTH big  */\n/* and little endian systems                                */\n\nVOID_RETURN sha512_hash(const unsigned char data[], unsigned long len, sha512_ctx ctx[1])\n{   uint32_t pos = (uint32_t)(ctx->count[0] & SHA512_MASK),\n             space = SHA512_BLOCK_SIZE - pos;\n    const unsigned char *sp = data;\n\n    if((ctx->count[0] += len) < len)\n        ++(ctx->count[1]);\n\n    while(len >= space)     /* tranfer whole blocks while possible  */\n    {\n        memcpy(((unsigned char*)ctx->wbuf) + pos, sp, space);\n        sp += space; len -= space; space = SHA512_BLOCK_SIZE; pos = 0;\n        bsw_64(ctx->wbuf, SHA512_BLOCK_SIZE >> 3);\n        sha512_compile(ctx);\n    }\n\n    memcpy(((unsigned char*)ctx->wbuf) + pos, sp, len);\n}\n\n/* SHA512 Final padding and digest calculation  */\n\nvoid sha512_end(void *hval, sha512_ctx ctx[1])\n{   \n    uint32_t    i = (uint32_t)(ctx->count[0] & SHA512_MASK);\n\n    /* put bytes in the buffer in an order in which references to   */\n    /* 32-bit words will put bytes with lower addresses into the    */\n    /* top of 32 bit words on BOTH big and little endian machines   */\n    bsw_64(ctx->wbuf, (i + 7) >> 3);\n\n    /* we now need to mask valid bytes and add the padding which is */\n    /* a single 1 bit and as many zero bits as necessary. Note that */\n    /* we can always add the first padding byte here because the    */\n    /* buffer always has at least one empty slot                    */\n    ctx->wbuf[i >> 3] &= li_64(ffffffffffffff00) << 8 * (~i & 7);\n    ctx->wbuf[i >> 3] |= li_64(0000000000000080) << 8 * (~i & 7);\n\n    /* we need 17 or more empty byte positions, one for the padding */\n    /* byte (above) and sixteen for the length count.  If there is  */\n    /* not enough space pad and empty the buffer                    */\n    if(i > SHA512_BLOCK_SIZE - 17)\n    {\n        if(i < 120) ctx->wbuf[15] = 0;\n        sha512_compile(ctx);\n        i = 0;\n    }\n    else\n        i = (i >> 3) + 1;\n\n    while(i < 14)\n        ctx->wbuf[i++] = 0;\n\n    /* the following 64-bit length fields are assembled in the      */\n    /* wrong byte order on little endian machines but this is       */\n    /* corrected later since they are only ever used as 64-bit      */\n    /* word values.                                                 */\n    ctx->wbuf[14] = (ctx->count[1] << 3) | (ctx->count[0] >> 61);\n    ctx->wbuf[15] = ctx->count[0] << 3;\n    sha512_compile(ctx);\n    bsw_64(ctx->hash,SHA512_DIGEST_SIZE>>3);\n\n    /* extract the hash value as bytes in case the hash buffer is   */\n    /* misaligned for 32-bit words                                  */\n    for(i = 0; i < (SHA512_DIGEST_SIZE>>3); ++i)\n        ((uint64_t *)hval)[i] = ctx->hash[i];\n}\n\nVOID_RETURN sha512(void *hval, const unsigned char data[], unsigned long len)\n{   \n    sha512_ctx  cx[1];\n\n    sha512_begin(cx);\n    sha512_hash(data, len, cx);\n    sha512_end(hval, cx);\n}\n\n#endif\n\n#if defined(__cplusplus)\n}\n#endif\n\n"
        },
        {
            "file_name": "sha256 copy.c",
            "content": "/*-\n * Copyright 2005,2007,2009 Colin Percival\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <sys/types.h>\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"sysendian.h\"\n\n#include \"sha256.h\"\n\n/*\n * Encode a length len/4 vector of (uint32_t) into a length len vector of\n * (unsigned char) in big-endian form.  Assumes len is a multiple of 4.\n */\nstatic void\nbe32enc_vect(unsigned char *dst, const uint32_t *src, size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len / 4; i++)\n\t\tbe32enc(dst + i * 4, src[i]);\n}\n\n/*\n * Decode a big-endian length len vector of (unsigned char) into a length\n * len/4 vector of (uint32_t).  Assumes len is a multiple of 4.\n */\nstatic void\nbe32dec_vect(uint32_t *dst, const unsigned char *src, size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len / 4; i++)\n\t\tdst[i] = be32dec(src + i * 4);\n}\n\n/* Elementary functions used by SHA256 */\n#define Ch(x, y, z)\t((x & (y ^ z)) ^ z)\n#define Maj(x, y, z)\t((x & (y | z)) | (y & z))\n#define SHR(x, n)\t(x >> n)\n#define ROTR(x, n)\t((x >> n) | (x << (32 - n)))\n#define S0(x)\t\t(ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22))\n#define S1(x)\t\t(ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25))\n#define s0(x)\t\t(ROTR(x, 7) ^ ROTR(x, 18) ^ SHR(x, 3))\n#define s1(x)\t\t(ROTR(x, 17) ^ ROTR(x, 19) ^ SHR(x, 10))\n\n/* SHA256 round function */\n#define RND(a, b, c, d, e, f, g, h, k)\t\t\t\\\n\tt0 = h + S1(e) + Ch(e, f, g) + k;\t\t\\\n\tt1 = S0(a) + Maj(a, b, c);\t\t\t\\\n\td += t0;\t\t\t\t\t\\\n\th  = t0 + t1;\n\n/* Adjusted round function for rotating state */\n#define RNDr(S, W, i, k)\t\t\t\\\n\tRND(S[(64 - i) % 8], S[(65 - i) % 8],\t\\\n\t    S[(66 - i) % 8], S[(67 - i) % 8],\t\\\n\t    S[(68 - i) % 8], S[(69 - i) % 8],\t\\\n\t    S[(70 - i) % 8], S[(71 - i) % 8],\t\\\n\t    W[i] + k)\n\n/*\n * SHA256 block compression function.  The 256-bit state is transformed via\n * the 512-bit input block to produce a new state.\n */\nstatic void\nSHA256_Transform(uint32_t * state, const unsigned char block[64])\n{\n\tuint32_t W[64];\n\tuint32_t S[8];\n\tuint32_t t0, t1;\n\tint i;\n\n\t/* 1. Prepare message schedule W. */\n\tbe32dec_vect(W, block, 64);\n\tfor (i = 16; i < 64; i++)\n\t\tW[i] = s1(W[i - 2]) + W[i - 7] + s0(W[i - 15]) + W[i - 16];\n\n\t/* 2. Initialize working variables. */\n\tmemcpy(S, state, 32);\n\n\t/* 3. Mix. */\n\tRNDr(S, W, 0, 0x428a2f98);\n\tRNDr(S, W, 1, 0x71374491);\n\tRNDr(S, W, 2, 0xb5c0fbcf);\n\tRNDr(S, W, 3, 0xe9b5dba5);\n\tRNDr(S, W, 4, 0x3956c25b);\n\tRNDr(S, W, 5, 0x59f111f1);\n\tRNDr(S, W, 6, 0x923f82a4);\n\tRNDr(S, W, 7, 0xab1c5ed5);\n\tRNDr(S, W, 8, 0xd807aa98);\n\tRNDr(S, W, 9, 0x12835b01);\n\tRNDr(S, W, 10, 0x243185be);\n\tRNDr(S, W, 11, 0x550c7dc3);\n\tRNDr(S, W, 12, 0x72be5d74);\n\tRNDr(S, W, 13, 0x80deb1fe);\n\tRNDr(S, W, 14, 0x9bdc06a7);\n\tRNDr(S, W, 15, 0xc19bf174);\n\tRNDr(S, W, 16, 0xe49b69c1);\n\tRNDr(S, W, 17, 0xefbe4786);\n\tRNDr(S, W, 18, 0x0fc19dc6);\n\tRNDr(S, W, 19, 0x240ca1cc);\n\tRNDr(S, W, 20, 0x2de92c6f);\n\tRNDr(S, W, 21, 0x4a7484aa);\n\tRNDr(S, W, 22, 0x5cb0a9dc);\n\tRNDr(S, W, 23, 0x76f988da);\n\tRNDr(S, W, 24, 0x983e5152);\n\tRNDr(S, W, 25, 0xa831c66d);\n\tRNDr(S, W, 26, 0xb00327c8);\n\tRNDr(S, W, 27, 0xbf597fc7);\n\tRNDr(S, W, 28, 0xc6e00bf3);\n\tRNDr(S, W, 29, 0xd5a79147);\n\tRNDr(S, W, 30, 0x06ca6351);\n\tRNDr(S, W, 31, 0x14292967);\n\tRNDr(S, W, 32, 0x27b70a85);\n\tRNDr(S, W, 33, 0x2e1b2138);\n\tRNDr(S, W, 34, 0x4d2c6dfc);\n\tRNDr(S, W, 35, 0x53380d13);\n\tRNDr(S, W, 36, 0x650a7354);\n\tRNDr(S, W, 37, 0x766a0abb);\n\tRNDr(S, W, 38, 0x81c2c92e);\n\tRNDr(S, W, 39, 0x92722c85);\n\tRNDr(S, W, 40, 0xa2bfe8a1);\n\tRNDr(S, W, 41, 0xa81a664b);\n\tRNDr(S, W, 42, 0xc24b8b70);\n\tRNDr(S, W, 43, 0xc76c51a3);\n\tRNDr(S, W, 44, 0xd192e819);\n\tRNDr(S, W, 45, 0xd6990624);\n\tRNDr(S, W, 46, 0xf40e3585);\n\tRNDr(S, W, 47, 0x106aa070);\n\tRNDr(S, W, 48, 0x19a4c116);\n\tRNDr(S, W, 49, 0x1e376c08);\n\tRNDr(S, W, 50, 0x2748774c);\n\tRNDr(S, W, 51, 0x34b0bcb5);\n\tRNDr(S, W, 52, 0x391c0cb3);\n\tRNDr(S, W, 53, 0x4ed8aa4a);\n\tRNDr(S, W, 54, 0x5b9cca4f);\n\tRNDr(S, W, 55, 0x682e6ff3);\n\tRNDr(S, W, 56, 0x748f82ee);\n\tRNDr(S, W, 57, 0x78a5636f);\n\tRNDr(S, W, 58, 0x84c87814);\n\tRNDr(S, W, 59, 0x8cc70208);\n\tRNDr(S, W, 60, 0x90befffa);\n\tRNDr(S, W, 61, 0xa4506ceb);\n\tRNDr(S, W, 62, 0xbef9a3f7);\n\tRNDr(S, W, 63, 0xc67178f2);\n\n\t/* 4. Mix local working variables into global state */\n\tfor (i = 0; i < 8; i++)\n\t\tstate[i] += S[i];\n\n\t/* Clean the stack. */\n\tmemset(W, 0, 256);\n\tmemset(S, 0, 32);\n\tt0 = t1 = 0;\n}\n\nstatic unsigned char PAD[64] = {\n\t0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n};\n\n/* Add padding and terminating bit-count. */\nstatic void\nSHA256_Pad(SHA256_CTX * ctx)\n{\n\tunsigned char len[8];\n\tuint32_t r, plen;\n\n\t/*\n\t * Convert length to a vector of bytes -- we do this now rather\n\t * than later because the length will change after we pad.\n\t */\n\tbe32enc_vect(len, ctx->count, 8);\n\n\t/* Add 1--64 bytes so that the resulting length is 56 mod 64 */\n\tr = (ctx->count[1] >> 3) & 0x3f;\n\tplen = (r < 56) ? (56 - r) : (120 - r);\n\tSHA256_Update(ctx, PAD, (size_t)plen);\n\n\t/* Add the terminating bit-count */\n\tSHA256_Update(ctx, len, 8);\n}\n\n/* SHA-256 initialization.  Begins a SHA-256 operation. */\nvoid\nSHA256_Init(SHA256_CTX * ctx)\n{\n\n\t/* Zero bits processed so far */\n\tctx->count[0] = ctx->count[1] = 0;\n\n\t/* Magic initialization constants */\n\tctx->state[0] = 0x6A09E667;\n\tctx->state[1] = 0xBB67AE85;\n\tctx->state[2] = 0x3C6EF372;\n\tctx->state[3] = 0xA54FF53A;\n\tctx->state[4] = 0x510E527F;\n\tctx->state[5] = 0x9B05688C;\n\tctx->state[6] = 0x1F83D9AB;\n\tctx->state[7] = 0x5BE0CD19;\n}\n\n/* Add bytes into the hash */\nvoid\nSHA256_Update(SHA256_CTX * ctx, const void *in, size_t len)\n{\n\tuint32_t bitlen[2];\n\tuint32_t r;\n\tconst unsigned char *src = in;\n\n\t/* Number of bytes left in the buffer from previous updates */\n\tr = (ctx->count[1] >> 3) & 0x3f;\n\n\t/* Convert the length into a number of bits */\n\tbitlen[1] = ((uint32_t)len) << 3;\n\tbitlen[0] = (uint32_t)(len >> 29);\n\n\t/* Update number of bits */\n\tif ((ctx->count[1] += bitlen[1]) < bitlen[1])\n\t\tctx->count[0]++;\n\tctx->count[0] += bitlen[0];\n\n\t/* Handle the case where we don't need to perform any transforms */\n\tif (len < 64 - r) {\n\t\tmemcpy(&ctx->buf[r], src, len);\n\t\treturn;\n\t}\n\n\t/* Finish the current block */\n\tmemcpy(&ctx->buf[r], src, 64 - r);\n\tSHA256_Transform(ctx->state, ctx->buf);\n\tsrc += 64 - r;\n\tlen -= 64 - r;\n\n\t/* Perform complete blocks */\n\twhile (len >= 64) {\n\t\tSHA256_Transform(ctx->state, src);\n\t\tsrc += 64;\n\t\tlen -= 64;\n\t}\n\n\t/* Copy left over data into buffer */\n\tmemcpy(ctx->buf, src, len);\n}\n\n/*\n * SHA-256 finalization.  Pads the input data, exports the hash value,\n * and clears the context state.\n */\nvoid\nSHA256_Final(unsigned char digest[32], SHA256_CTX * ctx)\n{\n\n\t/* Add padding */\n\tSHA256_Pad(ctx);\n\n\t/* Write the hash */\n\tbe32enc_vect(digest, ctx->state, 32);\n\n\t/* Clear the context state */\n\tmemset((void *)ctx, 0, sizeof(*ctx));\n}\n\n/* Initialize an HMAC-SHA256 operation with the given key. */\nvoid\nHMAC_SHA256_Init(HMAC_SHA256_CTX * ctx, const void * _K, size_t Klen)\n{\n\tunsigned char pad[64];\n\tunsigned char khash[32];\n\tconst unsigned char * K = _K;\n\tsize_t i;\n\n\t/* If Klen > 64, the key is really SHA256(K). */\n\tif (Klen > 64) {\n\t\tSHA256_Init(&ctx->ictx);\n\t\tSHA256_Update(&ctx->ictx, K, Klen);\n\t\tSHA256_Final(khash, &ctx->ictx);\n\t\tK = khash;\n\t\tKlen = 32;\n\t}\n\n\t/* Inner SHA256 operation is SHA256(K xor [block of 0x36] || data). */\n\tSHA256_Init(&ctx->ictx);\n\tmemset(pad, 0x36, 64);\n\tfor (i = 0; i < Klen; i++)\n\t\tpad[i] ^= K[i];\n\tSHA256_Update(&ctx->ictx, pad, 64);\n\n\t/* Outer SHA256 operation is SHA256(K xor [block of 0x5c] || hash). */\n\tSHA256_Init(&ctx->octx);\n\tmemset(pad, 0x5c, 64);\n\tfor (i = 0; i < Klen; i++)\n\t\tpad[i] ^= K[i];\n\tSHA256_Update(&ctx->octx, pad, 64);\n\n\t/* Clean the stack. */\n\tmemset(khash, 0, 32);\n}\n\n/* Add bytes to the HMAC-SHA256 operation. */\nvoid\nHMAC_SHA256_Update(HMAC_SHA256_CTX * ctx, const void *in, size_t len)\n{\n\n\t/* Feed data to the inner SHA256 operation. */\n\tSHA256_Update(&ctx->ictx, in, len);\n}\n\n/* Finish an HMAC-SHA256 operation. */\nvoid\nHMAC_SHA256_Final(unsigned char digest[32], HMAC_SHA256_CTX * ctx)\n{\n\tunsigned char ihash[32];\n\n\t/* Finish the inner SHA256 operation. */\n\tSHA256_Final(ihash, &ctx->ictx);\n\n\t/* Feed the inner hash to the outer SHA256 operation. */\n\tSHA256_Update(&ctx->octx, ihash, 32);\n\n\t/* Finish the outer SHA256 operation. */\n\tSHA256_Final(digest, &ctx->octx);\n\n\t/* Clean the stack. */\n\tmemset(ihash, 0, 32);\n}\n\n/**\n * PBKDF2_SHA256(passwd, passwdlen, salt, saltlen, c, buf, dkLen):\n * Compute PBKDF2(passwd, salt, c, dkLen) using HMAC-SHA256 as the PRF, and\n * write the output to buf.  The value dkLen must be at most 32 * (2^32 - 1).\n */\nvoid\nPBKDF2_SHA256(const uint8_t * passwd, size_t passwdlen, const uint8_t * salt,\n    size_t saltlen, uint64_t c, uint8_t * buf, size_t dkLen)\n{\n\tHMAC_SHA256_CTX PShctx, hctx;\n\tsize_t i;\n\tuint8_t ivec[4];\n\tuint8_t U[32];\n\tuint8_t T[32];\n\tuint64_t j;\n\tint k;\n\tsize_t clen;\n\n\t/* Compute HMAC state after processing P and S. */\n\tHMAC_SHA256_Init(&PShctx, passwd, passwdlen);\n\tHMAC_SHA256_Update(&PShctx, salt, saltlen);\n\n\t/* Iterate through the blocks. */\n\tfor (i = 0; i * 32 < dkLen; i++) {\n\t\t/* Generate INT(i + 1). */\n\t\tbe32enc(ivec, (uint32_t)(i + 1));\n\n\t\t/* Compute U_1 = PRF(P, S || INT(i)). */\n\t\tmemcpy(&hctx, &PShctx, sizeof(HMAC_SHA256_CTX));\n\t\tHMAC_SHA256_Update(&hctx, ivec, 4);\n\t\tHMAC_SHA256_Final(U, &hctx);\n\n\t\t/* T_i = U_1 ... */\n\t\tmemcpy(T, U, 32);\n\n\t\tfor (j = 2; j <= c; j++) {\n\t\t\t/* Compute U_j. */\n\t\t\tHMAC_SHA256_Init(&hctx, passwd, passwdlen);\n\t\t\tHMAC_SHA256_Update(&hctx, U, 32);\n\t\t\tHMAC_SHA256_Final(U, &hctx);\n\n\t\t\t/* ... xor U_j ... */\n\t\t\tfor (k = 0; k < 32; k++)\n\t\t\t\tT[k] ^= U[k];\n\t\t}\n\n\t\t/* Copy as many bytes as necessary into buf. */\n\t\tclen = dkLen - i * 32;\n\t\tif (clen > 32)\n\t\t\tclen = 32;\n\t\tmemcpy(&buf[i * 32], T, clen);\n\t}\n\n\t/* Clean PShctx, since we never called _Final on it. */\n\tmemset(&PShctx, 0, sizeof(HMAC_SHA256_CTX));\n}\n"
        },
        {
            "file_name": "sha256.c",
            "content": "/*-\n * Copyright 2005,2007,2009 Colin Percival\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * This file was originally written by Colin Percival and distributed\n * as a component of the scrypt key derivation function. In 2013,\n * Daniel Franke made minor changes for portability and included it as\n * a component of the EARWORM password hash. Original non-static\n * function names have been prefixed by 'earworm_' to prevent\n * namespace pollution.\n */\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"util.h\"\n#include \"sha256.h\"\n\n/*\n * Encode a length len/4 vector of (uint32_t) into a length len vector\n * of (unsigned char) in big-endian form.  Assumes len is a multiple\n * of 4.\n */\nstatic void\nbe32enc_vect(unsigned char *dst, const uint32_t *src, size_t len)\n{\n  size_t i;\n\n  for (i = 0; i < len / 4; i++)\n    be32enc(dst + i * 4, src[i]);\n}\n\n/*\n * Decode a big-endian length len vector of (unsigned char) into a length\n * len/4 vector of (uint32_t).  Assumes len is a multiple of 4.\n */\nstatic void\nbe32dec_vect(uint32_t *dst, const unsigned char *src, size_t len)\n{\n  size_t i;\n  \n  for (i = 0; i < len / 4; i++)\n    dst[i] = be32dec(src + i * 4);\n}\n\n/* Elementary functions used by SHA256 */\n#define Ch(x, y, z)\t((x & (y ^ z)) ^ z)\n#define Maj(x, y, z)\t((x & (y | z)) | (y & z))\n#define SHR(x, n)\t(x >> n)\n#define ROTR(x, n)\t((x >> n) | (x << (32 - n)))\n#define S0(x)\t\t(ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22))\n#define S1(x)\t\t(ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25))\n#define s0(x)\t\t(ROTR(x, 7) ^ ROTR(x, 18) ^ SHR(x, 3))\n#define s1(x)\t\t(ROTR(x, 17) ^ ROTR(x, 19) ^ SHR(x, 10))\n\n/* SHA256 round function */\n#define RND(a, b, c, d, e, f, g, h, k)                          \\\n  t0 = h + S1(e) + Ch(e, f, g) + k;                             \\\n                               t1 = S0(a) + Maj(a, b, c);       \\\n                                          d += t0;              \\\n                                          h  = t0 + t1;\n\n/* Adjusted round function for rotating state */\n#define RNDr(S, W, i, k)\t\t\t\\\n  RND(S[(64 - i) % 8], S[(65 - i) % 8],         \\\n      S[(66 - i) % 8], S[(67 - i) % 8],         \\\n      S[(68 - i) % 8], S[(69 - i) % 8],         \\\n      S[(70 - i) % 8], S[(71 - i) % 8],         \\\n      W[i] + k)\n\n/*\n * SHA256 block compression function.  The 256-bit state is\n * transformed via the 512-bit input block to produce a new state.\n */\nstatic void\nSHA256_Transform(uint32_t * state, const unsigned char block[64])\n{\n  uint32_t W[64];\n  uint32_t S[8];\n  uint32_t t0, t1;\n  int i;\n\n  /* 1. Prepare message schedule W. */\n  be32dec_vect(W, block, 64);\n  for (i = 16; i < 64; i++)\n    W[i] = s1(W[i - 2]) + W[i - 7] + s0(W[i - 15]) + W[i - 16];\n\n  /* 2. Initialize working variables. */\n  memcpy(S, state, 32);\n\n  /* 3. Mix. */\n  RNDr(S, W, 0, 0x428a2f98);\n  RNDr(S, W, 1, 0x71374491);\n  RNDr(S, W, 2, 0xb5c0fbcf);\n  RNDr(S, W, 3, 0xe9b5dba5);\n  RNDr(S, W, 4, 0x3956c25b);\n  RNDr(S, W, 5, 0x59f111f1);\n  RNDr(S, W, 6, 0x923f82a4);\n  RNDr(S, W, 7, 0xab1c5ed5);\n  RNDr(S, W, 8, 0xd807aa98);\n  RNDr(S, W, 9, 0x12835b01);\n  RNDr(S, W, 10, 0x243185be);\n  RNDr(S, W, 11, 0x550c7dc3);\n  RNDr(S, W, 12, 0x72be5d74);\n  RNDr(S, W, 13, 0x80deb1fe);\n  RNDr(S, W, 14, 0x9bdc06a7);\n  RNDr(S, W, 15, 0xc19bf174);\n  RNDr(S, W, 16, 0xe49b69c1);\n  RNDr(S, W, 17, 0xefbe4786);\n  RNDr(S, W, 18, 0x0fc19dc6);\n  RNDr(S, W, 19, 0x240ca1cc);\n  RNDr(S, W, 20, 0x2de92c6f);\n  RNDr(S, W, 21, 0x4a7484aa);\n  RNDr(S, W, 22, 0x5cb0a9dc);\n  RNDr(S, W, 23, 0x76f988da);\n  RNDr(S, W, 24, 0x983e5152);\n  RNDr(S, W, 25, 0xa831c66d);\n  RNDr(S, W, 26, 0xb00327c8);\n  RNDr(S, W, 27, 0xbf597fc7);\n  RNDr(S, W, 28, 0xc6e00bf3);\n  RNDr(S, W, 29, 0xd5a79147);\n  RNDr(S, W, 30, 0x06ca6351);\n  RNDr(S, W, 31, 0x14292967);\n  RNDr(S, W, 32, 0x27b70a85);\n  RNDr(S, W, 33, 0x2e1b2138);\n  RNDr(S, W, 34, 0x4d2c6dfc);\n  RNDr(S, W, 35, 0x53380d13);\n  RNDr(S, W, 36, 0x650a7354);\n  RNDr(S, W, 37, 0x766a0abb);\n  RNDr(S, W, 38, 0x81c2c92e);\n  RNDr(S, W, 39, 0x92722c85);\n  RNDr(S, W, 40, 0xa2bfe8a1);\n  RNDr(S, W, 41, 0xa81a664b);\n  RNDr(S, W, 42, 0xc24b8b70);\n  RNDr(S, W, 43, 0xc76c51a3);\n  RNDr(S, W, 44, 0xd192e819);\n  RNDr(S, W, 45, 0xd6990624);\n  RNDr(S, W, 46, 0xf40e3585);\n  RNDr(S, W, 47, 0x106aa070);\n  RNDr(S, W, 48, 0x19a4c116);\n  RNDr(S, W, 49, 0x1e376c08);\n  RNDr(S, W, 50, 0x2748774c);\n  RNDr(S, W, 51, 0x34b0bcb5);\n  RNDr(S, W, 52, 0x391c0cb3);\n  RNDr(S, W, 53, 0x4ed8aa4a);\n  RNDr(S, W, 54, 0x5b9cca4f);\n  RNDr(S, W, 55, 0x682e6ff3);\n  RNDr(S, W, 56, 0x748f82ee);\n  RNDr(S, W, 57, 0x78a5636f);\n  RNDr(S, W, 58, 0x84c87814);\n  RNDr(S, W, 59, 0x8cc70208);\n  RNDr(S, W, 60, 0x90befffa);\n  RNDr(S, W, 61, 0xa4506ceb);\n  RNDr(S, W, 62, 0xbef9a3f7);\n  RNDr(S, W, 63, 0xc67178f2);\n\n  /* 4. Mix local working variables into global state */\n  for (i = 0; i < 8; i++)\n    state[i] += S[i];\n\n  /* Clean the stack. */\n  secure_wipe(&t0, sizeof t0);\n  secure_wipe(&t1, sizeof t1);\n  secure_wipe(W, sizeof W);\n  secure_wipe(S, sizeof S);\n}\n\nstatic unsigned char PAD[64] = {\n  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n};\n\n/* Add padding and terminating bit-count. */\nstatic void\nSHA256_Pad(SHA256_CTX * ctx)\n{\n  unsigned char len[8];\n  uint32_t r, plen;\n\n  /*\n   * Convert length to a vector of bytes -- we do this now rather\n   * than later because the length will change after we pad.\n   */\n  be32enc_vect(len, ctx->count, 8);\n\n  /* Add 1--64 bytes so that the resulting length is 56 mod 64 */\n  r = (ctx->count[1] >> 3) & 0x3f;\n  plen = (r < 56) ? (56 - r) : (120 - r);\n  earworm_SHA256_Update(ctx, PAD, (size_t)plen);\n\n  /* Add the terminating bit-count */\n  earworm_SHA256_Update(ctx, len, 8);\n}\n\n/* SHA-256 initialization.  Begins a SHA-256 operation. */\nvoid\nearworm_SHA256_Init(SHA256_CTX * ctx)\n{\n\n  /* Zero bits processed so far */\n  ctx->count[0] = ctx->count[1] = 0;\n\n  /* Magic initialization constants */\n  ctx->state[0] = 0x6A09E667;\n  ctx->state[1] = 0xBB67AE85;\n  ctx->state[2] = 0x3C6EF372;\n  ctx->state[3] = 0xA54FF53A;\n  ctx->state[4] = 0x510E527F;\n  ctx->state[5] = 0x9B05688C;\n  ctx->state[6] = 0x1F83D9AB;\n  ctx->state[7] = 0x5BE0CD19;\n}\n\n/* Add bytes into the hash */\nvoid\nearworm_SHA256_Update(SHA256_CTX * ctx, const void *in, size_t len)\n{\n  uint32_t bitlen[2];\n  uint32_t r;\n  const unsigned char *src = in;\n\n  /* Number of bytes left in the buffer from previous updates */\n  r = (ctx->count[1] >> 3) & 0x3f;\n\n  /* Convert the length into a number of bits */\n  bitlen[1] = ((uint32_t)len) << 3;\n  bitlen[0] = (uint32_t)(len >> 29);\n\n  /* Update number of bits */\n  if ((ctx->count[1] += bitlen[1]) < bitlen[1])\n    ctx->count[0]++;\n  ctx->count[0] += bitlen[0];\n\n  /* Handle the case where we don't need to perform any transforms */\n  if (len < 64 - r) {\n    memcpy(&ctx->buf[r], src, len);\n    return;\n  }\n\n  /* Finish the current block */\n  memcpy(&ctx->buf[r], src, 64 - r);\n  SHA256_Transform(ctx->state, ctx->buf);\n  src += 64 - r;\n  len -= 64 - r;\n\n  /* Perform complete blocks */\n  while (len >= 64) {\n    SHA256_Transform(ctx->state, src);\n    src += 64;\n    len -= 64;\n  }\n\n  /* Copy left over data into buffer */\n  memcpy(ctx->buf, src, len);\n}\n\n/*\n * SHA-256 finalization.  Pads the input data, exports the hash value,\n * and clears the context state.\n */\nvoid\nearworm_SHA256_Final(unsigned char digest[32], SHA256_CTX * ctx)\n{\n\n  /* Add padding */\n  SHA256_Pad(ctx);\n\n  /* Write the hash */\n  be32enc_vect(digest, ctx->state, 32);\n\n  /* Clear the context state */\n  secure_wipe(ctx, sizeof (*ctx));\n}\n\n/* Initialize an HMAC-SHA256 operation with the given key. */\nvoid\nearworm_HMAC_SHA256_Init(HMAC_SHA256_CTX * ctx, const void * _K, size_t Klen)\n{\n  unsigned char pad[64];\n  unsigned char khash[32];\n  const unsigned char * K = _K;\n  size_t i;\n\n  /* If Klen > 64, the key is really SHA256(K). */\n  if (Klen > 64) {\n    earworm_SHA256_Init(&ctx->ictx);\n    earworm_SHA256_Update(&ctx->ictx, K, Klen);\n    earworm_SHA256_Final(khash, &ctx->ictx);\n    K = khash;\n    Klen = 32;\n  }\n\n  /* Inner SHA256 operation is SHA256(K xor [block of 0x36] || data). */\n  earworm_SHA256_Init(&ctx->ictx);\n  memset(pad, 0x36, 64);\n  for (i = 0; i < Klen; i++)\n    pad[i] ^= K[i];\n  earworm_SHA256_Update(&ctx->ictx, pad, 64);\n\n  /* Outer SHA256 operation is SHA256(K xor [block of 0x5c] || hash). */\n  earworm_SHA256_Init(&ctx->octx);\n  memset(pad, 0x5c, 64);\n  for (i = 0; i < Klen; i++)\n    pad[i] ^= K[i];\n  earworm_SHA256_Update(&ctx->octx, pad, 64);\n\n  /* Clean the stack. */\n  secure_wipe(khash, sizeof khash);\n}\n\n/* Add bytes to the HMAC-SHA256 operation. */\nvoid\nearworm_HMAC_SHA256_Update(HMAC_SHA256_CTX * ctx, const void *in, size_t len)\n{\n\n  /* Feed data to the inner SHA256 operation. */\n  earworm_SHA256_Update(&ctx->ictx, in, len);\n}\n\n/* Finish an HMAC-SHA256 operation. */\nvoid\nearworm_HMAC_SHA256_Final(unsigned char digest[32], HMAC_SHA256_CTX * ctx)\n{\n  unsigned char ihash[32];\n\n  /* Finish the inner SHA256 operation. */\n  earworm_SHA256_Final(ihash, &ctx->ictx);\n\n  /* Feed the inner hash to the outer SHA256 operation. */\n  earworm_SHA256_Update(&ctx->octx, ihash, 32);\n\n  /* Finish the outer SHA256 operation. */\n  earworm_SHA256_Final(digest, &ctx->octx);\n\n  /* Clean the stack. */\n  secure_wipe(ihash, sizeof ihash);\n}\n\n/**\n * PBKDF2_SHA256(passwd, passwdlen, salt, saltlen, c, buf, dkLen):\n * Compute PBKDF2(passwd, salt, c, dkLen) using HMAC-SHA256 as the\n * PRF, and write the output to buf.  The value dkLen must be at most\n * 32 * (2^32 - 1).\n */\nvoid\nearworm_PBKDF2_SHA256(const uint8_t * passwd, size_t passwdlen,\n\t\t      const uint8_t * salt, size_t saltlen,\n\t\t      uint64_t c, uint8_t * buf, size_t dkLen)\n{\n  HMAC_SHA256_CTX PShctx, hctx;\n  size_t i;\n  uint8_t ivec[4];\n  uint8_t U[32];\n  uint8_t T[32];\n  uint64_t j;\n  int k;\n  size_t clen;\n\n  /* Compute HMAC state after processing P and S. */\n  earworm_HMAC_SHA256_Init(&PShctx, passwd, passwdlen);\n  earworm_HMAC_SHA256_Update(&PShctx, salt, saltlen);\n\n  /* Iterate through the blocks. */\n  for (i = 0; i * 32 < dkLen; i++) {\n    /* Generate INT(i + 1). */\n    be32enc(ivec, (uint32_t)(i + 1));\n\n    /* Compute U_1 = PRF(P, S || INT(i)). */\n    memcpy(&hctx, &PShctx, sizeof(HMAC_SHA256_CTX));\n    earworm_HMAC_SHA256_Update(&hctx, ivec, 4);\n    earworm_HMAC_SHA256_Final(U, &hctx);\n\n    /* T_i = U_1 ... */\n    memcpy(T, U, 32);\n\n    for (j = 2; j <= c; j++) {\n      /* Compute U_j. */\n      earworm_HMAC_SHA256_Init(&hctx, passwd, passwdlen);\n      earworm_HMAC_SHA256_Update(&hctx, U, 32);\n      earworm_HMAC_SHA256_Final(U, &hctx);\n\n      /* ... xor U_j ... */\n      for (k = 0; k < 32; k++)\n        T[k] ^= U[k];\n    }\n\n    /* Copy as many bytes as necessary into buf. */\n    clen = dkLen - i * 32;\n    if (clen > 32)\n      clen = 32;\n    memcpy(&buf[i * 32], T, clen);\n  }\n\n  /* Clean PShctx, since we never called _Final on it. */\n  secure_wipe(&PShctx, sizeof(HMAC_SHA256_CTX));\n}\n"
        },
        {
            "file_name": "sha512 copy.cpp",
            "content": "// Copyright (c) 2014 Steve Thomas <steve AT tobtu DOT com>\n\n#include <string.h>\n#include \"sha512.h\"\n\nconst uint64_t SHA512_CONSTS[80] = {\n\tUINT64_C(0x428a2f98d728ae22), UINT64_C(0x7137449123ef65cd), UINT64_C(0xb5c0fbcfec4d3b2f), UINT64_C(0xe9b5dba58189dbbc), UINT64_C(0x3956c25bf348b538), \n\tUINT64_C(0x59f111f1b605d019), UINT64_C(0x923f82a4af194f9b), UINT64_C(0xab1c5ed5da6d8118), UINT64_C(0xd807aa98a3030242), UINT64_C(0x12835b0145706fbe), \n\tUINT64_C(0x243185be4ee4b28c), UINT64_C(0x550c7dc3d5ffb4e2), UINT64_C(0x72be5d74f27b896f), UINT64_C(0x80deb1fe3b1696b1), UINT64_C(0x9bdc06a725c71235), \n\tUINT64_C(0xc19bf174cf692694), UINT64_C(0xe49b69c19ef14ad2), UINT64_C(0xefbe4786384f25e3), UINT64_C(0x0fc19dc68b8cd5b5), UINT64_C(0x240ca1cc77ac9c65), \n\tUINT64_C(0x2de92c6f592b0275), UINT64_C(0x4a7484aa6ea6e483), UINT64_C(0x5cb0a9dcbd41fbd4), UINT64_C(0x76f988da831153b5), UINT64_C(0x983e5152ee66dfab), \n\tUINT64_C(0xa831c66d2db43210), UINT64_C(0xb00327c898fb213f), UINT64_C(0xbf597fc7beef0ee4), UINT64_C(0xc6e00bf33da88fc2), UINT64_C(0xd5a79147930aa725), \n\tUINT64_C(0x06ca6351e003826f), UINT64_C(0x142929670a0e6e70), UINT64_C(0x27b70a8546d22ffc), UINT64_C(0x2e1b21385c26c926), UINT64_C(0x4d2c6dfc5ac42aed), \n\tUINT64_C(0x53380d139d95b3df), UINT64_C(0x650a73548baf63de), UINT64_C(0x766a0abb3c77b2a8), UINT64_C(0x81c2c92e47edaee6), UINT64_C(0x92722c851482353b), \n\tUINT64_C(0xa2bfe8a14cf10364), UINT64_C(0xa81a664bbc423001), UINT64_C(0xc24b8b70d0f89791), UINT64_C(0xc76c51a30654be30), UINT64_C(0xd192e819d6ef5218), \n\tUINT64_C(0xd69906245565a910), UINT64_C(0xf40e35855771202a), UINT64_C(0x106aa07032bbd1b8), UINT64_C(0x19a4c116b8d2d0c8), UINT64_C(0x1e376c085141ab53), \n\tUINT64_C(0x2748774cdf8eeb99), UINT64_C(0x34b0bcb5e19b48a8), UINT64_C(0x391c0cb3c5c95a63), UINT64_C(0x4ed8aa4ae3418acb), UINT64_C(0x5b9cca4f7763e373), \n\tUINT64_C(0x682e6ff3d6b2b8a3), UINT64_C(0x748f82ee5defb2fc), UINT64_C(0x78a5636f43172f60), UINT64_C(0x84c87814a1f0ab72), UINT64_C(0x8cc702081a6439ec), \n\tUINT64_C(0x90befffa23631e28), UINT64_C(0xa4506cebde82bde9), UINT64_C(0xbef9a3f7b2c67915), UINT64_C(0xc67178f2e372532b), UINT64_C(0xca273eceea26619c), \n\tUINT64_C(0xd186b8c721c0c207), UINT64_C(0xeada7dd6cde0eb1e), UINT64_C(0xf57d4f7fee6ed178), UINT64_C(0x06f067aa72176fba), UINT64_C(0x0a637dc5a2c898a6), \n\tUINT64_C(0x113f9804bef90dae), UINT64_C(0x1b710b35131c471b), UINT64_C(0x28db77f523047d84), UINT64_C(0x32caab7b40c72493), UINT64_C(0x3c9ebe0a15c9bebc), \n\tUINT64_C(0x431d67c49c100d4c), UINT64_C(0x4cc5d4becb3e42b6), UINT64_C(0x597f299cfc657e2a), UINT64_C(0x5fcb6fab3ad6faec), UINT64_C(0x6c44198c4a475817)};\n\nvoid sha512Block(const uint64_t block[16], uint64_t state[8]);\n\nvoid Sha512::hash(const void *message, size_t length, void *out, uint32_t outLength)\n{\n\tuint64_t block[16];\n\tuint64_t state[8] = {\n\t\tUINT64_C(0x6a09e667f3bcc908), UINT64_C(0xbb67ae8584caa73b), UINT64_C(0x3c6ef372fe94f82b), UINT64_C(0xa54ff53a5f1d36f1),\n\t\tUINT64_C(0x510e527fade682d1), UINT64_C(0x9b05688c2b3e6c1f), UINT64_C(0x1f83d9abfb41bd6b), UINT64_C(0x5be0cd19137e2179)};\n\tsize_t   left = length;\n\n\twhile (left >= 128)\n\t{\n\t\tsha512Block((const uint64_t*) message, state);\n\t\tmessage = ((const uint64_t*) message) + 16;\n\t\tleft -= 128;\n\t}\n\tmemcpy(block, message, left);\n\t((uint8_t*) block)[left] = 0x80;\n\tmemset(((uint8_t*) block) + (left + 1), 0, 128 - (left + 1));\n\tif (left >= 128 - 16)\n\t{\n\t\tsha512Block(block, state);\n\t\tfor (uint32_t i = 0; i < 14; i++)\n\t\t{\n\t\t\tblock[i] = 0;\n\t\t}\n\t}\n\tuint64_t tmp;\n\ttmp = ((uint64_t) length) >> (64 - 3);\n\tblock[14] = WRITE_BIG_ENDIAN_64(tmp);\n\ttmp = ((uint64_t) length) << 3;\n\tblock[15] = WRITE_BIG_ENDIAN_64(tmp);\n\tsha512Block(block, state);\n\tif (outLength > 64)\n\t{\n\t\toutLength = 64;\n\t}\n\tfor (uint32_t i = 0, end = outLength / 8; i < end; i++)\n\t{\n\t\t((uint64_t*) out)[i] = WRITE_BIG_ENDIAN_64(state[i]);\n\t}\n\tfor (uint32_t i = outLength & ~7, shift = 56; i < outLength; i++, shift -= 8)\n\t{\n\t\t((uint8_t*) out)[i] = (uint8_t) (state[i / 8] >> shift);\n\t}\n}\n\nvoid Sha512::init()\n{\n\tm_messageLengthHi = 0;\n\tm_messageLengthLo = 0;\n\tm_state[0] = UINT64_C(0x6a09e667f3bcc908);\n\tm_state[1] = UINT64_C(0xbb67ae8584caa73b);\n\tm_state[2] = UINT64_C(0x3c6ef372fe94f82b);\n\tm_state[3] = UINT64_C(0xa54ff53a5f1d36f1);\n\tm_state[4] = UINT64_C(0x510e527fade682d1);\n\tm_state[5] = UINT64_C(0x9b05688c2b3e6c1f);\n\tm_state[6] = UINT64_C(0x1f83d9abfb41bd6b);\n\tm_state[7] = UINT64_C(0x5be0cd19137e2179);\n}\n\nvoid Sha512::update(const void *message, size_t length)\n{\n\tsize_t pos  = (size_t) m_messageLengthLo & 127;\n\tsize_t left = length;\n\n\tif (pos + left >= 128)\n\t{\n\t\tmemcpy(((uint8_t*) m_block) + pos, message, 128 - pos);\n\t\tsha512Block(m_block, m_state);\n\t\tmessage = ((const uint8_t*) message) + 128 - pos;\n\t\tleft -= 128 - pos;\n\t\twhile (left >= 128)\n\t\t{\n\t\t\tsha512Block(((const uint64_t*) message), m_state);\n\t\t\tmessage = ((const uint8_t*) message) + 128;\n\t\t\tleft -= 128;\n\t\t}\n\t\tmemcpy(m_block, message, left);\n\t}\n\telse\n\t{\n\t\tmemcpy(((uint8_t*) m_block) + pos, message, left);\n\t}\n\tm_messageLengthLo += length;\n\tif (m_messageLengthLo < length)\n\t{\n\t\tm_messageLengthHi++;\n\t}\n}\n\nvoid Sha512::finish(void *out, uint32_t outLength)\n{\n\tuint64_t lengthHi = m_messageLengthHi;\n\tuint64_t lengthLo = m_messageLengthLo;\n\n\t((uint8_t*) m_block)[lengthLo % 128] = 0x80;\n\tmemset(((uint8_t*) m_block) + (lengthLo % 128 + 1), 0, 128 - (lengthLo % 128 + 1));\n\tif (lengthLo % 128 >= 128 - 16)\n\t{\n\t\tsha512Block(m_block, m_state);\n\t\tfor (uint32_t i = 0; i < 15; i++)\n\t\t{\n\t\t\tm_block[i] = 0;\n\t\t}\n\t}\n\tlengthHi  = (lengthHi << 3) + (lengthLo >> (64 - 3));\n\tlengthLo *= 8;\n\tm_block[14] = WRITE_BIG_ENDIAN_64(lengthHi);\n\tm_block[15] = WRITE_BIG_ENDIAN_64(lengthLo);\n\tsha512Block(m_block, m_state);\n\tif (outLength > 64)\n\t{\n\t\toutLength = 64;\n\t}\n\tfor (uint32_t i = 0, end = outLength / 8; i < end; i++)\n\t{\n\t\t((uint64_t*) out)[i] = WRITE_BIG_ENDIAN_64(m_state[i]);\n\t}\n\tfor (uint32_t i = outLength & ~7, shift = 56; i < outLength; i++, shift -= 8)\n\t{\n\t\t((uint8_t*) out)[i] = (uint8_t) (m_state[i / 8] >> shift);\n\t}\n}\n\nvoid sha512Block(const uint64_t block[16], uint64_t state[8])\n{\n#define ROTR(n,s) ((n >> s) | (n << (64 - s)))\n#define SHA512_STEP(a,b,c,d,e,f,g,h,w,i) \\\n\th += (ROTR(e, 14) ^ ROTR(e, 18) ^ ROTR(e, 41)) + ((e & f) ^ (~e & g)) + SHA512_CONSTS[i] + w[i]; \\\n\td += h; \\\n\th += (ROTR(a, 28) ^ ROTR(a, 34) ^ ROTR(a, 39)) + ((a & b) ^ (a & c) ^ (b & c));\n\n\tuint64_t w[80];\n\tuint64_t a = state[0];\n\tuint64_t b = state[1];\n\tuint64_t c = state[2];\n\tuint64_t d = state[3];\n\tuint64_t e = state[4];\n\tuint64_t f = state[5];\n\tuint64_t g = state[6];\n\tuint64_t h = state[7];\n\n\tfor (int i = 0; i < 16; i++)\n\t{\n\t\tw[i] = READ_BIG_ENDIAN_64(block[i]);\n\t}\n\tfor (int i = 16; i < 80; i++)\n\t{\n        w[i] = \n\t\t\tw[i-16] +\n\t\t\tw[i- 7] +\n\t\t\t(ROTR(w[i-15],  1) ^ ROTR(w[i-15],  8) ^ (w[i-15] >> 7)) +\n\t\t\t(ROTR(w[i- 2], 19) ^ ROTR(w[i- 2], 61) ^ (w[i- 2] >> 6));\n\t}\n\n\tfor (int i = 0; i < 80; i += 8)\n\t{\n\t\tSHA512_STEP(a,b,c,d,e,f,g,h,w,i+0);\n\t\tSHA512_STEP(h,a,b,c,d,e,f,g,w,i+1);\n\t\tSHA512_STEP(g,h,a,b,c,d,e,f,w,i+2);\n\t\tSHA512_STEP(f,g,h,a,b,c,d,e,w,i+3);\n\t\tSHA512_STEP(e,f,g,h,a,b,c,d,w,i+4);\n\t\tSHA512_STEP(d,e,f,g,h,a,b,c,w,i+5);\n\t\tSHA512_STEP(c,d,e,f,g,h,a,b,w,i+6);\n\t\tSHA512_STEP(b,c,d,e,f,g,h,a,w,i+7);\n\t}\n\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\tstate[5] += f;\n\tstate[6] += g;\n\tstate[7] += h;\n\n#undef ROTR\n#undef SHA512_STEP\n}\n"
        },
        {
            "file_name": "sha512.c",
            "content": "/* sha512.c - optimized single block sha512 implementation.\n * Copyright 2013, epixoip.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that redistribution of source\n * retains the above copyright.\n */ \n\n#include <stdint.h>\n#include \"sha512.h\"\n\nvoid pf_sha512 (const unsigned char *in, size_t len, uint64_t digest[8])\n{\n        int i, j;\n        unsigned char buf[128] = {0};\n\n        uint64_t tmp1 = 0, tmp2 = 0;\n\n        uint64_t a,  b,  c,  d,  e,  f,  g,  h,\n                 aa, bb, cc, dd, ee, ff, gg, hh;\n\n        uint64_t w0  = 0, w1  = 0, w2  = 0, w3  = 0,\n                 w4  = 0, w5  = 0, w6  = 0, w7  = 0,\n                 w8  = 0, w9  = 0, w10 = 0, w11 = 0,\n                 w12 = 0, w13 = 0, w14 = 0, w15 = 0;\n\n        uint64_t *w[14];\n\n        w[ 0] = &w0;  w[ 1] = &w1;  w[ 2] = &w2;  w[ 3] = &w3,\n        w[ 4] = &w4;  w[ 5] = &w5;  w[ 6] = &w6;  w[ 7] = &w7;\n        w[ 8] = &w8;  w[ 9] = &w9;  w[10] = &w10; w[11] = &w11;\n        w[12] = &w12; w[13] = &w13; w[14] = &w14;\n\n        for (i = 0; i < len; i++)\n                buf[i] = in[i];\n        buf[len] = 0x80;\n\n        for (i=0, j=0; i < len + 1 && j < 15; i+=8, j++)\n                uchar_to_uint64 (*w[j], buf, i);\n        w15 = len << 3;\n\n        aa = 0x6a09e667f3bcc908;\n        bb = 0xbb67ae8584caa73b;\n        cc = 0x3c6ef372fe94f82b;\n        dd = 0xa54ff53a5f1d36f1;\n        ee = 0x510e527fade682d1;\n        ff = 0x9b05688c2b3e6c1f;\n        gg = 0x1f83d9abfb41bd6b;\n        hh = 0x5be0cd19137e2179;\n\n        SHA512_BODY;\n\n        digest[0] = __builtin_bswap64 (aa);\n        digest[1] = __builtin_bswap64 (bb);\n        digest[2] = __builtin_bswap64 (cc);\n        digest[3] = __builtin_bswap64 (dd);\n        digest[4] = __builtin_bswap64 (ee);\n        digest[5] = __builtin_bswap64 (ff);\n        digest[6] = __builtin_bswap64 (gg);\n        digest[7] = __builtin_bswap64 (hh);\n}\n"
        },
        {
            "file_name": "Sha512.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"Sha512_data.h\"\n\n#define\tROTATE(x,n)\t\t(((x) >> (n)) | ((x) << (64 - (n))))\n#define\tSHIFT(x,n)\t\t((x) >> (n))\n\n/*\n * Helper macros used by the SHA-512 computation.\n */\n#define\tCH(x,y,z)\t\t(((x) & (y)) ^ ((~(x)) & (z)))\n#define\tMAJ(x,y,z)\t\t(((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))\n#define\tSUM0(x)\t\t\t(ROTATE((x), 28) ^ ROTATE((x), 34) ^ ROTATE((x), 39))\n#define\tSUM1(x)\t\t\t(ROTATE((x), 14) ^ ROTATE((x), 18) ^ ROTATE((x), 41))\n#define\tRHO0(x)\t\t\t(ROTATE((x), 1) ^ ROTATE((x), 8) ^ SHIFT((x), 7))\n#define\tRHO1(x)\t\t\t(ROTATE((x), 19) ^ ROTATE((x), 61) ^ SHIFT((x), 6))\n\n/*\n * Constants used in each of the SHA-512 rounds.\n */\nconst QWORD K[80] = {\n(QWORD)(0x428a2f98d728ae22), (QWORD)(0x7137449123ef65cd),\n(QWORD)(0xb5c0fbcfec4d3b2f), (QWORD)(0xe9b5dba58189dbbc),\n(QWORD)(0x3956c25bf348b538), (QWORD)(0x59f111f1b605d019),\n(QWORD)(0x923f82a4af194f9b), (QWORD)(0xab1c5ed5da6d8118),\n(QWORD)(0xd807aa98a3030242), (QWORD)(0x12835b0145706fbe),\n(QWORD)(0x243185be4ee4b28c), (QWORD)(0x550c7dc3d5ffb4e2),\n(QWORD)(0x72be5d74f27b896f), (QWORD)(0x80deb1fe3b1696b1),\n(QWORD)(0x9bdc06a725c71235), (QWORD)(0xc19bf174cf692694),\n(QWORD)(0xe49b69c19ef14ad2), (QWORD)(0xefbe4786384f25e3),\n(QWORD)(0x0fc19dc68b8cd5b5), (QWORD)(0x240ca1cc77ac9c65),\n(QWORD)(0x2de92c6f592b0275), (QWORD)(0x4a7484aa6ea6e483),\n(QWORD)(0x5cb0a9dcbd41fbd4), (QWORD)(0x76f988da831153b5),\n(QWORD)(0x983e5152ee66dfab), (QWORD)(0xa831c66d2db43210),\n(QWORD)(0xb00327c898fb213f), (QWORD)(0xbf597fc7beef0ee4),\n(QWORD)(0xc6e00bf33da88fc2), (QWORD)(0xd5a79147930aa725),\n(QWORD)(0x06ca6351e003826f), (QWORD)(0x142929670a0e6e70),\n(QWORD)(0x27b70a8546d22ffc), (QWORD)(0x2e1b21385c26c926),\n(QWORD)(0x4d2c6dfc5ac42aed), (QWORD)(0x53380d139d95b3df),\n(QWORD)(0x650a73548baf63de), (QWORD)(0x766a0abb3c77b2a8),\n(QWORD)(0x81c2c92e47edaee6), (QWORD)(0x92722c851482353b),\n(QWORD)(0xa2bfe8a14cf10364), (QWORD)(0xa81a664bbc423001),\n(QWORD)(0xc24b8b70d0f89791), (QWORD)(0xc76c51a30654be30),\n(QWORD)(0xd192e819d6ef5218), (QWORD)(0xd69906245565a910),\n(QWORD)(0xf40e35855771202a), (QWORD)(0x106aa07032bbd1b8),\n(QWORD)(0x19a4c116b8d2d0c8), (QWORD)(0x1e376c085141ab53),\n(QWORD)(0x2748774cdf8eeb99), (QWORD)(0x34b0bcb5e19b48a8),\n(QWORD)(0x391c0cb3c5c95a63), (QWORD)(0x4ed8aa4ae3418acb),\n(QWORD)(0x5b9cca4f7763e373), (QWORD)(0x682e6ff3d6b2b8a3),\n(QWORD)(0x748f82ee5defb2fc), (QWORD)(0x78a5636f43172f60),\n(QWORD)(0x84c87814a1f0ab72), (QWORD)(0x8cc702081a6439ec),\n(QWORD)(0x90befffa23631e28), (QWORD)(0xa4506cebde82bde9),\n(QWORD)(0xbef9a3f7b2c67915), (QWORD)(0xc67178f2e372532b),\n(QWORD)(0xca273eceea26619c), (QWORD)(0xd186b8c721c0c207),\n(QWORD)(0xeada7dd6cde0eb1e), (QWORD)(0xf57d4f7fee6ed178),\n(QWORD)(0x06f067aa72176fba), (QWORD)(0x0a637dc5a2c898a6),\n(QWORD)(0x113f9804bef90dae), (QWORD)(0x1b710b35131c471b),\n(QWORD)(0x28db77f523047d84), (QWORD)(0x32caab7b40c72493),\n(QWORD)(0x3c9ebe0a15c9bebc), (QWORD)(0x431d67c49c100d4c),\n(QWORD)(0x4cc5d4becb3e42b6), (QWORD)(0x597f299cfc657e2a),\n(QWORD)(0x5fcb6fab3ad6faec), (QWORD)(0x6c44198c4a475817)\n};\n\nvoid Sha512_init(SHA512_DATA *sha)\n{\n\tsha->inputLen = 0;\n\tsha->A = (QWORD)(0x6a09e667f3bcc908);\n\tsha->B = (QWORD)(0xbb67ae8584caa73b);\n\tsha->C = (QWORD)(0x3c6ef372fe94f82b);\n\tsha->D = (QWORD)(0xa54ff53a5f1d36f1);\n\tsha->E = (QWORD)(0x510e527fade682d1);\n\tsha->F = (QWORD)(0x9b05688c2b3e6c1f);\n\tsha->G = (QWORD)(0x1f83d9abfb41bd6b);\n\tsha->H = (QWORD)(0x5be0cd19137e2179);\n\tsha->totalLen = 0;\n}\n\nvoid ProcessBlock(SHA512_DATA *sha, const BYTE *block)\n{\n\tQWORD W[80];\n\tQWORD a, b, c, d, e, f, g, h;\n\tQWORD temp, temp2;\n\tint t;\n\n\t/* Unpack the block into 80 64-bit words */\n\tfor(t = 0; t < 16; ++t)\n\t{\n\t\tW[t] = (((QWORD)(block[t * 8 + 0])) << 56) |\n\t\t       (((QWORD)(block[t * 8 + 1])) << 48) |\n\t\t       (((QWORD)(block[t * 8 + 2])) << 40) |\n\t\t       (((QWORD)(block[t * 8 + 3])) << 32) |\n\t\t       (((QWORD)(block[t * 8 + 4])) << 24) |\n\t\t       (((QWORD)(block[t * 8 + 5])) << 16) |\n\t\t       (((QWORD)(block[t * 8 + 6])) <<  8) |\n\t\t        ((QWORD)(block[t * 8 + 7]));\n\t}\n\tfor(t = 16; t < 80; ++t)\n\t{\n\t\tW[t] = RHO1(W[t - 2]) + W[t - 7] +\n\t\t\t   RHO0(W[t - 15]) + W[t - 16];\n\t}\n\n\t/* Load the SHA-512 state into local variables */\n\ta = sha->A;\n\tb = sha->B;\n\tc = sha->C;\n\td = sha->D;\n\te = sha->E;\n\tf = sha->F;\n\tg = sha->G;\n\th = sha->H;\n\n\t/* Perform 80 rounds of hash computations */\n\tfor(t = 0; t < 80; ++t)\n\t{\n\t\ttemp = h + SUM1(e) + CH(e, f, g) + K[t] + W[t];\n\t\ttemp2 = SUM0(a) + MAJ(a, b, c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + temp;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = temp + temp2;\n\t}\n\n\t/* Combine the previous SHA-512 state with the new state */\n\tsha->A += a;\n\tsha->B += b;\n\tsha->C += c;\n\tsha->D += d;\n\tsha->E += e;\n\tsha->F += f;\n\tsha->G += g;\n\tsha->H += h;\n}\n\nvoid Sha512_data(SHA512_DATA *sha, const void *buffer, DWORD len)\n{\n\tDWORD templen;\n\n\t/* Add to the total length of the input stream */\n\tsha->totalLen += (QWORD)len;\n\n\t/* Copy the blocks into the input buffer and process them */\n\twhile(len > 0)\n\t{\n\t\tif(!(sha->inputLen) && len >= 128)\n\t\t{\n\t\t\t/* Short cut: no point copying the data twice */\n\t\t\tProcessBlock(sha, (const BYTE *)buffer);\n\t\t\tbuffer = (const void *)(((const BYTE *)buffer) + 128);\n\t\t\tlen -= 128;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttemplen = len;\n\t\t\tif(templen > (128 - sha->inputLen))\n\t\t\t{\n\t\t\t\ttemplen = 128 - sha->inputLen;\n\t\t\t}\n\t\t\tmemcpy(sha->input + sha->inputLen, buffer, templen);\n\t\t\tif((sha->inputLen += templen) >= 128)\n\t\t\t{\n\t\t\t\tProcessBlock(sha, sha->input);\n\t\t\t\tsha->inputLen = 0;\n\t\t\t}\n\t\t\tbuffer = (const void *)(((const BYTE *)buffer) + templen);\n\t\t\tlen -= templen;\n\t\t}\n\t}\n}\n\nvoid WriteLong(BYTE *buf, QWORD value)\n{\n\tbuf[0] = (BYTE)(value >> 56);\n\tbuf[1] = (BYTE)(value >> 48);\n\tbuf[2] = (BYTE)(value >> 40);\n\tbuf[3] = (BYTE)(value >> 32);\n\tbuf[4] = (BYTE)(value >> 24);\n\tbuf[5] = (BYTE)(value >> 16);\n\tbuf[6] = (BYTE)(value >> 8);\n\tbuf[7] = (BYTE)value;\n}\n\nvoid Sha512_finalize(SHA512_DATA *sha,BYTE *hash)\n{\n\tQWORD totalBits;\n\n\t/* Compute the final hash if necessary */\n\tif(hash)\n\t{\n\t\t/* Pad the input data to a multiple of 1024 bits */\n\t\tif(sha->inputLen >= (128 - 16))\n\t\t{\n\t\t\t/* Need two blocks worth of padding */\n\t\t\tsha->input[(sha->inputLen)++] = (BYTE)0x80;\n\t\t\twhile(sha->inputLen < 128)\n\t\t\t{\n\t\t\t\tsha->input[(sha->inputLen)++] = (BYTE)0x00;\n\t\t\t}\n\t\t\tProcessBlock(sha, sha->input);\n\t\t\tsha->inputLen = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Need one block worth of padding */\n\t\t\tsha->input[(sha->inputLen)++] = (BYTE)0x80;\n\t\t}\n\t\twhile(sha->inputLen < (128 - 16))\n\t\t{\n\t\t\tsha->input[(sha->inputLen)++] = (BYTE)0x00;\n\t\t}\n\t\ttotalBits = (sha->totalLen << 3);\n\t\tmemset(sha->input + (128 - 16), 0, 8);\n\t\tWriteLong(sha->input + (128 - 8), totalBits);\n\t\tProcessBlock(sha, sha->input);\n\n\t\t/* Write the final hash value to the supplied buffer */\n\t\tWriteLong(hash,      sha->A);\n\t\tWriteLong(hash + 8,  sha->B);\n\t\tWriteLong(hash + 16, sha->C);\n\t\tWriteLong(hash + 24, sha->D);\n\t\tWriteLong(hash + 32, sha->E);\n\t\tWriteLong(hash + 40, sha->F);\n\t\tWriteLong(hash + 48, sha->G);\n\t\tWriteLong(hash + 56, sha->H);\n\t}\n}\n"
        },
        {
            "file_name": "shellaes128v1d4n64_aes.cpp",
            "content": "/**\n * rijndael-alg-fst.c\n *\n * @version 3.0 (December 2000)\n *\n * Optimised ANSI C code for the Rijndael cipher (now AES)\n *\n * @author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be>\n * @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be>\n * @author Paulo Barreto <paulo.barreto@terra.com.br>\n *\n * This code is hereby placed in the public domain.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <assert.h>\n#include <stdlib.h>\n\n#include \"shellaes128v1d4n64_aes.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Shellaes128v1d4n64_raw {\n\n/* Key setup for encryption of AES-128*/\n\nvoid aesKeySetupEnc(u32 rk[], const u8 key[]) {\n    int i = 0;\n    u32 temp;\n\n    rk[0] = GETU32(key     );\n    rk[1] = GETU32(key +  4);\n    rk[2] = GETU32(key +  8);\n    rk[3] = GETU32(key + 12);\n\n    for (i=0; i<10; ++i) {\n        temp  = rk[3];\n        rk[4] = rk[0] ^\n            (Te4[(temp >> 16) & 0xff] & 0xff000000) ^\n            (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^\n            (Te4[(temp      ) & 0xff] & 0x0000ff00) ^\n            (Te4[(temp >> 24)       ] & 0x000000ff) ^\n            rcon[i];\n        rk[5] = rk[1] ^ rk[4];\n        rk[6] = rk[2] ^ rk[5];\n        rk[7] = rk[3] ^ rk[6];\n\n        rk += 4;\n    }\n}\n\n/* Key setup for decryption of AES-128 */\n\nvoid aesKeySetupDec(u32 rk[], const u8 key[]) {\n\n    int Nr, i, j;\n    u32 temp;\n\n    Nr=10;\n\n    /* expand the cipher key: */\n    aesKeySetupEnc(rk, key);\n\n    /* invert the order of the round keys: */\n\n    for (i = 0, j = 4*Nr; i < j; i += 4, j -= 4) {\n        temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;\n        temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\n        temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\n        temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\n    }\n\n    /* apply the inverse MixColumn transform to all round keys but the first and the last: */\n\n    for (i = 1; i < Nr; i++) {\n        rk += 4;\n        rk[0] =\n            Td0[Te4[(rk[0] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[0] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[0]      ) & 0xff] & 0xff];\n        rk[1] =\n            Td0[Te4[(rk[1] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[1] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[1]      ) & 0xff] & 0xff];\n        rk[2] =\n            Td0[Te4[(rk[2] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[2] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[2]      ) & 0xff] & 0xff];\n        rk[3] =\n            Td0[Te4[(rk[3] >> 24)       ] & 0xff] ^\n            Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(rk[3] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(rk[3]      ) & 0xff] & 0xff];\n    }\n}\n\n/* Encryption of AES-128 */\n\nvoid aesEncrypt(const u32 rk[/*4*(Nr + 1)*/], const u8 pt[], u8 ct[]) {\n\n    u32 s0, s1, s2, s3, t0, t1, t2, t3;\n    int r;\n    int Nr=10;\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n\n    s0 = GETU32(pt     ) ^ rk[0];\n    s1 = GETU32(pt +  4) ^ rk[1];\n    s2 = GETU32(pt +  8) ^ rk[2];\n    s3 = GETU32(pt + 12) ^ rk[3];\n\n    r = Nr >> 1;\n    for (;;) {\n        t0 =\n            Te0[(s0 >> 24)       ] ^\n            Te1[(s1 >> 16) & 0xff] ^\n            Te2[(s2 >>  8) & 0xff] ^\n            Te3[(s3      ) & 0xff] ^\n            rk[4];\n        t1 =\n            Te0[(s1 >> 24)       ] ^\n            Te1[(s2 >> 16) & 0xff] ^\n            Te2[(s3 >>  8) & 0xff] ^\n            Te3[(s0      ) & 0xff] ^\n            rk[5];\n        t2 =\n            Te0[(s2 >> 24)       ] ^\n            Te1[(s3 >> 16) & 0xff] ^\n            Te2[(s0 >>  8) & 0xff] ^\n            Te3[(s1      ) & 0xff] ^\n            rk[6];\n        t3 =\n            Te0[(s3 >> 24)       ] ^\n            Te1[(s0 >> 16) & 0xff] ^\n            Te2[(s1 >>  8) & 0xff] ^\n            Te3[(s2      ) & 0xff] ^\n            rk[7];\n\n        rk += 8;\n        if (--r == 0) {\n            break;\n        }\n\n        s0 =\n            Te0[(t0 >> 24)       ] ^\n            Te1[(t1 >> 16) & 0xff] ^\n            Te2[(t2 >>  8) & 0xff] ^\n            Te3[(t3      ) & 0xff] ^\n            rk[0];\n        s1 =\n            Te0[(t1 >> 24)       ] ^\n            Te1[(t2 >> 16) & 0xff] ^\n            Te2[(t3 >>  8) & 0xff] ^\n            Te3[(t0      ) & 0xff] ^\n            rk[1];\n        s2 =\n            Te0[(t2 >> 24)       ] ^\n            Te1[(t3 >> 16) & 0xff] ^\n            Te2[(t0 >>  8) & 0xff] ^\n            Te3[(t1      ) & 0xff] ^\n            rk[2];\n        s3 =\n            Te0[(t3 >> 24)       ] ^\n            Te1[(t0 >> 16) & 0xff] ^\n            Te2[(t1 >>  8) & 0xff] ^\n            Te3[(t2      ) & 0xff] ^\n            rk[3];\n\n    }\n\n    /*\n     * apply last round and\n     * map cipher state to byte array block:\n     */\n    s0 =\n        (Te4[(t0 >> 24)       ] & 0xff000000) ^\n        (Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t2 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t3      ) & 0xff] & 0x000000ff) ^\n        rk[0];\n\n    PUTU32(ct     , s0);\n    s1 =\n        (Te4[(t1 >> 24)       ] & 0xff000000) ^\n        (Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t3 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t0      ) & 0xff] & 0x000000ff) ^\n        rk[1];\n    PUTU32(ct +  4, s1);\n    s2 =\n        (Te4[(t2 >> 24)       ] & 0xff000000) ^\n        (Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t0 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t1      ) & 0xff] & 0x000000ff) ^\n        rk[2];\n    PUTU32(ct +  8, s2);\n    s3 =\n        (Te4[(t3 >> 24)       ] & 0xff000000) ^\n        (Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t1 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t2      ) & 0xff] & 0x000000ff) ^\n        rk[3];\n    PUTU32(ct + 12, s3);\n}\n\n/* decryption of AES-128 */\n\nvoid aesDecrypt(const u32 rk[/*4*(Nr + 1)*/], const u8 ct[], u8 pt[]) {\n    u32 s0, s1, s2, s3, t0, t1, t2, t3;\n    int Nr=10;\n    int r;\n\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n    s0 = GETU32(ct     ) ^ rk[0];\n    s1 = GETU32(ct +  4) ^ rk[1];\n    s2 = GETU32(ct +  8) ^ rk[2];\n    s3 = GETU32(ct + 12) ^ rk[3];\n\n    r = Nr >> 1;\n    for (;;) {\n        t0 =\n            Td0[(s0 >> 24)       ] ^\n            Td1[(s3 >> 16) & 0xff] ^\n            Td2[(s2 >>  8) & 0xff] ^\n            Td3[(s1      ) & 0xff] ^\n            rk[4];\n        t1 =\n            Td0[(s1 >> 24)       ] ^\n            Td1[(s0 >> 16) & 0xff] ^\n            Td2[(s3 >>  8) & 0xff] ^\n            Td3[(s2      ) & 0xff] ^\n            rk[5];\n        t2 =\n            Td0[(s2 >> 24)       ] ^\n            Td1[(s1 >> 16) & 0xff] ^\n            Td2[(s0 >>  8) & 0xff] ^\n            Td3[(s3      ) & 0xff] ^\n            rk[6];\n        t3 =\n            Td0[(s3 >> 24)       ] ^\n            Td1[(s2 >> 16) & 0xff] ^\n            Td2[(s1 >>  8) & 0xff] ^\n            Td3[(s0      ) & 0xff] ^\n            rk[7];\n\n        rk += 8;\n        if (--r == 0) {\n            break;\n        }\n\n        s0 =\n            Td0[(t0 >> 24)       ] ^\n            Td1[(t3 >> 16) & 0xff] ^\n            Td2[(t2 >>  8) & 0xff] ^\n            Td3[(t1      ) & 0xff] ^\n            rk[0];\n        s1 =\n            Td0[(t1 >> 24)       ] ^\n            Td1[(t0 >> 16) & 0xff] ^\n            Td2[(t3 >>  8) & 0xff] ^\n            Td3[(t2      ) & 0xff] ^\n            rk[1];\n        s2 =\n            Td0[(t2 >> 24)       ] ^\n            Td1[(t1 >> 16) & 0xff] ^\n            Td2[(t0 >>  8) & 0xff] ^\n            Td3[(t3      ) & 0xff] ^\n            rk[2];\n        s3 =\n            Td0[(t3 >> 24)       ] ^\n            Td1[(t2 >> 16) & 0xff] ^\n            Td2[(t1 >>  8) & 0xff] ^\n            Td3[(t0      ) & 0xff] ^\n            rk[3];\n    }\n    /*\n     * apply last round and\n     * map cipher state to byte array block:\n     */\n    s0 =\n        (Td4[(t0 >> 24)       ] & 0xff000000) ^\n        (Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t2 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t1      ) & 0xff] & 0x000000ff) ^\n        rk[0];\n    PUTU32(pt     , s0);\n    s1 =\n        (Td4[(t1 >> 24)       ] & 0xff000000) ^\n        (Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t3 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t2      ) & 0xff] & 0x000000ff) ^\n        rk[1];\n    PUTU32(pt +  4, s1);\n    s2 =\n        (Td4[(t2 >> 24)       ] & 0xff000000) ^\n        (Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t0 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t3      ) & 0xff] & 0x000000ff) ^\n        rk[2];\n    PUTU32(pt +  8, s2);\n    s3 =\n        (Td4[(t3 >> 24)       ] & 0xff000000) ^\n        (Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n        (Td4[(t1 >>  8) & 0xff] & 0x0000ff00) ^\n        (Td4[(t0      ) & 0xff] & 0x000000ff) ^\n        rk[3];\n    PUTU32(pt + 12, s3);\n}\n\n\n\n} // namespace Shellaes128v1d4n64_raw\n"
        },
        {
            "file_name": "shellaes128v1d4n64_shellaes.cpp",
            "content": "/*\n * SHELL-AES Reference C Implementation\n *\n * Copyright 2014:\n *     Lei Wang <wang.lei@ntu.edu.sg>\n *              <shellaemode@gmail.com>\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n *\n */\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<stdint.h>\n\n#include \"shellaes128v1d4n64_aes.h\"\n#include \"shellaes128v1d4n64_shellaes.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Shellaes128v1d4n64_raw {\n\n/*print a byte string b[]. blen is the length of b[].*/\nvoid printf_byte_string(const u8 b[], unsigned long long int blen){\n    unsigned long long int i;\n\n    for(i=0; i<blen; ++i){\n        printf(\"%3x\", b[i]);\n\n        if(i%16==15&&i!=0){\n            printf(\"\\n\");\n        }\n    }\n    printf(\"\\n\");\n}\n\n/*xor the first blen bytes of two byte string byte1[] and byte2[],\nand save the result byte string to the first blen bytes of byte2[]*/\nvoid xor_byte_string(const u8 byte1[], u8 byte2[], unsigned long long int blen){\n\n    unsigned long long int i;\n\n    for(i=0; i<blen; ++i){\n        byte2[i]^=byte1[i];\n    }\n}\n\n/*compute the XOR checksum of a set of 128-bit state stored in a byte string byte1[]*/\nvoid checksum_state_string(const u8 byte1[], u8 checksum[], unsigned long long int blen){\n    memset(checksum, 0x00, 16);\n\n    while(blen!=0){\n        xor_byte_string(byte1, checksum, 16);\n        byte1+=16;\n        blen-=16;\n    }\n}\n\n/*compute 2*maskstate over GF(2^128) with f(x)=x^128+x^7+x^2+x+1*/\nvoid double_mask(u8 maskstate[]){\n    int i;\n    u8 msb;\n    u8 tempbyte;\n\n    msb=(maskstate[0] & 0x80)?1:0;\n\n    u8 carry=0;\n\n    for(i=15; i>=0; --i){\n        tempbyte=maskstate[i];\n        maskstate[i]=(tempbyte<<1)|carry;\n        carry=tempbyte>>7;\n    }\n\n    if(msb){\n        maskstate[15]^=0x87;\n    }\n}\n\n/*MIX function used in XLS*/\nvoid MIX(u8 byte1[], u8 byte2[], unsigned int blen){\n    // CHANGE VLA allocation changed to dynamic (for MSVC compiler)\n\t// u8 temp[blen];\n\tu8* temp = new u8[blen];\n    u8 tempbyte;\n    int i;\n    u8 carry;\n\n    memcpy(temp, byte1, blen);\n    xor_byte_string(byte2, temp, blen);\n\n    /*left rotate temp[] by one bit*/\n    carry=temp[0]>>7;\n    for(i=blen-1; i>=0; --i){\n        tempbyte=temp[i];\n        temp[i]=tempbyte<<1;\n        temp[i]|=carry;\n        carry=tempbyte>>7;\n    }\n\n    xor_byte_string(temp, byte1, blen);\n    xor_byte_string(temp, byte2, blen);\n\n\t// CHANGE memory management (VLA allocation changed to dynamic)\n\tdelete[] temp;\n}\n\n/*Setup the encryption key materials including mask key, and subkeys for SHELL-AES*/\nvoid KeySetupEnc(u32 mk[], u32 sk[], u8 L[], u8 Lprime[], u8 keyprime[], const u32 rk[], const u8 key[]){\n\n    u8 pt[16];\n    u8 ct[16];\n\n    int i;\n\n\n    /* generate Keyprime for CENC*/\n    for(i=0; i<16; ++i){\n        keyprime[i]=key[i]^0xF0;\n    }\n\n    /* produce L for masks of AES*/\n    memset(pt, 0x00, 16);\n    aesEncrypt(rk, pt, L);\n\n    /*produce the subkeys for auxiliary permutations*/\n    for(i=1; i<=3*d; ++i){\n        pt[15]=i;\n        aesEncrypt(rk, pt, ct);\n\n        sk[0]=GETU32(ct);\n        sk[1]=GETU32(ct+4);\n        sk[2]=GETU32(ct+8);\n        sk[3]=GETU32(ct+12);\n\n        sk=sk+4;\n    }\n\n    /*produce the mask keys for auxiliary permutations*/\n    for(i=3*d+1; i<=4*d; ++i){\n        pt[15]=i;\n\n        aesEncrypt(rk, pt, ct);\n\n        mk[0]=GETU32(ct);\n        mk[1]=GETU32(ct+4);\n        mk[2]=GETU32(ct+8);\n        mk[3]=GETU32(ct+12);\n\n        mk=mk+4;\n    }\n\n    /*produce Lprime for XEX layer*/\n\n    memset(pt, 0xFF, 16);\n    aesEncrypt(rk, pt, Lprime);\n}\n\n/*Setup the decryption key materials including mask key, and subkey for SHELL-AES*/\nvoid KeySetupDec(u32 mk[], u32 sk[], u32 isk[], u8 L[], u8 Lprime[], u8 keyprime[], const u32 rk[], const u8 key[]){\n\n    int i;\n    u32 temp;\n\n    KeySetupEnc(mk, sk, L, Lprime, keyprime, rk, key);\n\n    memcpy(isk, sk, 48*d);\n\n    /*inverse the order of round keys for each auxiliary permutation */\n    for(i=0; i<d; ++i){\n        temp=isk[12*i  ]; isk[12*i  ]=isk[12*i+ 8]; isk[12*i+ 8]=temp;\n        temp=isk[12*i+1]; isk[12*i+1]=isk[12*i+ 9]; isk[12*i+ 9]=temp;\n        temp=isk[12*i+2]; isk[12*i+2]=isk[12*i+10]; isk[12*i+10]=temp;\n        temp=isk[12*i+3]; isk[12*i+3]=isk[12*i+11]; isk[12*i+11]=temp;\n    }\n\n\n    /*apply inverse mixcolumn to the round keys*/\n    for(i=0; i< 12*d; ++i){\n        isk[i] =\n            Td0[Te4[(isk[i] >> 24)       ] & 0xff] ^\n            Td1[Te4[(isk[i] >> 16) & 0xff] & 0xff] ^\n            Td2[Te4[(isk[i] >>  8) & 0xff] & 0xff] ^\n            Td3[Te4[(isk[i]      ) & 0xff] & 0xff];\n    }\n}\n\n/*PX-MAC to process associated data*/\nvoid PXMAC(const u32 mk[], const u32 sk[], const u8 L[], u8 V[], const u32 rk[], const u8 ad[], unsigned long long int adlen){\n\n      int i=0;\n      u8 pt[16], ct[16];\n      u8 final_block_mask[16];\n\n\n      memset(pt, 0, 16);\n      memset(ct, 0, 16);\n\n      /*process associated data except the last block*/\n      memset(V, 0x00, 16);\n\n      while(adlen>16){\n            aesReducedEnc(mk+4*i, sk+12*i, ad, ct);\n            xor_byte_string(ct, V, 16);\n\n            ++i;\n            ad+=16;\n            adlen-=16;\n\n            if(i==d){\n                aesEncrypt(rk, V, ct);\n                memcpy(V, ct, 16);\n                i=0;\n            }\n      }\n\n      /*process the last block*/\n      memcpy(final_block_mask, L, 16);\n      double_mask(final_block_mask);\n\n      memcpy(pt, ad, adlen);\n\n      if(adlen!=16){\n            double_mask(final_block_mask);\n\n            pt[adlen]=0x80;\n            memset(pt+adlen+1, 0x00, 15-adlen);\n      }\n\n      aesReducedEnc(mk+4*i, sk+12*i, pt, ct);\n      xor_byte_string(ct, V, 16);\n\n      xor_byte_string(final_block_mask, V, 16);\n\n      /*the finalization AES*/\n      aesEncrypt(rk, V, ct);\n      memcpy(V, ct, 16);\n\n}\n\n/*CENC to process nonce*/\nvoid CENC(const u32 rkprime[], u8 S[], u8 F[], const u8 nonce[], unsigned long long int ptlen){\n\n    u8 ctr[16];\n    u8 G[16];\n    u8 ct[16];\n    int i, j=0;\n\n    /*initialize ctr*/\n    memset(ctr, 0, 16);\n    memcpy(ctr, nonce, byte_length_nonce);\n\n    /*produce the output S except the last block*/\n    aesEncrypt(rkprime, ctr, G);\n\n    while(ptlen>16){\n        /*increase ctr by adding 1*/\n        if(++ctr[15]==0){\n            i=14;\n            while(++ctr[i]==0){\n                --i;\n            }\n        }\n        /*update the value of G*/\n        if(j==w){\n            aesEncrypt(rkprime, ctr, G);\n            j=0;\n            continue;\n        }\n\n        aesEncrypt(rkprime, ctr, S);\n\n        xor_byte_string(G, S, 16);\n\n        S+=16;\n\n        ptlen-=16;\n        ++j;\n    }\n\n    /*produce the last block of S*/\n\n    if(++ctr[15]==0){\n          i=14;\n          while(++ctr[i]==0){\n               --i;\n          }\n    }\n\n    if(j==w){\n         aesEncrypt(rkprime, ctr, G);\n         j=0;\n         if(++ctr[15]==0){\n            i=14;\n            while(++ctr[i]==0){\n                    --i;\n            }\n        }\n    }\n\n    aesEncrypt(rkprime, ctr, ct);\n    xor_byte_string(G, ct, 16);\n\n    memcpy(S, ct, ptlen);\n\n    ++j;\n\n    /*produce the value of F*/\n\n    if(++ctr[15]==0){\n          i=14;\n          while(++ctr[i]==0){\n               --i;\n          }\n    }\n\n    if(j==w){\n         aesEncrypt(rkprime, ctr, G);\n         j=0;\n         if(++ctr[15]==0){\n            i=14;\n            while(++ctr[i]==0){\n                    --i;\n            }\n        }\n    }\n\n    aesEncrypt(rkprime, ctr, F);\n    xor_byte_string(G, F, 16);\n\n}\n\n/*PXENC layer*/\nvoid PXENC(const u32 mk[], const u32 sk[], const u8 L[], u8 V[], u8 Z[], const u32 rk[], const u8 I[], unsigned long long int ptlen){\n\n    int i=0;\n    u8 ct[16];\n\n    u8 final_block_mask[16];\n\n    /*process I[] except the last block*/\n    while(ptlen>16){\n        aesReducedEnc(mk+4*i, sk+12*i, I, ct);\n        xor_byte_string(ct, V, 16);\n\n        memcpy(Z, V, 16);\n\n        Z+=16;\n        I+=16;\n        ptlen-=16;\n        ++i;\n\n        if(i==d){\n                aesEncrypt(rk, V, ct);\n                memcpy(V, ct, 16);\n                i=0;\n        }\n\n    }\n\n    /*process the last block of I[]*/\n    aesReducedEnc(mk+4*i, sk+12*i, I, ct);\n    xor_byte_string(ct, V, 16);\n\n    memcpy(final_block_mask, L, 16);\n    double_mask(final_block_mask);\n    double_mask(final_block_mask);\n    double_mask(final_block_mask);\n\n    xor_byte_string(final_block_mask, V, 16);\n\n    memcpy(Z, V, 16);\n\n    /*the finalization AES*/\n    aesEncrypt(rk, V, ct);\n    memcpy(V, ct, 16);\n\n}\n\n/*PXDEC layer: the decryption of PXENC*/\nvoid PXDEC(const u32 mk[], const u32 isk[], const u8 L[], u8 V[], const u8 Z[], const u32 rk[], u8 I[], unsigned long long int ctlen){\n\n    int i=0;\n\n    u8 ct[16];\n    u8 final_block_mask[16];\n\n    /*process the output Z[] of XEXLayerDec except the last block*/\n    while(ctlen>16){\n        xor_byte_string(Z, V, 16);\n        aesReducedDec(mk+4*i, isk+12*i, V, ct);\n\n        memcpy(I, ct, 16);\n        memcpy(V, Z, 16);\n\n        Z+=16;\n        I+=16;\n        ctlen-=16;\n        ++i;\n\n        if(i==d){\n            i=0;\n            aesEncrypt(rk, V, ct);\n            memcpy(V, ct, 16);\n        }\n    }\n\n    /*process the last block*/\n    memcpy(final_block_mask, L, 16);\n    double_mask(final_block_mask);\n    double_mask(final_block_mask);\n    double_mask(final_block_mask);\n\n\n    xor_byte_string(Z, V, 16);\n    xor_byte_string(final_block_mask, V, 16);\n\n    aesReducedDec(mk+4*i, isk+12*i, V, I);\n\n    /*apply the finalization AES*/\n    memcpy(V, Z, 16);\n    aesEncrypt(rk, V, ct);\n    memcpy(V, ct, 16);\n}\n\n/* XEX layer to produce ciphertext*/\nvoid XEXLayerEnc(const u32 rk[], const u8 Lprime[], const u8 Z[], u8 C[], unsigned long long int ctlen){\n\n    u8 mask[16];\n    u8 temp[16];\n    u8 ct[16];\n\n    memcpy(mask, Lprime, 16);\n\n    while(ctlen!=0){\n        double_mask(mask);\n\n        memcpy(temp, Z, 16);\n\n        xor_byte_string(mask, temp, 16);\n        aesEncrypt(rk, temp, ct);\n        xor_byte_string(mask, ct, 16);\n        memcpy(C, ct, 16);\n\n        C+=16;\n        Z+=16;\n        ctlen-=16;\n    }\n}\n\n/*decryption of XEX layer*/\nvoid XEXLayerDec(const u32 irk[], const u8 Lprime[], const u8 C[], u8 Z[], unsigned long long int ctlen){\n\n    u8 mask[16];\n    u8 temp[16];\n    u8 pt[16];\n\n    memcpy(mask, Lprime, 16);\n\n    while(ctlen!=0){\n        double_mask(mask);\n\n        memcpy(temp, C, 16);\n        xor_byte_string(mask, temp, 16);\n        aesDecrypt(irk, temp, pt);\n        xor_byte_string(mask, pt, 16);\n\n        memcpy(Z, pt, 16);\n\n        C+=16;\n        Z+=16;\n        ctlen-=16;\n    }\n}\n\n/*generate tag for plaintext with multiple block length*/\nvoid tagGen(const u32 rk[], const u8 checksum[], const u8 Lprime[], const u8 U[], const u8 F[], u8 T[], unsigned long long int ptlen){\n    u8 mask1[16], mask2[16];\n    u8 temp[16];\n\n    /*generate 3*Lprime and 7*Lprime and store them in mask1[] and mask2[] respectively*/\n    memcpy(mask1, Lprime, 16);\n    double_mask(mask1);\n    memcpy(mask2, mask1, 16);\n    xor_byte_string(Lprime, mask1, 16);\n\n    double_mask(mask2);\n    xor_byte_string(mask1, mask2, 16);\n\n    /*generate 2^{lm+1}*3*Lprime and 2^{lm+1}*7*Lprime and store them in mask1[] and mask2[] respectively*/\n    while(ptlen!=0){\n        double_mask(mask1);\n        double_mask(mask2);\n        ptlen-=16;\n    }\n    double_mask(mask1);\n    double_mask(mask2);\n\n    /*produce the tag value*/\n    xor_byte_string(checksum, mask1, 16);\n\n    aesEncrypt(rk, mask1, temp);\n    xor_byte_string(U, temp, 16);\n    xor_byte_string(mask2, temp, 16);\n\n    aesEncrypt(rk, temp, T);\n    xor_byte_string(mask2, T, 16);\n    xor_byte_string(F, T, 16);\n}\n\n/*verify the validness of the tag T[]*/\nint tagVef(const u32 rk[], const u8 checksum[], const u8 Lprime[], const u8 U[], const u8 F[], const u8 T[], unsigned long long int ptlen){\n\n    u8 tempT[16];\n    int flag=1;\n    int i;\n\n    tagGen(rk, checksum, Lprime, U, F, tempT, ptlen);\n\n    for(i=0; i<16; ++i){\n        if(tempT[i]!=T[i]){\n            flag=0;\n        }\n    }\n    return flag;\n}\n\n/*SHELL-AES encryption for plaintexts of mutiple blocks long:\nparameters follow those of function shellaesEnc\n*/\nvoid shellaesEnc_fb(const u8 key[], const u8 nonce[], const u8 ad[], unsigned long long int adlen, const u8 p[], unsigned long long int ptlen, u8 c[], u8 tag[]){\n    u8 V[16], U[16], checksum[16], F[16], keyprime[16], L[16], Lprime[16];\n    u8* S;\n    u8* I;\n    u8* Z;\n\n    S= (u8 *) malloc(ptlen);\n    I= (u8 *) malloc(ptlen);\n    Z= (u8 *) malloc(ptlen);\n\n    memset(V, 0, 16);\n    memset(U, 0, 16);\n    memset(checksum, 0, 16);\n    memset(keyprime, 0, 16);\n    memset(F, 0, 16);\n    memset(L, 0, 16);\n    memset(Lprime, 0, 16);\n\n    u32 mk[4*d], sk[12*d], rk[44], rkprime[44];\n\n    /* key setup */\n    aesKeySetupEnc(rk, key);\n    KeySetupEnc(mk, sk, L, Lprime, keyprime, rk, key);\n    aesKeySetupEnc(rkprime, keyprime);\n\n    /*PXMAC: process associated data, and save output to V[]*/\n    PXMAC(mk, sk, L, V, rk, ad, adlen);\n\n    /*CENC: process nonce, and save output to S[] and F[]*/\n    CENC(rkprime, S, F, nonce, ptlen);\n\n    /*mask plaintext by xoring the output S[] of CENC, and save it to I[]*/\n    memcpy(I, S, ptlen);\n    xor_byte_string(p, I, ptlen);\n\n    /*PXENC: save outputs to Z[] and U[] */\n    PXENC(mk, sk, L, V, Z, rk, I, ptlen);\n    memcpy(U, V, 16);\n\n    /*XEX: produce the ciphertext*/\n    XEXLayerEnc(rk, Lprime, Z, c, ptlen);\n\n    /*generate tag*/\n    checksum_state_string(I, checksum, ptlen);\n    tagGen(rk, checksum, Lprime, U, F, tag, ptlen);\n\n    /*\n    printf(\"ciphertext is: \\n\");\n    printf_byte_string(c, ptlen);\n\n    printf(\"tag value is: \\n\");\n    printf_byte_string(tag, 16);\n    */\n\n    free(I);\n    free(Z);\n    free(S);\n}\n\n/*SHELL-AES decryption for plaintexts of mutiple blocks long:\nparameters follow those of function shellaesEnc\n*/\nint shellaesDecVef_fb(const u8 key[], const u8 nonce[], const u8 ad[], unsigned long long int adlen, const u8 c[], unsigned long long int ctlen, u8 p[], const u8 tag[]){\n\n    u8 V[16], U[16], checksum[16], keyprime[16], F[16], L[16], Lprime[16];\n\n    u8* S;\n    u8* I;\n    u8* Z;\n\n    S=(u8 *) malloc(ctlen);\n    I=(u8 *) malloc(ctlen);\n    Z=(u8 *) malloc(ctlen);\n\n    memset(V, 0, 16);\n    memset(U, 0, 16);\n    memset(checksum, 0, 16);\n    memset(keyprime, 0, 16);\n    memset(F, 0, 16);\n    memset(L, 0, 16);\n    memset(Lprime, 0, 16);\n\n    u32 mk[4*d], sk[12*d], isk[12*d], rk[44], irk[44], rkprime[44];\n\n    /*setup key materials*/\n    aesKeySetupEnc(rk, key);\n    aesKeySetupDec(irk, key);\n    KeySetupDec(mk, sk, isk, L, Lprime, keyprime, rk, key);\n    aesKeySetupEnc(rkprime, keyprime);\n\n    /*process associated data*/\n    PXMAC(mk, sk, L, V, rk, ad, adlen);\n\n    /*decryption of XEX layer*/\n    XEXLayerDec(irk, Lprime, c, Z, ctlen);\n\n    /*decryption of PXENC layer*/\n    PXDEC(mk, isk, L, V, Z, rk, I, ctlen);\n\n    /*CENC layer*/\n    CENC(rkprime, S, F, nonce, ctlen);\n\n    /*produce the plaintext*/\n    memcpy(p, S, ctlen);\n    xor_byte_string(I, p, ctlen);\n\n    /*verify the validness of tag*/\n    int flag;\n    memcpy(U, V, 16);\n    checksum_state_string(I, checksum, ctlen);\n\n    flag=tagVef(rk, checksum, Lprime, U, F, tag, ctlen);\n\n    /*\n    if(flag){\n        printf(\"the plaintext is:\\n\");\n        printf_byte_string(p, ctlen);\n    }\n    else{\n        printf(\"the tag is invalid!\");\n    }\n    */\n\n    free(I);\n    free(S);\n    free(Z);\n\n    return flag;\n\n}\n\n/*SHELL-AES decryption for plaintexts with a length longer than one block but not a multiple of block length:\nshellaesDec_fb is used to decrypt of the ciphertext without the last non-full block;\nparameters follow those of function shellaesEnc\n*/\nvoid shellaesDec_fb(const u8 key[], const u8 nonce[], const u8 ad[], unsigned long long int adlen, const u8 c[], unsigned long long int ctlen, u8 p[], u8 tag[]){\n\n    u8 V[16], U[16], checksum[16], keyprime[16], F[16], L[16], Lprime[16];\n\n    u8* S;\n    u8* I;\n    u8* Z;\n\n    S=(u8 *) malloc(ctlen);\n    I=(u8 *) malloc(ctlen);\n    Z=(u8 *) malloc(ctlen);\n\n    memset(V, 0, 16);\n    memset(U, 0, 16);\n    memset(checksum, 0, 16);\n    memset(keyprime, 0, 16);\n    memset(F, 0, 16);\n    memset(L, 0, 16);\n    memset(Lprime, 0, 16);\n\n    u32 mk[4*d], sk[12*d], isk[12*d], rk[44], irk[44], rkprime[44];\n\n    aesKeySetupEnc(rk, key);\n    aesKeySetupDec(irk, key);\n    KeySetupDec(mk, sk, isk, L, Lprime, keyprime, rk, key);\n    aesKeySetupEnc(rkprime, keyprime);\n\n    PXMAC(mk, sk, L, V, rk, ad, adlen);\n\n    XEXLayerDec(irk, Lprime, c, Z, ctlen);\n    PXDEC(mk, isk, L, V, Z, rk, I, ctlen);\n    memcpy(U, V, 16);\n\n    checksum_state_string(I, checksum, ctlen);\n\n    CENC(rkprime, S, F, nonce, ctlen);\n\n    memcpy(p, S, ctlen);\n    xor_byte_string(I, p, ctlen);\n\n    tagGen(rk, checksum, Lprime, U, F, tag, ctlen);\n\n    free(I);\n    free(S);\n    free(Z);\n\n\n}\n\n/*\nSHELL-AES encryption for plaintexts shorter than one blocks long:\nparameters follow those of function shellaesEnc\n*/\nvoid shellaesEnc_short(const u8 key[], const u8 nonce[], const u8 ad[], unsigned long long int adlen, const u8 p[], unsigned long long int ptlen, u8 c[], u8 tag[]){\n\n         u8 V[16], F[16], keyprime[16], L[16], Lprime[16], S[16], I[16];\n\n         u32 mk[4*d], sk[12*d], rk[44], rkprime[44];\n\n         u8 pt[16], pt1[16], pt2[16], ct1[16], ct2[16];\n         u8 mask[16];\n         u8 temp[16];\n         int i;\n\n         /*key setup*/\n         aesKeySetupEnc(rk, key);\n         KeySetupEnc(mk, sk, L, Lprime, keyprime, rk, key);\n         aesKeySetupEnc(rkprime, keyprime);\n\n         /*PXMAC: process the associated data and save output to V[]*/\n         memset(V, 0, 16);\n         PXMAC(mk, sk, L, V, rk, ad, adlen);\n\n         /*CENC: process nonce and save the output to S[] and F[]*/\n         CENC(rkprime, S, F, nonce, 16);\n\n\n         /*pad p[] to a full block and save it to pt[]*/\n         memset(pt, 0, 16);\n         memcpy(pt, p, ptlen);\n         pt[ptlen]=0x80;\n\n         /*mask pt[] by xoring the output S[] of CENC, and save it to I[] */\n         memcpy(I, S, 16);\n         xor_byte_string(pt, I, 16);\n\n         /*compute 3^3*Lprime and save it to mask[]*/\n         memcpy(mask, Lprime, 16);\n         for(i=0; i<3; ++i){\n            memcpy(temp, mask, 16);\n            double_mask(mask);\n            xor_byte_string(temp, mask, 16);\n         }\n\n         /*compute XEX cipher with tweak of 3^3*Lprime and input I[], and save the output to ct1[]*/\n\n         memcpy(pt1, I, 16);\n         xor_byte_string(mask, pt1, 16);\n         aesEncrypt(rk, pt1, ct1);\n         xor_byte_string(mask, ct1, 16);\n\n         /*compute XEX cipher with tweak of 2*3^3*Lprime and input I[], and save the output to ct2[]*/\n         double_mask(mask);\n         memcpy(pt2, I, 16);\n         xor_byte_string(mask, pt2, 16);\n         aesEncrypt(rk, pt2, ct2);\n         xor_byte_string(mask, ct2, 16);\n\n         /*compute XEX cipher with tweak of 2^2*3^3*Lprime and input of xoring ct1 and the output V of PX-MAC,\n           and save the output to ct1[]*/\n         xor_byte_string(ct1, V, 16);\n         memcpy(pt1, V, 16);\n         double_mask(mask);\n         xor_byte_string(mask, pt1, 16);\n         aesEncrypt(rk, pt1, ct1);\n         xor_byte_string(mask, ct1, 16);\n\n        /*compute XEX cipher with tweak of 2^3*3^3*Lprime and input of xoring ct2 and the updated V,\n          and save the output to ct2[]*/\n         xor_byte_string(ct2, V, 16);\n         memcpy(pt2, V, 16);\n         double_mask(mask);\n         xor_byte_string(mask, pt2, 16);\n         aesEncrypt(rk, pt2, ct2);\n         xor_byte_string(mask, ct2, 16);\n\n         /*xor ct2 with the output F of CENC*/\n         xor_byte_string(F, ct2, 16);\n\n         /*tag splitting:\n         produce the ciphertext and tag from ct1 and ct2*/\n         memcpy(c, ct1, ptlen);\n         for(i=ptlen; i<16; ++i){\n            tag[i-ptlen]=ct1[i];\n         }\n         for(i=0; i<ptlen; ++i){\n            tag[16-ptlen+i]=ct2[i];\n         }\n\n        /*\n        printf(\"ciphertext is: \\n\");\n        printf_byte_string(c, ptlen);\n\n        printf(\"tag value is: \\n\");\n        printf_byte_string(tag, 16);\n        */\n\n}\n\n/*\nSHELL-AES decryption for plaintexts shorter than one blocks long:\nparameters follow those of function shellaesEnc\n*/\nint shellaesDec_short(const u8 key[], const u8 nonce[], const u8 ad[], unsigned long long int adlen, const u8 c[], unsigned long long int ctlen, u8 p[], const u8 tag[]){\n\n    u8 V[16], F[16], keyprime[16], L[16], Lprime[16], S[16], I[16];\n    u32 mk[4*d], sk[12*d], rk[44], irk[44], rkprime[44];\n    u8  pt1[16], pt2[16], ct1[16], ct2[16];\n    u8 mask[16], mask1[16];\n    u8 temp[16];\n\n    int i, flag;\n\n    /* key setup */\n    aesKeySetupEnc(rk, key);\n    KeySetupEnc(mk, sk, L, Lprime, keyprime, rk, key);\n    aesKeySetupDec(irk, key);\n    aesKeySetupEnc(rkprime, keyprime);\n\n    memset(V, 0, 16);\n\n    /*PX-MAC*/\n    PXMAC(mk, sk, L, V, rk, ad, adlen);\n\n    /*derive the block of ciphertext and save it to ct1[]*/\n\n    memcpy(ct1, c, ctlen);\n    for(i=ctlen; i<16; ++i){\n        ct1[i]=tag[i-ctlen];\n    }\n\n    /*produce mask 3^3*Lprime*/\n    memcpy(mask, Lprime, 16);\n    for(i=0; i<3; ++i){\n        memcpy(temp, mask, 16);\n        double_mask(mask);\n        xor_byte_string(temp, mask, 16);\n    }\n\n    /*produce mask 2^2*3^3*Lprime*/\n    memcpy(mask1, mask, 16);\n    double_mask(mask1);\n    double_mask(mask1);\n\n    /*decrypt to obtain I[]*/\n    xor_byte_string(mask1, ct1, 16);\n    aesDecrypt(irk, ct1, pt1);\n    xor_byte_string(mask1, pt1, 16);\n\n    xor_byte_string(V, pt1, 16);\n    memcpy(ct1, pt1, 16);\n\n    xor_byte_string(ct1, V, 16);\n\n    xor_byte_string(mask, ct1, 16);\n    aesDecrypt(irk, ct1, pt1);\n    xor_byte_string(mask, pt1, 16);\n\n    memcpy(I, pt1, 16);\n\n    /*decrypt the plaintext*/\n    CENC(rkprime, S, F, nonce, 16);\n    xor_byte_string(S, pt1, 16);\n    memcpy(p, pt1, ctlen);\n\n    /*verify the validness of tag*/\n    memcpy(pt2, I, 16);\n    double_mask(mask);\n\n    xor_byte_string(mask, pt2, 16);\n    aesEncrypt(rk, pt2, ct2);\n    xor_byte_string(mask, ct2, 16);\n\n    xor_byte_string(V, ct2, 16);\n\n    memcpy(pt2, ct2, 16);\n\n    double_mask(mask1);\n\n    xor_byte_string(mask1, pt2, 16);\n    aesEncrypt(rk, pt2, ct2);\n    xor_byte_string(mask1, ct2, 16);\n\n    xor_byte_string(F, ct2, 16);\n\n\n    flag=1;\n\n    if(pt1[ctlen]!=0x80){\n        flag=0;\n    }\n\n    for(i=ctlen+1; i<16; ++i){\n        if(pt1[i]!=0){\n            flag=0;\n        }\n    }\n\n    for(i=0; i<ctlen; ++i){\n        if(ct2[i]!=tag[i+16-ctlen]){\n            flag=0;\n        }\n    }\n\n    /*\n     if(flag){\n        printf(\"the plaintext is:\\n\");\n        printf_byte_string(p, ctlen);\n    }\n    else{\n        printf(\"the tag is invalid!\");\n    }\n    */\n\n    return flag;\n}\n\n/*XLS function to process the non-full last block of plaintexts*/\nvoid XLS(const u32 rk[], const u8 Lprime[], const u8 p[], unsigned long long int fb_ptlen, unsigned int nfb_ptlen, u8 c[], u8 tag[]){\n    u8 mask1[16], mask2[16];\n    u8 temp[16];\n\t// CHANGE VLA allocation changed to dynamic (for MSVC compiler)\n\t// u8 pt[16], ct[16], byte1[nfb_ptlen], byte2[nfb_ptlen];\n\tu8 pt[16], ct[16];\n\tu8* byte1 = new u8[nfb_ptlen];\n\tu8* byte2 = new u8[nfb_ptlen];\n\n    int i;\n\n    /*produce mask 3^2*Lprime, and save it to mask1[]*/\n    memcpy(mask1, Lprime, 16);\n    for(i=0; i<2; ++i){\n        memcpy(temp, mask1, 16);\n        double_mask(mask1);\n        xor_byte_string(temp, mask1, 16);\n    }\n\n    /*produce mask 7^2*Lprime, and save it to mask2[]*/\n    memcpy(mask2, Lprime, 16);\n    for(i=0; i<2; ++i){\n        memcpy(temp, mask2, 16);\n        double_mask(mask2);\n        xor_byte_string(mask2, temp, 16);\n        double_mask(mask2);\n        xor_byte_string(temp, mask2, 16);\n    }\n\n    /*produce the masks for E' and E'', and save them to mask1[] and mask2[] respectively*/\n    while(fb_ptlen!=0){\n        double_mask(mask1);\n        double_mask(mask2);\n        fb_ptlen-=16;\n    }\n    double_mask(mask1);\n    double_mask(mask2);\n\n    /*First round of XLS*/\n\n    memcpy(pt, p, nfb_ptlen);\n    memcpy(pt+nfb_ptlen, tag, 16-nfb_ptlen);\n\n    /*apply E'*/\n    xor_byte_string(mask1, pt, 16);\n    aesEncrypt(rk, pt, ct);\n    xor_byte_string(mask1, ct, 16);\n\n    /*flip one bit*/\n    ct[15-nfb_ptlen]^=0x01;\n\n    memcpy(byte1, ct+16-nfb_ptlen, nfb_ptlen);\n    memcpy(byte2, tag+16-nfb_ptlen, nfb_ptlen);\n\n    /*MIX function*/\n    MIX(byte1, byte2, nfb_ptlen);\n\n    memcpy(ct+16-nfb_ptlen, byte1, nfb_ptlen);\n\n    memcpy(pt, ct, 16);\n\n    /*Second round of XLS*/\n\n    /*apply E''*/\n    xor_byte_string(mask2, pt, 16);\n    aesEncrypt(rk, pt, ct);\n    xor_byte_string(mask2, ct, 16);\n\n    ct[15-nfb_ptlen]^=0x01;\n\n    memcpy(byte1, ct+16-nfb_ptlen, nfb_ptlen);\n    MIX(byte1, byte2, nfb_ptlen);\n\n    memcpy(ct+16-nfb_ptlen, byte1, nfb_ptlen);\n    memcpy(pt, ct, 16);\n\n    /*the third round of XLS*/\n\n    xor_byte_string(mask1, pt, 16);\n    aesEncrypt(rk, pt, ct);\n    xor_byte_string(mask1, ct, 16);\n\n    /*produce ciphertext and tag*/\n    memcpy(c, ct, nfb_ptlen);\n    memcpy(tag, ct+nfb_ptlen, 16-nfb_ptlen);\n    memcpy(tag+16-nfb_ptlen, byte2, nfb_ptlen);\n\n\t// CHANGE memory management (VLA allocation changed to dynamic)\n\tdelete[] byte1;\n\tdelete[] byte2;\n}\n\n/*inverse of XLS*/\nvoid XLSInv(const u32 irk[], const u8 Lprime[], const u8 c[], unsigned long long fb_ctlen, unsigned int nfb_ctlen, u8 p[], u8 tag[]){\n    u8 pt[16], ct[16];\n    u8 temp[16];\n    u8 mask1[16], mask2[16];\n\t// CHANGE VLA allocation changed to dynamic (for MSVC compiler)\n    // u8 byte1[nfb_ctlen], byte2[nfb_ctlen];\n\tu8* byte1 = new u8[nfb_ctlen];\n\tu8* byte2 = new u8[nfb_ctlen];\n\n    int i;\n\n    /*produce mask 3^2*Lprime, and save it to mask1[]*/\n    memcpy(mask1, Lprime, 16);\n    for(i=0; i<2; ++i){\n        memcpy(temp, mask1, 16);\n        double_mask(mask1);\n        xor_byte_string(temp, mask1, 16);\n    }\n\n    /*produce mask 7^2*Lprime, and save it to mask2[]*/\n    memcpy(mask2, Lprime, 16);\n    for(i=0; i<2; ++i){\n        memcpy(temp, mask2, 16);\n        double_mask(mask2);\n        xor_byte_string(mask2, temp, 16);\n        double_mask(mask2);\n        xor_byte_string(temp, mask2, 16);\n    }\n\n    /*produce the masks for E' and E'', and save them to mask1[] and mask2[] respectively*/\n    while(fb_ctlen!=0){\n        double_mask(mask1);\n        double_mask(mask2);\n        fb_ctlen-=16;\n    }\n    double_mask(mask1);\n    double_mask(mask2);\n\n    memcpy(ct, c, nfb_ctlen);\n    memcpy(ct+nfb_ctlen, tag, 16-nfb_ctlen);\n    memcpy(byte2, tag+16-nfb_ctlen, nfb_ctlen);\n\n    /*the first round */\n\n    xor_byte_string(mask1, ct, 16);\n    aesDecrypt(irk, ct, pt);\n    xor_byte_string(mask1, pt, 16);\n\n    pt[15-nfb_ctlen]^=0x01;\n    memcpy(byte1, pt+16-nfb_ctlen, nfb_ctlen);\n    MIX(byte1, byte2, nfb_ctlen);\n    memcpy(pt+16-nfb_ctlen, byte1, nfb_ctlen);\n    memcpy(ct, pt, 16);\n\n    /*The second round*/\n\n    xor_byte_string(mask2, ct, 16);\n    aesDecrypt(irk, ct, pt);\n    xor_byte_string(mask2, pt, 16);\n\n    pt[15-nfb_ctlen]^=0x01;\n    memcpy(byte1, pt+16-nfb_ctlen, nfb_ctlen);\n    MIX(byte1, byte2, nfb_ctlen);\n\n    memcpy(pt+16-nfb_ctlen, byte1, nfb_ctlen);\n    memcpy(ct, pt, 16);\n\n    /*the third round */\n\n    xor_byte_string(mask1, ct, 16);\n    aesDecrypt(irk, ct, pt);\n    xor_byte_string(mask1, pt, 16);\n\n    /*separate the output to plaintext and tag*/\n    memcpy(p, pt, nfb_ctlen);\n    memcpy(tag, pt+nfb_ctlen, 16-nfb_ctlen);\n    memcpy(tag+16-nfb_ctlen, byte2, nfb_ctlen);\n\n\t// CHANGE memory management (VLA allocation changed to dynamic)\n\tdelete[] byte1;\n\tdelete[] byte2;\n}\n\n/*SHELL-AES encryption for plaintexts with a length longer than one block but not a multiple of block length:\nparameters follow those of function shellaesEnc\n*/\nvoid shellaesEnc_nfb(const u8 key[], const u8 nonce[], const u8 ad[], unsigned long long int adlen, const u8 p[], unsigned long long int ptlen, u8 c[], u8 tag[]){\n\n    u8 V[16], U[16], checksum[16], F[16], keyprime[16], L[16], Lprime[16];\n    u8* S;\n    u8* I;\n    u8* Z;\n\n    unsigned long long int pt_fblen;\n    unsigned int pt_nfblen;\n\n    pt_nfblen=ptlen%16;\n    pt_fblen=ptlen-pt_nfblen;\n\n    S= (u8 *) malloc(ptlen);\n    I= (u8 *) malloc(ptlen);\n    Z= (u8 *) malloc(pt_fblen);\n\n    memset(V, 0, 16);\n    memset(U, 0, 16);\n    memset(checksum, 0, 16);\n    memset(keyprime, 0, 16);\n    memset(F, 0, 16);\n    memset(L, 0, 16);\n    memset(Lprime, 0, 16);\n\n    u32 mk[4*d], sk[12*d], rk[44], rkprime[44];\n\n    /*key setup*/\n    aesKeySetupEnc(rk, key);\n    KeySetupEnc(mk, sk, L, Lprime, keyprime, rk, key);\n    aesKeySetupEnc(rkprime, keyprime);\n\n    /*process the plaintext except the last non-full block*/\n    PXMAC(mk, sk, L, V, rk, ad, adlen);\n    CENC(rkprime, S, F, nonce, ptlen);\n    memcpy(I, p, ptlen);\n    xor_byte_string(S, I, ptlen);\n    checksum_state_string(I, checksum, pt_fblen);\n    PXENC(mk, sk, L, V, Z, rk, I, pt_fblen);\n    memcpy(U, V, 16);\n    XEXLayerEnc(rk, Lprime, Z, c, pt_fblen);\n    tagGen(rk, checksum, Lprime, U, F, tag, pt_fblen);\n\n    /*XLS: process the last non-full block*/\n    XLS(rk, Lprime, p+pt_fblen, pt_fblen, pt_nfblen, c+pt_fblen, tag);\n\n    /*\n    printf(\"ciphertext is: \\n\");\n    printf_byte_string(c, ptlen);\n\n    printf(\"tag value is: \\n\");\n    printf_byte_string(tag, 16);\n    */\n\n    free(I);\n    free(Z);\n    free(S);\n\n}\n\n/*SHELL-AES decryption for ciphertexts with a length longer than one block but not a multiple of block length:\nparameters follow those of function shellaesEnc\n*/\nint shellaesDec_nfb(const u8 key[], const u8 nonce[], const u8 ad[], unsigned long long int adlen, const u8 c[], unsigned long long int ctlen, u8 p[], const u8 tag[]){\n    u8 V[16], U[16], checksum[16], F[16], keyprime[16], L[16], Lprime[16];\n    u8* S;\n    u8* I;\n    u8* Z;\n    u8 tempTag[16], tempTag2[16];\n    int i, flag;\n\n    unsigned long long int ct_fblen;\n    unsigned int ct_nfblen;\n\n    ct_nfblen=ctlen%16;\n    ct_fblen=ctlen-ct_nfblen;\n\n    S= (u8 *) malloc(ctlen);\n    I= (u8 *) malloc(ctlen);\n    Z= (u8 *) malloc(ct_fblen);\n\n    memset(V, 0, 16);\n    memset(U, 0, 16);\n    memset(checksum, 0, 16);\n    memset(keyprime, 0, 16);\n    memset(F, 0, 16);\n    memset(L, 0, 16);\n    memset(Lprime, 0, 16);\n\n    u32 mk[4*d], sk[12*d], isk[12*d], rk[44], irk[44], rkprime[44];\n\n    /*setup key*/\n    aesKeySetupEnc(rk, key);\n    aesKeySetupDec(irk, key);\n    KeySetupDec(mk, sk, isk, L, Lprime, keyprime, rk, key);\n    aesKeySetupEnc(rkprime, keyprime);\n\n    /*decrypt the last non-full block*/\n    memcpy(tempTag, tag, 16);\n    XLSInv(irk, Lprime, c+ct_fblen, ct_fblen, ct_nfblen, p+ct_fblen, tempTag);\n\n    /*process associated data*/\n    PXMAC(mk, sk, L, V, rk, ad, adlen);\n\n    /*decryption of XEX layer*/\n    XEXLayerDec(irk, Lprime, c, Z, ct_fblen);\n\n    /*decryption of PXENC layer*/\n    PXDEC(mk, isk, L, V, Z, rk, I, ct_fblen);\n    memcpy(U, V, 16);\n\n    /*process nonce*/\n    CENC(rkprime, S, F, nonce, ctlen);\n\n    /*produce plaintext*/\n    memcpy(p, I, ct_fblen);\n    xor_byte_string(S, p, ct_fblen);\n\n    /*verify the validness of tag*/\n    checksum_state_string(I, checksum, ct_fblen);\n    tagGen(rk, checksum, Lprime, U, F, tempTag2, ct_fblen);\n\n    flag=1;\n\n    for(i=0; i<16; ++i){\n        if(tempTag[i]!=tempTag2[i]){\n            flag=0;\n        }\n    }\n\n    /*\n\n    if(flag){\n        printf(\"the plaintext is: \\n\");\n        printf_byte_string(p, ctlen);\n    }\n    else{\n        printf(\"the tag is invalid!\");\n    }\n    */\n\n    return flag;\n\n}\n\n/*\nthe encryption procedure of SHELL-AES:\nkey[] is the secret key;\nnonce[] is the nonce;\nad[] is associated data;\nadlen is the byte length of associated data;\np[] is the plaintext;\nptlen is the byte length of plaintext;\nc[] is the ciphertext to be produced;\nctlen is the byte length of ciphertext.\n*/\nvoid shellaesEnc(const u8 key[], const u8 nonce[], const u8 ad[], unsigned long long int adlen, const u8 p[], unsigned long long int ptlen, u8 c[], unsigned long long int ctlen){\n\n    u8 tag[16];\n\n\n    if(ptlen<16){\n        /*plaintext is shorter than one block*/\n        shellaesEnc_short(key, nonce, ad, adlen, p, ptlen, c, tag);\n    }\n    else if (ptlen%16==0){\n        /*plaintext is multiple blocks long */\n        shellaesEnc_fb(key, nonce, ad, adlen, p, ptlen, c, tag);\n    }\n    else{\n         /*plaintext is longer than one block, and has a length that is not a mutiple of block length */\n        shellaesEnc_nfb(key, nonce, ad, adlen, p, ptlen, c, tag);\n    }\n\n    /*append the tag to ciphertext*/\n    memcpy(c+ptlen, tag, 16);\n\n    /*\n    printf(\"the ciphertext and the tag is \\n\");\n    printf_byte_string(c, ctlen);\n    */\n}\n\n/*\nthe encryption procedure of SHELL-AES:\nparameters follow those of function shellaesEnc\n*/\nint shellaesDec(const u8 key[], const u8 nonce[], const u8 ad[], unsigned long long int adlen, const u8 c[], unsigned long long int ctlen, u8 p[], unsigned long long int ptlen){\n\n    u8 tag[16];\n    int flag;\n\n    memcpy(tag, c+ptlen, 16);\n\n    if(ptlen<16){\n        /*plaintext is shorter than one block*/\n        flag=shellaesDec_short(key, nonce, ad, adlen, c, ptlen, p, tag);\n    }\n    else if (ptlen%16==0){\n        /*plaintext is multiple blocks long */\n        flag=shellaesDecVef_fb(key, nonce, ad, adlen, c, ptlen, p, tag);\n    }\n    else{\n        /*plaintext is longer than one block, and has a length that is not a mutiple of block length */\n        flag=shellaesDec_nfb(key, nonce, ad, adlen, c, ptlen, p, tag);\n    }\n\n    return flag;\n}\n\n} // namespace Shellaes128v1d4n64_raw\n"
        },
        {
            "file_name": "silverv1_encrypt.cpp",
            "content": "#include \"silverv1_encrypt.h\"\n\n\n/** SILVER byte oriented\n*  @author Daniel Penazzi,@author Miguel Montes\n      April, 2014.\n*  Silver, using a byte oriented endian neutral implementation of Rijndael\n* This code is not intended to be fast, only endian neutral and capable of running\n* on a variety of machines.\n\n* This code is hereby placed in the public domain.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"silverv1_rijndaelEndianNeutral.h\"\n\n/*change the following if a truncated tag is wanted. The default is 16 bytes\nDO NOT USE DIFFERENT TAG LENGTHS WITH THE SAME KEY UNLESS YOUR APPLICATION\nFORCES THE INCLUSION OF THE TAG LENGTH IN THE ASSOCIATED DATA*/\n#define TAGLENGTH 16\n\n/*u8 defined in .h Next is to define u64, preferably with\nuint, but some compilers of MS seem not to accept it*/\n\n#if __GNUC__ || (__STDC_VERSION__ >= 199901L)\n#include <stdint.h>\ntypedef uint64_t u64;\n#else\ntypedef unsigned long long u64;\n#endif\n\n// CHANGE namespace moved due to includes\nnamespace Silverv1_raw {\nint numRounds = -1;\n\nvoid LESTOREu64inbytearray(u64 Rv,u8* R){\n    u8 i;\n    for(i=0;i<8;i++) {\n        R[i]=Rv&0xff;\n        Rv=Rv>>8;\n    }\n}\n\n\n\n\nvoid XOR128(u8* A,const u8* B){\n    u8 i;\n    for(i=0;i<16;i++) A[i]^=B[i];\n}\n\n\nvoid NADD64(const u8* A,const u8* B,u8* R){\n    u64 Av1=(u64)A[0];\n    u64 Av2=(u64)A[8];\n    u64 Bv1=(u64)B[0];\n    u64 Bv2=(u64)B[8];\n    u64 Rv;\n    u8 i;\n    u64 H=256;\n    for(i=1;i<8;i++){\n        Av1+=H*((u64)A[i]);\n        Av2+=H*((u64)A[i+8]);\n        Bv1+=H*((u64)B[i]);\n        Bv2+=H*((u64)B[i+8]);\n        H=H*256;\n    }\n    Rv=Av1+Bv1;\n    for(i=0;i<8;i++) {\n        R[i]=Rv&0xff;\n        Rv=Rv>>8;\n    }\n    Rv=Av2+Bv2;\n    for(i=8;i<16;i++) {\n        R[i]=Rv&0xff;\n        Rv=Rv>>8;\n    }\n}/*end NADD*/\n\nvoid XORADD(u8* checksum,const u8*update,u8* mask){\n    u8 R[16];\n    NADD64(update,mask,R);\\\n    XOR128(checksum,R);\n}\n\n\n\nvoid Obtain_sessionrkeys(u8* kappa,u8* rkey,u8* counter){\n\n    u8 tempkeys[11*16];\n    int i,j;\n\n    rijndaelexpandKey(kappa,tempkeys);\n\n\n  /*keys 1,9 remain as they are  */\n   for(i=0;i<16;i++){\n        rkey[i]^=tempkeys[i+16];/*0 xor 1*/\n        for(j=2;j<9;j++){\n            rkey[16*j+i]^=tempkeys[16*j+i];/*j xor j*/\n        }\n        counter[i]=tempkeys[16*9+i];/*9th rkey  */\n        rkey[160+i]^=tempkeys[160+i];/*10 xor 10*/\n    }\n    /*above is normal key expansion.\n     in locations 16*11 through 16*14-1 we will hold a copy of the round keys 1,5,9.\n     so we can change the ones in 1,5,9 and then restore them*/\n     for(i=0;i<16;i++){\n        rkey[16*11+i]=rkey[16+i];/*copy r1*/\n        rkey[16*12+i]=rkey[16*5+i];/*copy r5*/\n        rkey[16*13+i]=rkey[16*9+i];/*copy r9*/\n    }\n    /*now make counter odd on both halves*/\n    counter[0]|=(0x1U);\n    counter[8]|=(0x1U);\n\n\n}/*========================= end Obtain_rkeys===============*/\n\n\n\n\nvoid TAES_ENCRYPT(const u8* in,u8* out,u8* rkey,u8* counter){\n     int i;\n     u8 tempcount;\n     /*set rkeys 1,5,9 using the backups*/\n\n\n\n     for(i=0;i<16;i++){\n        tempcount=counter[i];\n        rkey[16+i]=rkey[16*11+i]^tempcount;\n        rkey[16*5+i]=rkey[16*12+i]^tempcount;\n        rkey[16*9+i]=rkey[16*13+i]^tempcount;\n    }\n\n rijndaelEncrypt(rkey,in,out);\n\n\n}\n\n\n\n\nvoid TAES_DECRYPT(const u8* in,u8* out,u8* rk,u8* counter){\n     int i;\n     u8 tempcounter;\n\n     /*set rkeys 1,5,9 using the backups*/\n\n     for(i=0;i<16;i++){\n        tempcounter =counter[i];\n        rk[16+i]=rk[16*11+i]^tempcounter;\n        rk[16*5+i]=rk[16*12+i]^tempcounter;\n        rk[16*9+i]=rk[16*13+i]^tempcounter;\n    }\n\n rijndaelDecrypt(rk,in,out);\n\n\n}\n\n\n\n\n\nvoid TAG(u8* checksum,\n         u64 adlen,u64 mlen,u8* rkey,u8* tag,u8* kappa){\n         /* returns the tag, i.e., the encryption of the checksum*/\n    u8 i;\n    u8 tempkey;\n    u8 tmp[16];\n    u64 L=(u64)kappa[0];\n    u64 R=(u64)kappa[8];\n    u64 H=256;\n    for(i=1;i<8;i++){\n        L+=H*((u64)kappa[i]);\n        R+=H*((u64)kappa[i+8]);\n        H=H*256;\n    }/*this is needed for endian neutralness, in LE a cast would suffice*/\n    L+=adlen;\n    R+=mlen;\n    LESTOREu64inbytearray(L,tmp);\n    LESTOREu64inbytearray(R,tmp+8);\n\n    for(i=0;i<16;i++) {\n        tempkey=rkey[i];\n        rkey[i]=rkey[i+16*2];\n        rkey[i+16*2]=rkey[i+16*3];\n        rkey[i+16*3]=rkey[i+16*4];\n        rkey[i+16*4]=rkey[i+16*6];\n        rkey[i+16*6]=rkey[i+16*7];\n        rkey[i+16*7]=rkey[i+16*8];\n        rkey[i+16*8]=rkey[i+160];\n        rkey[i+160]=tempkey;\n        tempkey=rkey[i+16*12];/*changing the rkeys 1,5,9 is\n                       irrelevant because Taesencypt rewrites them.\n                       We have to change the order of the keys 11,12,13,\n                       which are the ones that are going to be put in rounds\n                       1,5,9 by taes  */\n        rkey[i+16*12]=rkey[i+16*11];\n        rkey[i+16*11]=rkey[i+16*13];\n        rkey[i+16*13]=tempkey;\n    }\n\n\n         TAES_ENCRYPT(checksum,tag,rkey,(tmp));\n\n\n\n\n   }\n   /*====================== end TAG=====================  */\n\n\n\n\n\n\nvoid SETUPcounterLEFT(u8* input,u8* counter){\n    u8 i;\n    for(i=0;i<8;i++) counter[i]=input[i];\n    for(i=8;i<16;i++) counter[i]=0;\n}\n\n\n\n\nvoid ProcessAD(u64 adlen,const unsigned char *ad,\n               u8* rkey,u8* kappa,u8* preIC,u8* checksum){\n\n  /*variable declarations */\n    u64 j,blockadlen;\n    u8 sout[16];\n    u8 initcounter[16];\n    u8 counter[16];\n    u8 kount=0;\n    u8 partial[16]={0};\n /*end variable declaration */\n for(j=0;j<16;j++) checksum[j]=0;\n if(adlen>0){\n    SETUPcounterLEFT(preIC,initcounter);\n    NADD64(kappa,initcounter,counter);\n    blockadlen=(adlen/16);/*number of ad full blocks\n\n      */\n    j=0;\n    while(j<blockadlen){\n        TAES_ENCRYPT(ad,sout,rkey,counter);\n        XOR128(checksum,sout);\n        NADD64(counter,initcounter,counter);\n        j++;ad+=16;\n      }/*endwhile. Now only a possible partial block exists */\n\n\n    j=(j<<4);/*now it counts bytes since each block has 16 bytes*/\n    if(j<adlen){ /*we DO have a partial block*/\n\n\n        while(j+kount<adlen){\n           partial[kount]=ad[kount];\n           kount++;\n        }/*endwhile  */\n\n        partial[kount]=1;\n        TAES_ENCRYPT(partial,sout,rkey,kappa);\n        /*kappa is never used elsewhere*/\n        XOR128(checksum,sout);\n    }/* end if j<adlen. no need to update counter*/\n\n }/*end if adlen*/\n\n }/*=================end ProcessAD ============*/\n\n\n\n /**==========================================\n      next function is  to process a partial plaintext block\n          \"retvalue\" is to be xored to the checksum.\n          j is the number of bytes processed so far.\n          side effects: encrypts/decrypts, i.e., changes the\n          ciphtxt/plaintxt stream.\n          the flag is so we can use the code in both enc and dec\n          this probably is slightly slower than having two codes\n          but is better if one needs to make changes\n    ===========================================**/\n\n\nvoid PartialBlock(u64 msglen,u8* rkey,u64 j,\n              const unsigned char *inb,unsigned char *outb,\n              int flag,u8* initcounter,u8* counter,u8* retvalue){\n    u8 i;\n    u8 sout[16];\n    u8 in[16];\n\n\n    LESTOREu64inbytearray(msglen,in);\n    for(i=0;i<8;i++) in[i+8]=in[i];\n\n\n\n    TAES_ENCRYPT(in,sout,rkey,counter);\n\n             /*in this case the plain cannot be incorporated into\n                the checksum since it is counter mode,\n                so silver does one more process\n              */\n\n\n        i=0;\n        if(flag){ /*enc */\n            while(i<msglen-j){\n                outb[i]=inb[i]^sout[i];\n                sout[i]^=outb[i];/*this writes the original inb[i] into sout.\n                        we do not write sout[i]=inb[i] directly\n                        since outb may have rewritten inb[i]*/\n                i++;\n            }/*endwhile   */\n        }/*end if*/\n        else {/*dec */\n            while(i<msglen-j){\n                sout[i]=outb[i]=inb[i]^sout[i];/*dec is easier than enc*/\n                 i++;\n            }/*endwhile   */\n        }/*end else*/\n        sout[15]=i;\n\n\n            /*first bytes of sout have the last bytes of plain, rest\n                is  encryption of the length and number of bytes at the end*/\n        NADD64(counter,initcounter,counter);\n\n\n        TAES_ENCRYPT(sout,retvalue,rkey,counter);\n\n\n }/*==============END partial block */\n\n\n\n\n\n\n/*\n                                ********************************************\n=============================================================================================\n            ENCRYPT and AUTENTICATE\n\n=============================================================================================\n*/\n\n\n\n\nint crypto_aead_encrypt(unsigned char *c,\n       unsigned long long *clen,\n       const unsigned char *m,\n       unsigned long long mlen,\n       const unsigned char *ad,\n       unsigned long long adlen,\n       const unsigned char *nsec,\n       const unsigned char *npub,\n       const unsigned char *k){\n\n      /*start: initialize auxiliary variables*/\n\n\n    u8 checksum[16];\n    u8 kappa[16];\n    u8 rkey[16*14];\n    u8 sout[16];\n    u64 j;\n    u8 tag[16];\n    u8 initcounter[16];\n    u8 counter[16];\n    u64 blockmlen=(mlen/16); /*number of plain full blocks*/\n\n\n\n    (void) nsec;\t\t\t/* avoid warning*/\n\n\n\n    rijndaelexpandKey(k,rkey);/*expand user key   */\n\n  /*=========get kappa======  */\n  rijndaelEncrypt(rkey,npub,kappa);\n\n\n/*=============get session rkeys and mask=====*/\n\n Obtain_sessionrkeys(kappa,rkey,initcounter);\n\n\n/*===============================\n              associated data\n=================================*/\n\n    ProcessAD(adlen,ad,rkey,kappa,initcounter,checksum);\n\n\n\n/*===========================================\n              ENCRYPT PLAINTEXT\n==============================================  */\n\n    NADD64(kappa,initcounter,counter);\n    *clen=mlen+TAGLENGTH;\n     j=0;\n    if(mlen>0){\n\n        while(j<blockmlen){\n            XOR128(checksum,m);\n            TAES_ENCRYPT(m,c,rkey,counter);\n            XORADD(checksum,c,counter);\n            NADD64(counter,initcounter,counter);\n            j++;m+=16;c+=16;\n        }/*endwhile. Now only a possible partial block exists */\n\n\n        j=(j<<4);\n\n        if(j<mlen){ /*last block is partial, then */\n\n            PartialBlock(mlen,rkey,j,m,c,1,initcounter,counter,sout);\n\n            XOR128(checksum,sout);\n\n            c+=(mlen-j);\n        }/*endif j<mlen*/\n\n }/*endif mlen>0, end encryption  */\n\n\n\n\n/*=========================\n             TAG\n===========================*/\n\n\n\n    TAG(checksum,adlen,mlen,rkey,tag,kappa);\n\n/*we could store directly into c in the default taglength=16\nbut we do it this way in case truncation is wanted*/\n\n\n\n\nfor(j=0;j<TAGLENGTH;j++) c[j]=tag[j];\n\n\nreturn 0;\n\n}/*end AEAD encrypt*/\n\n\n\n\n\n\n\n/*\n\n=============================================================================================\n\n                                        DECRYPT-VERIFY\n\n=============================================================================================\n\n*/\n\nint crypto_aead_decrypt(\n    unsigned char *m,unsigned long long *mlen,\n    unsigned char *nsec,\n    const unsigned char *c,unsigned long long clen,\n    const unsigned char *ad,unsigned long long adlen,\n    const unsigned char *npub,\n    const unsigned char *k){\n    /*WARNING we assume from the CAESAR call that the person in charge of the call to this\n    function will discard the plaintext if this function returns -1, and that\n    any attacker will not have access to m unless the return value is not -1.\n    */\n\n    if(clen<TAGLENGTH) return -1;\n    /* declaration of variables */\n    u8 checksum[16];\n    u8 kappa[16];\n    u8 rkey[16*14];\n    u8 sout[16];\n    u64 i,j;\n    u8 tag[16];\n    u8 initcounter[16];\n    u8 counter[16];\n    u64 kount=clen-TAGLENGTH;\n    u64 blockclen=(kount/16);/*number of ciphertext full blocks, excluding tag*/\n\n\n    (void) nsec;\t\t\t/* avoid warning*/\n\n\n\n    rijndaelexpandKey(k,rkey);/*expand user key   */\n\n  /*=========get kappa======  */\n  rijndaelEncrypt(rkey,npub,kappa);\n\n\n\n/*=============get session rkeys and mask=====*/\n\n Obtain_sessionrkeys(kappa,rkey,initcounter);\n\n/*===============================\n              associated data\n=================================*/\n\n    ProcessAD(adlen,ad,rkey,kappa,initcounter,checksum);\n\n\n /*==========================================================\n                  DECRYPT CIPHERTEXT\n\n=======================================================*/\n\n\n    NADD64(kappa,initcounter,counter);\n    *mlen=clen-TAGLENGTH;\n    j=0;\n    if(clen>TAGLENGTH){\n\n        while(j<blockclen){\n            XORADD(checksum,c,counter);\n            TAES_DECRYPT(c,m,rkey,counter);\n            XOR128(checksum,m);\n            NADD64(counter,initcounter,counter);\n            j++;c+=16;m+=16;\n        }/*endwhile. */\n\n        j=(j<<4);\n\n        if(j<kount){ /*last block is partial, then */\n            PartialBlock(kount,rkey,j,c,m,0,initcounter,counter,sout);\n            XOR128(checksum,sout);\n            c+=(kount-j);\n        }/*endif j  */\n\n\n    }/*end decryption\n\n\n       ==========================\n              VERIFY TAG\n       ===========================*/\n\n\n\n\n\n    TAG(checksum,adlen,kount,rkey,tag,kappa);\n\n\nj=0;\n/*to avoid side attacks and to try to fool the compiler into not optimizing too much*/\nfor(i=0;i<TAGLENGTH;i++) {\n    if(tag[i]!=c[i]) j+=2;\n        else j++;\n    }\n\n    if(j>TAGLENGTH) return -1;\n\n\n    return 0;\n}/*  ===============END aead decrypt ========================*/\n\n\n\n\n\n\n\n\n\n} // namespace Silverv1_raw\n"
        },
        {
            "file_name": "silverv1_rijndaelEndianNeutral.cpp",
            "content": "/**rijndael byte oriented. Does not attempt to be efficient,\nonly endian neutral by being byte oriented.\n Author Daniel Penazzi, april 2014\n\n\n* This code is hereby placed in the public domain.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n#include \"silverv1_rijndaelEndianNeutral.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Silverv1_raw {\n\nconst u8 SBOX[256] = {\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n};\nconst u8 INVSBOX[256] = {\n    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,\n    0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,\n    0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,\n    0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,\n    0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,\n    0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,\n    0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,\n    0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,\n    0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,\n    0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,\n    0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,\n    0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,\n    0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,\n    0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,\n    0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,\n    0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,\n    0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d\n};\n\n\nstatic const u8 rcon[10] = {\n    0x1U, 0x2U, 0x4U, 0x8U, 0x10U,\n    0x20U, 0x40U, 0x80U, 0x1bU, 0x36U};\n\n\nstatic const u8 GFx2[256] ={\n0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,\n0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,\n0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,\n0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,\n0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,\n0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,\n0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,\n0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,\n0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,\n0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,\n0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,\n0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,\n0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,\n0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,\n0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,\n0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5\n};\n\n\nstatic const u8 GFx3[256]={\n0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,\n0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,\n0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,\n0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,\n0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,\n0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,\n0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,\n0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,\n0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,\n0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,\n0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,\n0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,\n0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,\n0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,\n0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,\n0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a\n};\n\nstatic const u8 GFx9[256] ={\n0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,\n0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,\n0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,\n0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,\n0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,\n0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,\n0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,\n0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,\n0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,\n0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,\n0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,\n0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,\n0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,\n0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,\n0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,\n0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46\n};\n\n\nstatic const u8 GFx11[256] ={\n0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,\n0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,\n0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,\n0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,\n0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,\n0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,\n0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,\n0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,\n0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,\n0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,\n0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,\n0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,\n0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,\n0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,\n0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,\n0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3\n};\n\nstatic const u8 GFx13[256] ={\n0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,\n0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,\n0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,\n0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,\n0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,\n0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,\n0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,\n0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,\n0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,\n0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,\n0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,\n0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,\n0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,\n0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,\n0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,\n0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97\n};\n\nstatic const u8 GFx14[256] ={\n0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,\n0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,\n0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,\n0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,\n0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,\n0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,\n0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,\n0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,\n0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,\n0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,\n0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,\n0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,\n0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,\n0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,\n0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,\n0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d\n};\n\n\n\n\n/*sa,sb etc are the sources, A,B, etc the new\nmatrix is 2 3 1 1 rotated right\n*/\n\n#define MIXCOLUMN(sa,sb,sc,sd,A,B,C,D)\\\n    A=GFx2[sa]^GFx3[sb]^sc^sd;\\\n    B=GFx2[sb]^GFx3[sc]^sd^sa;\\\n    C=GFx2[sc]^GFx3[sd]^sa^sb;\\\n    D=GFx2[sd]^GFx3[sa]^sb^sc;\n\n\n/*ABCD      048(12)\n  EFGH  is  159(13)\n  IJKL      26(10)(14)\n  MNOP      37(11)(15)*/\nvoid ShiftRowandMixColumn(u8 *s,u8* t){\n    MIXCOLUMN(s[0],s[5],s[10],s[15],t[0],t[1],t[2],t[3])/*A,F,K,P*/\n    MIXCOLUMN(s[4],s[9],s[14],s[3],t[4],t[5],t[6],t[7])/*B,G,L,M*/\n    MIXCOLUMN(s[8],s[13],s[2],s[7],t[8],t[9],t[10],t[11])/*C,H,I,N*/\n    MIXCOLUMN(s[12],s[1],s[6],s[11],t[12],t[13],t[14],t[15])/*D,E,J,O*/\n}\n\n#define SIMPLE(sa,sb,sc,sd,A,B,C,D)\\\n    A=sa;\\\n    B=sb;\\\n    C=sc;\\\n    D=sd;\n\nvoid ShiftRowOnly(u8 *s,u8* t){\n    SIMPLE(s[0],s[5],s[10],s[15],t[0],t[1],t[2],t[3])/*A,F,K,P*/\n    SIMPLE(s[4],s[9],s[14],s[3],t[4],t[5],t[6],t[7])/*B,G,L,M*/\n    SIMPLE(s[8],s[13],s[2],s[7],t[8],t[9],t[10],t[11])/*C,H,I,N*/\n    SIMPLE(s[12],s[1],s[6],s[11],t[12],t[13],t[14],t[15])/*D,E,J,O*/\n}\n\n/*for dec now*/\n\n\n/* 14 11 13 9 rotated right*/\n\n#define INVMIXCOLUMN(sa,sb,sc,sd,A,B,C,D)\\\n    A=GFx14[sa]^GFx11[sb]^GFx13[sc]^GFx9[sd];\\\n    B=GFx14[sb]^GFx11[sc]^GFx13[sd]^GFx9[sa];\\\n    C=GFx14[sc]^GFx11[sd]^GFx13[sa]^GFx9[sb];\\\n    D=GFx14[sd]^GFx11[sa]^GFx13[sb]^GFx9[sc];\n\n\n\n\n\n/*ABCD      048(12)\n  EFGH  is  159(13)\n  IJKL      26(10)(14)\n  MNOP      37(11)(15)*/\nvoid InvMixColumn(u8* s,u8* t){\n    INVMIXCOLUMN(s[0],s[1],s[2],s[3],t[0],t[1],t[2],t[3])\n    INVMIXCOLUMN(s[4],s[5],s[6],s[7],t[4],t[5],t[6],t[7])\n    INVMIXCOLUMN(s[8],s[9],s[10],s[11],t[8],t[9],t[10],t[11])\n    INVMIXCOLUMN(s[12],s[13],s[14],s[15],t[12],t[13],t[14],t[15])\n}\n\n\n\n\n\nvoid InvShiftRowOnly(u8 *s,u8* t){\n    SIMPLE(s[0],s[13],s[10],s[7],t[0],t[1],t[2],t[3])/*A,H,K,N*/\n    SIMPLE(s[4],s[1],s[14],s[11],t[4],t[5],t[6],t[7])/*B,E,L,O*/\n    SIMPLE(s[8],s[5],s[2],s[15],t[8],t[9],t[10],t[11])/*C,F,I,P*/\n    SIMPLE(s[12],s[9],s[6],s[3],t[12],t[13],t[14],t[15])/*D,G,J,M*/\n}\n\n\n\n\n\n\nvoid rijndaelexpandKey(const u8 *k,u8* rk) {\n    register u8 i,j;\n    for(i=0;i<16;i++) rk[i]=k[i];\n\n    for(j=0;j<10;j++){\n\n    rk[16] =rk[0]^ SBOX[rk[13]] ^ (rcon[j]);\n    rk[17] =rk[1]^ SBOX[rk[14]];\n    rk[18] =rk[2]^ SBOX[rk[15]];\n    rk[19] =rk[3]^ SBOX[rk[12]];\n    for(i=20;i<32;i++) rk[i]=rk[i-16]^rk[i-4];\n\n    rk+=16;\n    }/*end for j*/\n\n} /*end keygen*/\n\n\nvoid rijndaelEncrypt(u8* rk,const u8* pt,u8* ct){\n register u8 i,j;\n  u8 s[16];\n  u8 t[16];\n    for(i=0;i<16;i++) t[i]=SBOX[pt[i]^rk[i]];\n    ShiftRowandMixColumn(t,s);/*end first round*/\n    for(j=0;j<4;j++){/*double rounds (2,3),(4,5),(6,7),(8,9)*/\n        rk+=16;\n        for(i=0;i<16;i++) s[i]=SBOX[s[i]^rk[i]];\n        ShiftRowandMixColumn(s,t);\n        rk+=16;\n        for(i=0;i<16;i++) t[i]=SBOX[t[i]^rk[i]];\n        ShiftRowandMixColumn(t,s);\n    }/*end for j, now last round*/\n    rk+=16;\n    for(i=0;i<16;i++) s[i]=SBOX[s[i]^rk[i]];\n    ShiftRowOnly(s,t);\n    rk+=16;\n    for(i=0;i<16;i++) ct[i]=t[i]^rk[i];/*final whitening*/\n\n\n}/*end enc*/\n\nvoid rijndaelDecrypt(u8* rk,const u8* ct,u8* pt){\n register u8 i,j;\n  u8 s[16];\n  u8 t[16];\n    rk+=160;\n    for(i=0;i<16;i++) t[i]=ct[i]^rk[i];/*inv encwhitening final*/\n    rk-=16;\n    InvShiftRowOnly(t,s);\n    for(i=0;i<16;i++) s[i]=INVSBOX[s[i]]^rk[i];\n    rk-=16;\n    for(j=0;j<8;j++){/* rounds 9,87,6,5,4,3,2*/\n        InvMixColumn(s,t);\n        InvShiftRowOnly(t,s);\n        for(i=0;i<16;i++) s[i]=INVSBOX[s[i]]^rk[i];\n        rk-=16;\n    }/*end for j, now last round*/\n    InvMixColumn(s,t);\n    InvShiftRowOnly(t,s);\n    for(i=0;i<16;i++) pt[i]=INVSBOX[s[i]]^rk[i];\n\n\n\n}/*end dec*/\n\n\n\n\n\n} // namespace Silverv1_raw\n"
        },
        {
            "file_name": "Skein512.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"Skein512_data.h\"\n\n//// DUMMY-DEBUG\n#define Skein_Show_Block(bits,ctx,X,blkPtr,wPtr,ksEvenPtr,ksOddPtr)\n#define Skein_Show_Round(bits,ctx,r,X)\n#define Skein_Show_R_Ptr(bits,ctx,r,X_ptr)\n#define Skein_Show_Final(bits,ctx,cnt,outPtr)\n#define Skein_Show_Key(bits,ctx,key,keyBytes)\n////\n\n#define SKEIN_T1_BIT(BIT)       ((BIT) - 64)            /* offset 64 because it's the second word  */\n                                \n#define SKEIN_T1_POS_TREE_LVL   SKEIN_T1_BIT(112)       /* bits 112..118: level in hash tree       */\n#define SKEIN_T1_POS_BIT_PAD    SKEIN_T1_BIT(119)       /* bit  119     : partial final input byte */\n#define SKEIN_T1_POS_BLK_TYPE   SKEIN_T1_BIT(120)       /* bits 120..125: type field               */\n#define SKEIN_T1_POS_FIRST      SKEIN_T1_BIT(126)       /* bits 126     : first block flag         */\n#define SKEIN_T1_POS_FINAL      SKEIN_T1_BIT(127)       /* bit  127     : final block flag         */\n\n#define SKEIN_T1_FLAG_FIRST     (((QWORD)  1 ) << SKEIN_T1_POS_FIRST)\n#define SKEIN_T1_FLAG_FINAL     (((QWORD)  1 ) << SKEIN_T1_POS_FINAL)\n#define SKEIN_T1_FLAG_BIT_PAD   (((QWORD)  1 ) << SKEIN_T1_POS_BIT_PAD)\n\n#define SKEIN_T1_TREE_LVL_MASK  (((QWORD)0x7F) << SKEIN_T1_POS_TREE_LVL)\n#define SKEIN_T1_TREE_LEVEL(n)  (((QWORD) (n)) << SKEIN_T1_POS_TREE_LVL)\n\n#define SKEIN_BLK_TYPE_KEY      ( 0)                    /* key, for MAC and KDF */\n#define SKEIN_BLK_TYPE_CFG      ( 4)                    /* configuration block */\n#define SKEIN_BLK_TYPE_PERS     ( 8)                    /* personalization string */\n#define SKEIN_BLK_TYPE_PK       (12)                    /* public key (for digital signature hashing) */\n#define SKEIN_BLK_TYPE_KDF      (16)                    /* key identifier for KDF */\n#define SKEIN_BLK_TYPE_NONCE    (20)                    /* nonce for PRNG */\n#define SKEIN_BLK_TYPE_MSG      (48)                    /* message processing */\n#define SKEIN_BLK_TYPE_OUT      (63)                    /* output stage */\n#define SKEIN_BLK_TYPE_MASK     (63)                    /* bit field mask */\n\n#define SKEIN_T1_BLK_TYPE(T)   (((QWORD) (SKEIN_BLK_TYPE_##T)) << SKEIN_T1_POS_BLK_TYPE)\n#define SKEIN_T1_BLK_TYPE_KEY   SKEIN_T1_BLK_TYPE(KEY)  /* key, for MAC and KDF */\n#define SKEIN_T1_BLK_TYPE_CFG   SKEIN_T1_BLK_TYPE(CFG)  /* configuration block */\n#define SKEIN_T1_BLK_TYPE_PERS  SKEIN_T1_BLK_TYPE(PERS) /* personalization string */\n#define SKEIN_T1_BLK_TYPE_PK    SKEIN_T1_BLK_TYPE(PK)   /* public key (for digital signature hashing) */\n#define SKEIN_T1_BLK_TYPE_KDF   SKEIN_T1_BLK_TYPE(KDF)  /* key identifier for KDF */\n#define SKEIN_T1_BLK_TYPE_NONCE SKEIN_T1_BLK_TYPE(NONCE)/* nonce for PRNG */\n#define SKEIN_T1_BLK_TYPE_MSG   SKEIN_T1_BLK_TYPE(MSG)  /* message processing */\n#define SKEIN_T1_BLK_TYPE_OUT   SKEIN_T1_BLK_TYPE(OUT)  /* output stage */\n#define SKEIN_T1_BLK_TYPE_MASK  SKEIN_T1_BLK_TYPE(MASK) /* field bit mask */\n\n#define SKEIN_T1_BLK_TYPE_CFG_FINAL       (SKEIN_T1_BLK_TYPE_CFG | SKEIN_T1_FLAG_FINAL)\n#define SKEIN_T1_BLK_TYPE_OUT_FINAL       (SKEIN_T1_BLK_TYPE_OUT | SKEIN_T1_FLAG_FINAL)\n\n#define SKEIN_VERSION           (1)\n#define SKEIN_ID_STRING_LE      (0x33414853)            /* \"SHA3\" (little-endian)*/\n\n#define SKEIN_MK_64(hi32,lo32)  ((((QWORD) hi32) << 32)+(lo32))\n#define SKEIN_SCHEMA_VER        SKEIN_MK_64(SKEIN_VERSION,SKEIN_ID_STRING_LE)\n#define SKEIN_KS_PARITY         SKEIN_MK_64(0x1BD11BDA,0xA9FC1A22)\n\n#define SKEIN_CFG_STR_LEN       (4*8)\n\n#define SKEIN_CFG_TREE_LEAF_SIZE_POS  ( 0)\n#define SKEIN_CFG_TREE_NODE_SIZE_POS  ( 8)\n#define SKEIN_CFG_TREE_MAX_LEVEL_POS  (16)\n\n#define SKEIN_CFG_TREE_LEAF_SIZE_MSK  (((QWORD) 0xFF) << SKEIN_CFG_TREE_LEAF_SIZE_POS)\n#define SKEIN_CFG_TREE_NODE_SIZE_MSK  (((QWORD) 0xFF) << SKEIN_CFG_TREE_NODE_SIZE_POS)\n#define SKEIN_CFG_TREE_MAX_LEVEL_MSK  (((QWORD) 0xFF) << SKEIN_CFG_TREE_MAX_LEVEL_POS)\n\n#define SKEIN_CFG_TREE_INFO(leaf,node,maxLvl)                   \\\n    ( (((QWORD)(leaf  )) << SKEIN_CFG_TREE_LEAF_SIZE_POS) |    \\\n      (((QWORD)(node  )) << SKEIN_CFG_TREE_NODE_SIZE_POS) |    \\\n      (((QWORD)(maxLvl)) << SKEIN_CFG_TREE_MAX_LEVEL_POS) )\n\n#define SKEIN_CFG_TREE_INFO_SEQUENTIAL SKEIN_CFG_TREE_INFO(0,0,0) /* use as treeInfo in InitExt() call for sequential processing */\n\n#define Skein_Get_Tweak(ctxPtr,TWK_NUM)         ((ctxPtr)->h.T[TWK_NUM])\n#define Skein_Set_Tweak(ctxPtr,TWK_NUM,tVal)    {(ctxPtr)->h.T[TWK_NUM] = (tVal);}\n\n#define Skein_Get_T0(ctxPtr)    Skein_Get_Tweak(ctxPtr,0)\n#define Skein_Get_T1(ctxPtr)    Skein_Get_Tweak(ctxPtr,1)\n#define Skein_Set_T0(ctxPtr,T0) Skein_Set_Tweak(ctxPtr,0,T0)\n#define Skein_Set_T1(ctxPtr,T1) Skein_Set_Tweak(ctxPtr,1,T1)\n\n#define Skein_Set_T0_T1(ctxPtr,T0,T1)           \\\n    {                                           \\\n    Skein_Set_T0(ctxPtr,(T0));                  \\\n    Skein_Set_T1(ctxPtr,(T1));                  \\\n    }\n\n#define Skein_Set_Type(ctxPtr,BLK_TYPE)         \\\n    Skein_Set_T1(ctxPtr,SKEIN_T1_BLK_TYPE_##BLK_TYPE)\n\n#define Skein_Start_New_Type(ctxPtr,BLK_TYPE)   \\\n    { Skein_Set_T0_T1(ctxPtr,0,SKEIN_T1_FLAG_FIRST | SKEIN_T1_BLK_TYPE_##BLK_TYPE); (ctxPtr)->h.bCnt=0; }\n\n#define Skein_Clear_First_Flag(hdr)      { (hdr).T[1] &= ~SKEIN_T1_FLAG_FIRST;       }\n#define Skein_Set_Bit_Pad_Flag(hdr)      { (hdr).T[1] |=  SKEIN_T1_FLAG_BIT_PAD;     }\n\n#define Skein_Set_Tree_Level(hdr,height) { (hdr).T[1] |= SKEIN_T1_TREE_LEVEL(height);}\n\nenum    \n    {   \n        /* Skein_256 round rotation constants */\n    R_256_0_0=14, R_256_0_1=16,\n    R_256_1_0=52, R_256_1_1=57,\n    R_256_2_0=23, R_256_2_1=40,\n    R_256_3_0= 5, R_256_3_1=37,\n    R_256_4_0=25, R_256_4_1=33,\n    R_256_5_0=46, R_256_5_1=12,\n    R_256_6_0=58, R_256_6_1=22,\n    R_256_7_0=32, R_256_7_1=32,\n\n        /* Skein_512 round rotation constants */\n    R_512_0_0=46, R_512_0_1=36, R_512_0_2=19, R_512_0_3=37,\n    R_512_1_0=33, R_512_1_1=27, R_512_1_2=14, R_512_1_3=42,\n    R_512_2_0=17, R_512_2_1=49, R_512_2_2=36, R_512_2_3=39,\n    R_512_3_0=44, R_512_3_1= 9, R_512_3_2=54, R_512_3_3=56,\n    R_512_4_0=39, R_512_4_1=30, R_512_4_2=34, R_512_4_3=24,\n    R_512_5_0=13, R_512_5_1=50, R_512_5_2=10, R_512_5_3=17,\n    R_512_6_0=25, R_512_6_1=29, R_512_6_2=39, R_512_6_3=43,\n    R_512_7_0= 8, R_512_7_1=35, R_512_7_2=56, R_512_7_3=22,\n\n        /* Skein1024 round rotation constants */\n    R1024_0_0=24, R1024_0_1=13, R1024_0_2= 8, R1024_0_3=47, R1024_0_4= 8, R1024_0_5=17, R1024_0_6=22, R1024_0_7=37,\n    R1024_1_0=38, R1024_1_1=19, R1024_1_2=10, R1024_1_3=55, R1024_1_4=49, R1024_1_5=18, R1024_1_6=23, R1024_1_7=52,\n    R1024_2_0=33, R1024_2_1= 4, R1024_2_2=51, R1024_2_3=13, R1024_2_4=34, R1024_2_5=41, R1024_2_6=59, R1024_2_7=17,\n    R1024_3_0= 5, R1024_3_1=20, R1024_3_2=48, R1024_3_3=41, R1024_3_4=47, R1024_3_5=28, R1024_3_6=16, R1024_3_7=25,\n    R1024_4_0=41, R1024_4_1= 9, R1024_4_2=37, R1024_4_3=31, R1024_4_4=12, R1024_4_5=47, R1024_4_6=44, R1024_4_7=30,\n    R1024_5_0=16, R1024_5_1=34, R1024_5_2=56, R1024_5_3=51, R1024_5_4= 4, R1024_5_5=53, R1024_5_6=42, R1024_5_7=41,\n    R1024_6_0=31, R1024_6_1=44, R1024_6_2=47, R1024_6_3=46, R1024_6_4=19, R1024_6_5=42, R1024_6_6=44, R1024_6_7=25,\n    R1024_7_0= 9, R1024_7_1=48, R1024_7_2=35, R1024_7_3=52, R1024_7_4=23, R1024_7_5=31, R1024_7_6=37, R1024_7_7=20\n    };\n\n#define SKEIN_512_ROUNDS_TOTAL (72)\n\n#define InjectKey(r)                                                \\\n    for (i=0;i < WCNT;i++)                                          \\\n         X[i] += ks[((r)+i) % (WCNT+1)];                            \\\n    X[WCNT-3] += ts[((r)+0) % 3];                                   \\\n    X[WCNT-2] += ts[((r)+1) % 3];                                   \\\n    X[WCNT-1] += (r);                    /* avoid slide attacks */  \\\n    Skein_Show_Round(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,X);\n\nQWORD RotL_64(QWORD x,DWORD N)\n{\n\treturn (x << (N & 63)) | (x >> ((64-N) & 63));\n}\n\n#define BLK_BITS    (WCNT*64)\n\nQWORD Skein_Swap64(QWORD w64)\n{    /* instantiate the function body here */\n    static const QWORD ONE = 1;              /* use this to check endianness */\n\n    /* figure out endianness \"on-the-fly\" */\n    if (1 == ((BYTE *) & ONE)[0])\n        return w64;                           /* little-endian is fast */\n    else\n        return  (( w64       & 0xFF) << 56) | /*    big-endian is slow */\n                (((w64 >> 8) & 0xFF) << 48) |\n                (((w64 >>16) & 0xFF) << 40) |\n                (((w64 >>24) & 0xFF) << 32) |\n                (((w64 >>32) & 0xFF) << 24) |\n                (((w64 >>40) & 0xFF) << 16) |\n                (((w64 >>48) & 0xFF) <<  8) |\n                (((w64 >>56) & 0xFF)      ) ;\n}\n\nvoid Skein_Put64_LSB_First(BYTE *dst,const QWORD *src,DWORD bCnt)\n{ /* this version is fully portable (big-endian or little-endian), but slow */\n    DWORD n;\n\n    for (n=0;n<bCnt;n++)\n        dst[n] = (BYTE) (src[n>>3] >> (8*(n&7)));\n}\n\nvoid Skein_Get64_LSB_First(QWORD *dst,const BYTE *src,DWORD wCnt)\n{ /* this version is fully portable (big-endian or little-endian), but slow */\n    size_t n;\n\n    for (n=0;n<8*wCnt;n+=8)\n        dst[n/8] = (((QWORD) src[n  ])      ) +\n                   (((QWORD) src[n+1]) <<  8) +\n                   (((QWORD) src[n+2]) << 16) +\n                   (((QWORD) src[n+3]) << 24) +\n                   (((QWORD) src[n+4]) << 32) +\n                   (((QWORD) src[n+5]) << 40) +\n                   (((QWORD) src[n+6]) << 48) +\n                   (((QWORD) src[n+7]) << 56) ;\n}\n\nvoid Skein_512_Process_Block(SKEIN512_DATA *ctx,const BYTE *blkPtr,size_t blkCnt,size_t byteCntAdd)\n{ /* do it in C */\n    enum\n        {\n        WCNT = SKEIN_512_STATE_WORDS\n        };\n\n    size_t  i,r;\n    QWORD  ts[3];                            /* key schedule: tweak */\n    QWORD  ks[WCNT+1];                       /* key schedule: chaining vars */\n    QWORD  X [WCNT];                         /* local copy of vars */\n    QWORD  w [WCNT];                         /* local copy of input block */\n\n    do  {\n        /* this implementation only supports 2**64 input bytes (no carry out here) */\n        ctx->h.T[0] += byteCntAdd;            /* update processed length */\n\n        /* precompute the key schedule for this block */\n        ks[WCNT] = SKEIN_KS_PARITY;\n        for (i=0;i < WCNT; i++)\n            {\n            ks[i]     = ctx->X[i];\n            ks[WCNT] ^= ctx->X[i];            /* compute overall parity */\n            }\n        ts[0] = ctx->h.T[0];\n        ts[1] = ctx->h.T[1];\n        ts[2] = ts[0] ^ ts[1];\n\n        Skein_Get64_LSB_First(w,blkPtr,WCNT); /* get input block in little-endian format */\n        Skein_Show_Block(BLK_BITS,&ctx->h,ctx->X,blkPtr,w,ks,ts);\n        for (i=0;i < WCNT; i++)               /* do the first full key injection */\n            {\n            X[i]  = w[i] + ks[i];\n            }\n        X[WCNT-3] += ts[0];\n        X[WCNT-2] += ts[1];\n\n        Skein_Show_Round(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INITIAL,X);\n        for (r=1;r <= SKEIN_512_ROUNDS_TOTAL/8; r++)\n            { /* unroll 8 rounds */\n            X[0] += X[1]; X[1] = RotL_64(X[1],R_512_0_0); X[1] ^= X[0];\n            X[2] += X[3]; X[3] = RotL_64(X[3],R_512_0_1); X[3] ^= X[2];\n            X[4] += X[5]; X[5] = RotL_64(X[5],R_512_0_2); X[5] ^= X[4];\n            X[6] += X[7]; X[7] = RotL_64(X[7],R_512_0_3); X[7] ^= X[6];  Skein_Show_Round(BLK_BITS,&ctx->h,8*r-7,X);\n\n            X[2] += X[1]; X[1] = RotL_64(X[1],R_512_1_0); X[1] ^= X[2];\n            X[4] += X[7]; X[7] = RotL_64(X[7],R_512_1_1); X[7] ^= X[4];\n            X[6] += X[5]; X[5] = RotL_64(X[5],R_512_1_2); X[5] ^= X[6];\n            X[0] += X[3]; X[3] = RotL_64(X[3],R_512_1_3); X[3] ^= X[0];  Skein_Show_Round(BLK_BITS,&ctx->h,8*r-6,X);\n\n            X[4] += X[1]; X[1] = RotL_64(X[1],R_512_2_0); X[1] ^= X[4];\n            X[6] += X[3]; X[3] = RotL_64(X[3],R_512_2_1); X[3] ^= X[6];\n            X[0] += X[5]; X[5] = RotL_64(X[5],R_512_2_2); X[5] ^= X[0];\n            X[2] += X[7]; X[7] = RotL_64(X[7],R_512_2_3); X[7] ^= X[2];  Skein_Show_Round(BLK_BITS,&ctx->h,8*r-5,X);\n\n            X[6] += X[1]; X[1] = RotL_64(X[1],R_512_3_0); X[1] ^= X[6];\n            X[0] += X[7]; X[7] = RotL_64(X[7],R_512_3_1); X[7] ^= X[0];\n            X[2] += X[5]; X[5] = RotL_64(X[5],R_512_3_2); X[5] ^= X[2];\n            X[4] += X[3]; X[3] = RotL_64(X[3],R_512_3_3); X[3] ^= X[4];  Skein_Show_Round(BLK_BITS,&ctx->h,8*r-4,X);\n            InjectKey(2*r-1);\n\n            X[0] += X[1]; X[1] = RotL_64(X[1],R_512_4_0); X[1] ^= X[0];\n            X[2] += X[3]; X[3] = RotL_64(X[3],R_512_4_1); X[3] ^= X[2];\n            X[4] += X[5]; X[5] = RotL_64(X[5],R_512_4_2); X[5] ^= X[4];\n            X[6] += X[7]; X[7] = RotL_64(X[7],R_512_4_3); X[7] ^= X[6];  Skein_Show_Round(BLK_BITS,&ctx->h,8*r-3,X);\n\n            X[2] += X[1]; X[1] = RotL_64(X[1],R_512_5_0); X[1] ^= X[2];\n            X[4] += X[7]; X[7] = RotL_64(X[7],R_512_5_1); X[7] ^= X[4];\n            X[6] += X[5]; X[5] = RotL_64(X[5],R_512_5_2); X[5] ^= X[6];\n            X[0] += X[3]; X[3] = RotL_64(X[3],R_512_5_3); X[3] ^= X[0];  Skein_Show_Round(BLK_BITS,&ctx->h,8*r-2,X);\n\n            X[4] += X[1]; X[1] = RotL_64(X[1],R_512_6_0); X[1] ^= X[4];\n            X[6] += X[3]; X[3] = RotL_64(X[3],R_512_6_1); X[3] ^= X[6];\n            X[0] += X[5]; X[5] = RotL_64(X[5],R_512_6_2); X[5] ^= X[0];\n            X[2] += X[7]; X[7] = RotL_64(X[7],R_512_6_3); X[7] ^= X[2];  Skein_Show_Round(BLK_BITS,&ctx->h,8*r-1,X);\n\n            X[6] += X[1]; X[1] = RotL_64(X[1],R_512_7_0); X[1] ^= X[6];\n            X[0] += X[7]; X[7] = RotL_64(X[7],R_512_7_1); X[7] ^= X[0];\n            X[2] += X[5]; X[5] = RotL_64(X[5],R_512_7_2); X[5] ^= X[2];\n            X[4] += X[3]; X[3] = RotL_64(X[3],R_512_7_3); X[3] ^= X[4];  Skein_Show_Round(BLK_BITS,&ctx->h,8*r  ,X);\n            InjectKey(2*r);\n            }\n        /* do the final \"feedforward\" xor, update context chaining vars */\n        for (i=0;i < WCNT;i++)\n            ctx->X[i] = X[i] ^ w[i];\n        Skein_Show_Round(BLK_BITS,&ctx->h,SKEIN_RND_FEED_FWD,ctx->X);\n\n\t\tSkein_Clear_First_Flag(ctx->h);\t\t/* clear the start bit */\n        blkPtr += SKEIN_512_BLOCK_BYTES;\n        }\n    while (--blkCnt);\n}\n\nvoid Skein512_init(SKEIN512_DATA *skein)\n{\n\tunion {\n\t\tBYTE\tb[SKEIN_512_STATE_BYTES];\n\t\tQWORD\tw[SKEIN_512_STATE_WORDS];\n\t\t} cfg;                                  /* config block */\n\n\t/* build/process config block for hashing */\n\tskein->h.hashBitLen = 512;\t                /* output hash byte count */\n\tSkein_Start_New_Type(skein,CFG_FINAL);        /* set tweaks: T0=0; T1=CFG | FINAL */\n\n\tmemset(&cfg.w,0,sizeof(cfg.w));             /* pre-pad cfg.w[] with zeroes */\n\tcfg.w[0]=Skein_Swap64(SKEIN_SCHEMA_VER);  /* set the schema, version */\n\tcfg.w[1]=Skein_Swap64(512);        /* hash result length in bits */\n\tcfg.w[2]=Skein_Swap64(SKEIN_CFG_TREE_INFO_SEQUENTIAL);\n\n\t/* compute the initial chaining values from config block */\n\tmemset(skein->X,0,sizeof(skein->X));            /* zero the chaining variables */\n\tSkein_512_Process_Block(skein,cfg.b,1,SKEIN_CFG_STR_LEN);\n\n\t/* The chaining vars ctx->X are now initialized for the given hashBitLen. */\n\t/* Set up to process the data message portion of the hash (default) */\n\tSkein_Start_New_Type(skein,MSG);              /* T0=0, T1= MSG type, h.bCnt=0 */\n}\n\nvoid Skein512_data(SKEIN512_DATA *skein,const BYTE *buffer,DWORD len)\n{\n    DWORD n;\n\n    /* process full blocks, if any */\n    if (len + skein->h.bCnt > SKEIN_512_BLOCK_BYTES)\n        {\n        if (skein->h.bCnt)                              /* finish up any buffered message data */\n            {\n            n = SKEIN_512_BLOCK_BYTES - skein->h.bCnt;  /* # bytes free in buffer b[] */\n            if (n)\n                {\n                memcpy(&skein->b[skein->h.bCnt],buffer,n);\n                len -= n;\n                buffer += n;\n                skein->h.bCnt += n;\n                }\n            Skein_512_Process_Block(skein,skein->b,1,SKEIN_512_BLOCK_BYTES);\n            skein->h.bCnt = 0;\n            }\n        /* now process any remaining full blocks, directly from input message data */\n        if (len > SKEIN_512_BLOCK_BYTES)\n            {\n            n = (len-1) / SKEIN_512_BLOCK_BYTES;   /* number of full blocks to process */\n            Skein_512_Process_Block(skein,buffer,n,SKEIN_512_BLOCK_BYTES);\n            len -= n * SKEIN_512_BLOCK_BYTES;\n            buffer += n * SKEIN_512_BLOCK_BYTES;\n            }\n        }\n\n    /* copy any remaining source message data bytes into b[] */\n    if (len)\n        {\n        memcpy(&skein->b[skein->h.bCnt],buffer,len);\n        skein->h.bCnt += len;\n        }\n}\n\nvoid Skein512_finalize(SKEIN512_DATA *skein,BYTE *hash)\n{\n    DWORD i,n,byteCnt;\n    QWORD X[SKEIN_512_STATE_WORDS];\n\n    skein->h.T[1] |= SKEIN_T1_FLAG_FINAL;                 /* tag as the final block */\n    if (skein->h.bCnt < SKEIN_512_BLOCK_BYTES)   /* zero pad b[] if necessary */\n        memset(&skein->b[skein->h.bCnt],0,SKEIN_512_BLOCK_BYTES - skein->h.bCnt);\n\n    Skein_512_Process_Block(skein,skein->b,1,skein->h.bCnt);  /* process the final block */\n    \n    /* now output the result */\n    byteCnt = (skein->h.hashBitLen + 7) >> 3;             /* total number of output bytes */\n\n    /* run Threefish in \"counter mode\" to generate more output */\n    memset(skein->b,0,sizeof(skein->b));  /* zero out b[], so it can hold the counter */\n    memcpy(X,skein->X,sizeof(X));       /* keep a local copy of counter mode \"key\" */\n    for (i=0;i*SKEIN_512_BLOCK_BYTES < byteCnt;i++)\n        {\n        ((QWORD *)skein->b)[0]= Skein_Swap64((QWORD) i); /* build the counter block */\n        Skein_Start_New_Type(skein,OUT_FINAL);\n        Skein_512_Process_Block(skein,skein->b,1,sizeof(QWORD)); /* run \"counter mode\" */\n        n = byteCnt - i*SKEIN_512_BLOCK_BYTES;   /* number of output bytes left to go */\n        if (n >= SKEIN_512_BLOCK_BYTES)\n            n  = SKEIN_512_BLOCK_BYTES;\n        Skein_Put64_LSB_First(hash+i*SKEIN_512_BLOCK_BYTES,skein->X,n);   /* \"output\" the ctr mode bytes */\n        Skein_Show_Final(512,&ctx->h,n,hashVal+i*SKEIN_512_BLOCK_BYTES);\n        memcpy(skein->X,X,sizeof(X));   /* restore the counter mode key for next time */\n        }\n}\n"
        },
        {
            "file_name": "Speed.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"Speed_data.h\"\n\n#define KEY_LEN_DBYTE  (SPEED_KEY_LEN/16) /* length of a key in double bytes */\n#define F_WD_LEN       (SPEED_DATA_LEN/8) /* length of a SPEED word in bits */\n#define H_WD_LEN       (F_WD_LEN/2)       /* length of a half word  in bits */\n\n#if   SPEED_DATA_LEN == 256\n#define F_WD_MASK   0xFFFFFFFFL\n#define H_WD_MASK   0xFFFF\n#define V_SHIFT     11\n#define KB_SIZE     (2*SPEED_NO_OF_RND)   /* size of kb in key shceduling */ \n#elif SPEED_DATA_LEN == 128\n#define F_WD_MASK   0xFFFF\n#define H_WD_MASK   0xFF\n#define V_SHIFT     4\n#define KB_SIZE     SPEED_NO_OF_RND\n#else /* SPEED_DATA_LEN == 64 */\n#define F_WD_MASK   0xFF\n#define H_WD_MASK   0xF\n#define V_SHIFT     1\n#define KB_SIZE     (SPEED_NO_OF_RND/2) \n#endif\n\n/* cyclically shift a SPEED internal data to the right by n bits */\n#define rotate_data_right(x, n)                         \\\n        ((((x) & F_WD_MASK) >> (n)) |                   \\\n         (((x) & F_WD_MASK) << (F_WD_LEN-(n))))\n\n/* cyclically shift a SPEED internal data to the left by n bits */\n#define rotate_data_left(x, n)                          \\\n        ((((x) & F_WD_MASK) << (n)) |                   \\\n         (((x) & F_WD_MASK) >> (F_WD_LEN-(n))))\n\n/* GG is the non-linear function used in key scheduling */\n#define GG(x2, x1, x0)                                  \\\n        ((x2) & (x1)) ^ ((x1) & (x0)) ^ ((x0) & (x2))\n\n/* FF1 is a non-linear function used in Pass 1 */\n#define FF1(x6, x5, x4, x3, x2, x1, x0)                 \\\n        ((x6) & (x3)) ^ ((x5) & (x1)) ^                 \\\n        ((x4) & (x2)) ^ ((x1) & (x0)) ^ (x0) \n\n/* FF2 is a non-linear function used in Pass 2 */\n#define FF2(x6, x5, x4, x3, x2, x1, x0)                 \\\n        ((x6) & (x4) & (x0)) ^ ((x4) & (x3) & (x0)) ^   \\\n        ((x5) & (x2)) ^ ((x4) & (x3)) ^ ((x4) & (x1)) ^ \\\n        ((x3) & (x0)) ^ (x1)\n\n/* FF3 is a non-linear function used in Pass 3 */\n#define FF3(x6, x5, x4, x3, x2, x1, x0)                 \\\n        ((x5) & (x4) & (x0)) ^ ((x6) & (x4)) ^          \\\n        ((x5) & (x2)) ^ ((x3) & (x0)) ^                 \\\n        ((x1) & (x0)) ^ (x3) \n\n/* FF4 is a non-linear function used in Pass 4 */\n#define FF4(x6, x5, x4, x3, x2, x1, x0)                 \\\n        ((x6) & (x4) & (x2) & (x0)) ^                   \\\n        ((x6) & (x5)) ^ ((x4) & (x3)) ^                 \\\n        ((x3) & (x2)) ^ ((x1) & (x0)) ^ (x2)\n\n/* translates chars into SPEED internal words */\n#if   SPEED_DATA_LEN == 256\n#define txt2itxt(txt, itxt) {                 \\\nint i;                                        \\\nfor (i = 0; i < 8; i++){                      \\\n  itxt[i] =  (DWORD)txt[4*i]          |  \\\n            ((DWORD)txt[4*i+1] <<  8) |  \\\n            ((DWORD)txt[4*i+2] << 16) |  \\\n            ((DWORD)txt[4*i+3] << 24);   \\\n}                                             \\\n}\n#elif SPEED_DATA_LEN == 128\n#define txt2itxt(txt, itxt) {                 \\\nint i;                                        \\\nfor (i = 0; i < 8; i++){                      \\\n  itxt[i] =  (DWORD)txt[2*i]          |  \\\n            ((DWORD)txt[2*i+1] <<  8);   \\\n}                                             \\\n}\n#else\n#define txt2itxt(txt, itxt) {                 \\\nint i;                                        \\\nfor (i = 0; i < 8; i++){                      \\\n  itxt[i] =  (DWORD)txt[i];              \\\n}                                             \\\n}\n#endif\n\n/* translates SPEED internal words into chars */\n#if SPEED_DATA_LEN == 256\n#define itxt2txt(itxt, txt) {                            \\\nint i;                                                   \\\nfor (i = 0; i < 8; i++){                                 \\\n  txt[4*i  ] = (BYTE) ( itxt[i]        & 0xFF); \\\n  txt[4*i+1] = (BYTE) ((itxt[i] >>  8) & 0xFF); \\\n  txt[4*i+2] = (BYTE) ((itxt[i] >> 16) & 0xFF); \\\n  txt[4*i+3] = (BYTE) ((itxt[i] >> 24) & 0xFF); \\\n}                                                        \\\n}\n#elif SPEED_DATA_LEN == 128\n#define itxt2txt(itxt, txt) {                            \\\nint i;                                                   \\\nfor (i = 0; i < 8; i++){                                 \\\n  txt[2*i  ] = (BYTE) ( itxt[i]        & 0xFF); \\\n  txt[2*i+1] = (BYTE) ((itxt[i] >>  8) & 0xFF); \\\n}                                                        \\\n}\n#else \n#define itxt2txt(itxt, txt) {                            \\\nint i;                                                   \\\nfor (i = 0; i < 8; i++){                                 \\\n  txt[i] = (BYTE) (itxt[i] & 0xFF);             \\\n}                                                        \\\n}\n#endif\n\n/* fractional part of sqrt(15), used in key scheduling */\n#if   SPEED_KEY_LEN == 48\n  static unsigned short sqrt15[3] = {0xDF7B, 0xD629, 0xE9DB};\n#elif SPEED_KEY_LEN == 64\n  static unsigned short sqrt15[3] = {0x362F, 0x5D00, 0xF20F};\n#elif SPEED_KEY_LEN == 80\n  static unsigned short sqrt15[3] = {0xC3D1, 0x1FD2, 0x589B};\n#elif SPEED_KEY_LEN == 96\n  static unsigned short sqrt15[3] = {0x4312, 0x91EB, 0x718E};\n#elif SPEED_KEY_LEN == 112\n  static unsigned short sqrt15[3] = {0xBF2A, 0x1E7D, 0xB257};\n#elif SPEED_KEY_LEN == 128\n  static unsigned short sqrt15[3] = {0x77A6, 0x1654, 0x6B2A};\n#elif SPEED_KEY_LEN == 144\n  static unsigned short sqrt15[3] = {0x0D9B, 0xA9D3, 0x668F};\n#elif SPEED_KEY_LEN == 160\n  static unsigned short sqrt15[3] = {0x19BE, 0xF855, 0x6D98};\n#elif SPEED_KEY_LEN == 176\n  static unsigned short sqrt15[3] = {0x022D, 0xE4E2, 0xD017};\n#elif SPEED_KEY_LEN == 192\n  static unsigned short sqrt15[3] = {0xEA2F, 0x7572, 0xC3B5};\n#elif SPEED_KEY_LEN == 208\n  static unsigned short sqrt15[3] = {0x1086, 0x480C, 0x3AA6};\n#elif SPEED_KEY_LEN == 224\n  static unsigned short sqrt15[3] = {0x9CA0, 0x98F7, 0xD0E4};\n#elif SPEED_KEY_LEN == 240\n  static unsigned short sqrt15[3] = {0x253C, 0xC901, 0x55F3};\n#else /* SPEED_KEY_LEN == 256 */\n  static unsigned short sqrt15[3] = {0x9BF4, 0xF659, 0xD76C};\n#endif\n\n/* key scheduling */\nvoid Speed_set_key(speed_ikey rndkey,const speed_key key)\n{\nDWORD i;\nDWORD kb[KB_SIZE];\nDWORD temp,\n      s0 = (DWORD)sqrt15[0],\n      s1 = (DWORD)sqrt15[1],\n      s2 = (DWORD)sqrt15[2];\n\n/* Step 1: translates a user key into 2-byte data units */\nfor (i = 0; i < KEY_LEN_DBYTE; i++){\n  kb[i] =  (DWORD)key[2*i] |\n          ((DWORD)key[2*i+1] << 8);\n}\n\n/* Step 2: extends the key */\nfor (i = KEY_LEN_DBYTE; i < KB_SIZE; i++){\n  temp  = GG(s2, s1, s0); \n  temp  = (temp << 5) | (temp >> 11);\n  temp += s2 + kb[i % KEY_LEN_DBYTE];\n  temp  = temp & 0xFFFF;\n  s2 = s1;\n  s1 = s0;\n  s0 = temp;\n  kb[i] = temp;\n}\n\n/* Step 3: translates 2-byte data into round keys (SPEED words) */\n#if   SPEED_DATA_LEN == 256   /* speed word length = 32 bits */\n  for (i = 0; i < KB_SIZE/2; i++){\n    rndkey[i] =  kb[2*i]           |\n                (kb[2*i+1] << 16);\n  }\n#elif SPEED_DATA_LEN == 128   /* speed word length = 16 bits */\n  memcpy (rndkey, kb, KB_SIZE * sizeof(DWORD));\n#else                         /* speed word length = 8 bits */\n  for (i = 0; i < KB_SIZE; i++){\n    rndkey[2*i]   =  kb[i]       & 0xFF;\n    rndkey[2*i+1] = (kb[i] >> 8) & 0xFF;\n  }\n#endif\n}\n\n/* encryption --- SPEED internal word oriented interface */\nvoid encrypt_rk(const speed_ikey rndkey,const speed_idata ipt,speed_idata ict)\n{\nDWORD i, k;\nDWORD temp, vv;\nDWORD t0 = ipt[0],\n      t1 = ipt[1],\n      t2 = ipt[2],\n      t3 = ipt[3],\n      t4 = ipt[4],\n      t5 = ipt[5],\n      t6 = ipt[6],\n      t7 = ipt[7];\n\nk = 0;   /* points to the first round key */\n\n/* Pass 1 */\nfor (i = 0; i < (SPEED_NO_OF_RND >> 2); i++) {\n  temp = FF1(t6, t5, t4, t3, t2, t1, t0);\n  vv   = (((temp >> H_WD_LEN) + temp) & H_WD_MASK) >> V_SHIFT;\n  temp = rotate_data_right(t7, H_WD_LEN - 1) +\n         rotate_data_right(temp, vv) +\n         rndkey[k++];\n\n  t7 = t6; t6 = t5; t5 = t4; t4 = t3;\n  t3 = t2; t2 = t1; t1 = t0; t0 = temp & F_WD_MASK;\n}\n\n/* Pass 2 */\nfor (i = 0; i < (SPEED_NO_OF_RND >> 2); i++) {\n  temp = FF2(t6, t5, t4, t3, t2, t1, t0);\n  vv   = (((temp >> H_WD_LEN) + temp) & H_WD_MASK) >> V_SHIFT;\n  temp = rotate_data_right(t7, H_WD_LEN - 1) +\n         rotate_data_right(temp, vv) +\n         rndkey[k++];\n\n  t7 = t6; t6 = t5; t5 = t4; t4 = t3;\n  t3 = t2; t2 = t1; t1 = t0; t0 = temp & F_WD_MASK;\n}\n\n/* Pass 3 */\nfor (i = 0; i < (SPEED_NO_OF_RND >> 2); i++) {\n  temp = FF3(t6, t5, t4, t3, t2, t1, t0);\n  vv   = (((temp >> H_WD_LEN) + temp) & H_WD_MASK) >> V_SHIFT;\n  temp = rotate_data_right(t7, H_WD_LEN - 1) +\n         rotate_data_right(temp, vv) +\n         rndkey[k++];\n\n  t7 = t6; t6 = t5; t5 = t4; t4 = t3;\n  t3 = t2; t2 = t1; t1 = t0; t0 = temp & F_WD_MASK;\n}\n\n/* Pass 4 */\nfor (i = 0; i < (SPEED_NO_OF_RND >> 2); i++) {\n  temp = FF4(t6, t5, t4, t3, t2, t1, t0);\n  vv   = (((temp >> H_WD_LEN) + temp) & H_WD_MASK) >> V_SHIFT;\n  temp = rotate_data_right(t7, H_WD_LEN - 1) +\n         rotate_data_right(temp, vv) +\n         rndkey[k++];\n\n  t7 = t6; t6 = t5; t5 = t4; t4 = t3;\n  t3 = t2; t2 = t1; t1 = t0; t0 = temp & F_WD_MASK;\n}\n\nict[0] = t0; ict[1] = t1; ict[2] = t2; ict[3] = t3;\nict[4] = t4; ict[5] = t5; ict[6] = t6; ict[7] = t7;\n\n}\n\n/* decryption --- SPEED internal word oriented interface */\nvoid decrypt_rk(const speed_ikey rndkey,const speed_idata ict,speed_idata ipt)\n{\nDWORD i, k;\nDWORD new_ipt7, temp, vv;\nDWORD t0 = ict[0], \n      t1 = ict[1],\n      t2 = ict[2],\n      t3 = ict[3],\n      t4 = ict[4],\n      t5 = ict[5],\n      t6 = ict[6],\n      t7 = ict[7];\n\nk = SPEED_NO_OF_RND - 1;  /* points to the last round key */\n\n/* Inverse of Pass 4 */\nfor (i = 0; i < (SPEED_NO_OF_RND >> 2); i++) {\n  new_ipt7 = t0; t0 = t1; t1 = t2; t2 = t3;\n  t3       = t4; t4 = t5; t5 = t6; t6 = t7;\n\n  temp = FF4(t6, t5, t4, t3, t2, t1, t0);\n  vv   = (((temp >> H_WD_LEN) + temp) & H_WD_MASK) >> V_SHIFT;\n\n  new_ipt7 = new_ipt7 -\n             rotate_data_right(temp, vv) -\n             rndkey[k--];\n\n  t7 = rotate_data_left(new_ipt7, H_WD_LEN - 1);\n}\n\n/* Inverse of Pass 3 */\nfor (i = 0; i < (SPEED_NO_OF_RND >> 2); i++) {\n  new_ipt7 = t0; t0 = t1; t1 = t2; t2 = t3;\n  t3       = t4; t4 = t5; t5 = t6; t6 = t7;\n\n  temp = FF3(t6, t5, t4, t3, t2, t1, t0);\n  vv   = (((temp >> H_WD_LEN) + temp) & H_WD_MASK) >> V_SHIFT;\n\n  new_ipt7 = new_ipt7 -\n             rotate_data_right(temp, vv) -\n             rndkey[k--];\n\n  t7 = rotate_data_left(new_ipt7, H_WD_LEN - 1);\n}\n\n/* Inverse of Pass 2 */\nfor (i = 0; i < (SPEED_NO_OF_RND >> 2); i++) {\n  new_ipt7 = t0; t0 = t1; t1 = t2; t2 = t3;\n  t3       = t4; t4 = t5; t5 = t6; t6 = t7;\n\n  temp = FF2(t6, t5, t4, t3, t2, t1, t0);\n  vv   = (((temp >> H_WD_LEN) + temp) & H_WD_MASK) >> V_SHIFT;\n\n  new_ipt7 = new_ipt7 -\n             rotate_data_right(temp, vv) -\n             rndkey[k--];\n\n  t7 = rotate_data_left(new_ipt7, H_WD_LEN - 1);\n}\n\n/* Inverse of Pass 1 */\nfor (i = 0; i < (SPEED_NO_OF_RND >> 2); i++) {\n  new_ipt7 = t0; t0 = t1; t1 = t2; t2 = t3;\n  t3       = t4; t4 = t5; t5 = t6; t6 = t7;\n\n  temp = FF1(t6, t5, t4, t3, t2, t1, t0);\n  vv   = (((temp >> H_WD_LEN) + temp) & H_WD_MASK) >> V_SHIFT;\n\n  new_ipt7 = new_ipt7 -\n             rotate_data_right(temp, vv) -\n             rndkey[k--];\n\n  t7 = rotate_data_left(new_ipt7, H_WD_LEN - 1);\n}\n\nipt[0] = t0; ipt[1] = t1; ipt[2] = t2; ipt[3] = t3;\nipt[4] = t4; ipt[5] = t5; ipt[6] = t6; ipt[7] = t7;\n\n}\n\n/* encryption --- char oriented interface */\nvoid Speed_encrypt(const speed_ikey rndkey,const speed_data pt,speed_data ct)\n{\nspeed_idata ipt;\nspeed_idata ict;\n\ntxt2itxt (pt, ipt);\nencrypt_rk(rndkey, ipt, ict);\nitxt2txt (ict, ct);\n}\n\n/* decryption --- char oriented interface */\nvoid Speed_decrypt(const speed_ikey rndkey,const speed_data ct,speed_data pt)\n{\nspeed_idata ipt;\nspeed_idata ict;\n\ntxt2itxt (ct, ict);\ndecrypt_rk(rndkey, ict, ipt);\nitxt2txt (ipt, pt);\n}\n"
        },
        {
            "file_name": "Sponge.c",
            "content": "/**\n * A simple implementation of Blake2b's internal permutation \n * in the form of a sponge.\n * \n * Author: The Lyra PHC team (http://www.lyra-kdf.net/) -- 2014.\n * \n * This software is hereby placed in the public domain.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n#include <string.h>\n#include <stdio.h>\n#include <time.h>\n#include \"Sponge.h\"\n#include \"Lyra2.h\"\n\n\n/**\n * Initializes the Sponge State. The first 512 bits are set to zeros and the remainder \n * receive Blake2b's IV as per Blake2b's specification. <b>Note:</b> Even though sponges\n * typically have their internal state initialized with zeros, Blake2b's G function\n * has a fixed point: if the internal state and message are both filled with zeros. the \n * resulting permutation will always be a block filled with zeros; this happens because \n * Blake2b does not use the constants originally employed in Blake2 inside its G function, \n * relying on the IV for avoiding possible fixed points.\n * \n * @param state         The 1024-bit array to be initialized\n */\ninline void initState(uint64_t state[/*16*/]) {\n    memset(state, 0, 64); //first 512 bis are zeros\n    state[8] = blake2b_IV[0];\n    state[9] = blake2b_IV[1];\n    state[10] = blake2b_IV[2];\n    state[11] = blake2b_IV[3];\n    state[12] = blake2b_IV[4];\n    state[13] = blake2b_IV[5];\n    state[14] = blake2b_IV[6];\n    state[15] = blake2b_IV[7];\n}\n\n/**\n * Execute Blake2b's G function, with all 12 rounds.\n * \n * @param v     A 1024-bit (16 uint64_t) array to be processed by Blake2b's G function\n */\ninline static void blake2bLyra(uint64_t *v) {\n    ROUND_LYRA(0);\n    ROUND_LYRA(1);\n    ROUND_LYRA(2);\n    ROUND_LYRA(3);\n    ROUND_LYRA(4);\n    ROUND_LYRA(5);\n    ROUND_LYRA(6);\n    ROUND_LYRA(7);\n    ROUND_LYRA(8);\n    ROUND_LYRA(9);\n    ROUND_LYRA(10);\n    ROUND_LYRA(11);\n}\n\n/**\n * Executes a reduced version of Blake2b's G function with only one round\n * @param v     A 1024-bit (16 uint64_t) array to be processed by Blake2b's G function\n */\ninline static void reducedBlake2bLyra(uint64_t *v) {\n    ROUND_LYRA(0);\n}\n\n/**\n * Performs a squeeze operation, using Blake2b's G function as the \n * internal permutation\n * \n * @param state      The current state of the sponge \n * @param out        Array that will receive the data squeezed\n * @param len        The number of bytes to be squeezed into the \"out\" array\n */\ninline void squeeze(uint64_t *state, byte *out, unsigned int len) {\n    int fullBlocks = len / BLOCK_LEN_BYTES;\n    byte *ptr = out;\n    int i;\n    //Squeezes full blocks\n    for (i = 0; i < fullBlocks; i++) {\n        memcpy(ptr, state, BLOCK_LEN_BYTES);\n        blake2bLyra(state);\n        ptr += BLOCK_LEN_BYTES;\n    }\n\n    //Squeezes remaining bytes\n    memcpy(ptr, state, (len % BLOCK_LEN_BYTES));\n}\n\n/**\n * Performs an absorb operation for a single block (BLOCK_LEN_INT64 words\n * of type uint64_t), using Blake2b's G function as the internal permutation\n * \n * @param state The current state of the sponge \n * @param in    The block to be absorbed (BLOCK_LEN_INT64 words)\n */\ninline void absorbBlock(uint64_t *state, const uint64_t *in) {\n    //XORs the first BLOCK_LEN_INT64 words of \"in\" with the current state\n    state[0] ^= in[0];\n    state[1] ^= in[1];\n    state[2] ^= in[2];\n    state[3] ^= in[3];\n    state[4] ^= in[4];\n    state[5] ^= in[5];\n    state[6] ^= in[6];\n    state[7] ^= in[7];\n    state[8] ^= in[8];\n    state[9] ^= in[9];\n    state[10] ^= in[10];\n    state[11] ^= in[11];\n    //printArray(state, 128, \"state\");\n\n    //Applies the transformation f to the sponge's state\n    blake2bLyra(state);\n}\n\n/** \n * Performs a squeeze operation for two rows in sequence, using \n * reduced Blake2b's G function as the internal permutation\n * \n * @param state     The current state of the sponge \n * @param row       Row to receive the data squeezed\n */\ninline void reducedSqueezeRow(uint64_t* state, uint64_t* row) {\n    int i;\n    //M[row][col] = H.reduced_squeeze()\n    for (i = 0; i < N_COLS; i++) {\n        row[0] = state[0];\n        row[1] = state[1];\n        row[2] = state[2];\n        row[3] = state[3];\n        row[4] = state[4];\n        row[5] = state[5];\n        row[6] = state[6];\n        row[7] = state[7];\n        row[8] = state[8];\n        row[9] = state[9];\n        row[10] = state[10];\n        row[11] = state[11];\n         \n        //Goes to next block (column) that will receive the squeezed data\n        row += BLOCK_LEN_INT64;\n        \n        //Applies the reduced-round transformation f to the sponge's state\n        reducedBlake2bLyra(state);\n    }\n}\n\n/**\n * Performs a duplex operation over \"M[rowInOut] XOR M[rowIn]\", writing the output \"rand\"\n * on M[rowOut] and making \"M[rowInOut] =  M[rowInOut] XOR rotW(rand)\", where rotW is a 64-bit \n * rotation to the left.\n *\n * @param state          The current state of the sponge \n * @param rowIn          Row used only as input\n * @param rowInOut       Row used as input and to receive output after rotation\n * @param rowOut         Row receiving the output\n *\n */\ninline void reducedDuplexRowSetup(uint64_t *state, uint64_t *rowIn, uint64_t *rowInOut, uint64_t *rowOut) {\n    uint64_t* ptr64In = rowIn; \t\t//In Lyra2: pointer to prev\n    uint64_t* ptr64InOut = rowInOut; \t//In Lyra2: pointer to row*\n    uint64_t* ptr64Out = rowOut; \t//In Lyra2: pointer to row\n    int i; \n    for (i = 0; i < N_COLS; i++) {\n        //Absorbing \"M[rowInOut] XOR M[rowIn]\"\n        state[0] ^= ptr64InOut[0] ^ ptr64In[0];\n        state[1] ^= ptr64InOut[1] ^ ptr64In[1];\n        state[2] ^= ptr64InOut[2] ^ ptr64In[2];\n        state[3] ^= ptr64InOut[3] ^ ptr64In[3];\n        state[4] ^= ptr64InOut[4] ^ ptr64In[4];\n        state[5] ^= ptr64InOut[5] ^ ptr64In[5];\n        state[6] ^= ptr64InOut[6] ^ ptr64In[6];\n        state[7] ^= ptr64InOut[7] ^ ptr64In[7];\n        state[8] ^= ptr64InOut[8] ^ ptr64In[8];\n        state[9] ^= ptr64InOut[9] ^ ptr64In[9];\n        state[10] ^= ptr64InOut[10] ^ ptr64In[10];\n        state[11] ^= ptr64InOut[11] ^ ptr64In[11];\n        \n        //Applies the reduced-round transformation f to the sponge's state\n        reducedBlake2bLyra(state);\n\n        //M[rowOut][col] = rand\n        ptr64Out[0] = state[0];\n        ptr64Out[1] = state[1];\n        ptr64Out[2] = state[2];\n        ptr64Out[3] = state[3];\n        ptr64Out[4] = state[4];\n        ptr64Out[5] = state[5];\n        ptr64Out[6] = state[6];\n        ptr64Out[7] = state[7];\n        ptr64Out[8] = state[8];\n        ptr64Out[9] = state[9];\n        ptr64Out[10] = state[10];\n        ptr64Out[11] = state[11];\n\n\n        //M[rowInOut][col] = M[rowInOut][col] XOR rotW(rand)\n        ptr64InOut[0] ^= state[11];\n        ptr64InOut[1] ^= state[0];\n        ptr64InOut[2] ^= state[1];\n        ptr64InOut[3] ^= state[2];\n        ptr64InOut[4] ^= state[3];\n        ptr64InOut[5] ^= state[4];\n        ptr64InOut[6] ^= state[5];\n        ptr64InOut[7] ^= state[6];\n        ptr64InOut[8] ^= state[7];\n        ptr64InOut[9] ^= state[8];\n        ptr64InOut[10] ^= state[9];\n        ptr64InOut[11] ^= state[10];\n\n        //Goes to next column (i.e., next block in sequence)\n        ptr64InOut += BLOCK_LEN_INT64;\n        ptr64In += BLOCK_LEN_INT64;\n        ptr64Out += BLOCK_LEN_INT64;\n    }\n}\n\n/**\n * Performs a duplex operation over \"M[rowInOut] XOR M[rowIn]\", using the output \"rand\"\n * to make \"M[rowOut][col] = M[rowOut][col] XOR rand\" and \"M[rowInOut] = M[rowInOut] XOR rotW(rand)\", \n * where rotW is a 64-bit rotation to the left.\n *\n * @param state          The current state of the sponge \n * @param rowIn          Row used only as input\n * @param rowInOut       Row used as input and to receive output after rotation\n * @param rowOut         Row receiving the output\n *\n */\ninline void reducedDuplexRow(uint64_t *state, uint64_t *rowIn, uint64_t *rowInOut, uint64_t *rowOut) {\n    uint64_t* ptr64InOut = rowInOut; \t//In Lyra2: pointer to row*\n    uint64_t* ptr64In = rowIn;          //In Lyra2: pointer to prev\n    uint64_t* ptr64Out = rowOut; \t//In Lyra2: pointer to row\n    int i;\n    for (i = 0; i < N_COLS; i++) {\n\t\n\t//Absorbing \"M[rowInOut] XOR M[rowIn]\"\n        state[0] ^= ptr64InOut[0] ^ ptr64In[0];\n        state[1] ^= ptr64InOut[1] ^ ptr64In[1];\n        state[2] ^= ptr64InOut[2] ^ ptr64In[2];\n        state[3] ^= ptr64InOut[3] ^ ptr64In[3];\n        state[4] ^= ptr64InOut[4] ^ ptr64In[4];\n        state[5] ^= ptr64InOut[5] ^ ptr64In[5];\n        state[6] ^= ptr64InOut[6] ^ ptr64In[6];\n        state[7] ^= ptr64InOut[7] ^ ptr64In[7];\n        state[8] ^= ptr64InOut[8] ^ ptr64In[8];\n        state[9] ^= ptr64InOut[9] ^ ptr64In[9];\n        state[10] ^= ptr64InOut[10] ^ ptr64In[10];\n        state[11] ^= ptr64InOut[11] ^ ptr64In[11];\n        \n        //Applies the reduced-round transformation f to the sponge's state\n        reducedBlake2bLyra(state);\n\n\t//M[rowOut][col] = M[rowOut][col] XOR rand\n        ptr64Out[0] ^= state[0];\n        ptr64Out[1] ^= state[1];\n        ptr64Out[2] ^= state[2];\n        ptr64Out[3] ^= state[3];\n        ptr64Out[4] ^= state[4];\n        ptr64Out[5] ^= state[5];\n        ptr64Out[6] ^= state[6];\n        ptr64Out[7] ^= state[7];\n        ptr64Out[8] ^= state[8];\n        ptr64Out[9] ^= state[9];\n        ptr64Out[10] ^= state[10];\n        ptr64Out[11] ^= state[11];\n\n\t//M[rowInOut][col] = M[rowInOut][col] XOR rotW(rand)\n        ptr64InOut[0] ^= state[11];\n        ptr64InOut[1] ^= state[0];\n        ptr64InOut[2] ^= state[1];\n        ptr64InOut[3] ^= state[2];\n        ptr64InOut[4] ^= state[3];\n        ptr64InOut[5] ^= state[4];\n        ptr64InOut[6] ^= state[5];\n        ptr64InOut[7] ^= state[6];\n        ptr64InOut[8] ^= state[7];\n        ptr64InOut[9] ^= state[8];\n        ptr64InOut[10] ^= state[9];\n        ptr64InOut[11] ^= state[10];\n\n        //Goes to next block\n        ptr64Out += BLOCK_LEN_INT64;\n        ptr64InOut += BLOCK_LEN_INT64;\n        ptr64In += BLOCK_LEN_INT64;\n    }\n}\n\n/**\n Prints an array of unsigned chars\n */\nvoid printArray(unsigned char *array, unsigned int size, char *name) {\n    int i;\n    printf(\"%s: \", name);\n    for (i = 0; i < size; i++) {\n        printf(\"%2x|\", array[i]);\n    }\n    printf(\"\\n\");\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n"
        },
        {
            "file_name": "stribob192r1_sbob_pi64.cpp",
            "content": "// sbob_pi64.c\n// 28-Apr-14  Markku-Juhani O. Saarinen <mjos@iki.fi>\n\n// Reference 64-bit GCC version\n\n#include \"stribob192r1_stribob.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Stribob192r1_raw {\n\n// sbob_tab64.c\nextern const uint64_t sbob_sl64[8][256];\nextern const uint64_t sbob_rc64[12][8];\n\n// 64-bit ANSI C version\n\nvoid sbob_pi(w512_t *s512)\n{\n    int i, r;\n    w512_t t;                           // temporary\n\n    for (r = 0; r < 12; r++) {          // 12 rounds\n\n        for (i = 0; i < 8; i++)         // t = x ^ rc\n            t.q[i] = s512->q[i] ^ sbob_rc64[r][i];\n\n        for (i = 0; i < 8; i++) {       // s-box and linear op\n            s512->q[i] = sbob_sl64[0][t.b[i]] ^\n                        sbob_sl64[1][t.b[i + 8]] ^\n                        sbob_sl64[2][t.b[i + 16]] ^\n                        sbob_sl64[3][t.b[i + 24]] ^\n                        sbob_sl64[4][t.b[i + 32]] ^\n                        sbob_sl64[5][t.b[i + 40]] ^\n                        sbob_sl64[6][t.b[i + 48]] ^\n                        sbob_sl64[7][t.b[i + 56]];\n        }\n    }\n\n    // clearing t deemed unnecessary\n}\n\n\n\n} // namespace Stribob192r1_raw\n"
        },
        {
            "file_name": "stribob192r1_stribob.cpp",
            "content": "// stribob.c\n// 06-Feb-14    Markku-Juhani O. Saarinen <mjos@iki.fi>\n//              See LICENSE for Licensing and Warranty information.\n\n#include \"stribob192r1_stribob.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Stribob192r1_raw {\n\n// initialization\n\nvoid sbob_clr(sbob_t *sb)\n{\n    int i;\n\n    for (i = 0; i < 8; i++)\n        sb->s.q[i] = 0;\n    sb->l = 0;\n}\n\n// end a data element (compulsory between different types)\n\nvoid sbob_fin(sbob_t *sb, sbob_pad_t pad)\n{\n    // pad\n    sb->s.b[sb->l] ^= BLNK_END;\n    sb->s.b[SBOB_RATE] ^= pad | BLNK_FIN;\n\n    // compress and zero the buffer\n    sbob_pi(&sb->s);\n    sb->l = 0;\n}\n\n// put data in\n\nvoid sbob_put(sbob_t *sb, sbob_pad_t pad, const void *in, size_t len)\n{\n    int j;\n    size_t i;\n\n    j = sb->l;\n    for (i = 0; i < len; i++) {\n        if (j == SBOB_RATE) {\n            sb->s.b[SBOB_RATE] ^= pad;\n            sbob_pi(&sb->s);\n            j = 0;\n        }\n        sb->s.b[j++] ^= ((const uint8_t *) in)[i];\n    }\n    sb->l = j;\n}\n\n// get data out\n\nvoid sbob_get(sbob_t *sb, sbob_pad_t pad, void *out, size_t len)\n{\n    int j;\n    size_t i;\n\n    j = sb->l;\n    for (i = 0; i < len; i++) {\n        if (j == SBOB_RATE) {\n            sb->s.b[SBOB_RATE] ^= pad;\n            sbob_pi(&sb->s);\n            j = 0;\n        }\n        ((uint8_t *) out)[i] = sb->s.b[j++];\n    }\n    sb->l = j;\n}\n\n// compare (0 == equal)\n\nint sbob_cmp(sbob_t *sb, sbob_pad_t pad, const void *in, size_t len)\n{\n    int j, d;\n    size_t i;\n\n    j = sb->l;\n    d = 0;\n    for (i = 0; i < len; i++) {\n        if (j == SBOB_RATE) {\n            sb->s.b[SBOB_RATE] ^= pad;\n            sbob_pi(&sb->s);\n            j = 0;\n        }\n        if (d == 0)\n            d = ((int) ((const uint8_t *) in)[i]) - ((int) sb->s.b[j]);\n        j++;\n    }\n    sb->l = j;\n\n    return d;\n}\n\n// encrypt data\n\nvoid sbob_enc(sbob_t *sb, sbob_pad_t pad,\n    void *out, const void *in, size_t len)\n{\n    int j;\n    size_t i;\n\n    j = sb->l;\n    for (i = 0; i < len; i++) {\n        if (j == SBOB_RATE) {\n            sb->s.b[SBOB_RATE] ^= pad;\n            sbob_pi(&sb->s);\n            j = 0;\n        }\n        sb->s.b[j] ^= ((const uint8_t *) in)[i];\n        ((uint8_t *) out)[i] = sb->s.b[j++];\n    }\n    sb->l = j;\n}\n\n// decrypt data\n\nvoid sbob_dec(sbob_t *sb, sbob_pad_t pad,\n    void *out, const void *in, size_t len)\n{\n    int j;\n    size_t i;\n    uint8_t t;\n\n    j = sb->l;\n    for (i = 0; i < len; i++) {\n        if (j == SBOB_RATE) {\n            sb->s.b[SBOB_RATE] ^= pad;\n            sbob_pi(&sb->s);\n            j = 0;\n        }\n        t = ((const uint8_t *) in)[i];\n        ((uint8_t *) out)[i] = sb->s.b[j] ^ t;\n        sb->s.b[j++] = t;\n    }\n    sb->l = j;\n}\n\n\n} // namespace Stribob192r1_raw\n"
        },
        {
            "file_name": "tiaoxin-optimized.c",
            "content": "/*\n * Tiaoxin-346 Optimized C Implementation for AES-NI (additional optimizations included)\n *\n * Copyright 2014:\n *     Ivica Nikolic <cube444@gmail.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n */\n\n#include <string.h>\n#include <stdlib.h>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <wmmintrin.h>\n#include <tmmintrin.h>\n\n\n/*\n * Macros for SSE instructions\n */\n#define xor(a,b) \t_mm_xor_si128(a,b)\n#define and(a,b) \t_mm_and_si128(a,b)\n#define enc(a,b) \t_mm_aesenc_si128(a,b)\n#define load(p)       \t_mm_load_si128((__m128i *)(p))\n#define store(p,x)    \t_mm_storeu_si128((__m128i *)(p), (x))\n#define constant8(b15,b14,b13,b12,b11,b10,b9,b8,b7,b6,b5,b4,b3,b2,b1,b0)   _mm_set_epi8 ((b0),(b1),(b2),(b3),(b4),(b5),(b6),(b7),(b8),(b9),(b10),(b11),(b12),(b13),(b14),(b15))\n\n\n\n/*\n * The transformations R(T_s,M)\n */\n#define RT3( T , M ) tmp  = T[0];T[0] = enc(T[2],M);T[2] = T[1];T[1] = enc(tmp,Z0);T[0] = xor(T[0], tmp);\n#define RT4( T , M ) tmp  = T[0];T[0] = enc(T[3],M);T[3] = T[2];T[2] = T[1];T[1] = enc(tmp,Z0);T[0] = xor(T[0], tmp);\n#define RT6( T , M ) tmp  = T[0];T[0] = enc(T[5],M);T[5] = T[4];T[4] = T[3];T[3] = T[2];T[2] = T[1];T[1] = enc(tmp,Z0);T[0] = xor(T[0], tmp);\n\n/*\n * The transformation Update\n */\n#define UPDATE( T3 , T4 , T6 , M0 , M1 , M2 )\\\nRT3( T3, M0 );\\\nRT4( T4, M1 );\\\nRT6( T6, M2 );\n\n/*\n * The output functions for the ciphertext\n */\n#define OUTPUT1( T3 , T4 , T6 , cipher, offset )\\\n\tstore( (__m128 *)(cipher+offset), xor( T4[1] , xor( T3[0] , xor( T3[2] , and( T6[3] , T4[3] ) ) ) ) );\n#define OUTPUT2( T3 , T4 , T6 , cipher, offset )\\\n\tstore( (__m128 *)(cipher+offset), xor( T3[1] , xor( T6[0] , xor( T4[2] , and( T6[5] , T3[2] ) ) ) ) );\n\n/*\n * Fast round of decryption of ciphertext block\n */\n\n#define DECRYPTION_ROUND( T3 , T4 , T6 , C0 , C1 , storeM0, storeM1)\\\n\t\\\n\tC0 = xor( T3[1] , xor ( and(T6[2],T4[2]) , C0 ) );\\\n        C1 = xor( T4[1] , xor ( and(T6[4],T3[1]) , C1 ) );\\\n        \\\n\ttmpM1 = enc( T6[5], T6[0] );\\\n\ttmpM0 = enc( T3[2], T3[0] );\\\n        \\\n       \ttmp = T4[1];\\\n       \tT4[1] = enc( T4[0], Z0    );\\\n\tT4[0] = enc( T4[3], T4[0] );\\\n        T4[3] = T4[2]; \\\n        T4[2] = tmp; \\\n        \\\n\tT3[2] = T3[1];\\\n        T3[1] = enc( T3[0] , Z0);\\\n        \\\n\tT6[5] = T6[4]; T6[4] = T6[3]; T6[3] = T6[2]; T6[2] = T6[1]; T6[1] = enc( T6[0] , Z0);\\\n\t\\\n\tT3[0] = xor( T4[1] , C0 ); \\\n        T6[0] = xor( T3[1] , C1 ); \\\n\ttmpM0 = xor( tmpM0 , T3[0] );\\\n\ttmpM1 = xor( tmpM0 , xor( T6[0] , tmpM1) );\\\n\tT4[0] = xor( T4[0],tmpM1);\\\n\tstore( (__m128 *)(storeM0), tmpM0 );\\\n        store( (__m128 *)(storeM1), tmpM1 );\n\n\n/*\n *\n * The encryption and authenticationd\n *\n */\nint tiaoxin_optimized_encrypt( const unsigned char *ad,unsigned long long adlen,\n\t\t\t       const unsigned char *m,unsigned long long mlen,\n\t\t\t       const unsigned char *nsec,const unsigned char *npub,const unsigned char *k,\n\t\t\t       unsigned char *c,unsigned long long *clen)\n{\n\tunsigned long long i;\n\tunsigned char incomplete_block[32];\n\t__m128i T3[3];\n\t__m128i T4[4];\n\t__m128i T6[6];\n\t__m128i tmp;\n\t__m128i Z0 \t= constant8( 0x42,0x8a,0x2f,0x98,0xd7,0x28,0xae,0x22,0x71,0x37,0x44,0x91,0x23,0xef,0x65,0xcd );\n\t__m128i Z1 \t= constant8( 0xb5,0xc0,0xfb,0xcf,0xec,0x4d,0x3b,0x2f,0xe9,0xb5,0xdb,0xa5,0x81,0x89,0xdb,0xbc );\n\t__m128i perm    = constant8( 7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8 );\n\t__m128i K;\n\t__m128i IV;\n\t__m128i Tag;\n\t__m128i M[4];\n\t__m128i W0,W1;\n\n\t/*\n\t * Get the key and the nonce\n\t */\n\tK  = load( (__m128i *) ( k ) );\n\tIV = load( (__m128i *) ( npub ) );\n\n\n\tW0 = _mm_set_epi64x( adlen, adlen );\n\tW1 = _mm_set_epi64x( mlen , mlen  );\n\tW0 = _mm_shuffle_epi8( W0 , perm  );\n\tW1 = _mm_shuffle_epi8( W1 , perm  );\n\n\t/*\n\t * Initialization\n\t */\n\tT3[0] = T4[0] = T6[0] = K;\n\tT3[1] = T4[1] = T6[1] = K;\n\tT3[2] = T4[2] = T6[2] = IV;\n\tT4[3] = Z0; T6[3] = Z1;\n\tT6[4] = T6[5] = xor(Z0,Z0);\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\n\n\t/*\n\t * Process associated data blocks\n\t */\n\tfor( i = 0; i + 128 <= adlen; i+=128 ){\n\t      M[0] = load( (__m128i *) (ad + i +  0) );\n\t      M[1] = load( (__m128i *) (ad + i + 16) );\n\t      UPDATE( T3 , T4 , T6, M[0] , M[1] , xor(M[0],M[1]) );\n\t      M[2] = load( (__m128i *) (ad + i + 32) );\n\t      M[3] = load( (__m128i *) (ad + i + 48) );\n\t      UPDATE( T3 , T4 , T6, M[2] , M[3] , xor(M[2],M[3]) );\n\t      M[0] = load( (__m128i *) (ad + i + 64) );\n\t      M[1] = load( (__m128i *) (ad + i + 80) );\n\t      UPDATE( T3 , T4 , T6, M[0] , M[1] , xor(M[0],M[1]) );\n\t      M[2] = load( (__m128i *) (ad + i + 96) );\n\t      M[3] = load( (__m128i *) (ad + i +112) );\n\t      UPDATE( T3 , T4 , T6, M[2] , M[3] , xor(M[2],M[3]) );\n\t}\n\tfor( ; i+32 <= adlen; i+=32 ){\n\t      M[0] = load( (__m128i *) (ad + i +  0) );\n\t      M[1] = load( (__m128i *) (ad + i + 16) );\n\t      UPDATE( T3 , T4 , T6, M[0] , M[1] , xor(M[0],M[1]) );\n\t}\n\t// Incomplete block\n\tif( adlen > i ){\n\t  memset( incomplete_block , 0, 32 );\n\t  memcpy( incomplete_block , ad + i, adlen - i );\n\t  M[0] = load( (__m128i *) (incomplete_block +  0) );\n\t  M[1] = load( (__m128i *) (incomplete_block + 16) );\n\t  UPDATE( T3 , T4 , T6, M[0] , M[1] , xor(M[0],M[1]) );\n\t}\n\n\n\t/*\n\t * Encryption of message blocks\n\t */\n\tfor( i = 0; i + 128 <= mlen; i+=128 ){\n\t      M[0] = load( (__m128i *) (m + i +  0) );\n\t      M[1] = load( (__m128i *) (m + i + 16) );\n\t      UPDATE ( T3 , T4 , T6, M[0] , M[1] , xor(M[0],M[1]) );\n\t      OUTPUT1( T3 , T4 , T6 , c , i +  0);\n\t      OUTPUT2( T3 , T4 , T6 , c , i + 16);\n\t      M[2] = load( (__m128i *) (m + i + 32) );\n\t      M[3] = load( (__m128i *) (m + i + 48) );\n\t      UPDATE ( T3 , T4 , T6, M[2] , M[3] , xor(M[2],M[3]) );\n\t      OUTPUT1( T3 , T4 , T6 , c , i + 32);\n\t      OUTPUT2( T3 , T4 , T6 , c , i + 48);\n\t      M[0] = load( (__m128i *) (m + i + 64) );\n\t      M[1] = load( (__m128i *) (m + i + 80) );\n\t      UPDATE ( T3 , T4 , T6, M[0] , M[1] , xor(M[0],M[1]) );\n\t      OUTPUT1( T3 , T4 , T6 , c , i + 64);\n\t      OUTPUT2( T3 , T4 , T6 , c , i + 80);\n\t      M[2] = load( (__m128i *) (m + i + 96) );\n\t      M[3] = load( (__m128i *) (m + i +112) );\n\t      UPDATE ( T3 , T4 , T6, M[2] , M[3] , xor(M[2],M[3]) );\n\t      OUTPUT1( T3 , T4 , T6 , c , i + 96);\n\t      OUTPUT2( T3 , T4 , T6 , c , i +112);\n\t}\n\tfor( ; i + 32 <= mlen; i+=32 ){\n\t      M[0] = load( (__m128i *) (m + i +  0) );\n\t      M[1] = load( (__m128i *) (m + i + 16) );\n\t      UPDATE( T3 , T4 , T6, M[0] , M[1] , xor(M[0],M[1]) );\n\t      OUTPUT1( T3 , T4 , T6 , c , i +  0);\n\t      OUTPUT2( T3 , T4 , T6 , c , i + 16);\n\t}\n\t// Incomplete block\n\tif( mlen > i ){\n\t  memset( incomplete_block , 0, 32 );\n\t  memcpy( incomplete_block , m + i, mlen - i );\n\t  M[0] = load( (__m128i *) (incomplete_block +  0) );\n\t  M[1] = load( (__m128i *) (incomplete_block + 16) );\n\t  UPDATE( T3 , T4 , T6, M[0] , M[1] , xor(M[0],M[1]) );\n\t  OUTPUT1( T3 , T4 , T6 , incomplete_block ,   0);\n\t  OUTPUT2( T3 , T4 , T6 , incomplete_block ,  16);\n\t  memcpy( c + i, incomplete_block, mlen - i);\n\t}\n\n\t/*\n\t * Finalization\n\t */\n\t// Lengths\n\tUPDATE( T3 , T4 , T6 , W0 , W1 , xor(W0,W1) );\n\t// 20 additional rounds\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\n\n\t/*\n\t * Tag as XOR of all state words\n\t */\n\tTag  = xor(T3[0], xor(T3[1], xor(T3[2], xor(T4[0], xor(T4[1], xor(T4[2], xor(T4[3],\n\t       xor(T6[0], xor(T6[1], xor(T6[2], xor(T6[3], xor(T6[4], T6[5] ) ) ) ) ) ) ) ) ) ) ) ) ;\n\tstore( (__m128 *)( incomplete_block ), Tag );\n\tmemcpy( c + mlen, incomplete_block , 16 );\n\n\t// Set the length of the ciphertext\n\t*clen = mlen + 16;\n\n\treturn 0;\n}\n\n\n\n/*\n *\n * The decryption and verification\n *\n */\nint tiaoxin_optimized_decrypt(unsigned char *m,unsigned long long *mlen,\n\t\t\t      unsigned char *nsec,\n\t\t\t      const unsigned char *c,unsigned long long clen,\n\t\t\t      const unsigned char *ad,unsigned long long adlen,\n\t\t\t      const unsigned char *npub,const unsigned char *k)\n{\n\n\tunsigned char incomplete_block[32];\n\tunsigned long long i;\n\t__m128i T3[3];\n\t__m128i T4[4];\n\t__m128i T6[6];\n\t__m128i W0, W1;\n\t__m128i tmp;\n\t__m128i tmpM0,tmpM1;\n\t__m128i Z0 \t= constant8( 0x42,0x8a,0x2f,0x98,0xd7,0x28,0xae,0x22,0x71,0x37,0x44,0x91,0x23,0xef,0x65,0xcd );\n\t__m128i Z1 \t= constant8( 0xb5,0xc0,0xfb,0xcf,0xec,0x4d,0x3b,0x2f,0xe9,0xb5,0xdb,0xa5,0x81,0x89,0xdb,0xbc );\n\t__m128i perm    = constant8( 7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8 );\n\t__m128i K;\n\t__m128i IV;\n\t__m128i Tag;\n\t__m128i C[4];\n\n\t/*\n\t * Get the key and the nonce\n\t */\n\tK  = load( (__m128i *) ( k ) );\n\tIV = load( (__m128i *) ( npub ) );\n\n\tW0 = _mm_set_epi64x( adlen, adlen );\n\tW1 = _mm_set_epi64x( clen -16, clen-16  );\n\tW0 = _mm_shuffle_epi8( W0 , perm  );\n\tW1 = _mm_shuffle_epi8( W1 , perm  );\n\n\n\t/*\n\t * Initialization\n\t */\n\tT3[0] = T4[0] = T6[0] = K;\n\tT3[1] = T4[1] = T6[1] = K;\n\tT3[2] = T4[2] = T6[2] = IV;\n\tT4[3] = Z0; T6[3] = Z1;\n\tT6[4] = T6[5] = xor(Z0,Z0);\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\tUPDATE( T3 , T4 , T6, Z0 , Z1 , Z0 );\n\n\n\t/*\n\t * Process associated data blocks\n\t */\n\tfor( i = 0; i + 128 <= adlen; i+=128 ){\n\t      C[0] = load( (__m128i *) (ad + i +  0) );\n\t      C[1] = load( (__m128i *) (ad + i + 16) );\n\t      UPDATE( T3 , T4 , T6, C[0] , C[1] , xor(C[0],C[1]) );\n\t      C[2] = load( (__m128i *) (ad + i + 32) );\n\t      C[3] = load( (__m128i *) (ad + i + 48) );\n\t      UPDATE( T3 , T4 , T6, C[2] , C[3] , xor(C[2],C[3]) );\n\t      C[0] = load( (__m128i *) (ad + i + 64) );\n\t      C[1] = load( (__m128i *) (ad + i + 80) );\n\t      UPDATE( T3 , T4 , T6, C[0] , C[1] , xor(C[0],C[1]) );\n\t      C[2] = load( (__m128i *) (ad + i + 96) );\n\t      C[3] = load( (__m128i *) (ad + i +112) );\n\t      UPDATE( T3 , T4 , T6, C[2] , C[3] , xor(C[2],C[3]) );\n\t}\n\tfor( ; i+32 <= adlen; i+=32 ){\n\t      C[0] = load( (__m128i *) (ad + i +  0) );\n\t      C[1] = load( (__m128i *) (ad + i + 16) );\n\t      UPDATE( T3 , T4 , T6, C[0] , C[1] , xor(C[0],C[1]) );\n\t}\n\t// Incomplete block\n\tif( adlen > i ){\n\t  memset( incomplete_block , 0, 32 );\n\t  memcpy( incomplete_block , ad + i, adlen - i );\n\t  C[2] = load( (__m128i *) (incomplete_block +  0) );\n\t  C[3] = load( (__m128i *) (incomplete_block + 16) );\n\t  UPDATE( T3 , T4 , T6, C[2] , C[3] , xor(C[2],C[3]) );\n\t}\n\n\n\t/*\n\t * Decryption\n\t */\n\tclen -= 16;\n\tif( clen < 0 )\n\t  return -1;\n\n\tfor( i = 0; i + 128 <= clen; i+=128 ){\n\t      C[0] = load( (__m128i *) (c + i +  0) );\n\t      C[1] = load( (__m128i *) (c + i + 16) );\n\t      DECRYPTION_ROUND( T3 , T4 , T6, C[0] , C[1] , m + i +  0 , m + i +  16 );\n\t      C[2] = load( (__m128i *) (c + i + 32) );\n\t      C[3] = load( (__m128i *) (c + i + 48) );\n\t      DECRYPTION_ROUND( T3 , T4 , T6, C[2] , C[3] , m + i + 32 , m + i +  48 );\n\t      C[0] = load( (__m128i *) (c + i + 64) );\n\t      C[1] = load( (__m128i *) (c + i + 80) );\n\t      DECRYPTION_ROUND( T3 , T4 , T6, C[0] , C[1] , m + i + 64 , m + i +  80 );\n\t      C[2] = load( (__m128i *) (c + i + 96) );\n\t      C[3] = load( (__m128i *) (c + i +112) );\n\t      DECRYPTION_ROUND( T3 , T4 , T6, C[2] , C[3] , m + i + 96 , m + i + 112 );\n\t}\n\tfor( ; i + 32 <= clen; i+=32 ){\n\t      C[0] = load( (__m128i *) (c + i +  0) );\n\t      C[1] = load( (__m128i *) (c + i + 16) );\n\t      DECRYPTION_ROUND( T3 , T4 , T6, C[0] , C[1] , m + i +  0 , m + i +  16 );\n\t}\n\t// Incomplete block\n\tif( clen > i ){\n\t  memset( incomplete_block , 0, 32 );\n\t  memcpy( incomplete_block , c + i, clen - i );\n\t  C[0] = load( (__m128i *) (incomplete_block +  0) );\n\t  C[1] = load( (__m128i *) (incomplete_block + 16) );\n\t  UPDATE( T3 , T4 , T6 , xor(Z0,Z0), xor(Z0,Z0), xor(Z0,Z0) );\n\t  tmpM0  = xor( C[0] , xor( T3[0] , xor( T3[2] , xor( T4[1] , and( T6[3], T4[3] ) ) ) ) ) ;\n\t  if( clen  - i <= 16 ){\n\t    store((__m128 *)incomplete_block, tmpM0);\n\t    memset( incomplete_block + ((unsigned int)(clen  - i) ), 0, 16 - ((unsigned int)(clen  - i) ) );\n\t    tmpM0 = load( incomplete_block);\n\t  }\n\t  tmpM1  = xor(xor( C[1] , xor( T6[0] , xor( T4[2] , xor( T3[1] , and( T6[5], T3[2] ) ) ) ) ),tmpM0);\n\t  if( clen - i > 16 ){\n\t    store((__m128 *)incomplete_block, tmpM1);\n\t    memset( incomplete_block + (clen - i - 16 ), 0, 32 - (clen - i ) );\n\t    tmpM1 =  load( incomplete_block);\n\t  }\n\t  else{\n\t    tmpM1 = xor(Z0,Z0);\n\t  }\n\t  T3[0] = xor(T3[0],tmpM0);\n\t  T4[0] = xor(T4[0],tmpM1);\n\t  T6[0] = xor(T6[0],xor(tmpM0,tmpM1));\n\t  store((__m128 *)(incomplete_block+  0), tmpM0);\n\t  store((__m128 *)(incomplete_block+ 16), tmpM1);\n\t  memcpy( m + i +  0 , incomplete_block, clen - i );\n\t}\n\n\t/*\n\t * Finalization\n\t */\n\t// Lengths\n\tUPDATE( T3 , T4 , T6 , W0 , W1 , xor(W0,W1) );\n\t// 20 additional rounds\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\tUPDATE( T3 , T4 , T6 , Z1 , Z0 , Z1);\n\n\n\n\t/*\n\t * Produce the tag as XOR of all state words\n\t */\n\tTag  = xor(T3[0], xor(T3[1], xor(T3[2], xor(T4[0], xor(T4[1], xor(T4[2], xor(T4[3],\n\t       xor(T6[0], xor(T6[1], xor(T6[2], xor(T6[3], xor(T6[4], T6[5] ) ) ) ) ) ) ) ) ) ) ) ) ;\n\tstore( (__m128 *)( incomplete_block ), Tag );\n\n\t/*\n\t * Check if the tag is correct\n\t */\n\tif(0!=memcmp(incomplete_block, c + clen , 16)) return -1;\n\n\n\n\t// Set the length of the plaintext\n\t*mlen = clen;\n\n\treturn 0;\n}\n"
        },
        {
            "file_name": "tortuga.c",
            "content": "#include <math.h>\n#include <string.h>\n\n#include \"turtle.h\"\n\n#ifndef TORTUGA_SALT_BYTES\n#define TORTUGA_SALT_BYTES    16\n#endif\n\n#ifndef TORTUGA_MIN_KEY_BYTES\n#define TORTUGA_MIN_KEY_BYTES 16\n#endif\n\n#ifdef TORTUGA_DEBUG\n#include <stdio.h>\n#endif\n\nstatic unsigned int upper_power_of_four(const unsigned int v) {\n\n\tconst unsigned int temp = 1 << ((unsigned int) ceil(log2(v)));\n\n\treturn ((const unsigned int) log2(temp)) & 1 ? temp << 1 : temp;\n}\n\nstatic unsigned char * encode_uint_(unsigned char * res, const unsigned int x) {\n\n\tres[0] =  x        & 0xFF;\n\tres[1] = (x >>  8) & 0xFF;\n\tres[2] = (x >> 16) & 0xFF;\n\tres[3] = (x >> 24) & 0xFF;\n\n\treturn res;\n}\n\nstatic void tortuga_genkey(unsigned char * key , const unsigned int  key_size,\n                     const unsigned char * salt, const unsigned int salt_size) {\n\n\tunsigned char salt_[TORTUGA_SALT_BYTES];\n\n\tunsigned int i, len = key_size >> 2;\n\n\tunsigned char tmp[4];\n\tunsigned char backup[key_size];\n\n\tmemset(salt_, 0, TORTUGA_SALT_BYTES);\n\tmemcpy(salt_, salt, salt_size < TORTUGA_SALT_BYTES ? salt_size : TORTUGA_SALT_BYTES);\n\n\tfor (i = 0; i < len; ++i)\n\t\tturtle(&backup[i << 2], encode_uint_(tmp,i), sizeof(tmp), 1, 0, salt_, TORTUGA_SALT_BYTES);\n\n\tfor (i = 0; i < key_size; ++i)\n\t\tkey[i] ^= backup[i];\n\n\tif (salt_size > TORTUGA_SALT_BYTES)\n\t\ttortuga_genkey(key, key_size, salt + TORTUGA_SALT_BYTES, salt_size - TORTUGA_SALT_BYTES);\n\n}\n\nunsigned int tortuga_internal_key_size(const unsigned int m_cost) {\n\n\tconst unsigned int key_bytes_ = upper_power_of_four(m_cost + 1);\n\n\treturn key_bytes_ < TORTUGA_MIN_KEY_BYTES ? TORTUGA_MIN_KEY_BYTES : key_bytes_;\n}\n\nvoid tortuga(unsigned char * out  , const unsigned int   out_size,\n       const unsigned char * input, const unsigned int input_size,\n       const unsigned char * salt , const unsigned int  salt_size,\n const unsigned int t_cost, const unsigned int m_cost) {\n\n\tunsigned int ipos, ilen, i, counter = 0;\n\n\t/* Waste memory. */\n\tconst unsigned int key_bytes = tortuga_internal_key_size(m_cost);\n\n\tconst unsigned int min_iterations = ((t_cost * TORTUGA_MIN_KEY_BYTES) / key_bytes + 1) << 1;\n\n\tconst unsigned int   state_size = sqrt(key_bytes);\n\tconst unsigned int message_size = state_size >> 2;\n\n\tunsigned char state[state_size];\n\tunsigned char   key[key_bytes ];\n\n\tmemset(key  , 0, sizeof(key  ));\n\tmemset(state, 0, sizeof(state));\n\n\t/* Prevent length extension attacks. */\n\ttortuga_genkey(encode_uint_(key  ,  salt_size), sizeof(key  )      , salt, salt_size  );\n\tturtle_inplace(encode_uint_(state, input_size), sizeof(state), 1, 0, key , sizeof(key));\n\n\tfor (ipos = 0; ipos < input_size; ipos += message_size /*, ++counter */ ) {\n\n\t\tilen = input_size - ipos < message_size ? input_size % message_size : message_size;\n\n\t\tfor (i = 0; i < ilen; ++i)\n\t\t\tstate[i] ^= input[ipos + i];\n\n\t\t/* Absorb some bytes. */\n\t\tturtle_inplace(state, sizeof(state), 1, 0, key, sizeof(key));\n\t}\n\n\t/* Waste time. */\n\twhile (counter++ < min_iterations)\n\t\tturtle_inplace(state, sizeof(state), 1, 0, key, sizeof(key));\n\n\tfor (i = 0; i + message_size < out_size; i += message_size) {\n\n\t\t/* Squeeze some bytes. */\n\t\tmemcpy(out + i, state, message_size);\n\t\tturtle_inplace(state, sizeof(state), 1, 0, key, sizeof(key));\n\t}\n\n\t/* Squeeze last bytes. */\n\tmemcpy(out + i, state, out_size - i);\n\n#ifdef TORTUGA_DEBUG\n\n\tprintf(\"key_bytes:       %u\\n\", key_bytes     );\n\tprintf(\"min_iterations:  %u\\n\", min_iterations);\n\tprintf(\"state_size:      %u\\n\", state_size    );\n\tprintf(\"message_size:    %u\\n\", message_size  );\n\n#endif\n\n}\n"
        },
        {
            "file_name": "trivia128v1_encrypt.cpp",
            "content": "//Trivia128v1\n// May 14, 2014\n\n#include<stdio.h>\n#include<stdlib.h>\n#include\"trivia128v1_encrypt.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Trivia128v1_raw {\nint numRounds = -1;\n\ntypedef unsigned char u8;\ntypedef unsigned short u16;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n\n#define CONST_alpha_32 0x00400007              // The primitive polynomial for GF(2^32)\n#define CONST_beta_64 0x000000000000001B       // The primitive polynomial for GF(2^64)\n#define PROC_CHECKSUM 1                        // Here we process Checksum blocks.\n#define PROC_BLOCK 0\n#define PROC_AD 1\t\t\t\t// Process Associated Data.\n#define PROC_MSG 0\t\t\t\t// Process Message.\n\n/* Different Modes of Uses of Streamcipher Keys */\n#define DROP_KEY 0                              // NO use so drop the key...\n#define CT_GEN_KEY 1\t\t\t\t// to generate ciphertext\n#define LEN_HASH_KEY_AD 2\t\t\t// to handle variable length hashing for AD\n#define LEN_HASH_KEY_MSG 3\t\t\t// to handle variable length hashing for Message\n#define ENCRYPTION 1\t\t\t\t// If 1 encrypting, otherwise (i.e, 0) decrypting\n//#define CHUNK_SIZE 0x40000000\t\t\t// Process checksum after 2^30 blocks(for TriviA-0 version)\n#define CHUNK_SIZE 0x40000000\t\t\t// Process checksum after 128 blocks(for TriviA-128 version) // CHANGE\n#define MAX_IT 0x00400000          // Intermediate Tag (if any) upto 2^29 blocks (2^32 bytes)\n\n/* Will be used For TriviA-0 version */\n/*\n#define CHUNK_SIZE_MSG 0x40000000\n#define IT 0   \t\t\t\t\t// No intermediate Tag (ITag)\n#define param 0x0000000000000000\n*/\n/* Will be used TriviA-128 version */\n#define CHUNK_SIZE_MSG 128       \t // Process checksum after 2^7 Msg Blocks (not for AD) for ITag\n#define IT 1\t\t\t\t   // Intermediate Tag is produced until 2^{32} blocks\n#define param 0x0080000000000000\n\n\n\n//............ALL MODULES............\n\nstatic void store64(u8 *Bytes, u64 Block)\n{ int i; for (i = 7; i >= 0; i--) {Bytes[i] = (u8)Block; Block >>= 8; }}\n\nstatic void store32(u8 *Bytes, u32 word)\n{ int i; for (i = 3; i >= 0; i--) {Bytes[i] = (u8)word;  word >>= 8; }}\n\nu64 load64(const u8 *Bytes)\n{int i; u64 temp, Block = Bytes[0];\nfor(i = 1; i <8; i++) {Block <<= 8; Block = (Block)^(u64)(Bytes[i]);} return Block;}\n\nu32 load32(const u8 *Bytes)\n{int i; u32 temp, Block = (u8)Bytes[0];\nfor(i = 1; i <4; i++) {Block <<= 8; Block = (Block)^(u32)(Bytes[i]);} return Block;}\n\n\nstatic void set_zero64(u64 *a, int len)\n{int i; for(i=0; i<len; i++){a[i]=0;}}\n\nstatic void set_zero32(u32 *a, int len)\n{int i; for(i=0; i<len; i++){a[i]=0;}}\n\n/* It Updates the Streamcipher state (64 rounds together) and also generates the 64 bit key. */\n\nvoid SC_Update64(u64 *S, u64 *Z)\n{\nu64 t1 = (S[0] << (66 - 64) | S[1] >> (128 - 66)) ^ (S[1] << (132 - 128) | S[2] >> (192 - 132));\nu64 t2 = (S[3] << (69 - 64) | S[4] >> (128 - 69)) ^ (S[3] << (105 - 64) | S[4] >> (128 - 105));\nu64 t3 = (S[5] << (66 - 64) | S[6] >> (128 - 66)) ^ (S[6] << (147 - 128) | S[7] >> (192 - 147));\nZ[0] = t1 ^ t2 ^ t3 ^ ((S[0] << 38 | S[1] >> 26) & (S[3] << 2 | S[4] >> 62)); // Key Block generated\n\n//Computing Updated Blocks\nt1 ^= ((S[1] << (130 - 128) | S[2] >> (192 - 130)) & (S[1] << (131 - 128) | S[2] >> (192 - 131))) ^ (S[3] << (96 - 64) | S[4] >> (128 - 96));\nt2 ^= ((S[3] << (103 - 64) | S[4] >> (128 - 103)) & (S[3] << (104 - 64) | S[4] >> (128 - 104))) ^ (S[5] << (120 - 64) | S[6] >> (128 - 120));\nt3 ^= ((S[6] << (145 - 128) | S[7] >> (192 - 145)) & (S[6] << (146 - 128) | S[7] >> (192 - 146))) ^ (S[0] << (75 - 64) | S[1] >> (128 - 75));\n\n//Shifting and Inserting Updated Blocks\nS[2] = S[1]; S[1] = S[0]; S[0] = t3;   S[4] = S[3]; S[3] = t1;   S[7] = S[6]; S[6] = S[5]; S[5] = t2;\n}\n\nvoid load_SC(u64 *SC_State, const u8 *k, const u8 *npub)\n{\n   SC_State[0] = load64(k); SC_State[1] = load64(k+8); SC_State[2] = 0xFFFFFFFFFFFFFFFF;\n   SC_State[3] = 0xFFFFFFFFFFFFFFFF; SC_State[4] = 0xFFFFFFFFFFFFFFFF; SC_State[5]=param;\n   SC_State[6] = load64(npub); SC_State[7] = 0xFFFFFFFFFFFFFFFF;\n}\n\nu64 Key_Ext64(u64 *S)\n{\nu64 Z;\nu64 t1 = (S[0] << (66 - 64) | S[1] >> (128 - 66)) ^ (S[1] << (132 - 128) | S[2] >> (192 - 132));\nu64 t2 = (S[3] << (69 - 64) | S[4] >> (128 - 69)) ^ (S[3] << (105 - 64) | S[4] >> (128 - 105));\nu64 t3 = (S[5] << (66 - 64) | S[6] >> (128 - 66)) ^ (S[6] << (147 - 128) | S[7] >> (192 - 147));\nZ = t1 ^ t2 ^ t3 ^ ((S[0] << 38 | S[1] >> 26) & (S[3] << 2 | S[4] >> 62)); // Key Block generated\n\nreturn Z;\n}\n\nvoid insert_SC(u64 *SC_State, u32 *Tag)\n{\n   SC_State[0] ^= ((u64)Tag[0]<<32)^Tag[1];\n   SC_State[1] ^= ((u64)Tag[2]<<32)^Tag[3];\n   SC_State[2] ^= ((u64)Tag[4]<<32);\n   SC_State[3] ^= ((u64)Tag[4])<<36;\n}\n\n/* Multiplication by alpha power m. We use mainly for m = 1,2,3,4 */\n/*----------------------------------------------------------------*/\nu32 Mult_by_alpha_power(u32 a, int m)\n{\n   int i; u32 result;\n   for(i=0; i<m; i++)\n   {\n    result = a<<1;\n    if((a>>31)&1==1) result = result^(CONST_alpha_32);\n    a = result;\n   }\n   return result;\n}\n\n/* Horner's Multiplication for 32-bit Vandermonde Matrix Multiplcaition\nWhen FULL is 1 (for AD) we process 160 bit tags, otheriwse (for message) 128 bit\n----------------------------------------------------------------------*/\nvoid V_Horner_32(u32 Input, u32* Tag, u8 FULL)\n{\n    Tag[0] = Tag[0]^Input;\n        Tag[1] = Mult_by_alpha_power(Tag[1],1)^Input;\n        Tag[2] = Mult_by_alpha_power(Tag[2],2)^Input;\n        Tag[3] = Mult_by_alpha_power(Tag[3],3)^Input;\n    if(FULL==1) Tag[4]=Mult_by_alpha_power(Tag[4],4)^Input;\n}\n/* Multiplication by beta power m, we use m = 1,2,3 */\n/*--------------------------------------------------*/\nu64 Mult_by_beta_power(u64 b, int m)\n{\n   int i; u64 result;\n   for(i=0; i<m; i++)\n   {\n    result = b<<1;\n    if((b>>63)&1==1) result = result^(CONST_beta_64);\n    b = result;\n   }\n   return result;\n}\n/* Horner's Multiplication for 64-bit Vandermonde Matrix Multiplcaition\nWhen FULL is 1 (for AD) we process 4 checksum blocks, otheriwse (for message) 3 blocks\n--------------------------------------------------------------------*/\nvoid V_Horner_64(u64 Input, u64* Checksum, u8 FULL)\n{\n    Checksum[0] = Checksum[0]^Input;\n        Checksum[1] = Mult_by_beta_power(Checksum[1],1)^Input;\n        Checksum[2] = Mult_by_beta_power(Checksum[2],2)^Input;\n    if(FULL==1) Checksum[3] = Mult_by_beta_power(Checksum[3],3)^Input;\n}\n\n/* Reverse a 32 bit string */\nu32 Reverse_32(u32 a)\n{\n  u32 i, b=0;\n\n  for(i=0;i<31;i++){\n    b^=(a&1); a=a>>1; b=b<<1;}\n  b^=(a&1);\n  return b;\n}\n\n/* Multiplications of two 32 bit field elements */\n/*-----------------------------------------------*/\nu32 Field_Mult_32(u32 a, u32 b)\n{\n   u32 result=0, i;\n\n   b=Reverse_32(b);\n\n   if(b&1==1) result=a;\n\n   for(i=1;i<32;i++)\n   {\n    b=b>>1;\n    result=Mult_by_alpha_power(result,1);\n    if(b&1==1) result=result^a;\n   }\n   return result;\n}\n\n/* Pad The Final Block (Possibly Empty and must be Incomplete) by appending 10*  */\n/*------------------------------------------------------------------------------ */\nu64 pad(const u8 *Bytes, int Last_len)\n{\n  int i; u64 Block=0;\n  for (i = 0;i <Last_len; i++) {Block ^= (u64)Bytes[i]; Block <<= 8; }\n  Block ^= 128; Block <<= 8*(7-Last_len); return Block;\n}\n\n/*-----------------------------------------------------------------------------------------------*/\n/* The Main Module of TriviA which would be repeated for every 64 bits of message or associate data */\n/* Apply Pseudo-dot-Product and, update State bits, Tag & Checksum (if not processing checksum)  */\n/*------------------------------------------------------------------------------ */\nvoid process_block(u64 Block, u32 *Tag, u64 *Checksum, u64 *SC_State, u64 *Z, u8 IsChecksum, u8 IsAD)\n{\n   u32 State_Key[2], word[2], PDP;\n\n   word[0]= (u32)(Block>>32); word[1]= (u32)Block;                       // Parse Blocks into words\n\n   State_Key[0]= (u32)((SC_State[0]>>32)&(0xFFFFFFFF));\n   State_Key[1]= (u32)(SC_State[0]&(0xFFFFFFFF));                    // Obtain State-key Words\n\n   SC_Update64(SC_State, Z);                                               // State Bits Updated\n\n   PDP = Field_Mult_32(word[0]^State_Key[0], word[1]^State_Key[1]); // Pseudo-dot-Product\n\n   V_Horner_32(PDP, Tag, IsAD);                                         // Update Tag always.\n\n   if(!IsChecksum) {V_Horner_64(Block, Checksum, IsAD);}       // update checksum if not checksum block.\n}\n\n\n\n\n\nvoid Initialize_process_AD_Reinitialize(u64 *SC_State, const unsigned char *ad, unsigned long long adlen)\n{\n   u64  Z[4], Checksum[4], Block;\n   u32 dummy_word[2], Tag[5], ck_ctr, temp;\n   u8 FINISH;\n   int i;\n\n   for(i=0; i<18; i++) {SC_Update64(SC_State, Z);} // Update SC_State for 18 64-rounds.\n\n\n/*  PROCESS ASSOCIATED DATA BLOCKS...   */\n//----------------------------------------\n\n   ck_ctr = CHUNK_SIZE;  set_zero32(Tag,5);  set_zero64(Checksum,4);\n   while(adlen >=8) // Process All But the Final Block of AD\n   {\n    Block = load64(ad);\n    process_block(Block, Tag, Checksum, SC_State, Z, PROC_BLOCK, PROC_AD); // Update the Tag and Checksum\n        ad = ad+8; adlen = adlen-8; ck_ctr--;\n        if(ck_ctr==0) // process the checksum blocks\n    {\n       for(i=0; i<4; i++){\n        process_block(Checksum[i], Tag, Checksum, SC_State, Z, PROC_CHECKSUM, PROC_AD);}// Update Tag\n                                                                                                // for the Checksum Block\n       ck_ctr=CHUNK_SIZE; set_zero64(Checksum,4); // Reset The Chunk Counter and Set the Checksum Array to zero\n    }\n   }\n\n   process_block(pad(ad, adlen), Tag, Checksum, SC_State, Z, PROC_BLOCK, PROC_AD); // Update the Tag and Checksum for the\n                                                                                   // Final Block\n\n\n// Update the Tag for the Final 4 Checksum Blocks for AD and Get the Key for Variable Length Handling\n   for(i=0; i<4; i++){process_block(Checksum[i], Tag, Checksum, SC_State, Z+i, PROC_CHECKSUM, PROC_AD);}\n\n// Add the Currently Generated Key to Handle Variable Length AD\n   Tag[0] ^= (u32)(Z[0]>>32); Tag[1] ^= (u32)(Z[0]); Tag[2] ^= (u32)(Z[1]>>32); Tag[3] ^= (u32)(Z[1]); Tag[4] ^= (u32)(Z[2]>>32);\n\n   insert_SC(SC_State, Tag); // Insert Tag for AD to streamcipher state\n   for(i=0; i<18; i++) {SC_Update64(SC_State, Z);} // Update SC_State for 18 64-rounds.\n\n\n}\n\n\n\nint crypto_aead_encrypt(\nunsigned char *c,unsigned long long *clen,\nconst unsigned char *m,unsigned long long mlen,\nconst unsigned char *ad,unsigned long long adlen,\nconst unsigned char *nsec,\nconst unsigned char *npub,\nconst unsigned char *k\n)\n{\n   u64 SC_State[8], Z[4], Checksum[4], Block;\n   u32 dummy_word[2], Tag[5], ck_ctr, blk_ctr, temp;\n   u8 FINISH;\n   int i;\n   *clen=0;\n   load_SC(SC_State, k, npub);  // Load State Blocks with Nonce and key\n\n   Initialize_process_AD_Reinitialize(SC_State, ad, adlen); //Initialize, Process AD and Reinitialize */\n\n\n/*  PROCESS MESSAGE BLOCKS.       */\n//--------------------------------//\n\n\n   ck_ctr = CHUNK_SIZE_MSG; blk_ctr= MAX_IT;  set_zero32(Tag,5); set_zero64(Checksum,4);\n   while(mlen >=8) // Process ALL but the Final Block of Message\n   {\n\n    Block = load64(m);\n    process_block(Block, Tag, Checksum, SC_State, Z, PROC_BLOCK, PROC_MSG);\n        for(i=0;i<8;i++) {c[i] = ((u8)(Z[0]>>(8*(7-i))))^(m[i]); }  // ciphertext computation\n\n\n        m = m+8; c= c+8; mlen = mlen-8; *clen = *clen+8; ck_ctr--; if(blk_ctr>0) blk_ctr--;\n\n    if(ck_ctr==0) // process the checksum blocks\n    {\n       for(i=0; i<3; i++)\n       {\n        process_block(Checksum[i], Tag, Checksum, SC_State, Z, PROC_CHECKSUM, PROC_MSG);\n       }\n       ck_ctr=CHUNK_SIZE_MSG; set_zero64(Checksum,4);\n\n       if(IT && blk_ctr!=0 && mlen > 0) // In case of Itag, we compute intermediate tag.  // CHANGE\n       {\n        for(i=0;i<4;i++){store32(c, Tag[i]); c= c+4;} *clen= *clen+16;\n       }\n    }\n   }\n\n// Process the Final Block (possibly emty) of Mesage after we apply 10* pad\n   process_block(pad(m, mlen), Tag, Checksum, SC_State, Z, PROC_BLOCK, PROC_MSG);\n   for(i=0;i<mlen;i++) {c[i] = ((u8)(Z[0]>>(8*(7-i))))^(m[i]);} //ciphertext for final block\n\n\n\n   *clen= *clen+mlen; c=c+mlen;\n\n// ...And the final 4 Checksum Blocks for AD\n   for(i=0; i<3; i++){process_block(Checksum[i], Tag, Checksum, SC_State, Z+i, PROC_CHECKSUM, PROC_MSG);}\n\n// Add the currently generated key to handle variable length AD\n   Tag[0] ^= (u32)(Z[0]>>32); Tag[1] ^= (u32)Z[0]; Tag[2] ^= (u32)(Z[2]>>32); Tag[3] ^= (u32)Z[2];\n   for(i=0;i<4;i++){store32(c, Tag[i]); c= c+4;} *clen= *clen+16;\n\n  return 0;\n}\n\n\n\n\n\n\n\n  int crypto_aead_decrypt(\n       unsigned char *m,unsigned long long *outputmlen,\n       unsigned char *nsec,\n       const unsigned char *c,unsigned long long clen,\n       const unsigned char *ad,unsigned long long adlen,\n       const unsigned char *npub,\n       const unsigned char *k\n     )\n{\n   u64 SC_State[8], Z[4], Checksum[4], Block;\n   u32 dummy_word[2], Tag[5], ck_ctr, blk_ctr, temp;\n   u8 FINISH, *tempvar;\n   u64 t1, t2, t3, i, j;\n   int ctr_tag=0;\n   *outputmlen=0;\n\n\n\n   load_SC(SC_State, k, npub);  // Load State Blocks with Nonce and key\n\n   Initialize_process_AD_Reinitialize(SC_State, ad, adlen); //Initialize, Process AD and Reinitialize */\n\n/*  PROCESS CIPHERTEXT BLOCKS.       */\n//--------------------------------//\n\n   ck_ctr = CHUNK_SIZE_MSG; blk_ctr= MAX_IT;  set_zero32(Tag,5); set_zero64(Checksum,4);\n   while(clen-16 >=8) // Process ALL but the Final Block of Message\n   {\n\n        Z[0] = Key_Ext64(SC_State);\n\n        for(i=0;i<8;i++) {m[i] = ((u8)(Z[0]>>(8*(7-i))))^(c[i]);  }\n        Block = load64(m);\n    process_block(Block, Tag, Checksum, SC_State, Z, PROC_BLOCK, PROC_MSG);\n\n          // message computation\n\n        m = m+8; c= c+8; *outputmlen = *outputmlen+8; clen = clen-8;\n        ck_ctr--; if(blk_ctr>0) blk_ctr--;\n\n    if(ck_ctr==0) // process the checksum blocks\n    {\n       for(i=0; i<3; i++)\n       {\n        process_block(Checksum[i], Tag, Checksum, SC_State, Z, PROC_CHECKSUM, PROC_MSG);\n       }\n       ck_ctr=CHUNK_SIZE_MSG; set_zero64(Checksum,4);\n\n       if(IT && blk_ctr!=0 && clen > 32) // In case of Itag, we compute intermediate tag. // CHANGE\n       {\n        for(i=0;i<4;i++){ c= c+4;} clen= clen-16;\n\n\n            for(i=0;i<4;i++)//Checking the equality of the intermediate tags\n            {\n\n                    temp=load32((c-16+i*4));\n                    if((Tag[i])!= temp) return -1;\n            }\n       }\n\n    }\n   }\n\n\n\n// Process the Final Block (possibly empty) of cipheretxt\n   Z[0] = Key_Ext64(SC_State);\n\n   for(i=0;i<clen-16;i++) {m[i] = ((u8)(Z[0]>>(8*(7-i))))^(c[i]);} //message for final block\n   process_block(pad(m, clen-16), Tag, Checksum, SC_State, Z, PROC_BLOCK, PROC_MSG);\n   *outputmlen=*outputmlen+clen-16; c=c+clen-16;\n// ...And the final 4 Checksum Blocks for AD\n   for(i=0; i<3; i++){process_block(Checksum[i], Tag, Checksum, SC_State, Z+i, PROC_CHECKSUM, PROC_MSG);}\n\n// Add the currently generated key to handle variable length AD\n   Tag[0] ^= (u32)(Z[0]>>32); Tag[1] ^= (u32)Z[0]; Tag[2] ^= (u32)(Z[2]>>32); Tag[3] ^= (u32)Z[2];\n   for(i=0;i<4;i++){ c= c+4;}     clen=clen-16;\n   temp=load32(c-4);\n\n   for(i=0;i<4;i++)//Checking the equality of the intermediate tags\n           {\n                temp=load32((c-16+i*4));\n                if((Tag[i])!= temp)  return -1;\n           }\n\nreturn 0;\n}\n\n\n\n\n\n} // namespace Trivia128v1_raw\n"
        },
        {
            "file_name": "turtle.c",
            "content": "#include <stdlib.h>\n#include <string.h>\n\nstatic void xor_each(unsigned char * A, const unsigned char * B, const unsigned int sz) {\n\n\tconst unsigned char * B_end = B + sz;\n\n\twhile (B != B_end)\n\t\t*A++ ^= *B++;\n}\n\nstatic unsigned char * dflt_permutation(const unsigned int n, unsigned char * res,\n const unsigned char * x, const unsigned int w,\n const unsigned char * f_data, const unsigned int f_data_size) {\n\n\tunsigned int i;\n\n\tfor (i = 0; i < w; ++i) {\n\n\t\t/* Use a different algebraic order so that our xors don't cancel. */\n\t\tres[i] = x[i] + f_data[(n + i) % f_data_size];\n\t}\n\n\treturn res;\n}\n\nstatic unsigned char * turtle_(unsigned char * res,\n const unsigned char * X, const unsigned int sz,\n const unsigned int w, unsigned int * n,\n unsigned char * (*f)\n  (const unsigned int, unsigned char *, const unsigned char *, const unsigned int,\n                                           const unsigned char *, const unsigned int),\n const unsigned char * f_data, const unsigned int f_data_size) {\n\n\tunsigned char L[sz >> 1];\n\tunsigned char R[sz - sizeof(L)];\n\n\tunsigned char tmp[sizeof(R)];\n\n\tif (sz == w) {\n\n\t\treturn f((*n)++, res, X, w, f_data, f_data_size);\n\t}\n\n\tmemcpy(L, X            , sizeof(L));\n\tmemcpy(R, X + sizeof(L), sizeof(R));\n\n\txor_each(R, turtle_(tmp, L, sizeof(L), w, n, f, f_data, f_data_size), sizeof(R));\n\txor_each(L, turtle_(tmp, R, sizeof(R), w, n, f, f_data, f_data_size), sizeof(L));\n\n\txor_each(R, turtle_(tmp, L, sizeof(L), w, n, f, f_data, f_data_size), sizeof(R));\n\txor_each(L, turtle_(tmp, R, sizeof(R), w, n, f, f_data, f_data_size), sizeof(L));\n\n\tmemcpy(res            , L, sizeof(L));\n\tmemcpy(res + sizeof(L), R, sizeof(R));\n\n\treturn res;\n}\n\nunsigned char * turtle(unsigned char * res,\n const unsigned char * X, const unsigned int sz, const unsigned int w,\n unsigned char * (*f)(const unsigned int, unsigned char *, const unsigned char *,\n                        const unsigned int, const unsigned char *, const unsigned int),\n unsigned char * f_data, const unsigned int f_data_size) {\n\n\tunsigned int n = 0;\n\n\treturn turtle_(res, X, sz, w, &n, f ? f : dflt_permutation, f_data, f_data_size);\n}\n\nunsigned char * turtle_inplace(\n unsigned char * X, const unsigned int sz, const unsigned int w,\n unsigned char * (*f)(const unsigned int, unsigned char *, const unsigned char *,\n                        const unsigned int, const unsigned char *, const unsigned int),\n unsigned char * f_data, const unsigned int f_data_size) {\n\n\tunsigned char tmp[sz];\n\n   turtle(tmp, X, sz, w, f, f_data, f_data_size);\n\n\tmemcpy(X, tmp, sz);\n\n\treturn X;\n}\n"
        },
        {
            "file_name": "twine80n6clocv1_cloc.cpp",
            "content": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"twine80n6clocv1_cloc.h\"\n#include \"twine80n6clocv1_api.h\"\n#include \"twine80n6clocv1_twine.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Twine80n6clocv1_raw {\n\n/* setup key */\nint ae_init(ae_cxt* cxt, const byte* userkey, int keylen)\n{\n    if(keylen/8 != CRYPTO_KEYBYTES){\n        return KEY_ERROR;\n    }\n    cxt->userkey = (byte*)userkey;\n    Keyschedule(keylen, userkey);\n    cxt->klen = keylen;\n\n    return SUCCESS;\n}\n\n/* associated data and nonce length in byte\n * nlen should be less than 16 bytes and larger than 0 byte;\n */\nint process_ad(ae_cxt* cxt, const byte* ad, unsigned long long adlen, const byte* nonce, unsigned long long nlen)\n{\n    byte* state = cxt->es;\n\n    cxt->ad = (byte*) ad;\n    cxt->adlen = adlen;\n    cxt->nonce = (byte*) nonce;\n    cxt->nlen = nlen;\n    /* process the first block */\n    int ozp = 0;\n    if(adlen < STATE_LEN){       // less than one block\n        memcpy(state, ad, adlen);\n        memset(state+adlen, 0, STATE_LEN-adlen);\n        state[adlen] = 0x80;\n        ozp = 1;                // one-zero padding works only if the adlen < 16\n    }\n    else{                       // full first block\n        memcpy(state, ad, STATE_LEN);\n    }\n\n    /* apply fix0 and the E_k */\n    int fix0 = state[0] & 0x80;    /* test if the MSB is zero */\n    state[0] &= 0x7f;\n\n    /* apply the first encryption */\n    Encode(state, state);\n    /* when fix0 works, apply h */\n    if(fix0){\n        word* wd = (word*) state;\n        h(wd[0], wd[1], wd[2], wd[3]);\n    }\n    else{\n        // do nothing\n    }\n\n    /* process the middle normal blocks of ad */\n    unsigned long long i;\n    for(i = 1; i < (unsigned long long)adlen/STATE_LEN; i++){\n        xor_bytes(state, ad+i*STATE_LEN, STATE_LEN);\n        pstate2(\"After xoring associated data:\", state);\n        Encode(state, state);\n    }\n    /* process the last block partial block if any */\n    unsigned long long lastblocklen = adlen % STATE_LEN;\n    if((adlen > STATE_LEN) && lastblocklen){\n        xor_bytes(state, ad+i*STATE_LEN, lastblocklen);\n        state[lastblocklen] ^= 0x80;\n        pstate2(\"After processing last partial associated data block:\", state);\n        Encode(state, state);\n        ozp = 1;\n    }\n\n    /* process the nonce */\n    xor_bytes(state, nonce, nlen);\n\n    /* apply padding to nonce */\n    if(nlen != STATE_LEN)\n        state[nlen] ^= 0x80;\n\n    /* apply f1 or f2 to get V */\n    if(ozp){ // apply f2\n        word* wd = (word*) state;\n        f2(wd[0], wd[1], wd[2], wd[3]);\n    }\n    else{ // apply f1\n        word* wd = (word*) state;\n        f1(wd[0], wd[1], wd[2], wd[3]);\n    }\n    pstate2(\"After applying f1/f2 to state:\", state);\n\n    memcpy(cxt->ts, state, STATE_LEN);\n    Encode(state, state);\n\n    return SUCCESS;\n}\n\n/*\n * plaintext, message length in byte, ciphertext, associated data, and associated data length in byte tag, and tag length in byte\n */\nint ae_encrypt(ae_cxt* cxt, byte* pt, unsigned long long mlen, byte* ct, byte* tag, unsigned long long tlen, int enc_dec)\n{\n    cxt->pt = pt;\n    cxt->ptlen = mlen;\n    cxt->ct = ct;\n    cxt->ctlen = mlen;\n    cxt->tag = tag;\n    cxt->tlen = tlen;\n\n    byte* es = cxt->es;\n    byte* ts = cxt->ts;\n\n    word* wd = (word*) ts;\n    if(mlen != 0){\n        g2(wd[0], wd[1], wd[2], wd[3]);\n        Encode(cxt->ts, cxt->ts);\n    }\n    else{\n        g1(wd[0], wd[1], wd[2], wd[3]);\n        Encode(cxt->ts, cxt->ts);\n        memcpy(tag, ts, tlen);\n        return SUCCESS;\n    }\n\n\n    unsigned long long pc = 0;\n    while((pc + STATE_LEN) < mlen){\n        if(enc_dec == ENC){ // encryption\n            xor_bytes(es, pt+pc, STATE_LEN);\n            pstate2(\"After xoring message block:\", es);\n            memcpy(ct+pc, es, STATE_LEN);\n        }\n        else{ // decryption\n            xor_bytes2(pt+pc, ct+pc, es, STATE_LEN);\n            pstate2(\"After xoring ciphertext block:\", es);\n            memcpy(es, ct+pc, STATE_LEN);\n        }\n        xor_bytes(ts, es, STATE_LEN);\n        Encode(ts, ts);\n        /* apply fix1 */\n        es[0] |= 0x80;\n        pstate2(\"After applying fix1:\", es);\n        Encode(es, es);\n        pc += STATE_LEN;\n    }\n\n    /* process the last block */\n    unsigned long long lastblocklen = mlen - pc;\n    if(enc_dec == ENC){ // encryption\n        xor_bytes(es, pt+pc, lastblocklen);\n        pstate2(\"After xoring last partial message block:\", es);\n        memcpy(ct+pc, es, lastblocklen);\n    }\n    else{ // decryption\n        xor_bytes2(pt+pc, ct+pc, es, lastblocklen);\n        pstate2(\"After xoring last partial ciphertext block:\", es);\n        memcpy(es, ct+pc, lastblocklen);\n    }\n    xor_bytes(ts, es, lastblocklen);\n    pstate2(\"tag state:\", ts);\n    if(lastblocklen != STATE_LEN){ // apply f2\n        /* apply padding only when last message block is not full */\n        ts[lastblocklen] ^= 0x80;\n        word* wd = (word*) ts;\n        f2(wd[0], wd[1], wd[2], wd[3]);\n    }\n    else{ // apply f1\n        word* wd = (word*) ts;\n        f1(wd[0], wd[1], wd[2], wd[3]);\n    }\n\n    pstate2(\"After applying f1/f2:\", ts);\n    Encode(ts, ts);\n    memcpy(tag, ts, tlen);\n\n    return SUCCESS;\n}\n\n\n} // namespace Twine80n6clocv1_raw\n"
        },
        {
            "file_name": "twine80n6clocv1_twine.cpp",
            "content": "/* Copyright (c) 2014, NEC Corporation. All rights reserved.\n*\n* LICENSE\n*\n* 1. NEC Corporation (\"NEC\") hereby grants users to use and reproduce\n*twine program (\"Software\") for testing and evaluation purpose for\n*CAESAR (Competition for Authenticated Encryption: Security, Applicability,\n*and Robustness). The users must not use the Software for any other purpose\n*or distribute it to any third party.\n*\n* 2. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n*OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n*FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL NEC\n*BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, OR CONSEQUENTIAL\n*DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n*ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OF THE\n*SOFTWARE.\n*\n* 3. In the event of an user's failure to comply with any term of this License\n*or wrongful act, NEC may terminate such user's use of the Software. Upon such\n*termination the user must cease all use of the Software and destroy all copies\n*of the Software.\n*\n* 4. The users shall comply with all applicable laws and regulations, including\n*export and import control laws, which govern the usage of the Software.\n*/\n\n#include <stdio.h>\n#include \"twine80n6clocv1_twine.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Twine80n6clocv1_raw {\n\nconst uint8 S[16] = {\n    0xc, 0x0, 0xf, 0xa, 0x2, 0xb, 0x9, 0x5,\n    0x8, 0x3, 0xd, 0x7, 0x1, 0xe, 0x6, 0x4\n};\n\n// Key schedule constants\nconst uint8 CON_H[ROUND-1] = {0,0,0,1,2,4,0,0,1,3,6,4,0,1,2,5,2,4,1,3,7,7,6,5,2,4,0,1,3,7,6,4,1,2,4};  // HIGH 3-bit\nconst uint8 CON_L[ROUND-1] = {1,2,4,0,0,0,3,6,4,0,0,3,5,2,4,0,3,6,7,6,4,3,5,1,1,2,7,6,4,0,3,5,1,2,4};  // LOW 3-bit\n\nuint8\tek[ROUND][8]; \t\t\t\t\t// Extended key area: 4bit x Round\n\n/** Encryption **/\nvoid Encode(uint8 text[8], uint8 cipher[8])\n{\n#ifdef _PRINT\n    printf(\"Twine  input: \");\n    pstate(text, 8);\n#endif\n    uint8\ti;\n    uint8\tdata1[16], tmp;\n\n    //Set plaintext\n    data1[0] = text[0]>>4;\n    data1[1] = text[0]&0xf;\n    data1[2] = text[1]>>4;\n    data1[3] = text[1]&0xf;\n    data1[4] = text[2]>>4;\n    data1[5] = text[2]&0xf;\n    data1[6] = text[3]>>4;\n    data1[7] = text[3]&0xf;\n    data1[8] = text[4]>>4;\n    data1[9] = text[4]&0xf;\n    data1[10] = text[5]>>4;\n    data1[11] = text[5]&0xf;\n    data1[12] = text[6]>>4;\n    data1[13] = text[6]&0xf;\n    data1[14] = text[7]>>4;\n    data1[15] = text[7]&0xf;\n\n    //Round functions\n    for(i=0; ; i++)\n    {\n        data1[1] ^= S[data1[0] ^ ek[i][0]];\n        data1[3] ^= S[data1[2] ^ ek[i][1]];\n        data1[5] ^= S[data1[4] ^ ek[i][2]];\n        data1[7] ^= S[data1[6] ^ ek[i][3]];\n        data1[9] ^= S[data1[8] ^ ek[i][4]];\n        data1[11] ^= S[data1[10] ^ ek[i][5]];\n        data1[13] ^= S[data1[12] ^ ek[i][6]];\n        data1[15] ^= S[data1[14] ^ ek[i][7]];\n\n        i++;\n        data1[2] ^= S[data1[1] ^ ek[i][0]];\n        data1[6] ^= S[data1[11] ^ ek[i][1]];\n        data1[0] ^= S[data1[3] ^ ek[i][2]];\n        data1[4] ^= S[data1[9] ^ ek[i][3]];\n        data1[10] ^= S[data1[7] ^ ek[i][4]];\n        data1[14] ^= S[data1[13] ^ ek[i][5]];\n        data1[8] ^= S[data1[5] ^ ek[i][6]];\n        data1[12] ^= S[data1[15] ^ ek[i][7]];\n\n        if(i == (ROUND-1))\n            break;\n\n        tmp = data1[0];\n        data1[0] = data1[2];\n        data1[2] = data1[14];\n        data1[14] = data1[12];\n        data1[12] = tmp;\n\n        tmp = data1[1];\n        data1[1] = data1[11];\n        data1[11] = data1[15];\n        data1[15] = data1[5];\n        data1[5] = tmp;\n\n        tmp = data1[3];\n        data1[3] = data1[9];\n        data1[9] = data1[13];\n        data1[13] = data1[7];\n        data1[7] = tmp;\n\n        tmp = data1[4];\n        data1[4] = data1[6];\n        data1[6] = data1[10];\n        data1[10] = data1[8];\n        data1[8] = tmp;\n    }\n\n    //Set ciphertext\n    cipher[0] = (data1[1]<<4) ^ data1[2];\n    cipher[1] = (data1[11]<<4) ^ data1[6];\n    cipher[2] = (data1[3]<<4) ^ data1[0];\n    cipher[3] = (data1[9]<<4) ^ data1[4];\n    cipher[4] = (data1[7]<<4) ^ data1[10];\n    cipher[5] = (data1[13]<<4) ^ data1[14];\n    cipher[6] = (data1[5]<<4) ^ data1[8];\n    cipher[7] = (data1[15]<<4) ^ data1[12];\n#ifdef _PRINT\n    printf(\"Twine output: \");\n    pstate(cipher, 8);\n#endif\n}\n\n/** Decryption **/\nvoid Decode(uint8 cipher[8], uint8 text[8])\n{\n    uint8\ti, tmp;\n    uint8\tdata1[16];\n\n    //Set ciphertext\n    data1[0] = cipher[0]>>4;\n    data1[1] = cipher[0]&0xf;\n    data1[2] = cipher[1]>>4;\n    data1[3] = cipher[1]&0xf;\n    data1[4] = cipher[2]>>4;\n    data1[5] = cipher[2]&0xf;\n    data1[6] = cipher[3]>>4;\n    data1[7] = cipher[3]&0xf;\n    data1[8] = cipher[4]>>4;\n    data1[9] = cipher[4]&0xf;\n    data1[10] = cipher[5]>>4;\n    data1[11] = cipher[5]&0xf;\n    data1[12] = cipher[6]>>4;\n    data1[13] = cipher[6]&0xf;\n    data1[14] = cipher[7]>>4;\n    data1[15] = cipher[7]&0xf;\n\n    //Round functions\n    for(i=ROUND-1; ; i--)\n    {\n        data1[1] ^= S[data1[0] ^ ek[i][0]];\n        data1[3] ^= S[data1[2] ^ ek[i][1]];\n        data1[5] ^= S[data1[4] ^ ek[i][2]];\n        data1[7] ^= S[data1[6] ^ ek[i][3]];\n        data1[9] ^= S[data1[8] ^ ek[i][4]];\n        data1[11] ^= S[data1[10] ^ ek[i][5]];\n        data1[13] ^= S[data1[12] ^ ek[i][6]];\n        data1[15] ^= S[data1[14] ^ ek[i][7]];\n\n        i--;\n        data1[0] ^= S[data1[5] ^ ek[i][0]];\n        data1[4] ^= S[data1[1] ^ ek[i][1]];\n        data1[12] ^= S[data1[7] ^ ek[i][2]];\n        data1[8] ^= S[data1[3] ^ ek[i][3]];\n        data1[6] ^= S[data1[13] ^ ek[i][4]];\n        data1[2] ^= S[data1[9] ^ ek[i][5]];\n        data1[10] ^= S[data1[15] ^ ek[i][6]];\n        data1[14] ^= S[data1[11] ^ ek[i][7]];\n\n        if(i == 0)\n            break;\n\n        tmp = data1[1];\n        data1[1] = data1[5];\n        data1[5] = data1[15];\n        data1[15] = data1[11];\n        data1[11] = tmp;\n\n        tmp = data1[3];\n        data1[3] = data1[7];\n        data1[7] = data1[13];\n        data1[13] = data1[9];\n        data1[9] = tmp;\n\n        tmp = data1[0];\n        data1[0] = data1[12];\n        data1[12] = data1[14];\n        data1[14] = data1[2];\n        data1[2] = tmp;\n\n        tmp = data1[4];\n        data1[4] = data1[8];\n        data1[8] = data1[10];\n        data1[10] = data1[6];\n        data1[6] = tmp;\n    }\n\n    //Set plaintext\n    text[0] = (data1[5]<<4) ^ data1[0];\n    text[1] = (data1[1]<<4) ^ data1[4];\n    text[2] = (data1[7]<<4) ^ data1[12];\n    text[3] = (data1[3]<<4) ^ data1[8];\n    text[4] = (data1[13]<<4) ^ data1[6];\n    text[5] = (data1[9]<<4) ^ data1[2];\n    text[6] = (data1[15]<<4) ^ data1[10];\n    text[7] = (data1[11]<<4) ^ data1[14];\n}\n\n/** 80-bit Key schedule for single-block **/\nvoid Keyschedule80(const uint8 sk[80/8])\n{\n    int\ti;\n    uint8\ttmp[80/4];\n    uint8\twk[4];\n\n    //Copy the key\n#if 1\n    for(i=0; i<(80/4); i+=2)\n    {\n        tmp[i] = sk[i/2] >> 4;\n        tmp[i+1] = sk[i/2] & 0x0f;\n    }\n#else\n    tmp[0] = sk[0] >> 4;\n    tmp[1] = sk[0] & 0x0f;\n    tmp[2] = sk[1] >> 4;\n    tmp[3] = sk[1] & 0x0f;\n    tmp[4] = sk[2] >> 4;\n    tmp[5] = sk[2] & 0x0f;\n    tmp[6] = sk[3] >> 4;\n    tmp[7] = sk[3] & 0x0f;\n    tmp[8] = sk[4] >> 4;\n    tmp[9] = sk[4] & 0x0f;\n    tmp[10] = sk[5] >> 4;\n    tmp[11] = sk[5] & 0x0f;\n    tmp[12] = sk[6] >> 4;\n    tmp[13] = sk[6] & 0x0f;\n    tmp[14] = sk[7] >> 4;\n    tmp[15] = sk[7] & 0x0f;\n    tmp[16] = sk[8] >> 4;\n    tmp[17] = sk[8] & 0x0f;\n    tmp[18] = sk[9] >> 4;\n    tmp[19] = sk[9] & 0x0f;\n#endif\n\n    //Extended key (ek) generation\n    for(i=0; ; i+=2)\n    {\n        //ek for two rounds\n        ek[i][0] = tmp[1];\n        ek[i][1] = tmp[3];\n        ek[i][2] = tmp[4];\n        ek[i][3] = tmp[6];\n        ek[i][4] = tmp[13];\n        ek[i][5] = tmp[14];\n        ek[i][6] = tmp[15];\n        ek[i][7] = tmp[16];\n\n        ek[i+1][0] = tmp[5];\n        ek[i+1][1] = tmp[7] ^ CON_H[i];\n        ek[i+1][2] = tmp[8];\n        ek[i+1][3] = tmp[10];\n        ek[i+1][4] = tmp[17];\n        ek[i+1][5] = tmp[18];\n        ek[i+1][6] = tmp[19] ^ CON_L[i];\n        ek[i+1][7] = tmp[1] ^ S[tmp[0]];\n\n        //to the last two rounds\n        if(i == (ROUND-2))\n            break;\n\n        //rotations for two rounds\n        wk[3] = tmp[4] ^ S[tmp[16]];\n        wk[0] = tmp[5] ^ S[wk[3]];\n        wk[1] = tmp[6];\n        wk[2] = ek[i+1][1];\n\n        tmp[4] = tmp[12];\n        tmp[5] = tmp[13];\n        tmp[6] = tmp[14];\n        tmp[7] = tmp[15];\n\n        tmp[12] = ek[i+1][7];\n        tmp[13] = tmp[2];\n        tmp[14] = tmp[3];\n        tmp[15] = tmp[0] ^ CON_L[i+1];\n\n        tmp[0] = tmp[8] ^ S[ek[i+1][7]];\n        tmp[1] = tmp[9];\n        tmp[2] = tmp[10];\n        tmp[3] = tmp[11] ^ CON_H[i+1];\n\n        tmp[8] = tmp[16];\n        tmp[9] = tmp[17];\n        tmp[10] = tmp[18];\n        tmp[11] = tmp[19] ^ CON_L[i];\n\n        tmp[16] = wk[0];\n        tmp[17] = wk[1];\n        tmp[18] = wk[2];\n        tmp[19] = wk[3];\n    }\n}\n\n/** 128-bit Key schedule for single-block **/\nvoid Keyschedule128(const uint8 sk[128/4])\n{\n    int\ti;\n    uint8\ttmp[128/4];\n    uint8\twk[5];\n\n    //Copy the key\n#if 1\n    for(i=0; i<(128/4); i+=2)\n    {\n        tmp[i] = sk[i/2] >> 4;\n        tmp[i+1] = sk[i/2] & 0x0f;\n    }\n#else\n    tmp[0] = sk[0] >> 4;\n    tmp[1] = sk[0] & 0x0f;\n    tmp[2] = sk[1] >> 4;\n    tmp[3] = sk[1] & 0x0f;\n    tmp[4] = sk[2] >> 4;\n    tmp[5] = sk[2] & 0x0f;\n    tmp[6] = sk[3] >> 4;\n    tmp[7] = sk[3] & 0x0f;\n    tmp[8] = sk[4] >> 4;\n    tmp[9] = sk[4] & 0x0f;\n    tmp[10] = sk[5] >> 4;\n    tmp[11] = sk[5] & 0x0f;\n    tmp[12] = sk[6] >> 4;\n    tmp[13] = sk[6] & 0x0f;\n    tmp[14] = sk[7] >> 4;\n    tmp[15] = sk[7] & 0x0f;\n    tmp[16] = sk[8] >> 4;\n    tmp[17] = sk[8] & 0x0f;\n    tmp[18] = sk[9] >> 4;\n    tmp[19] = sk[9] & 0x0f;\n    tmp[20] = sk[10] >> 4;\n    tmp[21] = sk[10] & 0x0f;\n    tmp[22] = sk[11] >> 4;\n    tmp[23] = sk[11] & 0x0f;\n    tmp[24] = sk[12] >> 4;\n    tmp[25] = sk[12] & 0x0f;\n    tmp[26] = sk[13] >> 4;\n    tmp[27] = sk[13] & 0x0f;\n    tmp[28] = sk[14] >> 4;\n    tmp[29] = sk[14] & 0x0f;\n    tmp[30] = sk[15] >> 4;\n    tmp[31] = sk[15] & 0x0f;\n#endif\n\n    //Extended key (ek) generation\n    for(i=0; ; i+=2)\n    {\n        //ek for two rounds\n        ek[i][0] = tmp[2];\n        ek[i][1] = tmp[3];\n        ek[i][2] = tmp[12];\n        ek[i][3] = tmp[15];\n        ek[i][4] = tmp[17];\n        ek[i][5] = tmp[18];\n        ek[i][6] = tmp[28];\n        ek[i][7] = tmp[31];\n\n        ek[i+1][0] = tmp[6];\n        ek[i+1][1] = tmp[7] ^ CON_H[i];\n        ek[i+1][2] = tmp[16];\n        ek[i+1][3] = tmp[19] ^ CON_L[i];\n        ek[i+1][4] = tmp[21];\n        ek[i+1][5] = tmp[22];\n        ek[i+1][6] = tmp[1] ^ S[tmp[0]];\n        ek[i+1][7] = tmp[0];\n\n        //to the last two rounds\n        if(i == (ROUND-2))\n            break;\n\n        //rotations for two rounds\n        wk[3] = tmp[4] ^ S[tmp[16]];\n        wk[0] = tmp[5] ^ S[wk[3]];\n        wk[1] = tmp[6];\n        wk[2] = tmp[7] ^ CON_H[i];\n\n        tmp[4] = tmp[12];\n        tmp[5] = tmp[13];\n        tmp[6] = tmp[14];\n        tmp[7] = tmp[15];\n\n        tmp[12] = tmp[20];\n        tmp[13] = tmp[21];\n        tmp[14] = tmp[22];\n        tmp[15] = tmp[23] ^ S[tmp[30]] ^ CON_L[i+1];\n\n        wk[4] = tmp[20];\n        tmp[20] = tmp[28];\n        tmp[21] = tmp[29];\n        tmp[22] = tmp[30];\n        tmp[23] = tmp[31];\n\n        tmp[28] = wk[0];\n        tmp[29] = wk[1];\n        tmp[30] = wk[2];\n        tmp[31] = wk[3];\n\n\n        wk[3] = tmp[0];\n        wk[0] = ek[i+1][6];\n        wk[1] = tmp[2];\n        wk[2] = tmp[3];\n\n        tmp[0] = tmp[8] ^ S[wk[4]];\n        tmp[1] = tmp[9];\n        tmp[2] = tmp[10];\n        tmp[3] = tmp[11] ^ CON_H[i+1];\n\n        tmp[8] = tmp[16];\n        tmp[9] = tmp[17];\n        tmp[10] = tmp[18];\n        tmp[11] = tmp[19] ^ CON_L[i];\n\n        tmp[16] = tmp[24];\n        tmp[17] = tmp[25];\n        tmp[18] = tmp[26];\n        tmp[19] = tmp[27] ^ S[wk[2]];\n\n        tmp[24] = wk[0];\n        tmp[25] = wk[1];\n        tmp[26] = wk[2];\n        tmp[27] = wk[3];\n    }\n}\n\nint Keyschedule(const uint32 key_len, const uint8 sk[128/8])\n{\n    if(key_len == 80)\n        Keyschedule80(sk);\n    else if(key_len == 128)\n        Keyschedule128(sk);\n    else\n        return -1;\n\n    return 0;\n}\n\n} // namespace Twine80n6clocv1_raw\n"
        },
        {
            "file_name": "twocats-blake2b.c",
            "content": "#include \"twocats-internal.h\"\n\n#if defined(__AVX2__) || defined(__SSE2__)\n#include \"../blake2-sse/blake2b.c\"\n#else\n#include \"../blake2-ref/blake2b-ref.c\"\n#endif\n\n// Initilized the state.\nstatic bool init(TwoCats_H *H) {\n    return !blake2b_init(&(H->c.blake2bState), 64);\n}\n\n// Update the state.\nstatic bool update(TwoCats_H *H, const uint8_t *data, uint32_t dataSize) {\n    return !blake2b_update(&(H->c.blake2bState), data, dataSize);\n}\n\n// Finalize and write out the result.\nstatic bool final(TwoCats_H *H, uint8_t *hash) {\n    return !blake2b_final(&(H->c.blake2bState), hash, 64);\n}\n\n// Initialize the hashing object for Blake2b hashing.\nvoid TwoCats_InitBlake2b(TwoCats_H *H) {\n    H->name = \"blake2b\";\n    H->size = 64;\n    H->Init = init;\n    H->Update = update;\n    H->Final = final;\n}\n\n"
        },
        {
            "file_name": "twocats-blake2s.c",
            "content": "#include \"twocats-internal.h\"\n\n#if defined(__AVX2__) || defined(__SSE2__)\n#include \"../blake2-sse/blake2s.c\"\n#else\n#include \"../blake2-ref/blake2s-ref.c\"\n#endif\n\n// Initilized the state.\nstatic bool init(TwoCats_H *H) {\n    return !blake2s_init(&(H->c.blake2sState), 32);\n}\n\n// Update the state.\nstatic bool update(TwoCats_H *H, const uint8_t *data, uint32_t dataSize) {\n    return !blake2s_update(&(H->c.blake2sState), data, dataSize);\n}\n\n// Finalize and write out the result.\nstatic bool final(TwoCats_H *H, uint8_t *hash) {\n    return !blake2s_final(&(H->c.blake2sState), hash, 32);\n}\n\n// Initialize the hashing object for Blake2s hashing.\nvoid TwoCats_InitBlake2s(TwoCats_H *H) {\n    H->name = \"blake2s\";\n    H->size = 32;\n    H->Init = init;\n    H->Update = update;\n    H->Final = final;\n}\n\n"
        },
        {
            "file_name": "twocats-common.c",
            "content": "/*\n   TwoCats common functions between reference and optimized C versions.\n\n   Written in 2014 by Bill Cox <waywardgeek@gmail.com>\n\n   To the extent possible under law, the author(s) have dedicated all copyright\n   and related and neighboring rights to this software to the public domain\n   worldwide. This software is distributed without any warranty.\n\n   You should have received a copy of the CC0 Public Domain Dedication along with\n   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <time.h>\n#include \"twocats-internal.h\"\n\n// Print the state.\nvoid TwoCats_PrintState(char *message, uint32_t *state, uint32_t length) {\n    printf(\"%s\\n\", message);\n    for(uint32_t i = 0; i < length; i++) {\n        printf(\"%u \", state[i]);\n    }\n    printf(\"\\n\");\n}\n\n// Print a value out in hex - from Catena.\nvoid TwoCats_PrintHex(char *message, uint8_t *x, int len) {\n    puts(message);\n    for(uint32_t i = 0; i < len; i++) {\n        if(i != 0 && i % 8 == 0) {\n            puts(\"\");\n        }\n        printf(\"%02x \", x[i]);\n    }\n    printf(\"     %d (octets)\\n\\n\", len);\n}\n\n// Just dump memory in a format that can be passed to the dieharder tests with:\n//   dieharder -a -g 202 -f dieharder_data\nvoid TwoCats_DumpMemory(char *fileName, uint32_t *mem, uint64_t memlen) {\n    FILE *file = fopen(fileName, \"w\");\n    if(file == NULL) {\n        fprintf(stderr, \"Unable to open file %s for writing\\n\", fileName);\n        return;\n    }\n    fprintf(file, \"type: d\\n\");\n    fprintf(file, \"count: %lu\\n\", memlen);\n    fprintf(file, \"numbit: 32\\n\");\n    for(uint64_t i = 0; i < memlen; i++) {\n        fprintf(file, \"%u\\n\", mem[i]);\n    }\n    fclose(file);\n}\n\n// Hash a 32-bit value into the current state.\nstatic bool updateUint32(TwoCats_H *H, uint32_t value) {\n    uint8_t buf[sizeof(uint32_t)];\n    encodeLittleEndian(buf, &value, 4);\n    if(!H->Update(H, buf, sizeof(uint32_t))) {\n        return false;\n    }\n    return true;\n}\n\n// Scramble the hash value.\nstatic bool scrambleHash(TwoCats_H *H, uint32_t *hash32) {\n    uint8_t buf[H->size];\n    encodeLittleEndian(buf, hash32, H->size);\n    if(!H->Init(H) || !H->Update(H, buf, H->size) || !H->Final(H, buf)) {\n        secureZeroMemory(buf, H->size);\n        return false;\n    }\n    decodeLittleEndian(hash32, buf, H->size);\n    secureZeroMemory(buf, H->size);\n    return true;\n}\n\n// Scramble the 32-bit hash state, including a single uint32_t value.\nstatic bool hashState(TwoCats_H *H, uint32_t *state, uint32_t value) {\n    uint8_t buf[H->size];\n    encodeLittleEndian(buf, state, H->size);\n    if(!H->Init(H) || !H->Update(H, buf, H->size) ||\n            !H->UpdateUint32(H, value) || !H->Final(H, buf)) {\n        secureZeroMemory(buf, H->size);\n        return false;\n    }\n    decodeLittleEndian(state, buf, H->size);\n    secureZeroMemory(buf, H->size);\n    return true;\n}\n\n// Expand a fixed length hash to a variable length hash of uint32_t's.\nstatic bool expandUint32(TwoCats_H *H, uint32_t *out, uint32_t outlen, const uint32_t *hash32) { \n    for(uint32_t i = 0; i < outlen/H->len; i++) {\n        memcpy(out + i*H->len, hash32, H->len*sizeof(uint32_t));\n        if(!hashState(H, out + i*H->len, i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Finalize a hash and convert to an array of uint32_t.\nstatic bool finalUint32(TwoCats_H *H, uint32_t *hash32) {\n    uint8_t buf[H->size];\n    if(!H->Final(H, buf)) {\n        secureZeroMemory(buf, H->size);\n        return false;\n    }\n    decodeLittleEndian(hash32, buf, H->size);\n    secureZeroMemory(buf, H->size);\n    return true;\n}\n\n// Initialize a hashing object.\nvoid TwoCats_InitHash(TwoCats_H *H, TwoCats_HashType type) {\n    memset(H, 0, sizeof(TwoCats_H));\n    H->type = type;\n    H->UpdateUint32 = updateUint32;\n    H->Hash = scrambleHash;\n    H->HashState = hashState;\n    H->FinalUint32 = finalUint32;\n    H->ExpandUint32 = expandUint32;\n    switch(type) {\n    case TWOCATS_BLAKE2S: TwoCats_InitBlake2s(H); break;\n    case TWOCATS_BLAKE2B: TwoCats_InitBlake2b(H); break;\n    case TWOCATS_SHA256: TwoCats_InitSHA256(H); break;\n    case TWOCATS_SHA512: TwoCats_InitSHA512(H); break;\n    default:\n        fprintf(stderr, \"Unknown hash type\\n\");\n        exit(1);\n    }\n    H->len = H->size/4;\n}\n\n// Just return the hash type's name.\nchar *TwoCats_GetHashTypeName(TwoCats_HashType hashType) {\n    TwoCats_H H;\n    TwoCats_InitHash(&H, hashType);\n    return H.name;\n}\n\n// Return the size of the hash type.\nuint8_t TwoCats_GetHashTypeSize(TwoCats_HashType hashType) {\n    TwoCats_H H;\n    TwoCats_InitHash(&H, hashType);\n    return H.size;\n}\n\n// Find a hash type with the given name.\nTwoCats_HashType TwoCats_FindHashType(char *name) {\n    TwoCats_H H;\n    for(uint32_t i = 0; i < TWOCATS_NONE; i++) {\n        TwoCats_InitHash(&H, i);\n        if(!strcmp(H.name, name)) {\n            return i;\n        }\n    }\n    return TWOCATS_NONE;\n}\n\n// Verify that parameters are valid for password hashing.\nstatic bool verifyParameters(TwoCats_H *H, uint8_t startMemCost, uint8_t stopMemCost,\n        uint8_t timeCost, uint8_t multiplies, uint8_t lanes, uint8_t parallelism,\n        uint32_t blockSize, uint32_t subBlockSize) {\n\n    if(H->len < lanes || lanes == 0) {\n        fprintf(stderr, \"Invalid lanes size: the range is 1 through %u for %s\\n\", H->len,\n            TwoCats_GetHashTypeName(H->type));\n        return false;\n    }\n    if(startMemCost > stopMemCost) {\n        fprintf(stderr, \"startMemCost must be <= stopMemCost\\n\");\n        return false;\n    }\n    if(stopMemCost > 30) {\n        fprintf(stderr, \"stopMemCost must be <= 30\\n\");\n        return false;\n    }\n    if(timeCost > 30) {\n        fprintf(stderr, \"timeCost must be <= 30\\n\");\n        return false;\n    }\n    if(multiplies > 8) {\n        fprintf(stderr, \"multiplies must be <= 8\\n\");\n        return false;\n    }\n    if(parallelism == 0) {\n        fprintf(stderr, \"parallelism must be from 1 to 255\\n\");\n        return false;\n    }\n    if(blockSize > (1 << 20)) {\n        fprintf(stderr, \"blockSize must be a power of 2 from 32 to 2^20\\n\");\n        return false;\n    }\n    if(subBlockSize < 32 || subBlockSize > blockSize) {\n        fprintf(stderr, \"subBlockSize must be a power of 2 from 32 to blockSize.\\n\");\n        return false;\n    }\n    while(!(blockSize & 1)) {\n        blockSize >>= 1;\n    }\n    while(!(subBlockSize & 1)) {\n        subBlockSize >>= 1;\n    }\n    if(blockSize != 1) {\n        fprintf(stderr, \"blockSize must be a power of 2 from 32 to 2^20\\n\");\n        return false;\n    }\n    if(subBlockSize != 1) {\n        fprintf(stderr, \"subBlockSize must be a power of 2 from 32 to blockSize.\\n\");\n        return false;\n    }\n    return true;\n}\n\n// A simple password hashing interface.\nbool TwoCats_HashPassword(TwoCats_HashType hashType, uint8_t *hash, uint8_t *password,\n        uint32_t passwordSize, const uint8_t *salt, uint32_t saltSize, uint8_t memCost,\n        bool clearPassword) {\n    return TwoCats_HashPasswordFull(hashType, hash, password, passwordSize,\n        salt, saltSize, memCost, 0, TWOCATS_PARALLELISM, clearPassword);\n}\n\n// The full password hashing interface.  \nbool TwoCats_HashPasswordFull(TwoCats_HashType hashType, uint8_t *hash, uint8_t *password,\n        uint32_t passwordSize, const uint8_t *salt, uint32_t saltSize, uint8_t memCost,\n        uint8_t timeCost, uint8_t parallelism, bool clearPassword) {\n\n    uint8_t multiplies = 3; // Decent match for Intel Sandy Bridge through Haswell\n    if(memCost <= 4) {\n        multiplies = 1; // Assume it fits in L1 cache\n    } else if(memCost < 10) {\n        multiplies = 2; // Assume it fits in L2 or L3 cache\n    }\n    uint32_t blockSize = TWOCATS_BLOCKSIZE;\n    uint32_t subBlockSize = TWOCATS_SUBBLOCKSIZE;\n    uint64_t memSize = (uint64_t)1024 << memCost;\n    while(blockSize >= 64 && memSize/(parallelism*blockSize) < TWOCATS_MINBLOCKS) {\n        blockSize >>= 1;\n    }\n    if(subBlockSize > blockSize) {\n        subBlockSize = blockSize;\n    }\n    while(parallelism > 1 && memSize/(parallelism*blockSize) < TWOCATS_MINBLOCKS) {\n        parallelism--;\n    }\n    return TwoCats_HashPasswordExtended(hashType, hash, password, passwordSize, salt,\n        saltSize, NULL, 0, memCost, memCost, timeCost, multiplies, TWOCATS_LANES,\n        parallelism, TWOCATS_BLOCKSIZE, TWOCATS_SUBBLOCKSIZE, TWOCATS_OVERWRITECOST,\n        clearPassword, false);\n}\n\n// The extended password hashing interface.  \nbool TwoCats_HashPasswordExtended(TwoCats_HashType hashType, uint8_t *hash, uint8_t *password,\n        uint32_t passwordSize, const uint8_t *salt, uint32_t saltSize, uint8_t *data,\n        uint32_t dataSize, uint8_t startMemCost, uint8_t stopMemCost, uint8_t timeCost,\n        uint8_t multiplies, uint8_t lanes, uint8_t parallelism, uint32_t blockSize,\n        uint32_t subBlocksize, uint8_t overwriteCost, bool clearPassword, bool clearData) {\n\n    if(!TwoCats_ClientHashPassword(hashType, hash, password, passwordSize, salt,\n            saltSize, data, dataSize, startMemCost, stopMemCost, timeCost, multiplies,\n            lanes, parallelism, blockSize, subBlocksize, overwriteCost, clearPassword, clearData)) {\n        return false;\n    }\n    return TwoCats_ServerHashPassword(hashType, hash);\n}\n\n// Update an existing password hash to a more difficult level of memory cost (garlic).\nbool TwoCats_UpdatePassword(TwoCats_HashType hashType, uint8_t *hash, uint8_t oldMemCost,\n        uint8_t newMemCost, uint8_t timeCost, uint8_t multiplies, uint8_t lanes,\n        uint8_t parallelism, uint32_t blockSize, uint32_t subBlockSize) {\n\n    TwoCats_H H;\n    TwoCats_InitHash(&H, hashType);\n    if(!verifyParameters(&H, oldMemCost, newMemCost, timeCost, multiplies, lanes,\n            parallelism, blockSize, subBlockSize)) {\n        return false;\n    }\n    uint32_t hash32[H.len];\n    decodeLittleEndian(hash32, hash, H.size);\n    if(!TwoCats(&H, hash32, oldMemCost, newMemCost, timeCost, multiplies, lanes,\n            parallelism, blockSize, subBlockSize, 0)) {\n        return false;\n    }\n    encodeLittleEndian(hash, hash32, H.size);\n    return TwoCats_ServerHashPassword(hashType, hash);\n}\n\n// Client-side portion of work for server-relief mode.  Return true if there are no memory\n// allocation errors.  The password and data are not cleared if there is an error.\nbool TwoCats_ClientHashPassword(TwoCats_HashType hashType, uint8_t *hash, uint8_t *password,\n        uint32_t passwordSize, const uint8_t *salt, uint32_t saltSize, uint8_t *data,\n        uint32_t dataSize, uint8_t startMemCost, uint8_t stopMemCost, uint8_t timeCost,\n        uint8_t multiplies, uint8_t lanes, uint8_t parallelism, uint32_t blockSize,\n        uint32_t subBlockSize, uint8_t overwriteCost, bool clearPassword, bool clearData) {\n\n    TwoCats_H H;\n    TwoCats_InitHash(&H, hashType);\n    if(!verifyParameters(&H, startMemCost, stopMemCost, timeCost, multiplies, lanes,\n            parallelism, blockSize, subBlockSize)) {\n        return false;\n    }\n\n    // Convert overwiteCost from relative to startMemCost to absolute\n    if(overwriteCost >= startMemCost) {\n        overwriteCost = 0;\n    } else if(overwriteCost != 0) {\n        overwriteCost = startMemCost - overwriteCost;\n    }\n\n    // Add all the inputs, other than stopMemCost\n    uint32_t hash32[H.len];\n    if(!H.Init(&H) || !H.UpdateUint32(&H, passwordSize) ||\n            !H.UpdateUint32(&H, saltSize) || !H.UpdateUint32(&H, dataSize) ||\n            !H.UpdateUint32(&H, blockSize) || !H.UpdateUint32(&H, subBlockSize) ||\n            !H.Update(&H, &startMemCost, 1) || !H.Update(&H, &timeCost, 1) ||\n            !H.Update(&H, &multiplies, 1) || !H.Update(&H, &lanes, 1) ||\n            !H.Update(&H, &parallelism, 1) || !H.Update(&H, &overwriteCost, 1) ||\n            !H.Update(&H, password, passwordSize) || !H.Update(&H, salt, saltSize) ||\n            !H.Update(&H, data, dataSize) || !H.FinalUint32(&H, hash32)) {\n        return false;\n    }\n\n    // Now clear the password and data if allowed\n    if(clearPassword && passwordSize != 0) {\n        secureZeroMemory(password, passwordSize);\n    }\n    if(clearData && dataSize != 0) {\n        secureZeroMemory(data, dataSize);\n    }\n\n    if(!TwoCats(&H, hash32, startMemCost, stopMemCost, timeCost, multiplies,\n            lanes, parallelism, blockSize, subBlockSize, overwriteCost)) {\n        return false;\n    }\n    encodeLittleEndian(hash, hash32, H.size);\n    secureZeroMemory(hash32, H.size);\n    return true;\n}\n\n// Server portion of work for server-relief mode.\nbool TwoCats_ServerHashPassword(TwoCats_HashType hashType, uint8_t *hash) {\n    TwoCats_H H;\n    TwoCats_InitHash(&H, hashType);\n    return H.Init(&H) && H.Update(&H, hash, H.size) && H.Final(&H, hash);\n}\n\n// The SkinnyCat API.\nbool SkinnyCat_HashPassword(TwoCats_HashType hashType, uint8_t *hash, uint8_t *password,\n        uint8_t passwordSize, const uint8_t *salt, uint8_t saltSize, uint8_t memCost,\n        bool clearPassword) {\n    uint32_t blockSize = TWOCATS_BLOCKSIZE;\n    while(blockSize > 32 && ((uint64_t)1024 << memCost)/blockSize < TWOCATS_MINBLOCKS) {\n        blockSize >>= 1;\n    }\n    printf(\"blockSize:%u\\n\", blockSize);\n    return TwoCats_HashPasswordExtended(hashType, hash, password, passwordSize, salt, saltSize, NULL, 0,\n        memCost, memCost, 0, 0, TWOCATS_LANES, 1, blockSize, blockSize, 0, clearPassword, false);\n}\n\n// This is the prototype required for the password hashing competition.\n// t_cost is a multiplier on CPU work.  m_cost is garlic.\n// If possible, call TwoCats_SimpleHashPassword instead so that the password can be cleared.\nint PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen,\n        unsigned int t_cost, unsigned int m_cost) {\n    if(outlen != 32) {\n        fprintf(stderr, \"Expected outlen == 32\\n\");\n        return 1;\n    }\n    return !TwoCats_HashPasswordFull(TWOCATS_HASHTYPE, out, (uint8_t *)in, inlen,\n        salt, saltlen, m_cost, t_cost, TWOCATS_PARALLELISM, false);\n}\n\n// Just measure the time for a given memCost and timeCost.  Return -1 if memory allocation fails.\nstatic clock_t findRuntime(TwoCats_HashType hashType, uint8_t memCost, uint8_t timeCost,\n        uint8_t multiplies, uint8_t lanes) {\n    uint32_t keySize = TwoCats_GetHashTypeSize(hashType);\n    uint8_t buf[keySize];\n    clock_t start = clock();\n    if(!TwoCats_HashPasswordExtended(hashType, buf, NULL, 0, NULL, 0, NULL, 0, memCost,\n            memCost, timeCost, multiplies, lanes, TWOCATS_PARALLELISM, TWOCATS_BLOCKSIZE,\n            TWOCATS_SUBBLOCKSIZE, 0, false, false)) {\n        fprintf(stderr, \"Memory hashing failed\\n\");\n        return -1;\n    }\n    clock_t end = clock();\n    return (end - start) * 1000 / CLOCKS_PER_SEC;\n}\n\n// Find a good memCost for a given time on this machine.  This just finds the largest\n// memCost that runs in less than milliseconds ms.  Return 255 on failure to allocate memory.\nstatic uint8_t findMemCost(TwoCats_HashType hashType, uint32_t milliseconds, uint32_t\n        maxMem, clock_t *finalTime, uint8_t lanes) {\n    // First, find a decent memCost\n    uint8_t memCost = 0;\n    clock_t runtime = findRuntime(hashType, 0, 0, 0, lanes);\n    while(runtime < milliseconds && (1 << memCost) <= maxMem) {\n        memCost++;\n        if(runtime < milliseconds/8) {\n            memCost++;\n        }\n        runtime = findRuntime(hashType, memCost, 0, 0, lanes);\n        //printf(\"New findMemCost runtime: %u\\n\", runtime);\n    }\n    *finalTime = runtime;\n    return memCost;\n}\n\n// Find parameter settings on this machine for a given desired runtime and maximum memory\n// usage.  maxMem is in KiB.  Runtime with be typically +/- 50% and memory will be <= maxMem.\nvoid TwoCats_FindCostParameters(TwoCats_HashType hashType, uint32_t milliseconds, uint32_t\n        maxMem, uint8_t *memCost, uint8_t *timeCost, uint8_t *multiplies, uint8_t *lanes) {\n\n// Lanes is simplest to pick.  If we have good custom code for it, use it.\n#if defined(__AVX2__)\n    *lanes = 8;\n#elif defined(__SSE2__)\n    *lanes = 4;\n#else\n    *lanes = 1;\n#endif\n\n    clock_t runtime;\n    *memCost = findMemCost(hashType, milliseconds/8, maxMem/8, &runtime, *lanes);\n    // Now increase timeCost until we see it beginning to work\n    clock_t initialRuntime = findRuntime(hashType, *memCost, 0, 0, *lanes);\n    clock_t prevRuntime;\n    *timeCost = 0;\n    do {\n        *timeCost += 1;\n        prevRuntime = runtime;\n        runtime = findRuntime(hashType, *memCost, *timeCost, 0, *lanes);\n        //printf(\"Increasing timeCost: %u\\n\", runtime);\n    } while(runtime < 1.05*initialRuntime);\n    *timeCost -= 1;\n    initialRuntime = prevRuntime;\n\n    *multiplies = 0;\n    do {\n        *multiplies += 1;\n        runtime = findRuntime(hashType, *memCost, *timeCost, *multiplies, *lanes);\n        //printf(\"New multiply runtime: %u\\n\", runtime);\n    } while(runtime < 1.05*initialRuntime && *multiplies < 8);\n\n    // Now scale up the memory\n    while(runtime < milliseconds && (1 << *memCost) < maxMem) {\n        //printf(\"Adding 1 to memCost, runtime:%u memCost:%u\\n\", runtime, *memCost);\n        *memCost += 1;\n        runtime *= 1.75;\n    }\n\n    // Increase timeCost if still needed\n    while(runtime < milliseconds) {\n        //printf(\"Adding 1 to timecost\\n\");\n        *timeCost += 1;\n        runtime *= 1.75;\n    }\n}\n"
        },
        {
            "file_name": "twocats-dec.c",
            "content": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <openssl/evp.h>\n#include \"twocats.h\"\n\n#define KEY_SIZE 32\n#define SALT_SIZE 16\n\nstatic void usage(char *format, ...) {\n    va_list ap;\n    va_start(ap, format);\n    vfprintf(stderr, (char *)format, ap);\n    va_end(ap);\n    fprintf(stderr, \"\\nUsage: twocats-dec pasword file.enc\\n\"\n        \"    This will decrypt file to file.enc\\n\"\n        \"    Please use this as example code rather than a real encryption tool\\n\");\n    exit(1);\n}\n\nint main(int argc, char **argv) {\n    if(argc != 3) {\n        usage(\"Invalid number of arguments\");\n    }\n    char *password = argv[1];\n    char *inFileName = argv[2];\n    uint8_t salt[SALT_SIZE];\n    uint8_t key[KEY_SIZE];\n\n    if(strlen(inFileName) < 5 || strcmp(inFileName + strlen(inFileName) - 4, \".enc\")) {\n        fprintf(stderr, \"Input file must end in .enc\\n\");\n        return 1;\n    }\n    FILE *inFile = fopen(inFileName, \"r\");\n    if(inFile == NULL) {\n        fprintf(stderr, \"Unable to open file %s\\n\", inFileName);\n        return 1;\n    }\n    char outFileName[strlen(inFileName)];\n    strcpy(outFileName, inFileName);\n    outFileName[strlen(inFileName) - 4] = '\\0';\n    FILE *outFile = fopen(outFileName, \"w\");\n    if(outFile == NULL) {\n        fprintf(stderr, \"Unable to open file %s for writing\\n\", outFileName);\n        return 1;\n    }\n\n    // Read the file header: salt, key, memCost, timeCost\n    uint8_t timeCost, memCost, multiplies, lanes;\n    if(fread(salt, sizeof(uint8_t), SALT_SIZE, inFile) != SALT_SIZE ||\n            fread(&memCost, sizeof(uint8_t), 1, inFile) != 1 ||\n            fread(&timeCost, sizeof(uint8_t), 1, inFile) != 1 ||\n            fread(&multiplies, sizeof(uint8_t), 1, inFile) != 1 ||\n            fread(&lanes, sizeof(uint8_t), 1, inFile) != 1) {\n        fprintf(stderr, \"Input file too short\\n\");\n        return 1;\n    }\n\n    if(!TwoCats_HashPasswordExtended(TWOCATS_HASHTYPE, key, (uint8_t *)password, strlen(password),\n            salt, SALT_SIZE, NULL, 0, memCost, memCost, timeCost, multiplies, lanes, TWOCATS_PARALLELISM,\n            TWOCATS_BLOCKSIZE, TWOCATS_SUBBLOCKSIZE, TWOCATS_OVERWRITECOST, false, false)) {\n        fprintf(stderr, \"Unable to hash password - memory allocation failed\\n\");\n        return 1;\n    }\n\n    // Initialize encrpytion\n    EVP_CIPHER_CTX ctx;\n    uint8_t out[32]; /* at least one block longer than in[] */\n    EVP_DecryptInit(&ctx, EVP_aes_256_cbc(), key, salt);\n\n    // Encrypt input stream to output stream\n    int outlen;\n    int c;\n    while((c = getc(inFile)) != EOF) {\n        uint8_t buf = c;\n        EVP_DecryptUpdate(&ctx, out, &outlen, &buf, sizeof(uint8_t));\n        if(outlen != 0) {\n            fwrite(out, sizeof(uint8_t), outlen, outFile);\n        }\n    }\n\n    // Finalize encryption\n    EVP_DecryptFinal(&ctx, out, &outlen);\n    if(outlen != 0) {\n        fwrite(out, sizeof(uint8_t), outlen, outFile);\n    }\n    fclose(outFile);\n    fclose(inFile);\n\n    return 0;\n}\n"
        },
        {
            "file_name": "twocats-enc.c",
            "content": "#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <openssl/evp.h>\n#include \"twocats.h\"\n\n#define KEY_SIZE 32\n#define SALT_SIZE 16\n\nstatic void usage(char *format, ...) {\n    va_list ap;\n    va_start(ap, format);\n    vfprintf(stderr, (char *)format, ap);\n    va_end(ap);\n    fprintf(stderr, \"\\nUsage: twocats-enc pasword file\\n\"\n        \"    This will create file.enc, encrypted with AES-256 in CBC mode.\\n\"\n        \"    Please use this as example code rather than a real encryption tool\\n\");\n    exit(1);\n}\n\n// Read from /dev/urandom to find a salt.\nstatic void genSalt(uint8_t *salt) {\n    FILE *randFile = fopen(\"/dev/urandom\", \"r\");\n    if(randFile == NULL) {\n        fprintf(stderr, \"Unable to open random /dev/urandom\\n\");\n        exit(1);\n    }\n    for(uint32_t i = 0; i < SALT_SIZE; i++) {\n        salt[i] = getc(randFile);\n    }\n    fclose(randFile);\n}\n\nint main(int argc, char **argv) {\n    if(argc != 3) {\n        usage(\"Invalid number of arguments\");\n    }\n    char *password = argv[1];\n    char *inFileName = argv[2];\n    uint8_t salt[SALT_SIZE];\n    uint8_t key[KEY_SIZE];\n\n    FILE *inFile = fopen(inFileName, \"r\");\n    if(inFile == NULL) {\n        fprintf(stderr, \"Unable to open file %s\\n\", inFileName);\n        return 1;\n    }\n    char outFileName[strlen(inFileName) + 4];\n    strcpy(outFileName, inFileName);\n    strcat(outFileName, \".enc\");\n    FILE *outFile = fopen(outFileName, \"w\");\n    if(outFile == NULL) {\n        fprintf(stderr, \"Unable to open file %s for writing\\n\", outFileName);\n        return 1;\n    }\n\n    // Find out how much memory to use to have 0.5 second of hashing.  Max out at 2GiB.\n    // 1000 means 1000 milliseconds, and 20 means 2^21 KiB max memory == 2 GiB.\n    uint8_t memCost, timeCost, multiplies, lanes;\n    TwoCats_FindCostParameters(TWOCATS_BLAKE2S, 1000, 2*1024*1024, &memCost, &timeCost, &multiplies, &lanes);\n    printf(\"Encrypting with memCost=%u timeCost=%u multiplies=%u lanes=%u\\n\", memCost, timeCost, multiplies, lanes);\n\n    genSalt(salt);\n    if(!TwoCats_HashPasswordExtended(TWOCATS_HASHTYPE, key, (uint8_t *)password, strlen(password),\n            salt, SALT_SIZE, NULL, 0, memCost, memCost, timeCost, multiplies, lanes, TWOCATS_PARALLELISM,\n            TWOCATS_BLOCKSIZE, TWOCATS_SUBBLOCKSIZE, TWOCATS_OVERWRITECOST, false, false)) {\n        fprintf(stderr, \"Unable to hash password - memory allocation failed\\n\");\n        return 1;\n    }\n\n    // Write header: salt, memCost, timeCost, lanes\n    fwrite(salt, sizeof(uint8_t), SALT_SIZE, outFile);\n    fwrite(&memCost, sizeof(uint8_t), 1, outFile);\n    fwrite(&timeCost, sizeof(uint8_t), 1, outFile);\n    fwrite(&multiplies, sizeof(uint8_t), 1, outFile);\n    fwrite(&lanes, sizeof(uint8_t), 1, outFile);\n\n    // Initialize encrpytion\n    EVP_CIPHER_CTX ctx;\n    uint8_t out[32]; /* at least one block longer than in[] */\n    EVP_EncryptInit(&ctx, EVP_aes_256_cbc(), key, salt);\n\n    // Encrypt input stream to output stream\n    int outlen;\n    int c;\n    while((c = getc(inFile)) != EOF) {\n        uint8_t buf = c;\n        EVP_EncryptUpdate(&ctx, out, &outlen, &buf, sizeof(uint8_t));\n        if(outlen != 0) {\n            fwrite(out, sizeof(uint8_t), outlen, outFile);\n        }\n    }\n\n    // Finalize encryption\n    EVP_EncryptFinal(&ctx, out, &outlen);\n    if(outlen != 0) {\n        fwrite(out, sizeof(uint8_t), outlen, outFile);\n    }\n    fclose(outFile);\n    fclose(inFile);\n\n    return 0;\n}\n"
        },
        {
            "file_name": "twocats-ref.c",
            "content": "/*\n   TwoCats reference C implementation\n\n   Written in 2014 by Bill Cox <waywardgeek@gmail.com>\n\n   To the extent possible under law, the author(s) have dedicated all copyright\n   and related and neighboring rights to this software to the public domain\n   worldwide. This software is distributed without any warranty.\n\n   You should have received a copy of the CC0 Public Domain Dedication along with\n   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"twocats-internal.h\"\n\n// Add the last hashed data into the result.\nstatic void addIntoHash(TwoCats_H *H, uint32_t *hash32, uint32_t parallelism, uint32_t *states) {\n    for(uint32_t p = 0; p < parallelism; p++) {\n        for(uint32_t i = 0; i < H->len; i++) {\n            hash32[i] += states[p*H->len + i];\n        }\n    }\n}\n\n// Compute the bit reversal of v.\nstatic uint32_t reverse(uint32_t v, uint32_t numBits) {\n    uint32_t result = 0;\n    while(numBits-- != 0) {\n        result = (result << 1) | (v & 1);\n        v >>= 1;\n    }\n    return result;\n}\n\n// Hash three blocks together with fast SSE friendly hash function optimized for high memory bandwidth.\nstatic bool hashBlocks(TwoCats_H *H, uint32_t *state, uint32_t *mem, uint32_t blocklen,\n        uint32_t subBlocklen, uint64_t fromAddr, uint64_t prevAddr, uint64_t toAddr,\n        uint32_t multiplies, uint32_t repetitions, uint8_t lanes) {\n\n    // Do SIMD friendly memory hashing and a scalar CPU friendly parallel multiplication chain\n    uint32_t numSubBlocks = blocklen/subBlocklen;\n    uint32_t a = state[0];\n    uint32_t b = state[1];\n    uint32_t c = state[2];\n    uint32_t d = state[3];\n\n    for(uint32_t r = 0; r < repetitions; r++) {\n        uint32_t *f = mem + fromAddr;\n        uint32_t *t = mem + toAddr;\n        for(uint32_t i = 0; i < numSubBlocks; i++) {\n            uint32_t randVal = *f;\n            uint32_t *p = mem + prevAddr + subBlocklen*(randVal & (numSubBlocks - 1));\n            for(uint32_t j = 0; j < subBlocklen/lanes; j++) {\n\n                // Compute the multiplication chain\n                for(uint32_t k = 0; k < multiplies; k++) {\n                    a ^= (uint64_t)b*c >> 32;\n                    b += c;\n                    c ^= (uint64_t)a*d >> 32;\n                    d += a;\n                }\n\n                // Hash lanes of memory\n                for(uint32_t k = 0; k < lanes; k++) {\n                    state[k] = (state[k] + *p++) ^ *f++;\n                    state[k] = (state[k] >> 24) | (state[k] << 8);\n                    *t++ = state[k];\n                }\n            }\n        }\n    }\n    return H->HashState(H, state, a);\n}\n\n// Hash memory without doing any password dependent memory addressing to thwart cache-timing-attacks.\n// Use Solar Designer's sliding-power-of-two window, with Catena's bit-reversal.\nstatic bool hashWithoutPassword(TwoCats_H *H, uint32_t *state, uint32_t *mem, uint32_t p,\n        uint64_t blocklen, uint32_t blocksPerThread, uint32_t multiplies, uint32_t repetitions,\n        uint8_t lanes, uint32_t parallelism, uint32_t completedBlocks) {\n\n    uint64_t start = blocklen*blocksPerThread*p;\n    uint32_t firstBlock = completedBlocks;\n    if(completedBlocks == 0) {\n        // Initialize the first block of memory\n        if(!H->ExpandUint32(H, mem + start, blocklen, state)) {\n            return false;\n        }\n        firstBlock = 1;\n    }\n\n    // Hash one \"slice\" worth of memory hashing\n    uint32_t numBits = 1; // The number of bits in i\n    for(uint32_t i = firstBlock; i < completedBlocks + blocksPerThread/TWOCATS_SLICES; i++) {\n        while(1 << numBits <= i) {\n            numBits++;\n        }\n\n        // Compute the \"sliding reverse\" block position\n        uint32_t reversePos = reverse(i, numBits-1);\n        if(reversePos + (1 << (numBits-1)) < i) {\n            reversePos += 1 << (numBits-1);\n        }\n        uint64_t fromAddr = blocklen*reversePos;\n\n        // Compute which thread's memory to read from\n        if(fromAddr < completedBlocks*blocklen) {\n            fromAddr += blocklen*blocksPerThread*(i % parallelism);\n        } else {\n            fromAddr += start;\n        }\n\n        uint64_t toAddr = start + i*blocklen;\n        uint64_t prevAddr = toAddr - blocklen;\n        if(!hashBlocks(H, state, mem, blocklen, blocklen, fromAddr, prevAddr, toAddr,\n                multiplies, repetitions, lanes)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Hash memory with password dependent addressing.\nstatic bool hashWithPassword(TwoCats_H *H, uint32_t *state, uint32_t *mem, uint32_t p,\n        uint64_t blocklen, uint32_t subBlocklen, uint32_t blocksPerThread, uint32_t multiplies,\n        uint32_t repetitions, uint8_t lanes, uint32_t parallelism, uint32_t completedBlocks) {\n\n    uint64_t start = blocklen*blocksPerThread*p;\n\n    // Hash one \"slice\" worth of memory hashing\n    for(uint32_t i = completedBlocks; i < completedBlocks + blocksPerThread/TWOCATS_SLICES; i++) {\n\n        // Compute rand()^3 distance distribution\n        uint64_t v = state[0];\n        uint64_t v2 = v*v >> 32;\n        uint64_t v3 = v*v2 >> 32;\n        uint32_t distance = (i-1)*v3 >> 32;\n\n        // Hash the prior block and the block at 'distance' blocks in the past\n        uint64_t fromAddr = (i - 1 - distance)*blocklen;\n\n        // Compute which thread's memory to read from\n        if(fromAddr < completedBlocks*blocklen) {\n            fromAddr += blocklen*(state[1] % parallelism)*blocksPerThread;\n        } else {\n            fromAddr += start;\n        }\n\n        uint64_t toAddr = start + i*blocklen;\n        uint64_t prevAddr = toAddr - blocklen;\n        if(!hashBlocks(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr,\n                multiplies, repetitions, lanes)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Hash memory for one level of garlic.\nstatic bool hashMemory(TwoCats_H *H, uint32_t *hash32, uint32_t *mem, uint8_t memCost,\n        uint8_t timeCost, uint8_t multiplies, uint8_t lanes, uint8_t parallelism,\n        uint32_t blockSize, uint32_t subBlockSize, uint32_t resistantSlices) {\n\n    uint64_t memlen = (1024/sizeof(uint32_t)) << memCost;\n    uint32_t blocklen = blockSize/sizeof(uint32_t);\n    uint32_t subBlocklen = subBlockSize/sizeof(uint32_t);\n    uint32_t blocksPerThread = TWOCATS_SLICES*(memlen/(TWOCATS_SLICES * parallelism * blocklen));\n    uint32_t repetitions = 1 << timeCost;\n\n    // Initialize thread states\n    uint32_t states[H->len*parallelism];\n    if(!H->ExpandUint32(H, states, H->len*parallelism, hash32)) {\n        return false;\n    }\n\n    for(uint32_t slice = 0; slice < TWOCATS_SLICES; slice++) {\n        for(uint32_t p = 0; p < parallelism; p++) {\n            if(slice < resistantSlices) {\n                if(!hashWithoutPassword(H, states + p*H->len, mem, p, blocklen, blocksPerThread, multiplies,\n                        repetitions, lanes, parallelism, slice*blocksPerThread/TWOCATS_SLICES)) {\n                    return false;\n                }\n            } else {\n                if(!hashWithPassword(H, states + p*H->len, mem, p, blocklen, subBlocklen, blocksPerThread,\n                    multiplies, repetitions, lanes, parallelism, slice*blocksPerThread/TWOCATS_SLICES)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    // Apply a crypto-strength hash\n    addIntoHash(H, hash32, parallelism, states);\n    return H->Hash(H, hash32);\n}\n\n// The TwoCats internal password hashing function.  Return false if there is a memory allocation error.\nbool TwoCats(TwoCats_H *H, uint32_t *hash32, uint8_t startMemCost, uint8_t stopMemCost, uint8_t timeCost,\n        uint8_t multiplies, uint8_t lanes, uint8_t parallelism, uint32_t blockSize,\n        uint32_t subBlockSize, uint8_t overwriteCost) {\n\n    // Allocate memory\n    uint32_t *mem = malloc((uint64_t)1024 << stopMemCost);\n    if(mem == NULL) {\n        fprintf(stderr, \"Unable to allocate memory\\n\");\n        return false;\n    }\n\n    // Iterate through the levels of garlic.  Throw away some early memory to reduce the\n    // danger from leaking memory to an attacker.\n    for(uint8_t i = 0; i <= stopMemCost; i++) {\n        if(i >= startMemCost || i < overwriteCost) {\n            if(((uint64_t)1024 << i)/(parallelism*blockSize) >= TWOCATS_SLICES) {\n                uint32_t resistantSlices = TWOCATS_SLICES/2;\n                if(i < startMemCost) {\n                    resistantSlices = TWOCATS_SLICES;\n                }\n                if(!hashMemory(H, hash32, mem, i, timeCost, multiplies, lanes, parallelism,\n                        blockSize, subBlockSize, resistantSlices)) {\n                    return false;\n                }\n            }\n            // Not doing the last hash is for server relief support\n            if(i != stopMemCost && !H->Hash(H, hash32)) {\n                return false;\n            }\n        }\n    }\n\n    // The light is green, the trap is clean\n    //TwoCats_DumpMemory(\"dieharder_data\", mem, ((uint64_t)1024 << stopMemCost)/4);\n    free(mem);\n    return true;\n}\n"
        },
        {
            "file_name": "twocats-sha256.c",
            "content": "#include \"twocats-internal.h\"\n\n// Initilized the state.\nstatic bool init(TwoCats_H *H) {\n    return SHA256_Init(&(H->c.sha256State));\n}\n\n// Update the state.\nstatic bool update(TwoCats_H *H, const uint8_t *data, uint32_t dataSize) {\n    return SHA256_Update(&(H->c.sha256State), data, dataSize);\n}\n\n// Finalize and write out the result.\nstatic bool final(TwoCats_H *H, uint8_t *hash) {\n    return SHA256_Final(hash, &(H->c.sha256State));\n}\n\n// Initialize the hashing object for sha256 hashing.\nvoid TwoCats_InitSHA256(TwoCats_H *H) {\n    H->name = \"sha256\";\n    H->size = 32;\n    H->Init = init;\n    H->Update = update;\n    H->Final = final;\n}\n\n"
        },
        {
            "file_name": "twocats-sha512.c",
            "content": "#include \"twocats-internal.h\"\n\n// Initilized the state.\nstatic bool init(TwoCats_H *H) {\n    return SHA512_Init(&(H->c.sha512State));\n}\n\n// Update the state.\nstatic bool update(TwoCats_H *H, const uint8_t *data, uint32_t dataSize) {\n    return SHA512_Update(&(H->c.sha512State), data, dataSize);\n}\n\n// Finalize and write out the result.\nstatic bool final(TwoCats_H *H, uint8_t *hash) {\n    return SHA512_Final(hash, &(H->c.sha512State));\n}\n\n// Initialize the hashing object for sha512 hashing.\nvoid TwoCats_InitSHA512(TwoCats_H *H) {\n    H->name = \"sha512\";\n    H->size = 64;\n    H->Init = init;\n    H->Update = update;\n    H->Final = final;\n}\n\n"
        },
        {
            "file_name": "twocats.c",
            "content": "/*\n   TwoCats optimized C version\n\n   Written in 2014 by Bill Cox <waywardgeek@gmail.com>\n\n   To the extent possible under law, the author(s) have dedicated all copyright\n   and related and neighboring rights to this software to the public domain\n   worldwide. This software is distributed without any warranty.\n\n   You should have received a copy of the CC0 Public Domain Dedication along with\n   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <byteswap.h>\n#include \"twocats-internal.h\"\n\n// This include code copied from blake2s.c\n#ifdef __AVX2__\n#define HAVE_AVX2\n#endif\n#include \"../blake2-sse/blake2-config.h\"\n\n#include <emmintrin.h>\n#if defined(HAVE_SSSE3)\n#include <tmmintrin.h>\n#endif\n#if defined(HAVE_SSE41)\n#include <smmintrin.h>\n#endif\n#if defined(HAVE_AVX)\n#include <immintrin.h>\n#endif\n#if defined(HAVE_XOP)\n#include <x86intrin.h>\n#endif\n\n// This rotate code is motivated from blake2s-round.h\n#ifdef HAVE_AVX2\n#define DECLARE_ROTATE256_CONSTS \\\n    __m256i shuffleVal = _mm256_set_epi8(30, 29, 28, 31, 26, 25, 24, 27, 22, 21, 20, 23, 18, 17, 16, 19, \\\n        14, 13, 12, 15, 10, 9, 8, 11, 6, 5, 4, 7, 2, 1, 0, 3);\n#define ROTATE_LEFT8_256(s) _mm256_shuffle_epi8(s, shuffleVal)\n#endif\n\n#ifndef HAVE_XOP\n#ifdef HAVE_SSSE3\n#define DECLARE_ROTATE128_CONSTS \\\n    __m128i shuffleVal = _mm_set_epi8(14, 13, 12, 15, 10, 9, 8, 11, 6, 5, 4, 7, 2, 1, 0, 3);\n#define ROTATE_LEFT8_128(s) _mm_shuffle_epi8(s, shuffleVal)\n#else\n#define DECLARE_ROTATE128_CONSTS \\\n    __m128i shiftRightVal = _mm_set_epi32(24, 24, 24, 24); \\\n    __m128i shiftLeftVal = _mm_set_epi32(8, 8, 8, 8);\n#define ROTATE_LEFT8_128(s) _mm_or_si128(_mm_srl_epi32(s, shiftRightVal), _mm_sll_epi32(s, shiftLeftVal))\n#endif\n#endif\n\n// This structure is shared among all threads.\nstruct TwoCatsCommonDataStruct {\n    uint32_t *mem;\n    uint32_t *hash32;\n    uint32_t parallelism;\n    uint32_t blocklen;\n    uint32_t subBlocklen;\n    uint32_t blocksPerThread;\n    uint32_t repetitions;\n    uint8_t multiplies;\n    uint8_t lanes;\n    uint32_t completedBlocks;\n};\n\n// This structure is unique to each memory-hashing thread\nstruct TwoCatsContextStruct {\n    TwoCats_H H;\n    struct TwoCatsCommonDataStruct *common;\n    uint32_t *state;\n    uint32_t p; // This is the memory-thread number\n};\n\n// Add the last hashed data into the result.\nstatic void addIntoHash(TwoCats_H *H, uint32_t *hash32, uint32_t parallelism, uint32_t *states) {\n    for(uint32_t p = 0; p < parallelism; p++) {\n        for(uint32_t i = 0; i < H->len; i++) {\n            hash32[i] += states[p*H->len + i];\n        }\n    }\n}\n\n#if defined(HAVE_AVX2)\nstatic void convStateFromUint32ToM256i(uint32_t state[8], __m256i *v) {\n    *v = _mm256_set_epi32(state[7], state[6], state[5], state[4], state[3], state[2], state[1], state[0]);\n}\n\n// Convert two __m256i to uint32_t[8].\nstatic void convStateFromM256iToUint32(__m256i *v, uint32_t state[8]) {\n    uint32_t *p = (uint32_t *)v;\n    uint32_t i;\n    for(i = 0; i < 8; i++) {\n        state[i] = p[i];\n    }\n}\n#endif\n#if defined(HAVE_SSE2)\n// Convert a uint32_t[8] to two __m128i values. len must be 4 or 8.\nstatic void convStateFromUint32ToM128i(uint32_t state[8], __m128i *v1, __m128i *v2, uint8_t len) {\n    *v1 = _mm_set_epi32(state[3], state[2], state[1], state[0]);\n    if(len == 8) {\n        *v2 = _mm_set_epi32(state[7], state[6], state[5], state[4]);\n    }\n}\n\n// Convert two __m128i to uint32_t*. len must be 4 or 8.\nstatic void convStateFromM128iToUint32(__m128i *v1, __m128i *v2, uint32_t *state, uint8_t len) {\n    uint32_t *p = (uint32_t *)v1;\n    uint32_t i;\n    for(i = 0; i < 4; i++) {\n        state[i] = p[i];\n    }\n    if(len == 8) {\n        p = (uint32_t *)v2;\n        for(i = 0; i < 4; i++) {\n            state[i+4] = p[i];\n        }\n    }\n}\n#endif\n\n/* Hash three blocks together with fast SSE friendly hash function optimized for high memory bandwidth.\n   Basically, it does for every 8 words:\n       for(i = 0; i < 8; i++) {\n           state[i] = ROTATE_LEFT((state[i] + *p++) ^ *f++, 8);\n           *t++ = state[i];\n  \n   TODO: Optimizations for ARM, and widths other than 8 should be written as well. */\n       \nstatic inline void hashBlocksInner(TwoCats_H *H, uint32_t *state, uint32_t *mem,\n        uint32_t blocklen, uint32_t subBlocklen, uint64_t fromAddr, uint64_t prevAddr,\n        uint64_t toAddr, uint8_t multiplies, uint32_t repetitions, uint8_t lanes) {\n\n    // Do SIMD friendly memory hashing and a scalar CPU friendly parallel multiplication chain\n    uint32_t numSubBlocks = blocklen/subBlocklen;\n    uint32_t a = state[0];\n    uint32_t b = state[1];\n    uint32_t c = state[2];\n    uint32_t d = state[3];\n\n    bool haveFastCode = false;\n    if(lanes == 8) {\n#if defined(HAVE_AVX2)\n        haveFastCode = true;\n        __m256i s;\n        convStateFromUint32ToM256i(state, &s);\n        __m256i *m = (__m256i *)mem;\n        DECLARE_ROTATE256_CONSTS\n        __m256i *f;\n        __m256i *t;\n        __m256i *p;\n        for(uint32_t r = 0; r < repetitions-1; r++) {\n            f = m + fromAddr/8;\n            for(uint32_t i = 0; i < numSubBlocks; i++) {\n                uint32_t randVal = *(uint32_t *)f;\n                p = m + prevAddr/8 + (subBlocklen/8)*(randVal & (numSubBlocks - 1));\n                for(uint32_t j = 0; j < subBlocklen/8; j++) {\n\n                    // Compute the multiplication chain\n                    for(uint8_t k = 0; k < multiplies; k++) {\n                        a ^= (uint64_t)b*c >> 32;\n                        b += c;\n                        c ^= (uint64_t)a*d >> 32;\n                        d += a;\n                    }\n\n                    // Hash 32 bytes of memory\n                    s = _mm256_add_epi32(s, *p++);\n                    s = _mm256_xor_si256(s, *f++);\n                    s = ROTATE_LEFT8_256(s);\n                }\n            }\n        }\n        f = m + fromAddr/8;\n        t = m + toAddr/8;\n        for(uint32_t i = 0; i < numSubBlocks; i++) {\n            uint32_t randVal = *(uint32_t *)f;\n            p = m + prevAddr/8 + (subBlocklen/8)*(randVal & (numSubBlocks - 1));\n            for(uint32_t j = 0; j < subBlocklen/8; j++) {\n\n                // Compute the multiplication chain\n                for(uint8_t k = 0; k < multiplies; k++) {\n                    a ^= (uint64_t)b*c >> 32;\n                    b += c;\n                    c ^= (uint64_t)a*d >> 32;\n                    d += a;\n                }\n\n                // Hash 32 bytes of memory\n                s = _mm256_add_epi32(s, *p++);\n                s = _mm256_xor_si256(s, *f++);\n                s = ROTATE_LEFT8_256(s);\n                *t++ = s;\n            }\n        }\n        convStateFromM256iToUint32(&s, state);\n#elif defined(HAVE_SSE2)\n        haveFastCode = true;\n        __m128i s1;\n        __m128i s2;\n        convStateFromUint32ToM128i(state, &s1, &s2, 8);\n        __m128i *m = (__m128i *)mem;\n        DECLARE_ROTATE128_CONSTS\n        __m128i *f;\n        __m128i *t;\n        __m128i *p;\n        for(uint32_t r = 0; r < repetitions-1; r++) {\n            f = m + fromAddr/4;\n            for(uint32_t i = 0; i < numSubBlocks; i++) {\n                uint32_t randVal = *(uint32_t *)f;\n                p = m + prevAddr/4 + (subBlocklen/4)*(randVal & (numSubBlocks - 1));\n                for(uint32_t j = 0; j < subBlocklen/8; j++) {\n\n                    // Compute the multiplication chain\n                    for(uint8_t k = 0; k < multiplies; k++) {\n                        a ^= (uint64_t)b*c >> 32;\n                        b += c;\n                        c ^= (uint64_t)a*d >> 32;\n                        d += a;\n                    }\n\n                    // Hash 32 bytes of memory\n                    s1 = _mm_add_epi32(s1, *p++);\n                    s1 = _mm_xor_si128(s1, *f++);\n                    // Rotate left 8\n                    s1 = ROTATE_LEFT8_128(s1);\n                    s2 = _mm_add_epi32(s2, *p++);\n                    s2 = _mm_xor_si128(s2, *f++);\n                    // Rotate left 8\n                    s2 = ROTATE_LEFT8_128(s2);\n                }\n            }\n        }\n        f = m + fromAddr/4;\n        t = m + toAddr/4;\n        for(uint32_t i = 0; i < numSubBlocks; i++) {\n            uint32_t randVal = *(uint32_t *)f;\n            p = m + prevAddr/4 + (subBlocklen/4)*(randVal & (numSubBlocks - 1));\n            for(uint32_t j = 0; j < subBlocklen/8; j++) {\n\n                // Compute the multiplication chain\n                for(uint8_t k = 0; k < multiplies; k++) {\n                    a ^= (uint64_t)b*c >> 32;\n                    b += c;\n                    c ^= (uint64_t)a*d >> 32;\n                    d += a;\n                }\n\n                // Hash 32 bytes of memory\n                s1 = _mm_add_epi32(s1, *p++);\n                s1 = _mm_xor_si128(s1, *f++);\n                // Rotate left 8\n                s1 = ROTATE_LEFT8_128(s1);\n                *t++ = s1;\n                s2 = _mm_add_epi32(s2, *p++);\n                s2 = _mm_xor_si128(s2, *f++);\n                // Rotate left 8\n                s2 = ROTATE_LEFT8_128(s2);\n                *t++ = s2;\n            }\n        }\n        convStateFromM128iToUint32(&s1, &s2, state, 8);\n#endif\n    } else if(lanes == 4) {\n#if defined(HAVE_SSE2)\n        haveFastCode = true;\n        __m128i s;\n        convStateFromUint32ToM128i(state, &s, &s, 4);\n        __m128i *m = (__m128i *)mem;\n        DECLARE_ROTATE128_CONSTS\n        __m128i *f;\n        __m128i *t;\n        __m128i *p;\n        for(uint32_t r = 0; r < repetitions-1; r++) {\n            f = m + fromAddr/4;\n            for(uint32_t i = 0; i < numSubBlocks; i++) {\n                uint32_t randVal = *(uint32_t *)f;\n                p = m + prevAddr/4 + (subBlocklen/4)*(randVal & (numSubBlocks - 1));\n                for(uint32_t j = 0; j < subBlocklen/4; j++) {\n\n                    // Compute the multiplication chain\n                    for(uint8_t k = 0; k < multiplies; k++) {\n                        a ^= (uint64_t)b*c >> 32;\n                        b += c;\n                        c ^= (uint64_t)a*d >> 32;\n                        d += a;\n                    }\n\n                    // Hash 16 bytes of memory\n                    s = _mm_add_epi32(s, *p++);\n                    s = _mm_xor_si128(s, *f++);\n                    // Rotate left 8\n                    s = ROTATE_LEFT8_128(s);\n                }\n            }\n        }\n        f = m + fromAddr/4;\n        t = m + toAddr/4;\n        for(uint32_t i = 0; i < numSubBlocks; i++) {\n            uint32_t randVal = *(uint32_t *)f;\n            p = m + prevAddr/4 + (subBlocklen/4)*(randVal & (numSubBlocks - 1));\n            for(uint32_t j = 0; j < subBlocklen/4; j++) {\n\n                // Compute the multiplication chain\n                for(uint8_t k = 0; k < multiplies; k++) {\n                    a ^= (uint64_t)b*c >> 32;\n                    b += c;\n                    c ^= (uint64_t)a*d >> 32;\n                    d += a;\n                }\n\n                // Hash 16 bytes of memory\n                s = _mm_add_epi32(s, *p++);\n                s = _mm_xor_si128(s, *f++);\n                // Rotate left 8\n                s = ROTATE_LEFT8_128(s);\n                *t++ = s;\n            }\n        }\n        convStateFromM128iToUint32(&s, &s, state, 4);\n#endif\n    } else if(lanes == 2) {\n        // TODO: write 2-lane code here using MMX\n    }\n    if(!haveFastCode) {\n        for(uint32_t r = 0; r < repetitions-1; r++) {\n            uint32_t *f = mem + fromAddr;\n            for(uint32_t i = 0; i < numSubBlocks; i++) {\n                uint32_t randVal = *f;\n                uint32_t *p = mem + prevAddr + subBlocklen*(randVal & (numSubBlocks - 1));\n                for(uint32_t j = 0; j < subBlocklen/lanes; j++) {\n\n                    // Compute the multiplication chain\n                    for(uint32_t k = 0; k < multiplies; k++) {\n                        a ^= (uint64_t)b*c >> 32;\n                        b += c;\n                        c ^= (uint64_t)a*d >> 32;\n                        d += a;\n                    }\n\n                    // Hash lanes of memory\n                    for(uint32_t k = 0; k < lanes; k++) {\n                        state[k] = (state[k] + *p++) ^ *f++;\n                        state[k] = (state[k] >> 24) | (state[k] << 8);\n                    }\n                }\n            }\n        }\n        uint32_t *f = mem + fromAddr;\n        uint32_t *t = mem + toAddr;\n        for(uint32_t i = 0; i < numSubBlocks; i++) {\n            uint32_t randVal = *f;\n            uint32_t *p = mem + prevAddr + subBlocklen*(randVal & (numSubBlocks - 1));\n            for(uint32_t j = 0; j < subBlocklen/lanes; j++) {\n\n                // Compute the multiplication chain\n                for(uint32_t k = 0; k < multiplies; k++) {\n                    a ^= (uint64_t)b*c >> 32;\n                    b += c;\n                    c ^= (uint64_t)a*d >> 32;\n                    d += a;\n                }\n\n                // Hash lanes of memory\n                for(uint32_t k = 0; k < lanes; k++) {\n                    state[k] = (state[k] + *p++) ^ *f++;\n                    state[k] = (state[k] >> 24) | (state[k] << 8);\n                    *t++ = state[k];\n                }\n            }\n        }\n    }\n    H->HashState(H, state, a);\n}\n\n// This crazy wrapper is simply to force to optimizer to unroll the lanes loop.\nstatic inline void hashBlocksLanes(TwoCats_H *H, uint32_t state[8], uint32_t *mem, uint32_t blocklen,\n        uint32_t subBlocklen, uint64_t fromAddr, uint64_t prevAddr, uint64_t toAddr,\n        uint8_t multiplies, uint32_t repetitions, uint8_t lanes) {\n    switch(lanes) {\n    case 1:\n        hashBlocksInner(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, multiplies, repetitions, 1);\n        break;\n    case 2:\n        hashBlocksInner(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, multiplies, repetitions, 2);\n        break;\n    case 4:\n        hashBlocksInner(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, multiplies, repetitions, 4);\n        break;\n    case 8:\n        hashBlocksInner(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, multiplies, repetitions, 8);\n        break;\n    case 16:\n        hashBlocksInner(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, multiplies, repetitions, 16);\n        break;\n    default:\n        hashBlocksInner(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, multiplies, repetitions, lanes);\n    }\n}\n\n// This crazy wrapper is simply to force to optimizer to unroll the multiplication loop.\nstatic inline void hashBlocks(TwoCats_H *H, uint32_t state[8], uint32_t *mem, uint32_t blocklen,\n        uint32_t subBlocklen, uint64_t fromAddr, uint64_t prevAddr, uint64_t toAddr,\n        uint8_t multiplies, uint32_t repetitions, uint8_t lanes) {\n    switch(multiplies) {\n    case 0:\n        hashBlocksLanes(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, 0, repetitions, lanes);\n        break;\n    case 1:\n        hashBlocksLanes(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, 1, repetitions, lanes);\n        break;\n    case 2:\n        hashBlocksLanes(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, 2, repetitions, lanes);\n        break;\n    case 3:\n        hashBlocksLanes(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, 3, repetitions, lanes);\n        break;\n    case 4:\n        hashBlocksLanes(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, 4, repetitions, lanes);\n        break;\n    case 5:\n        hashBlocksLanes(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, 5, repetitions, lanes);\n        break;\n    case 6:\n        hashBlocksLanes(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, 6, repetitions, lanes);\n        break;\n    case 7:\n        hashBlocksLanes(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, 7, repetitions, lanes);\n        break;\n    case 8:\n        hashBlocksLanes(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr, 8, repetitions, lanes);\n        break;\n    }\n}\n\n// Bit-reversal function derived from Catena's version.\nstatic inline uint32_t reverse(uint32_t x, const uint8_t n)\n{\n    if(n == 0) {\n        return 0;\n    }\n    x = bswap_32(x);\n    x = ((x & 0x0f0f0f0f) << 4) | ((x & 0xf0f0f0f0) >> 4);\n    x = ((x & 0x33333333) << 2) | ((x & 0xcccccccc) >> 2);\n    x = ((x & 0x55555555) << 1) | ((x & 0xaaaaaaaa) >> 1);\n    return x >> (32 - n);\n}\n\n// Hash memory without doing any password dependent memory addressing to thwart cache-timing-attacks.\n// Use Solar Designer's sliding-power-of-two window, with Catena's bit-reversal.\nstatic void *hashWithoutPassword(void *contextPtr) {\n    struct TwoCatsContextStruct *ctx = (struct TwoCatsContextStruct *)contextPtr;\n    struct TwoCatsCommonDataStruct *c = ctx->common;\n\n    TwoCats_H *H = &(ctx->H);\n    uint32_t *state = ctx->state;\n    uint32_t *mem = c->mem;\n    uint32_t p = ctx->p;\n    uint32_t blocklen = c->blocklen;\n    uint32_t blocksPerThread = c->blocksPerThread;\n    uint8_t multiplies = c->multiplies;\n    uint32_t repetitions = c->repetitions;\n    uint32_t lanes = c->lanes;\n    uint32_t parallelism = c->parallelism;\n    uint32_t completedBlocks = c->completedBlocks;\n\n    uint64_t start = blocklen*blocksPerThread*p;\n    uint32_t firstBlock = completedBlocks;\n    if(completedBlocks == 0) {\n        // Initialize the first block of memory\n        H->ExpandUint32(H, mem + start, blocklen, state);\n        firstBlock = 1;\n    }\n\n    // Hash one \"slice\" worth of memory hashing\n    uint32_t numBits = 1; // The number of bits in i\n    for(uint32_t i = firstBlock; i < completedBlocks + blocksPerThread/TWOCATS_SLICES; i++) {\n        while(1 << numBits <= i) {\n            numBits++;\n        }\n\n        // Compute the \"sliding reverse\" block position\n        uint32_t reversePos = reverse(i, numBits-1);\n        if(reversePos + (1 << (numBits-1)) < i) {\n            reversePos += 1 << (numBits-1);\n        }\n\n        // Hash the prior block and the block at reversePos and write the result\n        uint64_t fromAddr = blocklen*reversePos;\n\n        // Compute which thread's memory to read from\n        if(fromAddr < completedBlocks*blocklen) {\n            fromAddr += blocklen*blocksPerThread*(i % parallelism);\n        } else {\n            fromAddr += start;\n        }\n\n        uint64_t toAddr = start + i*blocklen;\n        uint64_t prevAddr = toAddr - blocklen;\n        hashBlocks(H, state, mem, blocklen, blocklen, fromAddr, prevAddr, toAddr,\n            multiplies, repetitions, lanes);\n    }\n    pthread_exit(NULL);\n}\n\n// Hash memory with password dependent addressing.\nstatic void *hashWithPassword(void *contextPtr) {\n    struct TwoCatsContextStruct *ctx = (struct TwoCatsContextStruct *)contextPtr;\n    struct TwoCatsCommonDataStruct *c = ctx->common;\n\n    TwoCats_H *H = &(ctx->H);\n    uint32_t *state = ctx->state;\n    uint32_t *mem = c->mem;\n    uint32_t p = ctx->p;\n    uint64_t blocklen = c->blocklen;\n    uint32_t subBlocklen = c->subBlocklen;\n    uint32_t blocksPerThread = c->blocksPerThread;\n    uint8_t multiplies = c->multiplies;\n    uint32_t repetitions = c->repetitions;\n    uint8_t lanes = c->lanes;\n    uint32_t parallelism = c->parallelism;\n    uint32_t completedBlocks = c->completedBlocks;\n\n    uint64_t start = blocklen*blocksPerThread*p;\n\n    // Hash one \"slice\" worth of memory hashing\n    for(uint32_t i = completedBlocks; i < completedBlocks + blocksPerThread/TWOCATS_SLICES; i++) {\n\n        // Compute rand()^3 distance distribution\n        uint64_t v = state[0];\n        uint64_t v2 = v*v >> 32;\n        uint64_t v3 = v*v2 >> 32;\n        uint32_t distance = (i-1)*v3 >> 32;\n\n        // Hash the prior block and the block at 'distance' blocks in the past\n        uint64_t fromAddr = (i - 1 - distance)*blocklen;\n\n        // Compute which thread's memory to read from\n        if(fromAddr < completedBlocks*blocklen) {\n            fromAddr += blocklen*(state[1] % parallelism)*blocksPerThread;\n        } else {\n            fromAddr += start;\n        }\n\n        uint64_t toAddr = start + i*blocklen;\n        uint64_t prevAddr = toAddr - blocklen;\n        hashBlocks(H, state, mem, blocklen, subBlocklen, fromAddr, prevAddr, toAddr,\n            multiplies, repetitions, lanes);\n    }\n    pthread_exit(NULL);\n}\n\n// Hash memory for one level of garlic.\nstatic bool hashMemory(TwoCats_H *H, uint32_t *hash32, uint32_t *mem, uint8_t memCost,\n        uint8_t timeCost, uint8_t multiplies, uint8_t lanes, uint8_t parallelism,\n        uint32_t blockSize, uint32_t subBlockSize, uint32_t resistantSlices) {\n\n    uint64_t memlen = (1024/sizeof(uint32_t)) << memCost;\n    uint32_t blocklen = blockSize/sizeof(uint32_t);\n    uint32_t subBlocklen = subBlockSize/sizeof(uint32_t);\n    uint32_t blocksPerThread = TWOCATS_SLICES*(memlen/(TWOCATS_SLICES * parallelism * blocklen));\n    uint32_t repetitions = 1 << timeCost;\n\n\n    // Fill out the common constant data used in all threads\n    pthread_t memThreads[parallelism];\n    struct TwoCatsContextStruct c[parallelism];\n    struct TwoCatsCommonDataStruct common;\n    common.multiplies = multiplies;\n    common.lanes = lanes;\n    common.mem = mem;\n    common.hash32 = hash32;\n    common.blocklen = blocklen;\n    common.subBlocklen = subBlocklen;\n    common.blocksPerThread = blocksPerThread;\n    common.parallelism = parallelism;\n    common.repetitions = repetitions;\n\n    // Initialize thread states\n    uint32_t states[H->len*parallelism];\n    H->ExpandUint32(H, states, H->len*parallelism, hash32);\n    for(uint32_t p = 0; p < parallelism; p++) {\n        c[p].common = &common;\n        c[p].p = p;\n        c[p].state = states + p*H->len;\n        TwoCats_InitHash(&(c[p].H), H->type);\n    }\n\n    for(uint32_t slice = 0; slice < TWOCATS_SLICES; slice++) {\n        common.completedBlocks = slice*blocksPerThread/TWOCATS_SLICES;\n        for(uint32_t p = 0; p < parallelism; p++) {\n            int rc;\n            if(slice < resistantSlices) {\n                rc = pthread_create(&memThreads[p], NULL, hashWithoutPassword, (void *)(c + p));\n            } else {\n                rc = pthread_create(&memThreads[p], NULL, hashWithPassword, (void *)(c + p));\n            }\n            if(rc) {\n                fprintf(stderr, \"Unable to start threads\\n\");\n                return false;\n            }\n        }\n        for(uint32_t p = 0; p < parallelism; p++) {\n            (void)pthread_join(memThreads[p], NULL);\n        }\n    }\n\n    // Apply a crypto-strength hash\n    addIntoHash(H, hash32, parallelism, states);\n    H->Hash(H, hash32);\n    return true;\n}\n\n// The TwoCats password hashing function.  Return false if there is a memory allocation error.\nbool TwoCats(TwoCats_H *H, uint32_t *hash32, uint8_t startMemCost, uint8_t stopMemCost,\n        uint8_t timeCost, uint8_t multiplies, uint8_t lanes, uint8_t parallelism, uint32_t blockSize,\n        uint32_t subBlockSize, uint8_t overwriteCost) {\n\n    // Allocate memory\n    uint32_t *mem;\n    if(posix_memalign((void *)&mem,  64, (uint64_t)1024 << stopMemCost)) {\n        fprintf(stderr, \"Unable to allocate memory\\n\");\n        return false;\n    }\n\n    // Iterate through the levels of garlic.  Throw away some early memory to reduce the\n    // danger from leaking memory to an attacker.\n    for(uint8_t i = 0; i <= stopMemCost; i++) {\n        if(i >= startMemCost || i < overwriteCost) {\n            if(((uint64_t)1024 << i)/(parallelism*blockSize) >= TWOCATS_SLICES) {\n                uint32_t resistantSlices = TWOCATS_SLICES/2;\n                if(i < startMemCost) {\n                    resistantSlices = TWOCATS_SLICES;\n                }\n                if(!hashMemory(H, hash32, mem, i, timeCost, multiplies, lanes, parallelism,\n                        blockSize, subBlockSize, resistantSlices)) {\n                    free(mem);\n                    return false;\n                }\n            }\n            // Not doing the last hash is for server relief support\n            if(i != stopMemCost && !H->Hash(H, hash32)) {\n                return false;\n            }\n        }\n    }\n\n    // The light is green, the trap is clean\n    free(mem);\n    return true;\n}\n"
        },
        {
            "file_name": "Twofish.cpp",
            "content": "#include \"stdafx.h\"\n\n#include \"Twofish_data.h\"\n\n#  pragma intrinsic(_lrotr,_lrotl)\n\n#  define rotr(x,n) _lrotr(x,n)\n#  define rotl(x,n) _lrotl(x,n)\n\n#define bswap(x)    (rotl(x, 8) & 0x00ff00ff | rotr(x, 8) & 0xff00ff00)\n\n#define byte(x,n)   ((BYTE)((x) >> (8 * n)))\n\n#ifdef  BLOCK_SWAP\n#define BYTE_SWAP\n#define WORD_SWAP\n#endif\n\n#ifdef  BYTE_SWAP\n#define io_swap(x)  bswap(x)\n#else\n#define io_swap(x)  (x)\n#endif\n\n#ifdef  WORD_SWAP\n\n#define get_block(x)                            \\\n    ((DWORD *)(x))[0] = io_swap(in_blk[3]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_blk[2]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_blk[1]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_blk[0])\n\n#define put_block(x)                            \\\n    out_blk[3] = io_swap(((DWORD *)(x))[0]);    \\\n    out_blk[2] = io_swap(((DWORD *)(x))[1]);    \\\n    out_blk[1] = io_swap(((DWORD *)(x))[2]);    \\\n    out_blk[0] = io_swap(((DWORD *)(x))[3])\n\n#define get_key(x,len)                          \\\n    ((DWORD *)(x))[4] = ((DWORD *)(x))[5] =     \\\n    ((DWORD *)(x))[6] = ((DWORD *)(x))[7] = 0;  \\\n    switch((((len) + 63) / 64)) {               \\\n    case 2:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[0]);     \\\n    break;                                      \\\n    case 3:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[5]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[0]);     \\\n    break;                                      \\\n    case 4:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[7]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[6]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[5]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[3]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[6] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[7] = io_swap(in_key[0]);     \\\n    }\n\n#else\n\n#define get_block(x)                            \\\n    ((DWORD *)(x))[0] = io_swap(in_blk[0]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_blk[1]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_blk[2]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_blk[3])\n\n#define put_block(x)                            \\\n    out_blk[0] = io_swap(((DWORD *)(x))[0]);    \\\n    out_blk[1] = io_swap(((DWORD *)(x))[1]);    \\\n    out_blk[2] = io_swap(((DWORD *)(x))[2]);    \\\n    out_blk[3] = io_swap(((DWORD *)(x))[3])\n\n#define get_key(x,len)                          \\\n    ((DWORD *)(x))[4] = ((DWORD *)(x))[5] =     \\\n    ((DWORD *)(x))[6] = ((DWORD *)(x))[7] = 0;  \\\n    switch((((len) + 63) / 64)) {               \\\n    case 4:                                     \\\n    ((DWORD *)(x))[6] = io_swap(in_key[6]);     \\\n    ((DWORD *)(x))[7] = io_swap(in_key[7]);     \\\n    case 3:                                     \\\n    ((DWORD *)(x))[4] = io_swap(in_key[4]);     \\\n    ((DWORD *)(x))[5] = io_swap(in_key[5]);     \\\n    case 2:                                     \\\n    ((DWORD *)(x))[0] = io_swap(in_key[0]);     \\\n    ((DWORD *)(x))[1] = io_swap(in_key[1]);     \\\n    ((DWORD *)(x))[2] = io_swap(in_key[2]);     \\\n    ((DWORD *)(x))[3] = io_swap(in_key[3]);     \\\n    }\n\n#endif\n\n/* finite field arithmetic for GF(2**8) with the modular    */\n/* polynomial x^8 + x^6 + x^5 + x^3 + 1 (0x169)             */\n\n#define G_M 0x0169\n\nconst BYTE  tab_5b[4] = { 0, G_M >> 2, G_M >> 1, (G_M >> 1) ^ (G_M >> 2) };\nconst BYTE  tab_ef[4] = { 0, (G_M >> 1) ^ (G_M >> 2), G_M >> 1, G_M >> 2 };\n\n#define ffm_01(x)    (x)\n#define ffm_5b(x)   ((x) ^ ((x) >> 2) ^ tab_5b[(x) & 3])\n#define ffm_ef(x)   ((x) ^ ((x) >> 1) ^ ((x) >> 2) ^ tab_ef[(x) & 3])\n\nconst BYTE ror4[16] = { 0, 8, 1, 9, 2, 10, 3, 11, 4, 12, 5, 13, 6, 14, 7, 15 };\nconst BYTE ashx[16] = { 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 5, 14, 7 };\n\nconst BYTE qt0[2][16] = \n{   { 8, 1, 7, 13, 6, 15, 3, 2, 0, 11, 5, 9, 14, 12, 10, 4 },\n    { 2, 8, 11, 13, 15, 7, 6, 14, 3, 1, 9, 4, 0, 10, 12, 5 }\n};\n\nconst BYTE qt1[2][16] =\n{   { 14, 12, 11, 8, 1, 2, 3, 5, 15, 4, 10, 6, 7, 0, 9, 13 }, \n    { 1, 14, 2, 11, 4, 12, 3, 7, 6, 13, 10, 5, 15, 9, 0, 8 }\n};\n\nconst BYTE qt2[2][16] = \n{   { 11, 10, 5, 14, 6, 13, 9, 0, 12, 8, 15, 3, 2, 4, 7, 1 },\n    { 4, 12, 7, 5, 1, 6, 9, 10, 0, 14, 13, 8, 2, 11, 3, 15 }\n};\n\nconst BYTE qt3[2][16] = \n{   { 13, 7, 15, 4, 1, 2, 6, 14, 9, 11, 3, 0, 8, 5, 12, 10 },\n    { 11, 9, 5, 1, 12, 3, 13, 14, 6, 4, 7, 15, 2, 0, 8, 10 }\n};\n\nBYTE qp(const DWORD n, const BYTE x)\n{\n\tBYTE  a0, a1, a2, a3, a4, b0, b1, b2, b3, b4;\n\n    a0 = x >> 4; b0 = x & 15;\n    a1 = a0 ^ b0; b1 = ror4[b0] ^ ashx[a0];\n    a2 = qt0[n][a1]; b2 = qt1[n][b1];\n    a3 = a2 ^ b2; b3 = ror4[b2] ^ ashx[a2];\n    a4 = qt2[n][a3]; b4 = qt3[n][b3];\n    return (b4 << 4) | a4;\n}\n\n#ifdef  Q_TABLES\n\n#define q(n,x)  pTfd->q_tab[n][x]\n\nvoid gen_qtab(TWOFISH_DATA *pTfd)\n{\n\tDWORD  i;\n\n    for(i = 0; i < 256; ++i)\n    {       \n        q(0,i) = qp(0, (BYTE)i);\n        q(1,i) = qp(1, (BYTE)i);\n    }\n}\n\n#else\n\n#define q(n,x)  qp(n, x)\n\n#endif\n\n#ifdef  M_TABLE\n\nvoid gen_mtab(TWOFISH_DATA *pTfd)\n{\n\tDWORD  i, f01, f5b, fef;\n    \n    for(i = 0; i < 256; ++i)\n    {\n        f01 = q(1,i); f5b = ffm_5b(f01); fef = ffm_ef(f01);\n        pTfd->m_tab[0][i] = f01 + (f5b << 8) + (fef << 16) + (fef << 24);\n        pTfd->m_tab[2][i] = f5b + (fef << 8) + (f01 << 16) + (fef << 24);\n\n        f01 = q(0,i); f5b = ffm_5b(f01); fef = ffm_ef(f01);\n        pTfd->m_tab[1][i] = fef + (fef << 8) + (f5b << 16) + (f01 << 24);\n        pTfd->m_tab[3][i] = f5b + (f01 << 8) + (fef << 16) + (f5b << 24);\n    }\n}\n\n#define mds(n,x)    pTfd->m_tab[n][x]\n\n#else\n\n#define fm_00   ffm_01\n#define fm_10   ffm_5b\n#define fm_20   ffm_ef\n#define fm_30   ffm_ef\n#define q_0(x)  q(1,x)\n\n#define fm_01   ffm_ef\n#define fm_11   ffm_ef\n#define fm_21   ffm_5b\n#define fm_31   ffm_01\n#define q_1(x)  q(0,x)\n\n#define fm_02   ffm_5b\n#define fm_12   ffm_ef\n#define fm_22   ffm_01\n#define fm_32   ffm_ef\n#define q_2(x)  q(1,x)\n\n#define fm_03   ffm_5b\n#define fm_13   ffm_01\n#define fm_23   ffm_ef\n#define fm_33   ffm_5b\n#define q_3(x)  q(0,x)\n\n#define f_0(n,x)    ((DWORD)fm_0##n(x))\n#define f_1(n,x)    ((DWORD)fm_1##n(x) << 8)\n#define f_2(n,x)    ((DWORD)fm_2##n(x) << 16)\n#define f_3(n,x)    ((DWORD)fm_3##n(x) << 24)\n\n#define mds(n,x)    f_0(n,q_##n(x)) ^ f_1(n,q_##n(x)) ^ f_2(n,q_##n(x)) ^ f_3(n,q_##n(x))\n\n#endif\n\nDWORD h_fun(TWOFISH_DATA *pTfd,const DWORD x, const DWORD *key)\n{\n\tDWORD  b0, b1, b2, b3;\n\n#ifndef M_TABLE\n    DWORD  m5b_b0, m5b_b1, m5b_b2, m5b_b3;\n    DWORD  mef_b0, mef_b1, mef_b2, mef_b3;\n#endif\n\n    b0 = byte(x, 0); b1 = byte(x, 1); b2 = byte(x, 2); b3 = byte(x, 3);\n\n    switch(pTfd->k_len)\n    {\n    case 4: b0 = q(1, b0) ^ byte(key[3],0);\n            b1 = q(0, b1) ^ byte(key[3],1);\n            b2 = q(0, b2) ^ byte(key[3],2);\n            b3 = q(1, b3) ^ byte(key[3],3);\n    case 3: b0 = q(1, b0) ^ byte(key[2],0);\n            b1 = q(1, b1) ^ byte(key[2],1);\n            b2 = q(0, b2) ^ byte(key[2],2);\n            b3 = q(0, b3) ^ byte(key[2],3);\n    case 2: b0 = q(0,q(0,b0) ^ byte(key[1],0)) ^ byte(key[0],0);\n            b1 = q(0,q(1,b1) ^ byte(key[1],1)) ^ byte(key[0],1);\n            b2 = q(1,q(0,b2) ^ byte(key[1],2)) ^ byte(key[0],2);\n            b3 = q(1,q(1,b3) ^ byte(key[1],3)) ^ byte(key[0],3);\n    }\n#ifdef  M_TABLE\n\n    return  mds(0, b0) ^ mds(1, b1) ^ mds(2, b2) ^ mds(3, b3);\n\n#else\n\n    b0 = q(1, b0); b1 = q(0, b1); b2 = q(1, b2); b3 = q(0, b3);\n    m5b_b0 = ffm_5b(b0); m5b_b1 = ffm_5b(b1); m5b_b2 = ffm_5b(b2); m5b_b3 = ffm_5b(b3);\n    mef_b0 = ffm_ef(b0); mef_b1 = ffm_ef(b1); mef_b2 = ffm_ef(b2); mef_b3 = ffm_ef(b3);\n    b0 ^= mef_b1 ^ m5b_b2 ^ m5b_b3; b3 ^= m5b_b0 ^ mef_b1 ^ mef_b2;\n    b2 ^= mef_b0 ^ m5b_b1 ^ mef_b3; b1 ^= mef_b0 ^ mef_b2 ^ m5b_b3;\n\n    return b0 | (b3 << 8) | (b2 << 16) | (b1 << 24);\n\n#endif\n}\n\n#ifdef  MK_TABLE\n\n#define q20(x)  q(0,q(0,x) ^ byte(key[1],0)) ^ byte(key[0],0)\n#define q21(x)  q(0,q(1,x) ^ byte(key[1],1)) ^ byte(key[0],1)\n#define q22(x)  q(1,q(0,x) ^ byte(key[1],2)) ^ byte(key[0],2)\n#define q23(x)  q(1,q(1,x) ^ byte(key[1],3)) ^ byte(key[0],3)\n\n#define q30(x)  q(0,q(0,q(1, x) ^ byte(key[2],0)) ^ byte(key[1],0)) ^ byte(key[0],0)\n#define q31(x)  q(0,q(1,q(1, x) ^ byte(key[2],1)) ^ byte(key[1],1)) ^ byte(key[0],1)\n#define q32(x)  q(1,q(0,q(0, x) ^ byte(key[2],2)) ^ byte(key[1],2)) ^ byte(key[0],2)\n#define q33(x)  q(1,q(1,q(0, x) ^ byte(key[2],3)) ^ byte(key[1],3)) ^ byte(key[0],3)\n\n#define q40(x)  q(0,q(0,q(1, q(1, x) ^ byte(key[3],0)) ^ byte(key[2],0)) ^ byte(key[1],0)) ^ byte(key[0],0)\n#define q41(x)  q(0,q(1,q(1, q(0, x) ^ byte(key[3],1)) ^ byte(key[2],1)) ^ byte(key[1],1)) ^ byte(key[0],1)\n#define q42(x)  q(1,q(0,q(0, q(0, x) ^ byte(key[3],2)) ^ byte(key[2],2)) ^ byte(key[1],2)) ^ byte(key[0],2)\n#define q43(x)  q(1,q(1,q(0, q(1, x) ^ byte(key[3],3)) ^ byte(key[2],3)) ^ byte(key[1],3)) ^ byte(key[0],3)\n\nvoid gen_mk_tab(TWOFISH_DATA *pTfd,DWORD *key)\n{\n\tDWORD  i;\n    BYTE  by;\n\n    switch(pTfd->k_len)\n    {\n    case 2: for(i = 0; i < 256; ++i)\n            {\n                by = (BYTE)i;\n#ifdef ONE_STEP\n                pTfd->mk_tab[0][i] = mds(0, q20(by)); pTfd->mk_tab[1][i] = mds(1, q21(by));\n                pTfd->mk_tab[2][i] = mds(2, q22(by)); pTfd->mk_tab[3][i] = mds(3, q23(by));\n#else\n                sb[0][i] = q20(by); sb[1][i] = q21(by); \n                sb[2][i] = q22(by); sb[3][i] = q23(by);\n#endif\n            }\n            break;\n    \n    case 3: for(i = 0; i < 256; ++i)\n            {\n                by = (BYTE)i;\n#ifdef ONE_STEP\n                pTfd->mk_tab[0][i] = mds(0, q30(by)); pTfd->mk_tab[1][i] = mds(1, q31(by));\n                pTfd->mk_tab[2][i] = mds(2, q32(by)); pTfd->mk_tab[3][i] = mds(3, q33(by));\n#else\n                sb[0][i] = q30(by); sb[1][i] = q31(by); \n                sb[2][i] = q32(by); sb[3][i] = q33(by);\n#endif\n            }\n            break;\n    \n    case 4: for(i = 0; i < 256; ++i)\n            {\n                by = (BYTE)i;\n#ifdef ONE_STEP\n                pTfd->mk_tab[0][i] = mds(0, q40(by)); pTfd->mk_tab[1][i] = mds(1, q41(by));\n                pTfd->mk_tab[2][i] = mds(2, q42(by)); pTfd->mk_tab[3][i] = mds(3, q43(by));\n#else\n                sb[0][i] = q40(by); sb[1][i] = q41(by); \n                sb[2][i] = q42(by); sb[3][i] = q43(by);\n#endif\n            }\n    }\n}\n\n#  ifdef ONE_STEP\n#    define g0_fun(x) ( pTfd->mk_tab[0][byte(x,0)] ^ pTfd->mk_tab[1][byte(x,1)] \\\n                      ^ pTfd->mk_tab[2][byte(x,2)] ^ pTfd->mk_tab[3][byte(x,3)] )\n#    define g1_fun(x) ( pTfd->mk_tab[0][byte(x,3)] ^ pTfd->mk_tab[1][byte(x,0)] \\\n                      ^ pTfd->mk_tab[2][byte(x,1)] ^ pTfd->mk_tab[3][byte(x,2)] )\n#  else\n#    define g0_fun(x) ( mds(0, sb[0][byte(x,0)]) ^ mds(1, sb[1][byte(x,1)]) \\\n                      ^ mds(2, sb[2][byte(x,2)]) ^ mds(3, sb[3][byte(x,3)]) )\n#    define g1_fun(x) ( mds(0, sb[0][byte(x,3)]) ^ mds(1, sb[1][byte(x,0)]) \\\n                      ^ mds(2, sb[2][byte(x,1)]) ^ mds(3, sb[3][byte(x,2)]) )\n#  endif\n\n#else\n\n#define g0_fun(x)   h_fun(x,s_key)\n#define g1_fun(x)   h_fun(rotl(x,8),s_key)\n\n#endif\n\n/* The (12,8) Reed Soloman code has the generator polynomial\n\n  g(x) = x^4 + (a + 1/a) * x^3 + a * x^2 + (a + 1/a) * x + 1\n\nwhere the coefficients are in the finite field GF(2^8) with a\nmodular polynomial a^8 + a^6 + a^3 + a^2 + 1. To generate the\nremainder we have to start with a 12th order polynomial with our\neight input bytes as the coefficients of the 4th to 11th terms. \nThat is:\n\n  m[7] * x^11 + m[6] * x^10 ... + m[0] * x^4 + 0 * x^3 +... + 0\n  \nWe then multiply the generator polynomial by m[7] * x^7 and subtract\nit - xor in GF(2^8) - from the above to eliminate the x^7 term (the \nartihmetic on the coefficients is done in GF(2^8). We then multiply \nthe generator polynomial by x^6 * coeff(x^10) and use this to remove\nthe x^10 term. We carry on in this way until the x^4 term is removed\nso that we are left with:\n\n  r[3] * x^3 + r[2] * x^2 + r[1] 8 x^1 + r[0]\n\nwhich give the resulting 4 bytes of the remainder. This is equivalent \nto the matrix multiplication in the Twofish description but much faster \nto implement.\n\n*/\n\n#define G_MOD   0x0000014d\n\nDWORD mds_rem(DWORD p0, DWORD p1)\n{\n\tDWORD  i, t, u;\n\n    for(i = 0; i < 8; ++i)\n    {\n        t = p1 >> 24;   // get most significant coefficient\n        \n        p1 = (p1 << 8) | (p0 >> 24); p0 <<= 8;  // shift others up\n            \n        // multiply t by a (the primitive element - i.e. left shift)\n\n        u = (t << 1); \n        \n        if(t & 0x80)            // subtract modular polynomial on overflow\n        \n            u ^= G_MOD; \n\n        p1 ^= t ^ (u << 16);    // remove t * (a * x^2 + 1)  \n\n        u ^= (t >> 1);          // form u = a * t + t / a = t * (a + 1 / a); \n        \n        if(t & 0x01)            // add the modular polynomial on underflow\n        \n            u ^= G_MOD >> 1;\n\n        p1 ^= (u << 24) | (u << 8); // remove t * (a + 1/a) * (x^3 + x)\n    }\n\n    return p1;\n}\n\n/* initialise the key schedule from the user supplied key   */\n\nvoid Twofish_set_key(TWOFISH_DATA *pTfd,const DWORD *in_key, const DWORD key_len)\n{\n\tDWORD  i, a, b, me_key[4], mo_key[4];\n\n#ifdef Q_TABLES\n    if(!pTfd->qt_gen)\n    {\n        gen_qtab(pTfd); pTfd->qt_gen = 1;\n    }\n#endif\n\n#ifdef M_TABLE\n    if(!pTfd->mt_gen)\n    {\n        gen_mtab(pTfd); pTfd->mt_gen = 1;\n    }\n#endif\n\n    pTfd->k_len = key_len / 64;   /* 2, 3 or 4 */\n\n    for(i = 0; i < pTfd->k_len; ++i)\n    {\n        a = in_key[i + i];     me_key[i] = a;\n        b = in_key[i + i + 1]; mo_key[i] = b;\n        pTfd->s_key[pTfd->k_len - i - 1] = mds_rem(a, b);\n    }\n\n    for(i = 0; i < 40; i += 2)\n    {\n        a = 0x01010101 * i; b = a + 0x01010101;\n        a = h_fun(pTfd,a, me_key);\n        b = rotl(h_fun(pTfd,b, mo_key), 8);\n        pTfd->l_key[i] = a + b;\n        pTfd->l_key[i + 1] = rotl(a + 2 * b, 9);\n    }\n\n#ifdef MK_TABLE\n    gen_mk_tab(pTfd,pTfd->s_key);\n#endif\n}\n\n#define f_rnd(i)                                                    \\\n    t1 = g1_fun(blk[1]); t0 = g0_fun(blk[0]);                       \\\n    blk[2] = rotr(blk[2] ^ (t0 + t1 + pTfd->l_key[4 * (i) + 8]), 1);      \\\n    blk[3] = rotl(blk[3], 1) ^ (t0 + 2 * t1 + pTfd->l_key[4 * (i) + 9]);  \\\n    t1 = g1_fun(blk[3]); t0 = g0_fun(blk[2]);                       \\\n    blk[0] = rotr(blk[0] ^ (t0 + t1 + pTfd->l_key[4 * (i) + 10]), 1);     \\\n    blk[1] = rotl(blk[1], 1) ^ (t0 + 2 * t1 + pTfd->l_key[4 * (i) + 11])\n\nvoid Twofish_encrypt(const TWOFISH_DATA *pTfd,const DWORD *in_blk, DWORD *out_blk)\n{\n\tDWORD  t0, t1, blk[4];\n\n    blk[0] = in_blk[0] ^ pTfd->l_key[0];\n    blk[1] = in_blk[1] ^ pTfd->l_key[1];\n    blk[2] = in_blk[2] ^ pTfd->l_key[2];\n    blk[3] = in_blk[3] ^ pTfd->l_key[3];\n\n    f_rnd(0); f_rnd(1); f_rnd(2); f_rnd(3);\n    f_rnd(4); f_rnd(5); f_rnd(6); f_rnd(7);\n\n    out_blk[0] = blk[2] ^ pTfd->l_key[4];\n    out_blk[1] = blk[3] ^ pTfd->l_key[5];\n    out_blk[2] = blk[0] ^ pTfd->l_key[6];\n    out_blk[3] = blk[1] ^ pTfd->l_key[7]; \n}\n\n#define i_rnd(i)                                                        \\\n        t1 = g1_fun(blk[1]); t0 = g0_fun(blk[0]);                       \\\n        blk[2] = rotl(blk[2], 1) ^ (t0 + t1 + pTfd->l_key[4 * (i) + 10]);     \\\n        blk[3] = rotr(blk[3] ^ (t0 + 2 * t1 + pTfd->l_key[4 * (i) + 11]), 1); \\\n        t1 = g1_fun(blk[3]); t0 = g0_fun(blk[2]);                       \\\n        blk[0] = rotl(blk[0], 1) ^ (t0 + t1 + pTfd->l_key[4 * (i) +  8]);     \\\n        blk[1] = rotr(blk[1] ^ (t0 + 2 * t1 + pTfd->l_key[4 * (i) +  9]), 1)\n\nvoid Twofish_decrypt(const TWOFISH_DATA *pTfd,const DWORD *in_blk, DWORD *out_blk)\n{\n\tDWORD  t0, t1, blk[4];\n\n    blk[0] = in_blk[0] ^ pTfd->l_key[4];\n    blk[1] = in_blk[1] ^ pTfd->l_key[5];\n    blk[2] = in_blk[2] ^ pTfd->l_key[6];\n    blk[3] = in_blk[3] ^ pTfd->l_key[7];\n\n    i_rnd(7); i_rnd(6); i_rnd(5); i_rnd(4);\n    i_rnd(3); i_rnd(2); i_rnd(1); i_rnd(0);\n\n    out_blk[0] = blk[2] ^ pTfd->l_key[0];\n    out_blk[1] = blk[3] ^ pTfd->l_key[1];\n    out_blk[2] = blk[0] ^ pTfd->l_key[2];\n    out_blk[3] = blk[1] ^ pTfd->l_key[3]; \n}\n"
        },
        {
            "file_name": "Unicorn-A.cpp",
            "content": "#include \"stdafx.h\"\n\n#define ROUND    16\n#define LINE     8\n\n#define IK0 0\n#define IK4 ROUND*16+16\n#define EK0 IK0+16\n\nconst DWORD S[256] =\n{\n  0x95ae2518, 0x6fff22fc, 0xeda1a290, 0x9b6d8479,\n  0x15fe8611, 0x5528dc2a, 0x6c5f5b4d, 0x4c438f7f,\n  0xec212902, 0x4b7c2d23, 0xc185e5ad, 0x543af715,\n  0x16e06281, 0x8aeeb23a, 0x59814469, 0x37383871,\n  0x3389d470, 0x913961e5, 0x0da946b9, 0x99570fbd,\n  0x94dd3a4c, 0xa3dc48cc, 0x56a3d8d1, 0x3b54d057,\n  0xcc0e0e05, 0xafef6060, 0x5babd652, 0x758ad963,\n  0x7e4a8585, 0x46c0b38c, 0x90421c42, 0x0a689a40,\n  0xf80878c0, 0x92fa7b6b, 0xc92b53c2, 0x007364dc,\n  0x617eeb10, 0xd0580344, 0x17d4e6b7, 0xd667a0ab,\n  0x933ec1db, 0xea52f533, 0x428fa45c, 0x41049b0d,\n  0xe275ff98, 0x39e2af56, 0xd21c4f87, 0xe09b947b,\n  0xac41e362, 0x289cdbae, 0x9a8b1767, 0x57b75f9c,\n  0xb2eb6f9d, 0xeb7d0b3b, 0x87d95791,0xdc74689b,\n  0x6e6fa39e, 0x79edcb08, 0x609dbde7, 0x08441d84,\n  0x09a09c53, 0x35b8ad31, 0xf1d5d317, 0x69ac4020,\n  0x8faa9d55, 0xa9843545, 0xb649c4fb, 0x8b025924,\n  0x700151e9, 0x10e804ee, 0xb75c54de, 0x43f91095,\n  0xe988c025, 0x276a4af8, 0xc5af0d1a, 0x4a05b512,\n  0xa609147d, 0xda8cb80b, 0xe7263989, 0xf2bfb7fd,\n  0xa1325a4f, 0x9ffb7734, 0xc0555d38, 0x250ccf5f,\n  0xb11b26f1, 0xe43083bb, 0x2f2e5e2c, 0x77343ca7,\n  0x0e91747c, 0x124e0166, 0xf4a8d5e3, 0x389f7a73,\n  0x036405d4, 0xc3bc658e, 0xef10909a, 0xdbe3755d,\n  0x211a4bf7, 0xa7c62ed3, 0x1af40821, 0xb4cdac1c,\n  0x36b2aa43, 0x3d48980a, 0x3a8ee793, 0xdea2d2e1,\n  0x043342d7, 0x1ef636d2, 0xbff10af6, 0x2280bba0,\n  0x6bc28083, 0xf9b1cc49, 0x8e7a0c41, 0x96146639,\n  0x5f90f301, 0x2a3173b6, 0x7c5389b4, 0x19a693c7,\n  0xe8f79fcf, 0xb5e1e97e, 0x780b3bd8, 0x5d07dde0,\n  0x0566fd3d, 0x44f27051, 0x06b9a5ca, 0x3012c6c4,\n  0x81966992, 0x29a5debc, 0x6879ea77, 0x49629980,\n  0xbc5d2b32, 0xa5c5c91e, 0xd446795b, 0xa097b4a1,\n  0xfa4b5659, 0x8d76cd0c, 0x7bcae1c3, 0xd8d8f24a,\n  0x5e6cb6eb, 0xeecf37df, 0x510f3fe2, 0xca70e8ac,\n  0x0763fef5, 0x7a232c07, 0xc46509da, 0x1145159f,\n  0xcf5688f2, 0x663d41d9, 0xb84f72d0, 0xbd6e1f26,\n  0xf30d28a3, 0x48da312d, 0xce950027, 0x0c062404,\n  0xc886a93e, 0xe11d1688, 0xa424f968, 0xb08323b3,\n  0xf7b53e58, 0x019a11c5, 0x02b4ae06, 0xfee6f800,\n  0x474d9e8d, 0xb9c197be, 0xe5a418f3, 0xbb1132d6,\n  0xfbd3b06d, 0x89036ca2, 0x45d1433c, 0xa8697fa5,\n  0x325e96c6, 0x18ce12e4, 0xab2c02dd, 0xad13a8a4,\n  0x9e3cc26a, 0xdd7bab65, 0x7f0ac3cb, 0x1b1f91ec,\n  0xfc82638f, 0x72c31930, 0x984c506e, 0x52d0e050,\n  0xd13621b0, 0x26fcc84e, 0xcbdbc5ea, 0x80cb76b5,\n  0xd7c7a161, 0xd5273d54, 0x24bd8e14, 0xae504d46,\n  0x86a7be1d, 0xb35ad1a8, 0x5a20301b, 0x761e8b48,\n  0x50e9ee47, 0xf640ce5a, 0xfdf52aff, 0x7db67d13,\n  0x1d78effe, 0x2ce7ed72, 0x0f7f3419, 0xe32fdfe6,\n  0x6216582f, 0xcd87a72b, 0xff371a64, 0x4d7282b2,\n  0xc6ea4c28, 0xc229bf29, 0x851507f9, 0x825147ba,\n  0x4fadd796, 0x67df1bcd, 0x4e177eb8, 0x31fd06c9,\n  0x1399fb8b, 0x8c19334b, 0x6d2df136, 0xd3f88116,\n  0xdf61873f, 0x3fb3f6f4, 0x40baf46c, 0x977792af,\n  0x3ec8202e, 0xd992b1a9, 0xaabb49f0, 0x53d25299,\n  0x8800e297, 0x2de46e74, 0x73184e7a, 0xc7bebae8,\n  0x148df0a6, 0x2eec8d75, 0xbe3fa60e, 0xf0c9455e,\n  0x84606b6f, 0x1c7155ce, 0xa2f067ed, 0xe69395b1,\n  0x83e5fac8, 0x6a5b6d1f, 0x206bcaaa, 0x58d61378,\n  0x9d5971d5, 0x1f3b8c35, 0x2b988a94, 0x9cd7270f,\n  0x71b0b937, 0xbacce4ef, 0x23f36a03, 0x65942fbf,\n  0x342afc86, 0x3c9ec7fa, 0x0b47bcc1, 0x64225c09,\n  0x74deda82, 0xf5251e76, 0x63c4ec8a, 0x5c357c22\n};\n\nvoid F(DWORD ida, DWORD idb, DWORD *k, DWORD *oda, DWORD *odb)\n{\n  DWORD   wx0,wx1,wk0,wk1,tmp;\n\n  wx0 = ida + k[0];\n  wx1 = idb + k[2];\n  wk0 = idb + k[1];\n  wk1 = ida + k[3];\n  tmp = wx0 ^ (wx0<<23) ^ (wx1>>9) ^ (wx0>>23) ^ (wx1<9);\n  wx1 = wx1 ^ (wx1<23) ^ (wx0>>9) ^ (wx1>>23) ^ (wx0<<9);\n  wx0 = tmp * 0x7e167289;\n  wx1 ^= S[ wx0>>24 ];\n  wx1 *= 0xfe21464b;\n  wx0 ^= S[ wx1>>24 ];\n  wx1 ^= S[(wx0>>16)&0xff];\n  wx0 ^= S[(wx1>>16)&0xff];\n  wx1 ^= S[(wx0>> 8)&0xff];\n  wx0 ^= S[(wx1>> 8)&0xff];\n  wx1 ^= S[wx0&0xff];\n  wx0 ^= S[wx1&0xff];\n  wk0 *= 0x7e167289;\n  wk1 ^= S[ wk0>>24 ];\n  wk1 *= 0xfe21464b;\n  wk0 ^= S[ wk1>>24 ];\n  wk0 *= 0xfe21464b;\n  wk1 ^= S[ wk0>>24];\n  wk1 *= 0x7e167289;\n  wk0 ^= S[ wk1>>24];\n  wk1 ^= S[(wk0>>16)&0xff];\n  wk0 ^= S[(wk1>>16)&0xff];\n  wx1 ^= S[(wx0>>(24-((wk1&0xc)<<1)))&0xff];\n  wx0 ^= S[(wx1>>(24-((wk1&0x3)*8)))&0xff];\n  *oda = wx0 ^ wk0;\n  *odb = wx1 ^ wk0;\n  return;\n}\n\nvoid Unicorn_encrypt(const BYTE *eKey,const BYTE *src,BYTE *dst)\n{\n  DWORD   wx[4],tmp[2];\n  int i;\n\n  for (i = 0 ; i < 4 ; i++)\n    {\n      wx[i]   = src[i*4] << 24;\n      wx[i]   |= src[i*4+1] << 16;\n      wx[i]   |= src[i*4+2] << 8;\n      wx[i]   |= src[i*4+3];\n    }\n  for (i = 0 ; i < 4 ; i++)\n    {\n      wx[i] += *((DWORD *)(eKey+(IK0+i*4)));\n    }\n\n  for (i = 0 ; i < ROUND ; i++)\n    {\n      F(wx[2], wx[3], (DWORD *)&eKey[EK0+(i *16)], &tmp[0], &tmp[1]);\n      tmp[0] ^= wx[0];\n      tmp[1] ^= wx[1];\n      wx[0] = wx[2];\n      wx[1] = wx[3];\n      wx[2] = tmp[0];\n      wx[3] = tmp[1];\n    }\n\n  wx[0] -= *((DWORD *)(eKey+(IK4+8)));\n  wx[1] -= *((DWORD *)(eKey+(IK4+12)));\n  wx[2] -= *((DWORD *)(eKey+(IK4)));\n  wx[3] -= *((DWORD *)(eKey+(IK4+4)));\n\n  dst[0] = (BYTE) (wx[2] >> 24) ;\n  dst[1] = (BYTE)(wx[2] >> 16);\n  dst[2] = (BYTE) (wx[2] >> 8) ;\n  dst[3] = (BYTE) (wx[2]) ;\n  dst[4] = (BYTE)(wx[3] >> 24);\n  dst[5] = (BYTE)(wx[3] >> 16);\n  dst[6] = (BYTE) (wx[3] >> 8) ;\n  dst[7] = (BYTE) (wx[3]);\n  dst[8] = (BYTE)(wx[0] >> 24);\n  dst[9] = (BYTE)(wx[0] >> 16);\n  dst[10] = (BYTE)(wx[0] >> 8);\n  dst[11] = (BYTE) (wx[0]);\n  dst[12] = (BYTE)(wx[1] >> 24);\n  dst[13] = (BYTE)(wx[1] >> 16);\n  dst[14] = (BYTE)(wx[1] >> 8);\n  dst[15] = (BYTE) (wx[1]);\n}\n\nvoid Unicorn_decrypt(const BYTE *eKey,const BYTE *src,BYTE *dst)\n{\n  DWORD   wx[4], tmp[2];\n  int   i;\n\n  for (i = 0 ; i < 4 ; i++)\n    {\n      wx[i] = src[i*4] << 24;\n      wx[i] |= src[i*4+1] << 16;\n      wx[i] |= src[i*4+2] << 8;\n      wx[i] |= src[i*4+3];\n    }\n\n  for (i = 0 ; i < 4 ; i++)\n    {\n      wx[i] += *((DWORD *)(eKey+(IK4+i*4)));\n    }\n\n  for (i = ROUND-1 ; i >= 0 ; i--)\n    {\n      F(wx[2], wx[3], (DWORD *) &eKey[EK0+(i *16)], &tmp[0],&tmp [1]);\n      tmp [0] ^= wx[0];\n      tmp[1] ^= wx[1];\n\n      wx[0] = wx[2];\n      wx[1] = wx[3];\n      wx[2] = tmp[0];\n      wx[3] = tmp[1];\n    }\n\n  wx[0] -= *((DWORD *)(eKey+(IK0+8)));\n  wx[1] -= *((DWORD *)(eKey+(IK0+12)));\n  wx[2] -= *((DWORD *)(eKey+(IK0)));\n  wx[3] -= *((DWORD *)(eKey+(IK0+4)));\n\n  dst[0] = (BYTE)(wx[2] >> 24);\n  dst[1] = (BYTE)(wx[2] >> 16);\n  dst[2] = (BYTE)(wx[2] >> 8);\n  dst[3] = (BYTE) (wx[2]) ;\n  dst[4] = (BYTE)(wx[3] >> 24);\n  dst[5] = (BYTE)(wx[3] >> 16);\n  dst[6] = (BYTE)(wx[3] >> 8);\n  dst[7] = (BYTE) (wx[3]) ;\n  dst[8] = (BYTE) (wx [0] >> 24) ;\n  dst[9] = (BYTE)(wx[0] >> 16);\n  dst[10] = (BYTE)(wx[0] >> 8);\n  dst[11] = (BYTE) (wx[0]) ;\n  dst[12] = (BYTE)(wx[1] >> 24);\n  dst[13] = (BYTE)(wx[1] >> 16);\n  dst[14] = (BYTE) (wx[1] >> 8) ;\n  dst[15] = (BYTE) (wx[1]) ;\n}\n\nvoid Unicorn_set_key(BYTE *eKey,const BYTE *secret)\n{\n  DWORD   wk[LINE], ek[ROUND*4+8];\n  int   i,j, n = ROUND+2;\n  int   cnt = 0;\n\n  for (i = 0 ; i < LINE ; i++)\n    {\n      wk[i]   = secret[i*4]<<24 | secret[i*4+1]<<16 | secret[i*4+2]  << 8 | secret[i*4+3];\n    }\n\n  for (i = 0 ; i < 3 ; i++)\n    {\n      for (j = 0 ; j < LINE ; j++)\n        {\n          wk[j] *= 0x01010101;\n          wk[(j+1)%LINE] ^= S[ wk[j]>>24 ];\n        }\n    }\n\n  for (i = 0 ; i < 16*((ROUND+2)/2) ; i+=16)\n    {\n      for (j = i ; j < (i+8) ; j++)\n        {\n          wk[j%LINE] *= 0x01010101;\n          wk[(j+1)%LINE]^=S[wk[j%LINE]>>24];\n        }\n\n      for ( ; j < (i+16) ; j++)\n        {\n          wk[j%LINE] *= 0x01010101;\n          ek[cnt++] = wk[(j+1)%LINE] ^= S[ wk[j%LINE]>>24 ];\n        }\n    }\n  memcpy(&eKey[IK0], &ek[0], 4);\n  memcpy(&eKey[IK0+4], &ek[n], 4) ;\n  memcpy(&eKey[IK0+8], &ek[n*2], 4) ;\n  memcpy(&eKey[IK0+12], &ek[n*3], 4);\n  memcpy(&eKey[IK4], &ek[n-1], 4);\n  memcpy(&eKey[IK4+4], &ek[n*2-1], 4);\n  memcpy(&eKey[IK4+8], &ek[n*3-1], 4);\n  memcpy(&eKey[IK4+12], &ek[n*4-1], 4);\n  for (i = 1 ; i <= ROUND ; i++)\n    {\n      memcpy(&eKey[EK0*i], &ek[i], 4);\n      memcpy(&eKey[EK0*i+4], &ek[n+i], 4);\n      memcpy(&eKey[EK0*i+8], &ek[n*2+i], 4);\n      memcpy(&eKey[EK0* i +12], &ek[n*3+ i], 4);\n    }\n  return;\n}\n"
        },
        {
            "file_name": "wheeshtv1mr5fr7t256_encrypt.cpp",
            "content": "#include \"wheeshtv1mr5fr7t256_encrypt.h\"\n#include \"wheeshtv1mr5fr7t256_encrypt-original.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Wheeshtv1mr5fr7t256_raw {\nint numRounds = -1;\n\n/**\n * Wheesht Reference Implementation (Wheesht-5-7-256)\n *\n * Peter Maxwell 20140415\n *\n */\n\n\n\n\nvoid aead_enc_block(\n    aead_params_t * params,\n    aead_state_t * pre_state,\n    aead_block_t * fin_stream,\n    aead_block_t * fin_auth,\n    uint32_t flags  ) {\n\n    uint64_t m0 = 0LLU;\n    uint64_t m1 = 0LLU;\n    uint64_t m2 = 0LLU;\n    uint64_t m3 = 0LLU;\n    uint64_t m4 = 0LLU;\n    uint64_t m5 = 0LLU;\n    uint64_t m6 = 0LLU;\n    uint64_t m7 = 0LLU;\n    uint64_t t04 = 0LLU;\n    uint64_t t26 = 0LLU;\n\n#ifdef DEBUG\n    printf( \"\\n\\n\\naead_enc_block; block = %llu\\n\", params->block0 );\n#endif\n\n    if ( ! ( FLG_PRE_CALC & flags ) ) {\n\n        m0 = params->k0 ^ C0;\n        m1 = params->k1 ^ C1;\n        m2 = params->k2 ^ C2;\n        m3 = params->k3 ^ C3;\n        m4 = params->k0 ^ C4;\n        m5 = params->k1 ^ C5;\n        m6 = params->k2 ^ C6;\n        m7 = params->k3 ^ C7;\n\n        // Mix in s0, s1\n        PRINTSTATE( \"Mix s0,s1,p0,p1\" );\n        MIX( m0, m1, m2, m3, m4, m5, m6, m7, params->s0, params->s1, params->p0, params->p1 );\n        PRINTSTATE( \"\" );\n        PARTROUND5( m0, m1, m2, m3 );\n        PARTROUND5( m4, m5, m6, m7 );\n        PRINTSTATE( \"\" );\n\n        // Mix halves (swap 0<->4 and 2<->6)\n        t04 = m0; m0 = m4; m4 = t04;\n        t26 = m2; m2 = m6; m6 = t26;\n\n        // Save pre-state for future use\n        pre_state->r0 = m0;\n        pre_state->r1 = m1;\n        pre_state->r2 = m2;\n        pre_state->r3 = m3;\n        pre_state->r4 = m4;\n        pre_state->r5 = m5;\n        pre_state->r6 = m6;\n        pre_state->r7 = m7;\n\n    } else {\n\n        m0 = pre_state->r0;\n        m1 = pre_state->r1;\n        m2 = pre_state->r2;\n        m3 = pre_state->r3;\n        m4 = pre_state->r4;\n        m5 = pre_state->r5;\n        m6 = pre_state->r6;\n        m7 = pre_state->r7;\n\n    }\n\n    // Mix in blocks and mode and len\n    PRINTSTATE( \"Mix block0, block1, len, mode\" );\n    MIX( m0, m1, m2, m3, m4, m5, m6, m7, params->block0, params->block1, params->len, params->mode_bits );\n    PRINTSTATE( \"\" );\n    PARTROUND5( m0, m1, m2, m3 );\n    PARTROUND5( m4, m5, m6, m7 );\n    PRINTSTATE( \"\" );\n\n    // Mix halves (swap 0<->4 and 2<->6)\n    t04 = m0; m0 = m4; m4 = t04;\n    t26 = m2; m2 = m6; m6 = t26;\n\n    // Do final transform\n    PRINTSTATE( \"Final transform\" );\n    PARTROUND7( m0, m1, m2, m3 );\n    PARTROUND7( m4, m5, m6, m7 );\n    PRINTSTATE( \"\" );\n\n    // Mix halves (swap 0<->4 and 2<->6)\n    t04 = m0; m0 = m4; m4 = t04;\n    t26 = m2; m2 = m6; m6 = t26;\n\n    // Finalise\n    PRINTSTATE( \"XOR key\" );\n    m0 ^= params->k0;\n    m1 ^= params->k1;\n    m2 ^= params->k2;\n    m3 ^= params->k3;\n    m4 ^= params->k0;\n    m5 ^= params->k1;\n    m6 ^= params->k2;\n    m7 ^= params->k3;\n\n    PRINTSTATE( \"Result\" );\n\n    fin_stream->r0 = m0;\n    fin_stream->r1 = m1;\n    fin_stream->r2 = m2;\n    fin_stream->r3 = m3;\n    fin_auth->r0 = m4;\n    fin_auth->r1 = m5;\n    fin_auth->r2 = m6;\n    fin_auth->r3 = m7;\n\n}\n\n\n\nvoid aead_auth_block(\n    aead_block_t * cipher_text,\n    aead_block_t * auth_block_key,\n    aead_block_t * fin_auth_block ) {\n\n    uint64_t m0 = 0LLU;\n    uint64_t m1 = 0LLU;\n    uint64_t m2 = 0LLU;\n    uint64_t m3 = 0LLU;\n\n#ifdef DEBUG\n    printf(\"\\n\\n\\naead_auth_block\\n\");\n    printf( \"ciphertextin: m0:  %016llx; m1:  %016llx; m2:  %016llx; m3:  %016llx\\n\", cipher_text->r0, cipher_text->r1, cipher_text->r2, cipher_text->r3 );\n    printf( \"auth_block_key: m0:  %016llx; m1:  %016llx; m2:  %016llx; m3:  %016llx\\n\", auth_block_key->r0, auth_block_key->r1, auth_block_key->r2, auth_block_key->r3 );\n    printf( \"fin_auth_block: m0:  %016llx; m1:  %016llx; m2:  %016llx; m3:  %016llx\\n\", fin_auth_block->r0, fin_auth_block->r1, fin_auth_block->r2, fin_auth_block->r3 );\n#endif\n\n    m0 = auth_block_key->r0 ^ cipher_text->r0;\n    m1 = auth_block_key->r1 ^ cipher_text->r1;\n    m2 = auth_block_key->r2 ^ cipher_text->r2;\n    m3 = auth_block_key->r3 ^ cipher_text->r3;\n\n    PRINTHALFSTATE( \"Auth mix\" );\n    PARTROUND5( m0, m1, m2, m3 );\n    PRINTHALFSTATE( \"\" );\n\n    // Finalise\n    fin_auth_block->r0 = m0 ^ auth_block_key->r0;\n    fin_auth_block->r1 = m1 ^ auth_block_key->r1;\n    fin_auth_block->r2 = m2 ^ auth_block_key->r2;\n    fin_auth_block->r3 = m3 ^ auth_block_key->r3;\n\n}\n\n\n\nvoid aead_auth_fin(\n    aead_params_t * params,\n    aead_block_t * auth_key,\n    aead_block_t * fin_auth_block ) {\n\n    uint64_t m0 = C0 ^ auth_key->r0;\n    uint64_t m1 = C1 ^ auth_key->r1;\n    uint64_t m2 = C2 ^ auth_key->r2;\n    uint64_t m3 = C3 ^ auth_key->r3;\n    uint64_t m4 = C4 ^ auth_key->r0;\n    uint64_t m5 = C5 ^ auth_key->r1;\n    uint64_t m6 = C6 ^ auth_key->r2;\n    uint64_t m7 = C7 ^ auth_key->r3;\n    uint64_t t04 = 0LLU;\n    uint64_t t26 = 0LLU;\n\n#ifdef DEBUG\n    printf( \"\\n\\n\\naead_auth_fin\\n\");\n#endif\n\n    PRINTSTATE( \"Auth fin mix s0,s1,p0,p1\" );\n    MIX( m0, m1, m2, m3, m4, m5, m6, m7, params->s0, params->s1, params->p0, params->p1 );\n    PRINTSTATE( \"\" );\n    PARTROUND5( m0, m1, m2, m3 );\n    PARTROUND5( m4, m5, m6, m7 );\n    PRINTSTATE( \"\" );\n\n    // Mix halves (swap 0<->4 and 2<->6)\n    t04 = m0; m0 = m4; m4 = t04;\n    t26 = m2; m2 = m6; m6 = t26;\n\n    // Mix in blocks, mode and len\n    PRINTSTATE( \"Mix blocks, len and mode\" );\n    MIX( m0, m1, m2, m3, m4, m5, m6, m7, params->block0, params->block1, params->len, params->mode_bits );\n    PRINTSTATE( \"\" );\n    PARTROUND5( m0, m1, m2, m3 );\n    PARTROUND5( m4, m5, m6, m7 );\n    PRINTSTATE( \"\" );\n\n    // Mix halves (swap 0<->4 and 2<->6)\n    t04 = m0; m0 = m4; m4 = t04;\n    t26 = m2; m2 = m6; m6 = t26;\n\n    // Do final transform\n    PRINTSTATE( \"Final transform\" );\n    PARTROUND7( m0, m1, m2, m3 );\n    PARTROUND7( m4, m5, m6, m7 );\n    PRINTSTATE( \"\" );\n\n    // Finalise\n    fin_auth_block->r0 = m0 ^ m4 ^ auth_key->r0;\n    fin_auth_block->r1 = m1 ^ m5 ^ auth_key->r1;\n    fin_auth_block->r2 = m2 ^ m6 ^ auth_key->r2;\n    fin_auth_block->r3 = m3 ^ m7 ^ auth_key->r3;\n\n}\n\n\n\nint crypto_aead_encrypt(\n    unsigned char *c,unsigned long long *clen,\n    const unsigned char *m,unsigned long long mlen,\n    const unsigned char *ad,unsigned long long adlen,\n    const unsigned char *nsec,\n    const unsigned char *npub,\n    const unsigned char *k\n) {\n\n    // Set things up\n    aead_params_t aead_params;\n    aead_params.k0 = *( (uint64_t*)( k + 0 ) );\n    aead_params.k1 = *( (uint64_t*)( k + 8 ) );\n    aead_params.k2 = *( (uint64_t*)( k + 16 ) );\n    aead_params.k3 = *( (uint64_t*)( k + 24 ) );\n\n    // Because I misread the requirements, got the secret number mixed-up\n    // so have in effect removed the secret number and doubled size of\n    // public number, for now at least.\n    aead_params.p0 = *( (uint64_t*)( npub ) );\n    aead_params.p1 = *( (uint64_t*)( npub + 8 ) );\n    aead_params.s0 = *( (uint64_t*)( npub + 16 ) );\n    aead_params.s1 = *( (uint64_t*)( npub + 24 ) );\n\n    aead_block_t aead_block_afinkey;\n    aead_block_afinkey.r0 = *( (uint64_t*)( k + 32 ) );\n    aead_block_afinkey.r1 = *( (uint64_t*)( k + 40 ) );\n    aead_block_afinkey.r2 = *( (uint64_t*)( k + 48 ) );\n    aead_block_afinkey.r3 = *( (uint64_t*)( k + 56 ) );\n\n#ifdef DEBUG\n    printf( \"\\n\\n\\n----------\\n\" );\n    printf( \"K_c   : %016llx; %016llx; %016llx; %016llx;\\n\", aead_params.k0, aead_params.k1, aead_params.k2, aead_params.k3 );\n    printf( \"K_f   : %016llx; %016llx; %016llx; %016llx;\\n\", aead_block_afinkey.r0, aead_block_afinkey.r1, aead_block_afinkey.r2, aead_block_afinkey.r3 );\n    printf( \"npub  : %016llx; %016llx;\\n\", aead_params.p0, aead_params.p1 );\n    printf( \"nsec  : %016llx; %016llx;\\n\", aead_params.s0, aead_params.s1 );\n    printf( \"mlen  : %016llx (%llu);\\n\", mlen, mlen );\n    printf( \"adlen : %016llx (%llu);\\n\", adlen, adlen );\n    printf( \"----------\\n\\n\\n\" );\n#endif\n\n    // Cur block stream cipher result\n    aead_block_t aead_block_cfin = { 0LLU, 0LLU, 0LLU, 0LLU };\n\n    // Cur block auth value returned key and result\n    aead_block_t aead_block_atkey = { 0LLU, 0LLU, 0LLU, 0LLU };\n    aead_block_t aead_block_afin = { 0LLU, 0LLU, 0LLU, 0LLU };\n\n    // Cur working block\n    aead_block_t aead_block_work = { 0LLU, 0LLU, 0LLU, 0LLU };\n\n    // Total auth value result (word-wise addition of all previous values)\n    aead_block_t aead_block_auth = { 0LLU, 0LLU, 0LLU, 0LLU };\n\n    // Pre-calc'd states\n    aead_state_t pre_state = { 0LLU, 0LLU, 0LLU, 0LLU, 0LLU, 0LLU, 0LLU, 0LLU };\n\n    // Counters and such like\n    uint64_t m_block0 = 0LLU;\n    uint64_t m_block1 = 0LLU; // Obviously we'll never get this far, more for the sake of completeness\n    uint64_t ad_block0 = 0LLU;\n    uint64_t ad_block1 = 0LLU; // Obviously we'll never get this far, more for the sake of completeness\n    uint64_t m_bytes_left = mlen;\n    uint64_t ad_bytes_left = adlen;\n    uint32_t cur_flags = 0LLU;\n\n    // Current pointer within the output ciphertext buffer\n    unsigned char * cur_c = c;\n\n    // Make sure we zero out the c buffer\n    memset( c, 0, mlen + 32 );\n\n    // Encrypt first\n    while ( m_bytes_left > 0 ) {\n\n        // Test whether we've got a whole 256-bit == 32 byte block to work with or not\n        if ( m_bytes_left < BLOCKSIZE_BYTES ) {\n\n            // Partial block this time\n            memset( (unsigned char*)&aead_block_work, 0, sizeof( aead_block_t ) );\n            memcpy( (unsigned char*)&aead_block_work, (unsigned char*)m + ( m_block0 * BLOCKSIZE_BYTES ), m_bytes_left );\n\n            // Setup parameters\n            aead_params.block0 = m_block0;\n            aead_params.block1 = 0LLU;\n            aead_params.mode_bits = CRYPT_CIPHERTEXTBLOCK || CRYPT_HASNSEC  || CRYPT_HASNPUB || CRYPT_LASTBLOCK;\n            aead_params.len = m_bytes_left * 8;\n\n            // Set pre-calc mode(s) if not the first block\n            cur_flags = 0LLU;\n            cur_flags |= ( 0 == m_block0 ) ? 0 : FLG_PRE_CALC;\n\n            // Calculate this block\n            aead_enc_block( &aead_params, &pre_state, &aead_block_cfin, &aead_block_atkey, cur_flags  );\n\n            // XOR with plaintext\n            aead_block_work.r0 ^= aead_block_cfin.r0;\n            aead_block_work.r1 ^= aead_block_cfin.r1;\n            aead_block_work.r2 ^= aead_block_cfin.r2;\n            aead_block_work.r3 ^= aead_block_cfin.r3;\n\n            // Calculate auth for this block\n            aead_block_afin.r0 = 0LLU;\n            aead_block_afin.r1 = 0LLU;\n            aead_block_afin.r2 = 0LLU;\n            aead_block_afin.r3 = 0LLU;\n            aead_auth_block( &aead_block_work, &aead_block_atkey, &aead_block_afin );\n\n            // Copy ciphertext into buffer\n            memcpy( (unsigned char*)cur_c, (unsigned char*)&aead_block_work, m_bytes_left );\n            cur_c += m_bytes_left;\n\n            // Decrement m_bytes_left to zero\n            m_bytes_left = 0;\n\n\n        } else {\n\n            // We've got a whole block so it's easy\n            memset( (unsigned char*)&aead_block_work, 0, sizeof( aead_block_t ) );\n            memcpy( (unsigned char*)&aead_block_work, (unsigned char*)m + ( m_block0 * BLOCKSIZE_BYTES ), BLOCKSIZE_BYTES );\n\n            // Setup parameters\n            aead_params.block0 = m_block0;\n            aead_params.block1 = 0LLU;\n            aead_params.mode_bits = CRYPT_CIPHERTEXTBLOCK || CRYPT_HASNSEC  || CRYPT_HASNPUB;\n            aead_params.len = 256LLU;\n\n            // Set pre-calc mode(s) if not the first block\n            cur_flags = 0LLU;\n            cur_flags |=  ( 0 == m_block0 ) ? 0 : FLG_PRE_CALC;\n\n            // Calculate this block\n            aead_enc_block( &aead_params, &pre_state, &aead_block_cfin, &aead_block_atkey, cur_flags  );\n\n            // XOR with plaintext\n            aead_block_work.r0 ^= aead_block_cfin.r0;\n            aead_block_work.r1 ^= aead_block_cfin.r1;\n            aead_block_work.r2 ^= aead_block_cfin.r2;\n            aead_block_work.r3 ^= aead_block_cfin.r3;\n\n            // Calculate auth for this block\n            aead_block_afin.r0 = 0LLU;\n            aead_block_afin.r1 = 0LLU;\n            aead_block_afin.r2 = 0LLU;\n            aead_block_afin.r3 = 0LLU;\n            aead_auth_block( &aead_block_work, &aead_block_atkey, &aead_block_afin );\n\n            // Copy ciphertext into buffer\n            memcpy( (unsigned char*)cur_c, (unsigned char*)&aead_block_work, sizeof( aead_block_t ) );\n            cur_c += BLOCKSIZE_BYTES;\n\n            // Decrement m_bytes_left by blocksize\n            m_bytes_left -= BLOCKSIZE_BYTES;\n\n        }\n\n        // Add auth word-wise into total auth value\n        aead_block_auth.r0 += aead_block_afin.r0;\n        aead_block_auth.r1 += aead_block_afin.r1;\n        aead_block_auth.r2 += aead_block_afin.r2;\n        aead_block_auth.r3 += aead_block_afin.r3;\n\n        // Increment block counter\n        ++m_block0;\n\n    }\n\n    // Do ad\n    while ( ad_bytes_left > 0 ) {\n\n        // Test whether we've got a whole 256-bit == 32 byte block to work with or not\n        if ( ad_bytes_left < BLOCKSIZE_BYTES ) {\n\n            // Partial block this time\n            memset( (unsigned char*)&aead_block_work, 0, sizeof( aead_block_t ) );\n            memcpy( (unsigned char*)&aead_block_work, (unsigned char*)ad + ( ad_block0 * BLOCKSIZE_BYTES ), ad_bytes_left );\n\n            // Setup parameters\n            aead_params.block0 = ad_block0;\n            aead_params.block1 = 0LLU;\n            aead_params.mode_bits = CRYPT_ADBLOCK || CRYPT_HASNSEC  || CRYPT_HASNPUB || CRYPT_LASTBLOCK;\n            aead_params.len = ad_bytes_left * 8;\n\n            // Set pre-calc mode(s) if not the first block\n            cur_flags = 0LLU;\n            cur_flags |= ( 0 == ad_block0 ) ? 0 : FLG_PRE_CALC;\n\n            // Calculate this block\n            aead_enc_block( &aead_params, &pre_state, &aead_block_cfin, &aead_block_atkey, cur_flags  );\n\n            // XOR with plaintext\n            aead_block_work.r0 ^= aead_block_cfin.r0;\n            aead_block_work.r1 ^= aead_block_cfin.r1;\n            aead_block_work.r2 ^= aead_block_cfin.r2;\n            aead_block_work.r3 ^= aead_block_cfin.r3;\n\n            // Decrement ad_bytes_left to zero\n            ad_bytes_left = 0;\n\n\n        } else {\n\n            // We've got a whole block so it's easy\n            memset( (unsigned char*)&aead_block_work, 0, sizeof( aead_block_t ) );\n            memcpy( (unsigned char*)&aead_block_work, (unsigned char*)ad + ( ad_block0 * BLOCKSIZE_BYTES ), BLOCKSIZE_BYTES );\n\n            // Setup parameters\n            aead_params.block0 = ad_block0;\n            aead_params.block1 = 0LLU;\n            aead_params.mode_bits = CRYPT_ADBLOCK || CRYPT_HASNSEC  || CRYPT_HASNPUB;\n            aead_params.len = 256LLU;\n\n            // Set pre-calc mode(s) if not the first block\n            cur_flags = 0LLU;\n            cur_flags |= ( 0 == ad_block0 ) ? 0 : FLG_PRE_CALC;\n\n            // Calculate this block\n            aead_enc_block( &aead_params, &pre_state, &aead_block_cfin, &aead_block_atkey, cur_flags  );\n\n            // XOR with plaintext\n            aead_block_work.r0 ^= aead_block_cfin.r0;\n            aead_block_work.r1 ^= aead_block_cfin.r1;\n            aead_block_work.r2 ^= aead_block_cfin.r2;\n            aead_block_work.r3 ^= aead_block_cfin.r3;\n\n            // Decrement ad_bytes_left by blocksize\n            ad_bytes_left -= BLOCKSIZE_BYTES;\n\n        }\n\n        // Calculate auth for this block\n        aead_block_afin.r0 = 0LLU;\n        aead_block_afin.r1 = 0LLU;\n        aead_block_afin.r2 = 0LLU;\n        aead_block_afin.r3 = 0LLU;\n        aead_auth_block( &aead_block_work, &aead_block_atkey, &aead_block_afin );\n\n        // Add word-wise into total auth value\n        aead_block_auth.r0 += aead_block_afin.r0;\n        aead_block_auth.r1 += aead_block_afin.r1;\n        aead_block_auth.r2 += aead_block_afin.r2;\n        aead_block_auth.r3 += aead_block_afin.r3;\n\n        // Increment block counter\n        ++ad_block0;\n\n    }\n\n#ifdef DEBUG\n    printf( \"\\nAuth before finalisation tag added: %016llx; %016llx; %016llx; %016llx;\\n\", aead_block_auth.r0, aead_block_auth.r1, aead_block_auth.r2, aead_block_auth.r3 );\n#endif\n\n    // Final auth\n    aead_params.block0 = m_block0 + ad_block0;\n    aead_params.mode_bits = CRYPT_AUTHFINAL || CRYPT_HASNSEC  || CRYPT_HASNPUB || CRYPT_LASTBLOCK;\n    aead_params.len = 256LLU;\n    aead_auth_fin( &aead_params, &aead_block_afinkey, &aead_block_atkey );\n    aead_block_auth.r0 += aead_block_atkey.r0;\n    aead_block_auth.r1 += aead_block_atkey.r1;\n    aead_block_auth.r2 += aead_block_atkey.r2;\n    aead_block_auth.r3 += aead_block_atkey.r3;\n\n#ifdef DEBUG\n    printf( \"\\nAuth Tag: %016llx; %016llx; %016llx; %016llx;\\n\", aead_block_auth.r0, aead_block_auth.r1, aead_block_auth.r2, aead_block_auth.r3 );\n#endif\n\n    // Add auth tag to end of ciphertext stream\n    memcpy( (unsigned char*)cur_c, (unsigned char*)&aead_block_auth, sizeof( aead_block_t ) );\n\n    // Before I forget, set the output clen\n    *clen = mlen + BLOCKSIZE_BYTES;\n\n    return 0;\n}\n\n\n\n\nint crypto_aead_decrypt(\n    unsigned char *m,unsigned long long *outputmlen,\n    unsigned char *nsec,\n    const unsigned char *c,unsigned long long clen,\n    const unsigned char *ad,unsigned long long adlen,\n    const unsigned char *npub,\n    const unsigned char *k\n) {\n\n    // Set things up\n    aead_params_t aead_params;\n    aead_params.k0 = *( (uint64_t*)( k + 0 ) );\n    aead_params.k1 = *( (uint64_t*)( k + 8 ) );\n    aead_params.k2 = *( (uint64_t*)( k + 16 ) );\n    aead_params.k3 = *( (uint64_t*)( k + 24 ) );\n\n    // Because I misread the requirements, got the secret number mixed-up\n    // so have in effect removed the secret number and doubled size of\n    // public number, for now at least.\n    aead_params.p0 = *( (uint64_t*)( npub ) );\n    aead_params.p1 = *( (uint64_t*)( npub + 8 ) );\n    aead_params.s0 = *( (uint64_t*)( npub + 16 ) );\n    aead_params.s1 = *( (uint64_t*)( npub + 24 ) );\n\n    aead_block_t aead_block_afinkey;\n    aead_block_afinkey.r0 = *( (uint64_t*)( k + 32 ) );\n    aead_block_afinkey.r1 = *( (uint64_t*)( k + 40 ) );\n    aead_block_afinkey.r2 = *( (uint64_t*)( k + 48 ) );\n    aead_block_afinkey.r3 = *( (uint64_t*)( k + 56 ) );\n\n#ifdef DEBUG\n    printf( \"\\n\\n\\n----------\\n\" );\n    printf( \"K_c   : %016llx; %016llx; %016llx; %016llx;\\n\", aead_params.k0, aead_params.k1, aead_params.k2, aead_params.k3 );\n    printf( \"K_f   : %016llx; %016llx; %016llx; %016llx;\\n\", aead_block_afinkey.r0, aead_block_afinkey.r1, aead_block_afinkey.r2, aead_block_afinkey.r3 );\n    printf( \"npub  : %016llx; %016llx;\\n\", aead_params.p0, aead_params.p1 );\n    printf( \"nsec  : %016llx; %016llx;\\n\", aead_params.s0, aead_params.s1 );\n    printf( \"clan  : %016llx (%llu);\\n\", clen, clen );\n    printf( \"adlen : %016llx (%llu);\\n\", adlen, adlen );\n    printf( \"----------\\n\\n\\n\" );\n#endif\n\n    // Cur block stream cipher result\n    aead_block_t aead_block_cfin = { 0LLU, 0LLU, 0LLU, 0LLU };\n\n    // Cur block auth value returned key and result\n    aead_block_t aead_block_atkey = { 0LLU, 0LLU, 0LLU, 0LLU };\n    aead_block_t aead_block_afin = { 0LLU, 0LLU, 0LLU, 0LLU };\n\n    // Cur working block\n    aead_block_t aead_block_work = { 0LLU, 0LLU, 0LLU, 0LLU };\n\n    // Comparator final tag\n    aead_block_t aead_block_giventag = { 0LLU, 0LLU, 0LLU, 0LLU };\n\n    // Total auth value result (word-wise addition of all previous values)\n    aead_block_t aead_block_auth = { 0LLU, 0LLU, 0LLU, 0LLU };\n\n    // Pre-calc'd states\n    aead_state_t pre_state = { 0LLU, 0LLU, 0LLU, 0LLU, 0LLU, 0LLU, 0LLU, 0LLU };\n\n    // Temp mask\n    aead_state_t temp_mask = { 0LLU, 0LLU, 0LLU, 0LLU };\n\n    // Calculate the message length (ciphertext length less the auth tag)\n    signed long long message_len = ( clen - BLOCKSIZE_BYTES );\n    assert( message_len >= 0 );\n    *outputmlen = message_len;\n\n    // Counters and such like\n    uint64_t m_block0 = 0LLU;\n    uint64_t m_block1 = 0LLU; // Obviously we'll never get this far, more for the sake of completeness\n    uint64_t ad_block0 = 0LLU;\n    uint64_t ad_block1 = 0LLU; // Obviously we'll never get this far, more for the sake of completeness\n    uint64_t m_bytes_left = message_len;\n    uint64_t ad_bytes_left = adlen;\n    uint32_t cur_flags = 0LLU;\n\n    // Current pointer within the input ciphertext buffer\n    const unsigned char * cur_c = c;\n\n    // Make sure we zero out the m buffer\n    memset( m, 0, message_len );\n\n    // Encrypt first\n    while ( m_bytes_left > 0 ) {\n\n        // Test whether we've got a whole 256-bit == 32 byte block to work with or not\n        if ( m_bytes_left < BLOCKSIZE_BYTES ) {\n\n            // Copy ciphertext into working state\n            memset( (unsigned char*)&aead_block_work, 0, sizeof( aead_block_t ) );\n            memcpy( (unsigned char*)&aead_block_work, (unsigned char*)cur_c, m_bytes_left );\n            cur_c += m_bytes_left;\n\n            // Setup parameters\n            aead_params.block0 = m_block0;\n            aead_params.block1 = 0LLU;\n            aead_params.mode_bits = CRYPT_CIPHERTEXTBLOCK || CRYPT_HASNSEC  || CRYPT_HASNPUB || CRYPT_LASTBLOCK;\n            aead_params.len = m_bytes_left * 8;\n\n            // Set pre-calc mode(s) if not the first block\n            cur_flags = 0LLU;\n            cur_flags |= ( 0 == m_block0 ) ? 0 : FLG_PRE_CALC;\n\n            // Calculate this block\n            aead_enc_block( &aead_params, &pre_state, &aead_block_cfin, &aead_block_atkey, cur_flags  );\n\n            // Because we calc auth on whole blocks, even the last, and the\n            // cipher text doesn't have the last n bytes, we must use the\n            // calculated result and mask it in.\n            memset( (unsigned char*)&temp_mask, 0, BLOCKSIZE_BYTES );\n            memset( (unsigned char*)(&temp_mask) + m_bytes_left, (char)0xff, BLOCKSIZE_BYTES - m_bytes_left );\n            temp_mask.r0 &= aead_block_cfin.r0;\n            temp_mask.r1 &= aead_block_cfin.r1;\n            temp_mask.r2 &= aead_block_cfin.r2;\n            temp_mask.r3 &= aead_block_cfin.r3;\n            aead_block_work.r0 |= temp_mask.r0;\n            aead_block_work.r1 |= temp_mask.r1;\n            aead_block_work.r2 |= temp_mask.r2;\n            aead_block_work.r3 |= temp_mask.r3;\n\n            // Calculate auth for this block\n            aead_block_afin.r0 = 0LLU;\n            aead_block_afin.r1 = 0LLU;\n            aead_block_afin.r2 = 0LLU;\n            aead_block_afin.r3 = 0LLU;\n            aead_auth_block( &aead_block_work, &aead_block_atkey, &aead_block_afin );\n\n            // XOR with plaintext\n            aead_block_work.r0 ^= aead_block_cfin.r0;\n            aead_block_work.r1 ^= aead_block_cfin.r1;\n            aead_block_work.r2 ^= aead_block_cfin.r2;\n            aead_block_work.r3 ^= aead_block_cfin.r3;\n\n            // Partial block this time\n            memcpy( (unsigned char*)m + ( m_block0 * BLOCKSIZE_BYTES ), (unsigned char*)&aead_block_work, m_bytes_left );\n\n            // Decrement m_bytes_left to zero\n            m_bytes_left = 0;\n\n\n        } else {\n\n            // Copy ciphertext into working state\n            memset( (unsigned char*)&aead_block_work, 0, sizeof( aead_block_t ) );\n            memcpy( (unsigned char*)&aead_block_work, cur_c, BLOCKSIZE_BYTES );\n            cur_c += BLOCKSIZE_BYTES;\n\n            // Setup parameters\n            aead_params.block0 = m_block0;\n            aead_params.block1 = 0LLU;\n            aead_params.mode_bits = CRYPT_CIPHERTEXTBLOCK || CRYPT_HASNSEC  || CRYPT_HASNPUB;\n            aead_params.len = 256LLU;\n\n            // Set pre-calc mode(s) if not the first block\n            cur_flags = 0LLU;\n            cur_flags |=  ( 0 == m_block0 ) ? 0 : FLG_PRE_CALC;\n\n            // Calculate this block\n            aead_enc_block( &aead_params, &pre_state, &aead_block_cfin, &aead_block_atkey, cur_flags  );\n\n            // Calculate auth for this block\n            aead_block_afin.r0 = 0LLU;\n            aead_block_afin.r1 = 0LLU;\n            aead_block_afin.r2 = 0LLU;\n            aead_block_afin.r3 = 0LLU;\n            aead_auth_block( &aead_block_work, &aead_block_atkey, &aead_block_afin );\n\n            // XOR with plaintext\n            aead_block_work.r0 ^= aead_block_cfin.r0;\n            aead_block_work.r1 ^= aead_block_cfin.r1;\n            aead_block_work.r2 ^= aead_block_cfin.r2;\n            aead_block_work.r3 ^= aead_block_cfin.r3;\n\n            // We've got a whole block so it's easy\n            memcpy( (unsigned char*)m + ( m_block0 * BLOCKSIZE_BYTES ), (unsigned char*)&aead_block_work, BLOCKSIZE_BYTES );\n\n            // Decrement m_bytes_left by blocksize\n            m_bytes_left -= BLOCKSIZE_BYTES;\n\n        }\n\n        // Add word-wise into total auth value\n        aead_block_auth.r0 += aead_block_afin.r0;\n        aead_block_auth.r1 += aead_block_afin.r1;\n        aead_block_auth.r2 += aead_block_afin.r2;\n        aead_block_auth.r3 += aead_block_afin.r3;\n\n        // Increment block counter\n        ++m_block0;\n\n    }\n\n    // Do ad\n    while ( ad_bytes_left > 0 ) {\n\n        // Test whether we've got a whole 256-bit == 32 byte block to work with or not\n        if ( ad_bytes_left < BLOCKSIZE_BYTES ) {\n\n            // Copy ad into working state\n            memset( (unsigned char*)&aead_block_work, 0, sizeof( aead_block_t ) );\n            memcpy( (unsigned char*)&aead_block_work, (unsigned char*)ad + ( ad_block0 * BLOCKSIZE_BYTES ), ad_bytes_left );\n\n            // Setup parameters\n            aead_params.block0 = ad_block0;\n            aead_params.block1 = 0LLU;\n            aead_params.mode_bits = CRYPT_ADBLOCK || CRYPT_HASNSEC  || CRYPT_HASNPUB || CRYPT_LASTBLOCK;\n            aead_params.len = ad_bytes_left * 8;\n\n            // Set pre-calc mode(s) if not the first block\n            cur_flags = 0LLU;\n            cur_flags |= ( 0 == ad_block0 ) ? 0 : FLG_PRE_CALC;\n\n            // Calculate this block\n            aead_enc_block( &aead_params, &pre_state, &aead_block_cfin, &aead_block_atkey, cur_flags  );\n\n            // XOR with plaintext\n            aead_block_work.r0 ^= aead_block_cfin.r0;\n            aead_block_work.r1 ^= aead_block_cfin.r1;\n            aead_block_work.r2 ^= aead_block_cfin.r2;\n            aead_block_work.r3 ^= aead_block_cfin.r3;\n\n            // Decrement ad_bytes_left to zero\n            ad_bytes_left = 0;\n\n\n        } else {\n\n            // Copy ad into working state\n            memset( (unsigned char*)&aead_block_work, 0, sizeof( aead_block_t ) );\n            memcpy( (unsigned char*)&aead_block_work, (unsigned char*)ad + ( ad_block0 * BLOCKSIZE_BYTES ), BLOCKSIZE_BYTES );\n\n\n            // Setup parameters\n            aead_params.block0 = ad_block0;\n            aead_params.block1 = 0LLU;\n            aead_params.mode_bits = CRYPT_ADBLOCK || CRYPT_HASNSEC  || CRYPT_HASNPUB;\n            aead_params.len = 256LLU;\n\n            // Set pre-calc mode(s) if not the first block\n            cur_flags = 0LLU;\n            cur_flags |= ( 0 == ad_block0 ) ? 0 : FLG_PRE_CALC;\n\n            // Calculate this block\n            aead_enc_block( &aead_params, &pre_state, &aead_block_cfin, &aead_block_atkey, cur_flags  );\n\n            // XOR with plaintext\n            aead_block_work.r0 ^= aead_block_cfin.r0;\n            aead_block_work.r1 ^= aead_block_cfin.r1;\n            aead_block_work.r2 ^= aead_block_cfin.r2;\n            aead_block_work.r3 ^= aead_block_cfin.r3;\n\n            // Decrement ad_bytes_left by blocksize\n            ad_bytes_left -= BLOCKSIZE_BYTES;\n\n        }\n\n        // Calculate auth for this block\n        aead_block_afin.r0 = 0LLU;\n        aead_block_afin.r1 = 0LLU;\n        aead_block_afin.r2 = 0LLU;\n        aead_block_afin.r3 = 0LLU;\n        aead_auth_block( &aead_block_work, &aead_block_atkey, &aead_block_afin );\n\n        // Add word-wise into total auth value\n        aead_block_auth.r0 += aead_block_afin.r0;\n        aead_block_auth.r1 += aead_block_afin.r1;\n        aead_block_auth.r2 += aead_block_afin.r2;\n        aead_block_auth.r3 += aead_block_afin.r3;\n\n        // Increment block counter\n        ++ad_block0;\n\n    }\n\n#ifdef DEBUG\n    printf( \"\\nAuth before finalisation tag added: %016llx; %016llx; %016llx; %016llx;\\n\", aead_block_auth.r0, aead_block_auth.r1, aead_block_auth.r2, aead_block_auth.r3 );\n#endif\n\n    // Final auth\n    aead_params.block0 = m_block0 + ad_block0;\n    aead_params.mode_bits = CRYPT_AUTHFINAL || CRYPT_HASNSEC  || CRYPT_HASNPUB || CRYPT_LASTBLOCK;\n    aead_params.len = 256LLU;\n    aead_auth_fin( &aead_params, &aead_block_afinkey, &aead_block_atkey );\n    aead_block_auth.r0 += aead_block_atkey.r0;\n    aead_block_auth.r1 += aead_block_atkey.r1;\n    aead_block_auth.r2 += aead_block_atkey.r2;\n    aead_block_auth.r3 += aead_block_atkey.r3;\n\n#ifdef DEBUG\n    printf( \"\\nAuth Tag: %016llx; %016llx; %016llx; %016llx;\\n\", aead_block_auth.r0, aead_block_auth.r1, aead_block_auth.r2, aead_block_auth.r3 );\n#endif\n\n    // Compare auth tags\n    memcpy( (unsigned char*)&aead_block_giventag, (unsigned char*)cur_c, BLOCKSIZE_BYTES );\n    if ( \t( aead_block_auth.r0 == aead_block_giventag.r0 ) &&\n            ( aead_block_auth.r1 == aead_block_giventag.r1 ) &&\n            ( aead_block_auth.r2 == aead_block_giventag.r2 ) &&\n            ( aead_block_auth.r3 == aead_block_giventag.r3 ) ) {\n\n        return 0;\n\n    } else {\n\n        return -1;\n\n    }\n\n\n}\n\n\n    /*\n    unsigned char ourconst[] = \"Gloomy Winter's noo awa'; saft the westlin' breezes blaw. 1808\\n\";\n    int ourconstlen = strlen( ourconst );\n    printf( \"String: %s\\nLength: %d\\n\", ourconst, ourconstlen );\n\n    aead_block_t aead_block_ourconst = { 0LLU, 0LLU, 0LLU, 0LLU };\n    aead_bytestream_to_u64block( ourconst, &aead_block_ourconst, 0, 32 );\n    aead_bytestream_to_u64block( ourconst, &aead_block_ourconst, 32, 32 ); */\n\n\n} // namespace Wheeshtv1mr5fr7t256_raw\n"
        },
        {
            "file_name": "Yaes128v2.cpp",
            "content": "#include \"Yaes128v2.h\"\n#include \"yaes128v2_encrypt.h\"\n#include \"../../common/api.h\"\n#include \"EACglobals.h\"\n\nYaes128v2::Yaes128v2(int numRounds)\n    : CaesarInterface(CAESAR_YAES128V2, numRounds, CRYPTO_KEYBYTES, CRYPTO_NSECBYTES, CRYPTO_NPUBBYTES, CRYPTO_ABYTES) {\n    if (numRounds < -1 || numRounds > maxNumRounds) {\n        mainLogger.out(LOGGER_WARNING) << \"Weird number of rouds (\" << numRounds << \") for \" << shortDescription() << endl;\n    }\n    if (numRounds == -1) {\n        Yaes128v2_raw::numRounds = maxNumRounds;\n        CaesarCommon::numRounds = maxNumRounds;\n    } else {\n        Yaes128v2_raw::numRounds = m_numRounds;\n        CaesarCommon::numRounds = m_numRounds;\n    }\n}\n\nYaes128v2::~Yaes128v2() { }\n\nint Yaes128v2::encrypt(bits_t *c, length_t *clen, const bits_t *m, length_t mlen,\n                       const bits_t *ad, length_t adlen, const bits_t *nsec, const bits_t *npub,\n                       const bits_t *k) {\n    return Yaes128v2_raw::crypto_aead_encrypt(c, clen, m, mlen, ad, adlen, nsec, npub, k);\n}\n\nint Yaes128v2::decrypt(bits_t *m, length_t *outputmlen, bits_t *nsec,\n                       const bits_t *c, length_t clen, const bits_t *ad, length_t adlen,\n                       const bits_t *npub, const bits_t *k) {\n    return Yaes128v2_raw::crypto_aead_decrypt(m, outputmlen, nsec, c, clen, ad, adlen, npub, k);\n}\n\nstd::string Yaes128v2::shortDescription() const {\n    return \"Yaes128v2\";\n}\n"
        },
        {
            "file_name": "yaes128v2_aes-128.cpp",
            "content": "/**\n * aes-128.c\n *\n * @version 3.0 (December 2000)\n *\n * Optimised ANSI C code for the Rijndael cipher (now AES)\n *\n * @author Vincent Rijmen <vincent.rijmen@esat.kuleuven.be>\n * @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.be>\n * @author Paulo Barreto <paulo.barreto@terra.com.br>\n *\n * This code is hereby placed in the public domain.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Adapted for use with the reference implementation of YAES\n * May 2014\n * @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.be>\n */\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"yaes128v2_aes-128.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Yaes128v2_raw {\n\n/*\nTe0[x] = S [x].[02, 01, 01, 03];\nTe1[x] = S [x].[03, 02, 01, 01];\nTe2[x] = S [x].[01, 03, 02, 01];\nTe3[x] = S [x].[01, 01, 03, 02];\nTe4[x] = S [x].[01, 01, 01, 01];\n\nTd0[x] = Si[x].[0e, 09, 0d, 0b];\nTd1[x] = Si[x].[0b, 0e, 09, 0d];\nTd2[x] = Si[x].[0d, 0b, 0e, 09];\nTd3[x] = Si[x].[09, 0d, 0b, 0e];\nTd4[x] = Si[x].[01, 01, 01, 01];\n*/\n\nstatic const u32 Te0[256] = {\n    0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,\n    0xfff2f20dU, 0xd66b6bbdU, 0xde6f6fb1U, 0x91c5c554U,\n    0x60303050U, 0x02010103U, 0xce6767a9U, 0x562b2b7dU,\n    0xe7fefe19U, 0xb5d7d762U, 0x4dababe6U, 0xec76769aU,\n    0x8fcaca45U, 0x1f82829dU, 0x89c9c940U, 0xfa7d7d87U,\n    0xeffafa15U, 0xb25959ebU, 0x8e4747c9U, 0xfbf0f00bU,\n    0x41adadecU, 0xb3d4d467U, 0x5fa2a2fdU, 0x45afafeaU,\n    0x239c9cbfU, 0x53a4a4f7U, 0xe4727296U, 0x9bc0c05bU,\n    0x75b7b7c2U, 0xe1fdfd1cU, 0x3d9393aeU, 0x4c26266aU,\n    0x6c36365aU, 0x7e3f3f41U, 0xf5f7f702U, 0x83cccc4fU,\n    0x6834345cU, 0x51a5a5f4U, 0xd1e5e534U, 0xf9f1f108U,\n    0xe2717193U, 0xabd8d873U, 0x62313153U, 0x2a15153fU,\n    0x0804040cU, 0x95c7c752U, 0x46232365U, 0x9dc3c35eU,\n    0x30181828U, 0x379696a1U, 0x0a05050fU, 0x2f9a9ab5U,\n    0x0e070709U, 0x24121236U, 0x1b80809bU, 0xdfe2e23dU,\n    0xcdebeb26U, 0x4e272769U, 0x7fb2b2cdU, 0xea75759fU,\n    0x1209091bU, 0x1d83839eU, 0x582c2c74U, 0x341a1a2eU,\n    0x361b1b2dU, 0xdc6e6eb2U, 0xb45a5aeeU, 0x5ba0a0fbU,\n    0xa45252f6U, 0x763b3b4dU, 0xb7d6d661U, 0x7db3b3ceU,\n    0x5229297bU, 0xdde3e33eU, 0x5e2f2f71U, 0x13848497U,\n    0xa65353f5U, 0xb9d1d168U, 0x00000000U, 0xc1eded2cU,\n    0x40202060U, 0xe3fcfc1fU, 0x79b1b1c8U, 0xb65b5bedU,\n    0xd46a6abeU, 0x8dcbcb46U, 0x67bebed9U, 0x7239394bU,\n    0x944a4adeU, 0x984c4cd4U, 0xb05858e8U, 0x85cfcf4aU,\n    0xbbd0d06bU, 0xc5efef2aU, 0x4faaaae5U, 0xedfbfb16U,\n    0x864343c5U, 0x9a4d4dd7U, 0x66333355U, 0x11858594U,\n    0x8a4545cfU, 0xe9f9f910U, 0x04020206U, 0xfe7f7f81U,\n    0xa05050f0U, 0x783c3c44U, 0x259f9fbaU, 0x4ba8a8e3U,\n    0xa25151f3U, 0x5da3a3feU, 0x804040c0U, 0x058f8f8aU,\n    0x3f9292adU, 0x219d9dbcU, 0x70383848U, 0xf1f5f504U,\n    0x63bcbcdfU, 0x77b6b6c1U, 0xafdada75U, 0x42212163U,\n    0x20101030U, 0xe5ffff1aU, 0xfdf3f30eU, 0xbfd2d26dU,\n    0x81cdcd4cU, 0x180c0c14U, 0x26131335U, 0xc3ecec2fU,\n    0xbe5f5fe1U, 0x359797a2U, 0x884444ccU, 0x2e171739U,\n    0x93c4c457U, 0x55a7a7f2U, 0xfc7e7e82U, 0x7a3d3d47U,\n    0xc86464acU, 0xba5d5de7U, 0x3219192bU, 0xe6737395U,\n    0xc06060a0U, 0x19818198U, 0x9e4f4fd1U, 0xa3dcdc7fU,\n    0x44222266U, 0x542a2a7eU, 0x3b9090abU, 0x0b888883U,\n    0x8c4646caU, 0xc7eeee29U, 0x6bb8b8d3U, 0x2814143cU,\n    0xa7dede79U, 0xbc5e5ee2U, 0x160b0b1dU, 0xaddbdb76U,\n    0xdbe0e03bU, 0x64323256U, 0x743a3a4eU, 0x140a0a1eU,\n    0x924949dbU, 0x0c06060aU, 0x4824246cU, 0xb85c5ce4U,\n    0x9fc2c25dU, 0xbdd3d36eU, 0x43acacefU, 0xc46262a6U,\n    0x399191a8U, 0x319595a4U, 0xd3e4e437U, 0xf279798bU,\n    0xd5e7e732U, 0x8bc8c843U, 0x6e373759U, 0xda6d6db7U,\n    0x018d8d8cU, 0xb1d5d564U, 0x9c4e4ed2U, 0x49a9a9e0U,\n    0xd86c6cb4U, 0xac5656faU, 0xf3f4f407U, 0xcfeaea25U,\n    0xca6565afU, 0xf47a7a8eU, 0x47aeaee9U, 0x10080818U,\n    0x6fbabad5U, 0xf0787888U, 0x4a25256fU, 0x5c2e2e72U,\n    0x381c1c24U, 0x57a6a6f1U, 0x73b4b4c7U, 0x97c6c651U,\n    0xcbe8e823U, 0xa1dddd7cU, 0xe874749cU, 0x3e1f1f21U,\n    0x964b4bddU, 0x61bdbddcU, 0x0d8b8b86U, 0x0f8a8a85U,\n    0xe0707090U, 0x7c3e3e42U, 0x71b5b5c4U, 0xcc6666aaU,\n    0x904848d8U, 0x06030305U, 0xf7f6f601U, 0x1c0e0e12U,\n    0xc26161a3U, 0x6a35355fU, 0xae5757f9U, 0x69b9b9d0U,\n    0x17868691U, 0x99c1c158U, 0x3a1d1d27U, 0x279e9eb9U,\n    0xd9e1e138U, 0xebf8f813U, 0x2b9898b3U, 0x22111133U,\n    0xd26969bbU, 0xa9d9d970U, 0x078e8e89U, 0x339494a7U,\n    0x2d9b9bb6U, 0x3c1e1e22U, 0x15878792U, 0xc9e9e920U,\n    0x87cece49U, 0xaa5555ffU, 0x50282878U, 0xa5dfdf7aU,\n    0x038c8c8fU, 0x59a1a1f8U, 0x09898980U, 0x1a0d0d17U,\n    0x65bfbfdaU, 0xd7e6e631U, 0x844242c6U, 0xd06868b8U,\n    0x824141c3U, 0x299999b0U, 0x5a2d2d77U, 0x1e0f0f11U,\n    0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,\n};\nstatic const u32 Te1[256] = {\n    0xa5c66363U, 0x84f87c7cU, 0x99ee7777U, 0x8df67b7bU,\n    0x0dfff2f2U, 0xbdd66b6bU, 0xb1de6f6fU, 0x5491c5c5U,\n    0x50603030U, 0x03020101U, 0xa9ce6767U, 0x7d562b2bU,\n    0x19e7fefeU, 0x62b5d7d7U, 0xe64dababU, 0x9aec7676U,\n    0x458fcacaU, 0x9d1f8282U, 0x4089c9c9U, 0x87fa7d7dU,\n    0x15effafaU, 0xebb25959U, 0xc98e4747U, 0x0bfbf0f0U,\n    0xec41adadU, 0x67b3d4d4U, 0xfd5fa2a2U, 0xea45afafU,\n    0xbf239c9cU, 0xf753a4a4U, 0x96e47272U, 0x5b9bc0c0U,\n    0xc275b7b7U, 0x1ce1fdfdU, 0xae3d9393U, 0x6a4c2626U,\n    0x5a6c3636U, 0x417e3f3fU, 0x02f5f7f7U, 0x4f83ccccU,\n    0x5c683434U, 0xf451a5a5U, 0x34d1e5e5U, 0x08f9f1f1U,\n    0x93e27171U, 0x73abd8d8U, 0x53623131U, 0x3f2a1515U,\n    0x0c080404U, 0x5295c7c7U, 0x65462323U, 0x5e9dc3c3U,\n    0x28301818U, 0xa1379696U, 0x0f0a0505U, 0xb52f9a9aU,\n    0x090e0707U, 0x36241212U, 0x9b1b8080U, 0x3ddfe2e2U,\n    0x26cdebebU, 0x694e2727U, 0xcd7fb2b2U, 0x9fea7575U,\n    0x1b120909U, 0x9e1d8383U, 0x74582c2cU, 0x2e341a1aU,\n    0x2d361b1bU, 0xb2dc6e6eU, 0xeeb45a5aU, 0xfb5ba0a0U,\n    0xf6a45252U, 0x4d763b3bU, 0x61b7d6d6U, 0xce7db3b3U,\n    0x7b522929U, 0x3edde3e3U, 0x715e2f2fU, 0x97138484U,\n    0xf5a65353U, 0x68b9d1d1U, 0x00000000U, 0x2cc1ededU,\n    0x60402020U, 0x1fe3fcfcU, 0xc879b1b1U, 0xedb65b5bU,\n    0xbed46a6aU, 0x468dcbcbU, 0xd967bebeU, 0x4b723939U,\n    0xde944a4aU, 0xd4984c4cU, 0xe8b05858U, 0x4a85cfcfU,\n    0x6bbbd0d0U, 0x2ac5efefU, 0xe54faaaaU, 0x16edfbfbU,\n    0xc5864343U, 0xd79a4d4dU, 0x55663333U, 0x94118585U,\n    0xcf8a4545U, 0x10e9f9f9U, 0x06040202U, 0x81fe7f7fU,\n    0xf0a05050U, 0x44783c3cU, 0xba259f9fU, 0xe34ba8a8U,\n    0xf3a25151U, 0xfe5da3a3U, 0xc0804040U, 0x8a058f8fU,\n    0xad3f9292U, 0xbc219d9dU, 0x48703838U, 0x04f1f5f5U,\n    0xdf63bcbcU, 0xc177b6b6U, 0x75afdadaU, 0x63422121U,\n    0x30201010U, 0x1ae5ffffU, 0x0efdf3f3U, 0x6dbfd2d2U,\n    0x4c81cdcdU, 0x14180c0cU, 0x35261313U, 0x2fc3ececU,\n    0xe1be5f5fU, 0xa2359797U, 0xcc884444U, 0x392e1717U,\n    0x5793c4c4U, 0xf255a7a7U, 0x82fc7e7eU, 0x477a3d3dU,\n    0xacc86464U, 0xe7ba5d5dU, 0x2b321919U, 0x95e67373U,\n    0xa0c06060U, 0x98198181U, 0xd19e4f4fU, 0x7fa3dcdcU,\n    0x66442222U, 0x7e542a2aU, 0xab3b9090U, 0x830b8888U,\n    0xca8c4646U, 0x29c7eeeeU, 0xd36bb8b8U, 0x3c281414U,\n    0x79a7dedeU, 0xe2bc5e5eU, 0x1d160b0bU, 0x76addbdbU,\n    0x3bdbe0e0U, 0x56643232U, 0x4e743a3aU, 0x1e140a0aU,\n    0xdb924949U, 0x0a0c0606U, 0x6c482424U, 0xe4b85c5cU,\n    0x5d9fc2c2U, 0x6ebdd3d3U, 0xef43acacU, 0xa6c46262U,\n    0xa8399191U, 0xa4319595U, 0x37d3e4e4U, 0x8bf27979U,\n    0x32d5e7e7U, 0x438bc8c8U, 0x596e3737U, 0xb7da6d6dU,\n    0x8c018d8dU, 0x64b1d5d5U, 0xd29c4e4eU, 0xe049a9a9U,\n    0xb4d86c6cU, 0xfaac5656U, 0x07f3f4f4U, 0x25cfeaeaU,\n    0xafca6565U, 0x8ef47a7aU, 0xe947aeaeU, 0x18100808U,\n    0xd56fbabaU, 0x88f07878U, 0x6f4a2525U, 0x725c2e2eU,\n    0x24381c1cU, 0xf157a6a6U, 0xc773b4b4U, 0x5197c6c6U,\n    0x23cbe8e8U, 0x7ca1ddddU, 0x9ce87474U, 0x213e1f1fU,\n    0xdd964b4bU, 0xdc61bdbdU, 0x860d8b8bU, 0x850f8a8aU,\n    0x90e07070U, 0x427c3e3eU, 0xc471b5b5U, 0xaacc6666U,\n    0xd8904848U, 0x05060303U, 0x01f7f6f6U, 0x121c0e0eU,\n    0xa3c26161U, 0x5f6a3535U, 0xf9ae5757U, 0xd069b9b9U,\n    0x91178686U, 0x5899c1c1U, 0x273a1d1dU, 0xb9279e9eU,\n    0x38d9e1e1U, 0x13ebf8f8U, 0xb32b9898U, 0x33221111U,\n    0xbbd26969U, 0x70a9d9d9U, 0x89078e8eU, 0xa7339494U,\n    0xb62d9b9bU, 0x223c1e1eU, 0x92158787U, 0x20c9e9e9U,\n    0x4987ceceU, 0xffaa5555U, 0x78502828U, 0x7aa5dfdfU,\n    0x8f038c8cU, 0xf859a1a1U, 0x80098989U, 0x171a0d0dU,\n    0xda65bfbfU, 0x31d7e6e6U, 0xc6844242U, 0xb8d06868U,\n    0xc3824141U, 0xb0299999U, 0x775a2d2dU, 0x111e0f0fU,\n    0xcb7bb0b0U, 0xfca85454U, 0xd66dbbbbU, 0x3a2c1616U,\n};\nstatic const u32 Te2[256] = {\n    0x63a5c663U, 0x7c84f87cU, 0x7799ee77U, 0x7b8df67bU,\n    0xf20dfff2U, 0x6bbdd66bU, 0x6fb1de6fU, 0xc55491c5U,\n    0x30506030U, 0x01030201U, 0x67a9ce67U, 0x2b7d562bU,\n    0xfe19e7feU, 0xd762b5d7U, 0xabe64dabU, 0x769aec76U,\n    0xca458fcaU, 0x829d1f82U, 0xc94089c9U, 0x7d87fa7dU,\n    0xfa15effaU, 0x59ebb259U, 0x47c98e47U, 0xf00bfbf0U,\n    0xadec41adU, 0xd467b3d4U, 0xa2fd5fa2U, 0xafea45afU,\n    0x9cbf239cU, 0xa4f753a4U, 0x7296e472U, 0xc05b9bc0U,\n    0xb7c275b7U, 0xfd1ce1fdU, 0x93ae3d93U, 0x266a4c26U,\n    0x365a6c36U, 0x3f417e3fU, 0xf702f5f7U, 0xcc4f83ccU,\n    0x345c6834U, 0xa5f451a5U, 0xe534d1e5U, 0xf108f9f1U,\n    0x7193e271U, 0xd873abd8U, 0x31536231U, 0x153f2a15U,\n    0x040c0804U, 0xc75295c7U, 0x23654623U, 0xc35e9dc3U,\n    0x18283018U, 0x96a13796U, 0x050f0a05U, 0x9ab52f9aU,\n    0x07090e07U, 0x12362412U, 0x809b1b80U, 0xe23ddfe2U,\n    0xeb26cdebU, 0x27694e27U, 0xb2cd7fb2U, 0x759fea75U,\n    0x091b1209U, 0x839e1d83U, 0x2c74582cU, 0x1a2e341aU,\n    0x1b2d361bU, 0x6eb2dc6eU, 0x5aeeb45aU, 0xa0fb5ba0U,\n    0x52f6a452U, 0x3b4d763bU, 0xd661b7d6U, 0xb3ce7db3U,\n    0x297b5229U, 0xe33edde3U, 0x2f715e2fU, 0x84971384U,\n    0x53f5a653U, 0xd168b9d1U, 0x00000000U, 0xed2cc1edU,\n    0x20604020U, 0xfc1fe3fcU, 0xb1c879b1U, 0x5bedb65bU,\n    0x6abed46aU, 0xcb468dcbU, 0xbed967beU, 0x394b7239U,\n    0x4ade944aU, 0x4cd4984cU, 0x58e8b058U, 0xcf4a85cfU,\n    0xd06bbbd0U, 0xef2ac5efU, 0xaae54faaU, 0xfb16edfbU,\n    0x43c58643U, 0x4dd79a4dU, 0x33556633U, 0x85941185U,\n    0x45cf8a45U, 0xf910e9f9U, 0x02060402U, 0x7f81fe7fU,\n    0x50f0a050U, 0x3c44783cU, 0x9fba259fU, 0xa8e34ba8U,\n    0x51f3a251U, 0xa3fe5da3U, 0x40c08040U, 0x8f8a058fU,\n    0x92ad3f92U, 0x9dbc219dU, 0x38487038U, 0xf504f1f5U,\n    0xbcdf63bcU, 0xb6c177b6U, 0xda75afdaU, 0x21634221U,\n    0x10302010U, 0xff1ae5ffU, 0xf30efdf3U, 0xd26dbfd2U,\n    0xcd4c81cdU, 0x0c14180cU, 0x13352613U, 0xec2fc3ecU,\n    0x5fe1be5fU, 0x97a23597U, 0x44cc8844U, 0x17392e17U,\n    0xc45793c4U, 0xa7f255a7U, 0x7e82fc7eU, 0x3d477a3dU,\n    0x64acc864U, 0x5de7ba5dU, 0x192b3219U, 0x7395e673U,\n    0x60a0c060U, 0x81981981U, 0x4fd19e4fU, 0xdc7fa3dcU,\n    0x22664422U, 0x2a7e542aU, 0x90ab3b90U, 0x88830b88U,\n    0x46ca8c46U, 0xee29c7eeU, 0xb8d36bb8U, 0x143c2814U,\n    0xde79a7deU, 0x5ee2bc5eU, 0x0b1d160bU, 0xdb76addbU,\n    0xe03bdbe0U, 0x32566432U, 0x3a4e743aU, 0x0a1e140aU,\n    0x49db9249U, 0x060a0c06U, 0x246c4824U, 0x5ce4b85cU,\n    0xc25d9fc2U, 0xd36ebdd3U, 0xacef43acU, 0x62a6c462U,\n    0x91a83991U, 0x95a43195U, 0xe437d3e4U, 0x798bf279U,\n    0xe732d5e7U, 0xc8438bc8U, 0x37596e37U, 0x6db7da6dU,\n    0x8d8c018dU, 0xd564b1d5U, 0x4ed29c4eU, 0xa9e049a9U,\n    0x6cb4d86cU, 0x56faac56U, 0xf407f3f4U, 0xea25cfeaU,\n    0x65afca65U, 0x7a8ef47aU, 0xaee947aeU, 0x08181008U,\n    0xbad56fbaU, 0x7888f078U, 0x256f4a25U, 0x2e725c2eU,\n    0x1c24381cU, 0xa6f157a6U, 0xb4c773b4U, 0xc65197c6U,\n    0xe823cbe8U, 0xdd7ca1ddU, 0x749ce874U, 0x1f213e1fU,\n    0x4bdd964bU, 0xbddc61bdU, 0x8b860d8bU, 0x8a850f8aU,\n    0x7090e070U, 0x3e427c3eU, 0xb5c471b5U, 0x66aacc66U,\n    0x48d89048U, 0x03050603U, 0xf601f7f6U, 0x0e121c0eU,\n    0x61a3c261U, 0x355f6a35U, 0x57f9ae57U, 0xb9d069b9U,\n    0x86911786U, 0xc15899c1U, 0x1d273a1dU, 0x9eb9279eU,\n    0xe138d9e1U, 0xf813ebf8U, 0x98b32b98U, 0x11332211U,\n    0x69bbd269U, 0xd970a9d9U, 0x8e89078eU, 0x94a73394U,\n    0x9bb62d9bU, 0x1e223c1eU, 0x87921587U, 0xe920c9e9U,\n    0xce4987ceU, 0x55ffaa55U, 0x28785028U, 0xdf7aa5dfU,\n    0x8c8f038cU, 0xa1f859a1U, 0x89800989U, 0x0d171a0dU,\n    0xbfda65bfU, 0xe631d7e6U, 0x42c68442U, 0x68b8d068U,\n    0x41c38241U, 0x99b02999U, 0x2d775a2dU, 0x0f111e0fU,\n    0xb0cb7bb0U, 0x54fca854U, 0xbbd66dbbU, 0x163a2c16U,\n};\nstatic const u32 Te3[256] = {\n\n    0x6363a5c6U, 0x7c7c84f8U, 0x777799eeU, 0x7b7b8df6U,\n    0xf2f20dffU, 0x6b6bbdd6U, 0x6f6fb1deU, 0xc5c55491U,\n    0x30305060U, 0x01010302U, 0x6767a9ceU, 0x2b2b7d56U,\n    0xfefe19e7U, 0xd7d762b5U, 0xababe64dU, 0x76769aecU,\n    0xcaca458fU, 0x82829d1fU, 0xc9c94089U, 0x7d7d87faU,\n    0xfafa15efU, 0x5959ebb2U, 0x4747c98eU, 0xf0f00bfbU,\n    0xadadec41U, 0xd4d467b3U, 0xa2a2fd5fU, 0xafafea45U,\n    0x9c9cbf23U, 0xa4a4f753U, 0x727296e4U, 0xc0c05b9bU,\n    0xb7b7c275U, 0xfdfd1ce1U, 0x9393ae3dU, 0x26266a4cU,\n    0x36365a6cU, 0x3f3f417eU, 0xf7f702f5U, 0xcccc4f83U,\n    0x34345c68U, 0xa5a5f451U, 0xe5e534d1U, 0xf1f108f9U,\n    0x717193e2U, 0xd8d873abU, 0x31315362U, 0x15153f2aU,\n    0x04040c08U, 0xc7c75295U, 0x23236546U, 0xc3c35e9dU,\n    0x18182830U, 0x9696a137U, 0x05050f0aU, 0x9a9ab52fU,\n    0x0707090eU, 0x12123624U, 0x80809b1bU, 0xe2e23ddfU,\n    0xebeb26cdU, 0x2727694eU, 0xb2b2cd7fU, 0x75759feaU,\n    0x09091b12U, 0x83839e1dU, 0x2c2c7458U, 0x1a1a2e34U,\n    0x1b1b2d36U, 0x6e6eb2dcU, 0x5a5aeeb4U, 0xa0a0fb5bU,\n    0x5252f6a4U, 0x3b3b4d76U, 0xd6d661b7U, 0xb3b3ce7dU,\n    0x29297b52U, 0xe3e33eddU, 0x2f2f715eU, 0x84849713U,\n    0x5353f5a6U, 0xd1d168b9U, 0x00000000U, 0xeded2cc1U,\n    0x20206040U, 0xfcfc1fe3U, 0xb1b1c879U, 0x5b5bedb6U,\n    0x6a6abed4U, 0xcbcb468dU, 0xbebed967U, 0x39394b72U,\n    0x4a4ade94U, 0x4c4cd498U, 0x5858e8b0U, 0xcfcf4a85U,\n    0xd0d06bbbU, 0xefef2ac5U, 0xaaaae54fU, 0xfbfb16edU,\n    0x4343c586U, 0x4d4dd79aU, 0x33335566U, 0x85859411U,\n    0x4545cf8aU, 0xf9f910e9U, 0x02020604U, 0x7f7f81feU,\n    0x5050f0a0U, 0x3c3c4478U, 0x9f9fba25U, 0xa8a8e34bU,\n    0x5151f3a2U, 0xa3a3fe5dU, 0x4040c080U, 0x8f8f8a05U,\n    0x9292ad3fU, 0x9d9dbc21U, 0x38384870U, 0xf5f504f1U,\n    0xbcbcdf63U, 0xb6b6c177U, 0xdada75afU, 0x21216342U,\n    0x10103020U, 0xffff1ae5U, 0xf3f30efdU, 0xd2d26dbfU,\n    0xcdcd4c81U, 0x0c0c1418U, 0x13133526U, 0xecec2fc3U,\n    0x5f5fe1beU, 0x9797a235U, 0x4444cc88U, 0x1717392eU,\n    0xc4c45793U, 0xa7a7f255U, 0x7e7e82fcU, 0x3d3d477aU,\n    0x6464acc8U, 0x5d5de7baU, 0x19192b32U, 0x737395e6U,\n    0x6060a0c0U, 0x81819819U, 0x4f4fd19eU, 0xdcdc7fa3U,\n    0x22226644U, 0x2a2a7e54U, 0x9090ab3bU, 0x8888830bU,\n    0x4646ca8cU, 0xeeee29c7U, 0xb8b8d36bU, 0x14143c28U,\n    0xdede79a7U, 0x5e5ee2bcU, 0x0b0b1d16U, 0xdbdb76adU,\n    0xe0e03bdbU, 0x32325664U, 0x3a3a4e74U, 0x0a0a1e14U,\n    0x4949db92U, 0x06060a0cU, 0x24246c48U, 0x5c5ce4b8U,\n    0xc2c25d9fU, 0xd3d36ebdU, 0xacacef43U, 0x6262a6c4U,\n    0x9191a839U, 0x9595a431U, 0xe4e437d3U, 0x79798bf2U,\n    0xe7e732d5U, 0xc8c8438bU, 0x3737596eU, 0x6d6db7daU,\n    0x8d8d8c01U, 0xd5d564b1U, 0x4e4ed29cU, 0xa9a9e049U,\n    0x6c6cb4d8U, 0x5656faacU, 0xf4f407f3U, 0xeaea25cfU,\n    0x6565afcaU, 0x7a7a8ef4U, 0xaeaee947U, 0x08081810U,\n    0xbabad56fU, 0x787888f0U, 0x25256f4aU, 0x2e2e725cU,\n    0x1c1c2438U, 0xa6a6f157U, 0xb4b4c773U, 0xc6c65197U,\n    0xe8e823cbU, 0xdddd7ca1U, 0x74749ce8U, 0x1f1f213eU,\n    0x4b4bdd96U, 0xbdbddc61U, 0x8b8b860dU, 0x8a8a850fU,\n    0x707090e0U, 0x3e3e427cU, 0xb5b5c471U, 0x6666aaccU,\n    0x4848d890U, 0x03030506U, 0xf6f601f7U, 0x0e0e121cU,\n    0x6161a3c2U, 0x35355f6aU, 0x5757f9aeU, 0xb9b9d069U,\n    0x86869117U, 0xc1c15899U, 0x1d1d273aU, 0x9e9eb927U,\n    0xe1e138d9U, 0xf8f813ebU, 0x9898b32bU, 0x11113322U,\n    0x6969bbd2U, 0xd9d970a9U, 0x8e8e8907U, 0x9494a733U,\n    0x9b9bb62dU, 0x1e1e223cU, 0x87879215U, 0xe9e920c9U,\n    0xcece4987U, 0x5555ffaaU, 0x28287850U, 0xdfdf7aa5U,\n    0x8c8c8f03U, 0xa1a1f859U, 0x89898009U, 0x0d0d171aU,\n    0xbfbfda65U, 0xe6e631d7U, 0x4242c684U, 0x6868b8d0U,\n    0x4141c382U, 0x9999b029U, 0x2d2d775aU, 0x0f0f111eU,\n    0xb0b0cb7bU, 0x5454fca8U, 0xbbbbd66dU, 0x16163a2cU,\n};\nstatic const u32 Te4[256] = {\n    0x63636363U, 0x7c7c7c7cU, 0x77777777U, 0x7b7b7b7bU,\n    0xf2f2f2f2U, 0x6b6b6b6bU, 0x6f6f6f6fU, 0xc5c5c5c5U,\n    0x30303030U, 0x01010101U, 0x67676767U, 0x2b2b2b2bU,\n    0xfefefefeU, 0xd7d7d7d7U, 0xababababU, 0x76767676U,\n    0xcacacacaU, 0x82828282U, 0xc9c9c9c9U, 0x7d7d7d7dU,\n    0xfafafafaU, 0x59595959U, 0x47474747U, 0xf0f0f0f0U,\n    0xadadadadU, 0xd4d4d4d4U, 0xa2a2a2a2U, 0xafafafafU,\n    0x9c9c9c9cU, 0xa4a4a4a4U, 0x72727272U, 0xc0c0c0c0U,\n    0xb7b7b7b7U, 0xfdfdfdfdU, 0x93939393U, 0x26262626U,\n    0x36363636U, 0x3f3f3f3fU, 0xf7f7f7f7U, 0xccccccccU,\n    0x34343434U, 0xa5a5a5a5U, 0xe5e5e5e5U, 0xf1f1f1f1U,\n    0x71717171U, 0xd8d8d8d8U, 0x31313131U, 0x15151515U,\n    0x04040404U, 0xc7c7c7c7U, 0x23232323U, 0xc3c3c3c3U,\n    0x18181818U, 0x96969696U, 0x05050505U, 0x9a9a9a9aU,\n    0x07070707U, 0x12121212U, 0x80808080U, 0xe2e2e2e2U,\n    0xebebebebU, 0x27272727U, 0xb2b2b2b2U, 0x75757575U,\n    0x09090909U, 0x83838383U, 0x2c2c2c2cU, 0x1a1a1a1aU,\n    0x1b1b1b1bU, 0x6e6e6e6eU, 0x5a5a5a5aU, 0xa0a0a0a0U,\n    0x52525252U, 0x3b3b3b3bU, 0xd6d6d6d6U, 0xb3b3b3b3U,\n    0x29292929U, 0xe3e3e3e3U, 0x2f2f2f2fU, 0x84848484U,\n    0x53535353U, 0xd1d1d1d1U, 0x00000000U, 0xededededU,\n    0x20202020U, 0xfcfcfcfcU, 0xb1b1b1b1U, 0x5b5b5b5bU,\n    0x6a6a6a6aU, 0xcbcbcbcbU, 0xbebebebeU, 0x39393939U,\n    0x4a4a4a4aU, 0x4c4c4c4cU, 0x58585858U, 0xcfcfcfcfU,\n    0xd0d0d0d0U, 0xefefefefU, 0xaaaaaaaaU, 0xfbfbfbfbU,\n    0x43434343U, 0x4d4d4d4dU, 0x33333333U, 0x85858585U,\n    0x45454545U, 0xf9f9f9f9U, 0x02020202U, 0x7f7f7f7fU,\n    0x50505050U, 0x3c3c3c3cU, 0x9f9f9f9fU, 0xa8a8a8a8U,\n    0x51515151U, 0xa3a3a3a3U, 0x40404040U, 0x8f8f8f8fU,\n    0x92929292U, 0x9d9d9d9dU, 0x38383838U, 0xf5f5f5f5U,\n    0xbcbcbcbcU, 0xb6b6b6b6U, 0xdadadadaU, 0x21212121U,\n    0x10101010U, 0xffffffffU, 0xf3f3f3f3U, 0xd2d2d2d2U,\n    0xcdcdcdcdU, 0x0c0c0c0cU, 0x13131313U, 0xececececU,\n    0x5f5f5f5fU, 0x97979797U, 0x44444444U, 0x17171717U,\n    0xc4c4c4c4U, 0xa7a7a7a7U, 0x7e7e7e7eU, 0x3d3d3d3dU,\n    0x64646464U, 0x5d5d5d5dU, 0x19191919U, 0x73737373U,\n    0x60606060U, 0x81818181U, 0x4f4f4f4fU, 0xdcdcdcdcU,\n    0x22222222U, 0x2a2a2a2aU, 0x90909090U, 0x88888888U,\n    0x46464646U, 0xeeeeeeeeU, 0xb8b8b8b8U, 0x14141414U,\n    0xdedededeU, 0x5e5e5e5eU, 0x0b0b0b0bU, 0xdbdbdbdbU,\n    0xe0e0e0e0U, 0x32323232U, 0x3a3a3a3aU, 0x0a0a0a0aU,\n    0x49494949U, 0x06060606U, 0x24242424U, 0x5c5c5c5cU,\n    0xc2c2c2c2U, 0xd3d3d3d3U, 0xacacacacU, 0x62626262U,\n    0x91919191U, 0x95959595U, 0xe4e4e4e4U, 0x79797979U,\n    0xe7e7e7e7U, 0xc8c8c8c8U, 0x37373737U, 0x6d6d6d6dU,\n    0x8d8d8d8dU, 0xd5d5d5d5U, 0x4e4e4e4eU, 0xa9a9a9a9U,\n    0x6c6c6c6cU, 0x56565656U, 0xf4f4f4f4U, 0xeaeaeaeaU,\n    0x65656565U, 0x7a7a7a7aU, 0xaeaeaeaeU, 0x08080808U,\n    0xbabababaU, 0x78787878U, 0x25252525U, 0x2e2e2e2eU,\n    0x1c1c1c1cU, 0xa6a6a6a6U, 0xb4b4b4b4U, 0xc6c6c6c6U,\n    0xe8e8e8e8U, 0xddddddddU, 0x74747474U, 0x1f1f1f1fU,\n    0x4b4b4b4bU, 0xbdbdbdbdU, 0x8b8b8b8bU, 0x8a8a8a8aU,\n    0x70707070U, 0x3e3e3e3eU, 0xb5b5b5b5U, 0x66666666U,\n    0x48484848U, 0x03030303U, 0xf6f6f6f6U, 0x0e0e0e0eU,\n    0x61616161U, 0x35353535U, 0x57575757U, 0xb9b9b9b9U,\n    0x86868686U, 0xc1c1c1c1U, 0x1d1d1d1dU, 0x9e9e9e9eU,\n    0xe1e1e1e1U, 0xf8f8f8f8U, 0x98989898U, 0x11111111U,\n    0x69696969U, 0xd9d9d9d9U, 0x8e8e8e8eU, 0x94949494U,\n    0x9b9b9b9bU, 0x1e1e1e1eU, 0x87878787U, 0xe9e9e9e9U,\n    0xcecececeU, 0x55555555U, 0x28282828U, 0xdfdfdfdfU,\n    0x8c8c8c8cU, 0xa1a1a1a1U, 0x89898989U, 0x0d0d0d0dU,\n    0xbfbfbfbfU, 0xe6e6e6e6U, 0x42424242U, 0x68686868U,\n    0x41414141U, 0x99999999U, 0x2d2d2d2dU, 0x0f0f0f0fU,\n    0xb0b0b0b0U, 0x54545454U, 0xbbbbbbbbU, 0x16161616U,\n};\n\nstatic const u32 rcon[] = {\n    0x01000000, 0x02000000, 0x04000000, 0x08000000,\n    0x10000000, 0x20000000, 0x40000000, 0x80000000,\n    0x1B000000, 0x36000000, /* for 128-bit blocks, aes never uses more than 10 rcon values */\n};\n\n#define GETU32(pt) (((u32)(pt)[0] << 24) ^ ((u32)(pt)[1] << 16) ^ ((u32)(pt)[2] <<  8) ^ ((u32)(pt)[3]))\n#define PUTU32(ct, st) { (ct)[0] = (u8)((st) >> 24); (ct)[1] = (u8)((st) >> 16); (ct)[2] = (u8)((st) >>  8); (ct)[3] = (u8)(st); }\n\n/**\n * Expand the cipher key into the encryption key schedule.\n *\n * @return\tthe number of rounds for the given cipher key size.\n */\nint aes128KeySetupEnc(u32 rk[/*44*/], const u8 cipherKey[]) {\n   int i = 0;\n    u32 temp;\n\n    rk[0] = GETU32(cipherKey     );\n    rk[1] = GETU32(cipherKey +  4);\n    rk[2] = GETU32(cipherKey +  8);\n    rk[3] = GETU32(cipherKey + 12);\n        for (;;) {\n            temp  = rk[3];\n            rk[4] = rk[0] ^\n                (Te4[(temp >> 16) & 0xff] & 0xff000000) ^\n                (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^\n                (Te4[(temp      ) & 0xff] & 0x0000ff00) ^\n                (Te4[(temp >> 24)       ] & 0x000000ff) ^\n                rcon[i];\n            rk[5] = rk[1] ^ rk[4];\n            rk[6] = rk[2] ^ rk[5];\n            rk[7] = rk[3] ^ rk[6];\n            if (++i == 10) {\n                return 10;\n            }\n            rk += 4;\n        }\n    return 0;\n}\n\nvoid aes128Encrypt(const u32 rk[/*44*/], const u8 pt[16], u8 ct[16]) {\n    u32 s0, s1, s2, s3, t0, t1, t2, t3;\n    int r;\n\n    /*\n     * map byte array block to cipher state\n     * and add initial round key:\n     */\n    s0 = GETU32(pt     ) ^ rk[0];\n    s1 = GETU32(pt +  4) ^ rk[1];\n    s2 = GETU32(pt +  8) ^ rk[2];\n    s3 = GETU32(pt + 12) ^ rk[3];\n    /*\n     * 9 full rounds:\n     */\n    r = 5;\n    for (;;) {\n        t0 =\n            Te0[(s0 >> 24)       ] ^\n            Te1[(s1 >> 16) & 0xff] ^\n            Te2[(s2 >>  8) & 0xff] ^\n            Te3[(s3      ) & 0xff] ^\n            rk[4];\n        t1 =\n            Te0[(s1 >> 24)       ] ^\n            Te1[(s2 >> 16) & 0xff] ^\n            Te2[(s3 >>  8) & 0xff] ^\n            Te3[(s0      ) & 0xff] ^\n            rk[5];\n        t2 =\n            Te0[(s2 >> 24)       ] ^\n            Te1[(s3 >> 16) & 0xff] ^\n            Te2[(s0 >>  8) & 0xff] ^\n            Te3[(s1      ) & 0xff] ^\n            rk[6];\n        t3 =\n            Te0[(s3 >> 24)       ] ^\n            Te1[(s0 >> 16) & 0xff] ^\n            Te2[(s1 >>  8) & 0xff] ^\n            Te3[(s2      ) & 0xff] ^\n            rk[7];\n\n        rk += 8;\n        if (--r == 0) {\n            break;\n        }\n\n        s0 =\n            Te0[(t0 >> 24)       ] ^\n            Te1[(t1 >> 16) & 0xff] ^\n            Te2[(t2 >>  8) & 0xff] ^\n            Te3[(t3      ) & 0xff] ^\n            rk[0];\n        s1 =\n            Te0[(t1 >> 24)       ] ^\n            Te1[(t2 >> 16) & 0xff] ^\n            Te2[(t3 >>  8) & 0xff] ^\n            Te3[(t0      ) & 0xff] ^\n            rk[1];\n        s2 =\n            Te0[(t2 >> 24)       ] ^\n            Te1[(t3 >> 16) & 0xff] ^\n            Te2[(t0 >>  8) & 0xff] ^\n            Te3[(t1      ) & 0xff] ^\n            rk[2];\n        s3 =\n            Te0[(t3 >> 24)       ] ^\n            Te1[(t0 >> 16) & 0xff] ^\n            Te2[(t1 >>  8) & 0xff] ^\n            Te3[(t2      ) & 0xff] ^\n            rk[3];\n    }\n    /*\n     * apply last round and\n     * map cipher state to byte array block:\n     */\n    s0 =\n        (Te4[(t0 >> 24)       ] & 0xff000000) ^\n        (Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t2 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t3      ) & 0xff] & 0x000000ff) ^\n        rk[0];\n    PUTU32(ct     , s0);\n    s1 =\n        (Te4[(t1 >> 24)       ] & 0xff000000) ^\n        (Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t3 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t0      ) & 0xff] & 0x000000ff) ^\n        rk[1];\n    PUTU32(ct +  4, s1);\n    s2 =\n        (Te4[(t2 >> 24)       ] & 0xff000000) ^\n        (Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t0 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t1      ) & 0xff] & 0x000000ff) ^\n        rk[2];\n    PUTU32(ct +  8, s2);\n    s3 =\n        (Te4[(t3 >> 24)       ] & 0xff000000) ^\n        (Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n        (Te4[(t1 >>  8) & 0xff] & 0x0000ff00) ^\n        (Te4[(t2      ) & 0xff] & 0x000000ff) ^\n        rk[3];\n    PUTU32(ct + 12, s3);\n}\n\n\nvoid aes128round(u32 s[4], const u32 rk[4]) {\n/* 1 round encrypting s with round key rk */\n    u32 s0, s1, s2, s3;\n\n    s0 = s[0];\n    s1 = s[1];\n    s2 = s[2];\n    s3 = s[3];\n   s[0] =\n       Te0[(s0 >> 24)       ] ^\n       Te1[(s1 >> 16) & 0xff] ^\n       Te2[(s2 >>  8) & 0xff] ^\n       Te3[(s3      ) & 0xff] ^\n       rk[0];\n   s[1] =\n       Te0[(s1 >> 24)       ] ^\n       Te1[(s2 >> 16) & 0xff] ^\n       Te2[(s3 >>  8) & 0xff] ^\n       Te3[(s0      ) & 0xff] ^\n       rk[1];\n   s[2] =\n       Te0[(s2 >> 24)       ] ^\n       Te1[(s3 >> 16) & 0xff] ^\n       Te2[(s0 >>  8) & 0xff] ^\n       Te3[(s1      ) & 0xff] ^\n       rk[2];\n   s[3] =\n       Te0[(s3 >> 24)       ] ^\n       Te1[(s0 >> 16) & 0xff] ^\n       Te2[(s1 >>  8) & 0xff] ^\n       Te3[(s2      ) & 0xff] ^\n       rk[3];\n}\n\nvoid aes128rounds(const u32 rk[/*44*/], const u8 pt[16], u8 ct[16], int rounds, int start) {\n\n    u32 s[4];\n    int i;\n\n   s[0] = GETU32(pt     );\n   s[1] = GETU32(pt +  4);\n   s[2] = GETU32(pt +  8);\n   s[3] = GETU32(pt + 12);\n    for (i=0; i<rounds; i++) {\n        aes128round(s, rk+4*(start+i));\n    }\n    PUTU32(ct     , s[0]);\n    PUTU32(ct + 4 , s[1]);\n    PUTU32(ct + 8 , s[2]);\n    PUTU32(ct + 12, s[3]);\n\n}\n\n\n} // namespace Yaes128v2_raw\n"
        },
        {
            "file_name": "yaes128v2_encrypt.cpp",
            "content": "/*\n * @version 1.0 (May 2014)\n *\n * Reference ANSI C implementation of YAES\n *\n * @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.be>\n * @author Frederik Vercauteren <frederik.vercauteren@esat.kuleuven.be>\n */\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"yaes128v2_encrypt.h\"\n#include \"yaes128v2_api.h\"\n#include \"yaes128v2_aes-128.h\"\n// #include \"encrypt.h\"\n\n// CHANGE namespace moved due to includes\nnamespace Yaes128v2_raw {\nint numRounds = -1;\n\n// CHANGE typedef added from original encrypt.h\ntypedef unsigned long long\tull;\n\nvoid EF128(const u8 N[16], const u8 M[], ull Mlen, const u8 K[], u8 C[], u8 TE[16]);\nvoid DF128(const u8 N[16], const u8 C[], ull Clen, const u8 K[], u8 M[], u8 TE[16]);\nvoid AD128(const u8 A[], ull Alen, const u8 K[], u8 T[16]);\n\nint crypto_aead_encrypt(\n  unsigned char *c, unsigned long long *clen,\n  const unsigned char *m, unsigned long long mlen,\n  const unsigned char *ad, unsigned long long adlen,\n  const unsigned char *nsec,\n  const unsigned char *npub,\n  const unsigned char *k\n)\n{\n/*\n  ... the code for the cipher implementation goes here,\n  ... generating a ciphertext c[0],c[1],...,c[*clen-1]\n  ... from a plaintext m[0],m[1],...,m[mlen-1]\n  ... and associated data ad[0],ad[1],...,ad[adlen-1]\n  ... and secret message number nsec[0],nsec[1],...\n  ... and public message number npub[0],npub[1],...\n  ... and secret key k[0],k[1],...\n*/\n    u8 TA[16], TE[16];\n    int j;\n\n    if (adlen) {\n        AD128(ad, adlen, k, TA);\n    }\n    EF128(npub, m, mlen, k, c, TE);\n    if (adlen) {\n        for (j=0; j<16; j++)\n            TE[j] ^= TA[j];\n    }\n    for (j=0; j<CRYPTO_ABYTES; j++)\n        c[mlen+j] = TE[j];\n    *clen = mlen+CRYPTO_ABYTES;\n\n    return 0;\n}\n\nint crypto_aead_decrypt(\n  unsigned char *m, unsigned long long *mlen,\n  unsigned char *nsec,\n  const unsigned char *c, unsigned long long clen,\n  const unsigned char *ad, unsigned long long adlen,\n  const unsigned char *npub,\n  const unsigned char *k\n)\n{\n/*\n  ... the code for the cipher implementation goes here,\n  ... generating a plaintext m[0],m[1],...,m[*mlen-1]\n  ... and secret message number nsec[0],nsec[1],...\n  ... from a ciphertext c[0],c[1],...,c[clen-1]\n  ... and associated data ad[0],ad[1],...,ad[adlen-1]\n  ... and public message number npub[0],npub[1],...\n  ... and secret key k[0],k[1],...\n*/\n    u8 TA[16], TE[16], T[CRYPTO_ABYTES];\n    int j;\n\n    memcpy((void*)T, (void*)&c[clen-CRYPTO_ABYTES], CRYPTO_ABYTES);\n    if (adlen) {\n        AD128(ad, adlen, k, TA);\n    }\n    DF128(npub, c, clen-CRYPTO_ABYTES, k, m, TE);\n    if (adlen) {\n        for (j=0; j<16; j++)\n            TE[j] ^= TA[j];\n    }\n    *mlen = clen-CRYPTO_ABYTES;\n    if (memcmp((void*)TE, (void*)T, CRYPTO_ABYTES))\n        return -1;\n\n    return 0;\n}\n\n#define GFmultx(Y, X)\\\nif ((X)[15] & 0x01)\\\n    t = 0xE1;\\\nelse\\\n    t = 0;\\\nfor (j=15; j>0; j--)\\\n    (Y)[j] = ((X)[j]>>1 ) ^ ((X)[j-1]<<7);\\\n(Y)[0] = ((X)[0]>>1) ^ t;\n\n\nvoid EF128(const u8 npub[16], const u8 M[], ull Mlen, const u8 K[], u8 C[], u8 TE[16]) {\n\n    u32 rk[44];\n    u8 N[16];\n    u8 L[16], S[16], V[16], tmp[16], t;\n    int i, j, m, lastlen;\n\n    m = Mlen/16;\n    lastlen = Mlen % 16;\n\n    memset(S, 0, 16);\n    memcpy(N, npub, CRYPTO_NPUBBYTES);\n    N[CRYPTO_NPUBBYTES-1] |= 0x01;\n\n    aes128KeySetupEnc(rk, K);\n    aes128Encrypt(rk, N, L);\n\n    for (i=0; i<m; i++) {\n        aes128rounds(rk, L, V, 6, 1);\n        for (j=0; j<16; j++) {\n            V[j] ^= M[16*i+j];\n            C[16*i+j] = V[j] ^ L[j];\n        }\n        aes128rounds(rk, V, tmp, 4, 7);\n        for (j=0; j<16; j++)\n            S[j] ^= tmp[j];\n        GFmultx(L, L)\n    }\n\n    if (lastlen) {\n        aes128rounds(rk, L, V, 6, 1);\n\n        for (j=0; j<lastlen; j++) {\n            V[j] ^= M[16*m+j];\n            C[16*m+j] = V[j] ^ L[j];\n        }\n        V[lastlen] ^= 0x80;\n\n        aes128rounds(rk, V, tmp, 4, 7);\n        for (j=0; j<16; j++)\n            S[j] ^= tmp[j];\n        GFmultx(L, L)\n    }\n\n    GFmultx(tmp, L)\n    if (Mlen==0 || lastlen) {\n        GFmultx(tmp, tmp)\n    }\n    for (j=0; j<16; j++)\n        S[j] ^= L[j] ^ tmp[j];\n    aes128Encrypt(rk, S, TE);\n}\n\n\nvoid DF128(const u8 npub[16], const u8 C[], ull Clen, const u8 K[], u8 M[], u8 TE[16]) {\n\n    u32 rk[44];\n    u8 N[16];\n    u8 L[16], S[16], V[16], tmp[16], t;\n    int i, j, c, lastlen;\n\n    c = Clen/16;\n    lastlen = Clen % 16;\n\n    memset(S, 0, 16);\n    memcpy(N, npub, CRYPTO_NPUBBYTES);\n    N[CRYPTO_NPUBBYTES-1] |= 0x01;\n    aes128KeySetupEnc(rk, K);\n    aes128Encrypt(rk, N, L);\n\n    for (i=0; i<c; i++) {\n        aes128rounds(rk, L, V, 6, 1);\n        for (j=0; j<16; j++) {\n            tmp[j] = C[16*i+j] ^ L[j];\n            M[16*i+j] = V[j] ^ tmp[j];\n        }\n        aes128rounds(rk, tmp, tmp, 4, 7);\n        for (j=0; j<16; j++)\n            S[j] ^= tmp[j];\n        GFmultx(L, L)\n    }\n\n    if (lastlen) {\n        aes128rounds(rk, L, V, 6, 1);\n        for (j=0; j<lastlen; j++) {\n            tmp[j] = C[16*c+j] ^ L[j];\n            M[16*c+j] = V[j] ^ tmp[j];\n        }\n        tmp[lastlen] = 0x80 ^ V[lastlen];\n        for (j=lastlen+1; j<16; j++)\n            tmp[j] = V[j];\n\n        aes128rounds(rk, tmp, tmp, 4, 7);\n        for (j=0; j<16; j++)\n            S[j] ^= tmp[j];\n        GFmultx(L, L)\n    }\n    GFmultx(tmp, L)\n    if (Clen==0 || lastlen) {\n        GFmultx(tmp, tmp)\n    }\n    for (j=0; j<16; j++)\n        S[j] ^= L[j] ^ tmp[j];\n    aes128Encrypt(rk, S, TE);\n}\n\n\nvoid AD128(const u8 A[], ull Alen, const u8 K[], u8 T[16]) {\n\n    u32 rk[44];\n    u8 R[16], S[16], tmp[16], t;\n    int i, j, a, lastlen;\n\n    if (Alen == 0) {\n        memset(T, 0, 16);\n        return;\n    }\n\n    a = Alen/16;\n    lastlen = Alen % 16;\n\n    memset(S, 0, 16);\n    aes128KeySetupEnc(rk, K);\n    aes128Encrypt(rk, S, R);\n\n    for (i=0; i<a; i++) {\n        for (j=0; j<16; j++)\n            tmp[j] = A[i*16+j] ^ R[j];\n        aes128rounds(rk, tmp, tmp, 4, 1);\n        for (j=0; j<16; j++)\n            S[j] ^= tmp[j];\n        GFmultx(R, R)\n    }\n\n    if (lastlen) {\n\n      // initializing last block and XOR with R value\n      for (j=0; j<lastlen; j++)\n        tmp[j] = A[16*a+j] ^ R[j];\n      tmp[lastlen] = 0x80 ^ R[lastlen];\n      for (j = lastlen+1; j<16; j++)\n        tmp[j] = R[j];\n\n      aes128rounds(rk, tmp, tmp, 4, 1);\n      for (j=0; j<16; j++)\n        S[j] ^= tmp[j];\n      GFmultx(R, R)\n     }\n\n    GFmultx(tmp, R)\n    if (lastlen) {\n        GFmultx(tmp, tmp)\n    }\n    for (j=0; j<16; j++)\n        S[j] ^= R[j] ^ tmp[j];\n    aes128Encrypt(rk, S, T);\n}\n\n} // namespace Yaes128v2_raw\n"
        },
        {
            "file_name": "yarn.c",
            "content": "#include <assert.h>\n#include <limits.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"yarn.h\"\n\nstatic const uint64_t blake2_iv[8] = {\n\t0x6a09e667f3bcc908, 0xbb67ae8584caa73b,\n\t0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n\t0x510e527fade682d1, 0x9b05688c2b3e6c1f,\n\t0x1f83d9abfb41bd6b, 0x5be0cd19137e2179\n};\n\nstatic const int blake2_sigma[10][16] = {\n\t{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},\n\t{14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},\n\t{11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},\n\t{7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8},\n\t{9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13},\n\t{2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9},\n\t{12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11},\n\t{13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10},\n\t{6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5},\n\t{10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0}\n};\n\nstatic uint32_t pack8to32(uint8_t a, uint8_t b, uint8_t c, uint8_t d) {\n\treturn (uint32_t) a | ((uint32_t) b << 8) | ((uint32_t) c << 16) | ((uint32_t) d << 24);\n}\n\nstatic uint64_t pack32to64(uint32_t a, uint32_t b) {\n\treturn (uint64_t) a | ((uint64_t) b << 32);\n}\n\nstatic void unpack64to8n(uint8_t *res, uint64_t a, int count) {\n\tint i;\n\tfor (i = 0; i < count; i++) {\n\t\tres[i] = (uint8_t) (a >> (8 * i));\n\t}\n}\n\nstatic void strto64(uint64_t *out, const void *in, size_t inlen) {\n\tuint64_t buffer = 0;\n\tsize_t i;\n\tfor (i = 0; i < inlen; i++) {\n\t\tbuffer |= (uint64_t) (((const uint8_t *) in)[i]) << (8 * (i % 8));\n\t\tif (i % 8 == 7) {\n\t\t\tout[i / 8] = buffer;\n\t\t\tbuffer = 0;\n\t\t}\n\t}\n\tif (inlen % 8 != 0) {\n\t\tout[inlen / 8] = buffer;\n\t}\n}\n\nstatic void init_blake2b(uint64_t chain_value[8], size_t outlen, const void *salt, size_t saltlen, const void *pers, size_t perslen) {\n\tuint64_t salt64[2], pers64[2];\n\tassert(1 <= outlen && outlen <= 64 && saltlen <= 16 && perslen <= 16);\n\tmemcpy(chain_value, blake2_iv, 64);\n\tchain_value[0] ^= pack32to64(pack8to32(outlen, 0, 1, 1), 0);\n\tmemset(salt64, 0, 16);\n\tstrto64(salt64, salt, saltlen);\n\tmemset(pers64, 0, 16);\n\tstrto64(pers64, pers, perslen);\n\tchain_value[4] ^= salt64[0];\n\tchain_value[5] ^= salt64[1];\n\tchain_value[6] ^= pers64[0];\n\tchain_value[7] ^= pers64[1];\n}\n\nstatic uint64_t rot64(uint64_t a, int n) {\n\treturn (a >> n) | (a << (64 - n));\n}\n\nstatic void blake2b_g(int r, int i, uint64_t *a, uint64_t *b, uint64_t *c, uint64_t *d, const uint64_t block[16]) {\n\t*a = *a + *b + block[blake2_sigma[r % 10][2 * i]];\n\t*d = rot64(*d ^ *a, 32);\n\t*c = *c + *d;\n\t*b = rot64(*b ^ *c, 24);\n\t*a = *a + *b + block[blake2_sigma[r % 10][2 * i + 1]];\n\t*d = rot64(*d ^ *a, 16);\n\t*c = *c + *d;\n\t*b = rot64(*b ^ *c, 63);\n}\n\nstatic void blake2b_compress(uint64_t chain_value[8], const void *block, uint64_t t0, uint64_t t1, uint64_t f0, uint64_t f1) {\n\tuint64_t state[16], block64[16];\n\tint i;\n\tmemcpy(state, chain_value, 64);\n\tmemcpy(state + 8, blake2_iv, 64);\n\tstate[12] ^= t0;\n\tstate[13] ^= t1;\n\tstate[14] ^= f0;\n\tstate[15] ^= f1;\n\tstrto64(block64, block, 128);\n\tfor (i = 0; i < 12; i++) {\n\t\tblake2b_g(i, 0, &state[0], &state[4], &state[8], &state[12], block64);\n\t\tblake2b_g(i, 1, &state[1], &state[5], &state[9], &state[13], block64);\n\t\tblake2b_g(i, 2, &state[2], &state[6], &state[10], &state[14], block64);\n\t\tblake2b_g(i, 3, &state[3], &state[7], &state[11], &state[15], block64);\n\t\tblake2b_g(i, 4, &state[0], &state[5], &state[10], &state[15], block64);\n\t\tblake2b_g(i, 5, &state[1], &state[6], &state[11], &state[12], block64);\n\t\tblake2b_g(i, 6, &state[2], &state[7], &state[8], &state[13], block64);\n\t\tblake2b_g(i, 7, &state[3], &state[4], &state[9], &state[14], block64);\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tchain_value[i] ^= state[i] ^ state[i + 8];\n\t}\n}\n\nstatic void blake2b_process(uint64_t state[8], const void *in, size_t inlen) {\n\tsize_t i;\n\tchar buffer[128];\n\tfor (i = 0; i + 128 < inlen; i += 128) {\n\t\tblake2b_compress(state, (const char *) in + i, (uint64_t) (i + 128), 0, 0, 0);\n\t}\n\tmemcpy(buffer, (const char *) in + i, inlen - i);\n\tmemset(buffer + (inlen - i), 0, 128 - (inlen - i));\n\tblake2b_compress(state, buffer, inlen, 0, 0xffffffffffffffff, 0);\n}\n\nstatic void blake2b_hash(uint64_t state[8], size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, const void *pers, size_t perslen) {\n\tinit_blake2b(state, outlen, salt, saltlen, pers, perslen);\n\tblake2b_process(state, in, inlen);\n}\n\nstatic void unpack_state(void *out, size_t outlen, const uint64_t state[8]) {\n\tsize_t i;\n\tfor (i = 0; i < 8 && 8 * i < outlen; i++) {\n\t\tunpack64to8n((uint8_t *) out + 8 * i, state[i], outlen < 8 * (i + 1) ? outlen - 8 * i : 8);\n\t}\n}\n\nvoid blake2b(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, const void *pers, size_t perslen) {\n\tuint64_t state[8];\n\tblake2b_hash(state, outlen, in, inlen, salt, saltlen, pers, perslen);\n\tunpack_state(out, outlen, state);\n}\n\nvoid blake2b_expand(uint64_t state[8], void *exp, size_t explen, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, const void *pers, size_t perslen) {\n\tuint64_t tempstate[8];\n\tchar buffer[128];\n\tsize_t i;\n\tblake2b_hash(state, outlen, in, inlen, salt, saltlen, pers, perslen);\n\tmemset(buffer, 0, 128);\n\tfor (i = 0; i < explen; i += 64) {\n\t\tmemcpy(tempstate, state, 64);\n\t\tblake2b_compress(tempstate, buffer, i / 64, 0, 0, 0xffffffffffffffff);\n\t\tunpack_state(exp + i, explen < i + 64 ? explen - i : 64, tempstate);\n\t}\n}\n\nstatic const uint8_t aes_sbox[256] = {\n\t0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n\t0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n\t0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n\t0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n\t0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n\t0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n\t0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n\t0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n\t0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n\t0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n\t0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n\t0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n\t0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n\t0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n\t0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n\t0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n};\n\nstatic const uint8_t aes_dbl[256] = {\n\t0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,\n\t0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,\n\t0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,\n\t0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,\n\t0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,\n\t0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,\n\t0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,\n\t0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,\n\t0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,\n\t0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,\n\t0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,\n\t0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,\n\t0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,\n\t0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,\n\t0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,\n\t0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5\n};\n\nstatic void aesenc(uint8_t buffer[16], const uint8_t key[16]) {\n\tint i;\n\tuint8_t tmp[16];\n\tfor (i = 0; i < 16; i++) {\n\t\tbuffer[i] = aes_sbox[buffer[i]];\n\t}\n\tfor (i = 0; i < 16; i++) {\n\t\ttmp[i] = buffer[(i + 4 * (i % 4)) % 16];\n\t}\n\tfor (i = 0; i < 16; i++) {\n\t\tint r = i % 4;\n\t\tint c = i / 4;\n\t\tbuffer[i] = aes_dbl[tmp[i]] ^\n\t\t\ttmp[4 * c + ((r + 1) % 4)] ^ aes_dbl[tmp[4 * c + ((r + 1) % 4)]] ^\n\t\t\ttmp[4 * c + ((r + 2) % 4)] ^ tmp[4 * c + ((r + 3) % 4)];\n\t}\n\tfor (i = 0; i < 16; i++) {\n\t\tbuffer[i] ^= key[i];\n\t}\n}\n\nstatic void rotate_state(uint8_t (*state)[16], size_t par) {\n\tuint8_t tmp[16];\n\tmemcpy(tmp, state[0], 16);\n\tmemmove(state[0], state[1], 16 * (par - 1));\n\tmemcpy(state[par - 1], tmp, 16);\n}\n\nstatic size_t integerify(const uint8_t block[16], unsigned int m_cost) {\n\tsize_t res = 0;\n\tunsigned int i;\n\tfor (i = 0; i < sizeof(size_t) && i < 16; i++) {\n\t\tres |= (size_t) block[i] << (8 * i);\n\t}\n\treturn (res >> 4) & ((1ULL << m_cost) - 1);\n}\n\nint yarn(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost, unsigned int par, unsigned int initrnd, unsigned int m_step, const void *pers, size_t perslen) {\n\tuint64_t blake2b_state[8];\n\tsize_t i, j;\n\tuint8_t (*state)[16] = NULL, (*memory)[16] = NULL, (*keys)[16], *addr;\n\tif (!(1 <= outlen && outlen <= 64 && saltlen <= 16 && m_cost < sizeof(size_t) * 8 - 4 && par > 0 && perslen <= 16)) {\n\t\t/* Invalid parameters */\n\t\treturn 0;\n\t}\n\tif (!(state = malloc(16 * (par + 1 + initrnd))) || !(memory = malloc(16 << m_cost))) {\n\t\tif (state != NULL) {\n\t\t\tfree(state);\n\t\t}\n\t\treturn 0;\n\t}\n\tkeys = state + par;\n\taddr = state[par + initrnd];\n\tblake2b_expand(blake2b_state, state, 16 * (par + initrnd + 1), outlen, in, inlen, salt, saltlen, pers, perslen);\n\tfor (i = 0; i < 1ULL << m_cost; i++) {\n\t\tmemcpy(memory[i], state[0], 16);\n\t\tfor (j = 0; j < initrnd; j++) {\n\t\t\taesenc(state[0], keys[j]);\n\t\t}\n\t\trotate_state(state, par);\n\t}\n\tfor (i = 0; i < t_cost; i++) {\n\t\tif (i % m_step == m_step - 1) {\n\t\t\tsize_t idx = integerify(addr, m_cost);\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\taddr[j] = memory[idx][j] ^ state[1 % par][j];\n\t\t\t}\n\t\t\tmemcpy(memory[idx], state[1 % par], 16);\n\t\t\taesenc(state[0], addr);\n\t\t} else {\n\t\t\tuint8_t tmp[16];\n\t\t\tmemcpy(tmp, state[1 % par], 16);\n\t\t\taesenc(state[0], tmp);\n\t\t}\n\t\trotate_state(state, par);\n\t}\n\tblake2b_process(blake2b_state, state, 16 * par);\n\tunpack_state(out, outlen, blake2b_state);\n\tfree(state);\n\tfree(memory);\n\treturn 1;\n}\n\nint PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost) {\n\treturn yarn(out, outlen, in, inlen, salt, saltlen, t_cost, m_cost, 6, 10, 72, NULL, 0);\n}"
        },
        {
            "file_name": "yescrypt-common.c",
            "content": "/*-\n * Copyright 2013,2014 Alexander Peslyak\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"yescrypt.h\"\n\n#define BYTES2CHARS(bytes) \\\n\t((((bytes) * 8) + 5) / 6)\n\n#define HASH_SIZE 32 /* bytes */\n#define HASH_LEN BYTES2CHARS(HASH_SIZE) /* base-64 chars */\n\nstatic const char * const itoa64 =\n\t\"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\nstatic uint8_t * encode64_uint32(uint8_t * dst, size_t dstlen,\n    uint32_t src, uint32_t srcbits)\n{\n\tuint32_t bit;\n\n\tfor (bit = 0; bit < srcbits; bit += 6) {\n\t\tif (dstlen < 1)\n\t\t\treturn NULL;\n\t\t*dst++ = itoa64[src & 0x3f];\n\t\tdstlen--;\n\t\tsrc >>= 6;\n\t}\n\n\treturn dst;\n}\n\nstatic uint8_t * encode64(uint8_t * dst, size_t dstlen,\n    const uint8_t * src, size_t srclen)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < srclen; ) {\n\t\tuint8_t * dnext;\n\t\tuint32_t value = 0, bits = 0;\n\t\tdo {\n\t\t\tvalue |= (uint32_t)src[i++] << bits;\n\t\t\tbits += 8;\n\t\t} while (bits < 24 && i < srclen);\n\t\tdnext = encode64_uint32(dst, dstlen, value, bits);\n\t\tif (!dnext)\n\t\t\treturn NULL;\n\t\tdstlen -= dnext - dst;\n\t\tdst = dnext;\n\t}\n\n\treturn dst;\n}\n\nstatic int decode64_one(uint32_t * dst, uint8_t src)\n{\n\tconst char * ptr = strchr(itoa64, src);\n\tif (ptr) {\n\t\t*dst = ptr - itoa64;\n\t\treturn 0;\n\t}\n\t*dst = 0;\n\treturn -1;\n}\n\nstatic const uint8_t * decode64_uint32(uint32_t * dst, uint32_t dstbits,\n    const uint8_t * src)\n{\n\tuint32_t bit;\n\tuint32_t value;\n\n\tvalue = 0;\n\tfor (bit = 0; bit < dstbits; bit += 6) {\n\t\tuint32_t one;\n\t\tif (decode64_one(&one, *src)) {\n\t\t\t*dst = 0;\n\t\t\treturn NULL;\n\t\t}\n\t\tsrc++;\n\t\tvalue |= one << bit;\n\t}\n\n\t*dst = value;\n\treturn src;\n}\n\nuint8_t *\nyescrypt_r(const yescrypt_shared_t * shared, yescrypt_local_t * local,\n    const uint8_t * passwd, size_t passwdlen,\n    const uint8_t * setting,\n    uint8_t * buf, size_t buflen)\n{\n\tuint8_t hash[HASH_SIZE];\n\tconst uint8_t * src, * salt;\n\tuint8_t * dst;\n\tsize_t prefixlen, saltlen, need;\n\tuint8_t version;\n\tuint64_t N;\n\tuint32_t r, p;\n\tyescrypt_flags_t flags = YESCRYPT_WORM;\n\n\tif (setting[0] != '$' || setting[1] != '7')\n\t\treturn NULL;\n\tsrc = setting + 2;\n\tswitch ((version = *src)) {\n\tcase '$':\n\t\tbreak;\n\tcase 'X':\n\t\tsrc++;\n\t\tflags = YESCRYPT_RW;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\tif (*src != '$') {\n\t\tuint32_t decoded_flags;\n\t\tif (decode64_one(&decoded_flags, *src))\n\t\t\treturn NULL;\n\t\tflags = decoded_flags;\n\t\tif (*++src != '$')\n\t\t\treturn NULL;\n\t}\n\tsrc++;\n\n\t{\n\t\tuint32_t N_log2;\n\t\tif (decode64_one(&N_log2, *src))\n\t\t\treturn NULL;\n\t\tsrc++;\n\t\tN = (uint64_t)1 << N_log2;\n\t}\n\n\tsrc = decode64_uint32(&r, 30, src);\n\tif (!src)\n\t\treturn NULL;\n\n\tsrc = decode64_uint32(&p, 30, src);\n\tif (!src)\n\t\treturn NULL;\n\n\tprefixlen = src - setting;\n\n\tsalt = src;\n\tsrc = (uint8_t *)strrchr((char *)salt, '$');\n\tif (src)\n\t\tsaltlen = src - salt;\n\telse\n\t\tsaltlen = strlen((char *)salt);\n\n\tneed = prefixlen + saltlen + 1 + HASH_LEN + 1;\n\tif (need > buflen || need < saltlen)\n\t\treturn NULL;\n\n\tif (yescrypt_kdf(shared, local, passwd, passwdlen, salt, saltlen,\n\t    N, r, p, 0, flags, hash, sizeof(hash)))\n\t\treturn NULL;\n\n\tdst = buf;\n\tmemcpy(dst, setting, prefixlen + saltlen);\n\tdst += prefixlen + saltlen;\n\t*dst++ = '$';\n\n\tdst = encode64(dst, buflen - (dst - buf), hash, sizeof(hash));\n\t/* Could zeroize hash[] here, but yescrypt_kdf() doesn't zeroize its\n\t * memory allocations yet anyway. */\n\tif (!dst || dst >= buf + buflen) /* Can't happen */\n\t\treturn NULL;\n\n\t*dst = 0; /* NUL termination */\n\n\treturn buf;\n}\n\nuint8_t *\nyescrypt(const uint8_t * passwd, const uint8_t * setting)\n{\n\tstatic uint8_t buf[4 + 1 + 5 + 5 + BYTES2CHARS(32) + 1 + HASH_LEN + 1];\n\tyescrypt_shared_t shared;\n\tyescrypt_local_t local;\n\tuint8_t * retval;\n\n\tif (yescrypt_init_shared(&shared, NULL, 0,\n\t    0, 0, 0, YESCRYPT_SHARED_DEFAULTS, 0, NULL, 0))\n\t\treturn NULL;\n\tif (yescrypt_init_local(&local)) {\n\t\tyescrypt_free_shared(&shared);\n\t\treturn NULL;\n\t}\n\tretval = yescrypt_r(&shared, &local,\n\t    passwd, strlen((char *)passwd), setting, buf, sizeof(buf));\n\tif (yescrypt_free_local(&local)) {\n\t\tyescrypt_free_shared(&shared);\n\t\treturn NULL;\n\t}\n\tif (yescrypt_free_shared(&shared))\n\t\treturn NULL;\n\treturn retval;\n}\n\nuint8_t *\nyescrypt_gensalt_r(uint32_t N_log2, uint32_t r, uint32_t p,\n    yescrypt_flags_t flags,\n    const uint8_t * src, size_t srclen,\n    uint8_t * buf, size_t buflen)\n{\n\tuint8_t * dst;\n\tsize_t prefixlen = 3 + 1 + 5 + 5;\n\tsize_t saltlen = BYTES2CHARS(srclen);\n\tsize_t need;\n\n\tif (p == 1)\n\t\tflags &= ~YESCRYPT_PARALLEL_SMIX;\n\n\tif (flags) {\n\t\tif (flags & ~0x3f)\n\t\t\treturn NULL;\n\n\t\tprefixlen++;\n\t\tif (flags != YESCRYPT_RW)\n\t\t\tprefixlen++;\n\t}\n\n\tneed = prefixlen + saltlen + 1;\n\tif (need > buflen || need < saltlen || saltlen < srclen)\n\t\treturn NULL;\n\n\tif (N_log2 > 63 || ((uint64_t)r * (uint64_t)p >= (1U << 30)))\n\t\treturn NULL;\n\n\tdst = buf;\n\t*dst++ = '$';\n\t*dst++ = '7';\n\tif (flags) {\n\t\t*dst++ = 'X'; /* eXperimental, subject to change */\n\t\tif (flags != YESCRYPT_RW)\n\t\t\t*dst++ = itoa64[flags];\n\t}\n\t*dst++ = '$';\n\n\t*dst++ = itoa64[N_log2];\n\n\tdst = encode64_uint32(dst, buflen - (dst - buf), r, 30);\n\tif (!dst) /* Can't happen */\n\t\treturn NULL;\n\n\tdst = encode64_uint32(dst, buflen - (dst - buf), p, 30);\n\tif (!dst) /* Can't happen */\n\t\treturn NULL;\n\n\tdst = encode64(dst, buflen - (dst - buf), src, srclen);\n\tif (!dst || dst >= buf + buflen) /* Can't happen */\n\t\treturn NULL;\n\n\t*dst = 0; /* NUL termination */\n\n\treturn buf;\n}\n\nuint8_t *\nyescrypt_gensalt(uint32_t N_log2, uint32_t r, uint32_t p,\n    yescrypt_flags_t flags,\n    const uint8_t * src, size_t srclen)\n{\n\tstatic uint8_t buf[4 + 1 + 5 + 5 + BYTES2CHARS(32) + 1];\n\treturn yescrypt_gensalt_r(N_log2, r, p, flags, src, srclen,\n\t    buf, sizeof(buf));\n}\n\nint\ncrypto_scrypt(const uint8_t * passwd, size_t passwdlen,\n    const uint8_t * salt, size_t saltlen, uint64_t N, uint32_t r, uint32_t p,\n    uint8_t * buf, size_t buflen)\n{\n\tyescrypt_shared_t shared;\n\tyescrypt_local_t local;\n\tint retval;\n\n\tif (yescrypt_init_shared(&shared, NULL, 0,\n\t    0, 0, 0, YESCRYPT_SHARED_DEFAULTS, 0, NULL, 0))\n\t\treturn -1;\n\tif (yescrypt_init_local(&local)) {\n\t\tyescrypt_free_shared(&shared);\n\t\treturn -1;\n\t}\n\tretval = yescrypt_kdf(&shared, &local,\n\t    passwd, passwdlen, salt, saltlen, N, r, p, 0, 0, buf, buflen);\n\tif (yescrypt_free_local(&local)) {\n\t\tyescrypt_free_shared(&shared);\n\t\treturn -1;\n\t}\n\tif (yescrypt_free_shared(&shared))\n\t\treturn -1;\n\treturn retval;\n}\n"
        },
        {
            "file_name": "yescrypt-opt.c",
            "content": "/*-\n * Copyright 2009 Colin Percival\n * Copyright 2013,2014 Alexander Peslyak\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * This file was originally written by Colin Percival as part of the Tarsnap\n * online backup system.\n */\n\n#ifdef __i386__\n#warning \"This implementation does not use SIMD, and thus it runs a lot slower than the SIMD-enabled implementation. Enable at least SSE2 in the C compiler and use yescrypt-best.c instead unless you're building this SIMD-less implementation on purpose (portability to older CPUs or testing).\"\n#elif defined(__x86_64__)\n#warning \"This implementation does not use SIMD, and thus it runs a lot slower than the SIMD-enabled implementation. Use yescrypt-best.c instead unless you're building this SIMD-less implementation on purpose (for testing only).\"\n#endif\n\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#include \"sha256.h\"\n#include \"sysendian.h\"\n\n#include \"yescrypt.h\"\n\n#include \"yescrypt-platform.c\"\n\nstatic inline void\nblkcpy(uint64_t * dest, const uint64_t * src, size_t count)\n{\n\tdo {\n\t\t*dest++ = *src++; *dest++ = *src++;\n\t\t*dest++ = *src++; *dest++ = *src++;\n\t} while (count -= 4);\n}\n\nstatic inline void\nblkxor(uint64_t * dest, const uint64_t * src, size_t count)\n{\n\tdo {\n\t\t*dest++ ^= *src++; *dest++ ^= *src++;\n\t\t*dest++ ^= *src++; *dest++ ^= *src++;\n\t} while (count -= 4);\n}\n\ntypedef union {\n\tuint32_t w[16];\n\tuint64_t d[8];\n} salsa20_blk_t;\n\nstatic inline void\nsalsa20_simd_shuffle(const salsa20_blk_t * Bin, salsa20_blk_t * Bout)\n{\n#define COMBINE(out, in1, in2) \\\n\tBout->d[out] = Bin->w[in1 * 2] | ((uint64_t)Bin->w[in2 * 2 + 1] << 32);\n\tCOMBINE(0, 0, 2)\n\tCOMBINE(1, 5, 7)\n\tCOMBINE(2, 2, 4)\n\tCOMBINE(3, 7, 1)\n\tCOMBINE(4, 4, 6)\n\tCOMBINE(5, 1, 3)\n\tCOMBINE(6, 6, 0)\n\tCOMBINE(7, 3, 5)\n#undef COMBINE\n}\n\nstatic inline void\nsalsa20_simd_unshuffle(const salsa20_blk_t * Bin, salsa20_blk_t * Bout)\n{\n#define COMBINE(out, in1, in2) \\\n\tBout->w[out * 2] = Bin->d[in1]; \\\n\tBout->w[out * 2 + 1] = Bin->d[in2] >> 32;\n\tCOMBINE(0, 0, 6)\n\tCOMBINE(1, 5, 3)\n\tCOMBINE(2, 2, 0)\n\tCOMBINE(3, 7, 5)\n\tCOMBINE(4, 4, 2)\n\tCOMBINE(5, 1, 7)\n\tCOMBINE(6, 6, 4)\n\tCOMBINE(7, 3, 1)\n#undef COMBINE\n}\n\n/**\n * salsa20_8(B):\n * Apply the salsa20/8 core to the provided block.\n */\nstatic void\nsalsa20_8(uint64_t B[8])\n{\n\tsize_t i;\n\tsalsa20_blk_t X;\n#define x X.w\n\n\tsalsa20_simd_unshuffle((const salsa20_blk_t *)B, &X);\n\n\tfor (i = 0; i < 8; i += 2) {\n#define R(a,b) (((a) << (b)) | ((a) >> (32 - (b))))\n\t\t/* Operate on columns */\n\t\tx[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);\n\t\tx[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);\n\n\t\tx[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);\n\t\tx[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);\n\n\t\tx[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);\n\t\tx[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);\n\n\t\tx[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);\n\t\tx[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);\n\n\t\t/* Operate on rows */\n\t\tx[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);\n\t\tx[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);\n\n\t\tx[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);\n\t\tx[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);\n\n\t\tx[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);\n\t\tx[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);\n\n\t\tx[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);\n\t\tx[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);\n#undef R\n\t}\n#undef x\n\n\t{\n\t\tsalsa20_blk_t Y;\n\t\tsalsa20_simd_shuffle(&X, &Y);\n\t\tfor (i = 0; i < 16; i += 4) {\n\t\t\t((salsa20_blk_t *)B)->w[i] += Y.w[i];\n\t\t\t((salsa20_blk_t *)B)->w[i + 1] += Y.w[i + 1];\n\t\t\t((salsa20_blk_t *)B)->w[i + 2] += Y.w[i + 2];\n\t\t\t((salsa20_blk_t *)B)->w[i + 3] += Y.w[i + 3];\n\t\t}\n\t}\n}\n\n/**\n * blockmix_salsa8(Bin, Bout, X, r):\n * Compute Bout = BlockMix_{salsa20/8, r}(Bin).  The input Bin must be 128r\n * bytes in length; the output Bout must also be the same size.  The\n * temporary space X must be 64 bytes.\n */\nstatic void\nblockmix_salsa8(const uint64_t * Bin, uint64_t * Bout, uint64_t * X, size_t r)\n{\n\tsize_t i;\n\n\t/* 1: X <-- B_{2r - 1} */\n\tblkcpy(X, &Bin[(2 * r - 1) * 8], 8);\n\n\t/* 2: for i = 0 to 2r - 1 do */\n\tfor (i = 0; i < 2 * r; i += 2) {\n\t\t/* 3: X <-- H(X \\xor B_i) */\n\t\tblkxor(X, &Bin[i * 8], 8);\n\t\tsalsa20_8(X);\n\n\t\t/* 4: Y_i <-- X */\n\t\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\t\tblkcpy(&Bout[i * 4], X, 8);\n\n\t\t/* 3: X <-- H(X \\xor B_i) */\n\t\tblkxor(X, &Bin[i * 8 + 8], 8);\n\t\tsalsa20_8(X);\n\n\t\t/* 4: Y_i <-- X */\n\t\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\t\tblkcpy(&Bout[i * 4 + r * 8], X, 8);\n\t}\n}\n\n/* These are tunable */\n#define S_BITS 8\n#define S_SIMD 2\n#define S_P 4\n#define S_ROUNDS 6\n\n/* Number of S-boxes.  Not tunable, hard-coded in a few places. */\n#define S_N 2\n\n/* Derived values.  Not tunable on their own. */\n#define S_SIZE1 (1 << S_BITS)\n#define S_MASK ((S_SIZE1 - 1) * S_SIMD * 8)\n#define S_MASK2 (((uint64_t)S_MASK << 32) | S_MASK)\n#define S_SIZE_ALL (S_N * S_SIZE1 * S_SIMD)\n#define S_P_SIZE (S_P * S_SIMD)\n#define S_MIN_R ((S_P * S_SIMD + 15) / 16)\n\n/**\n * pwxform(B):\n * Transform the provided block using the provided S-boxes.\n */\nstatic void\nblock_pwxform(uint64_t * B, const uint64_t * S)\n{\n\tuint64_t (*X)[S_SIMD] = (uint64_t (*)[S_SIMD])B;\n\tconst uint8_t *S0 = (const uint8_t *)S;\n\tconst uint8_t *S1 = (const uint8_t *)(S + S_SIZE1 * S_SIMD);\n\tsize_t i, j;\n#if S_SIMD > 2\n\tsize_t k;\n#endif\n\n\tfor (j = 0; j < S_P; j++) {\n\t\tuint64_t *Xj = X[j];\n\t\tuint64_t x0 = Xj[0];\n#if S_SIMD > 1\n\t\tuint64_t x1 = Xj[1];\n#endif\n\n\t\tfor (i = 0; i < S_ROUNDS; i++) {\n\t\t\tuint64_t x = x0 & S_MASK2;\n\t\t\tconst uint64_t *p0, *p1;\n\n\t\t\tp0 = (const uint64_t *)(S0 + (uint32_t)x);\n\t\t\tp1 = (const uint64_t *)(S1 + (x >> 32));\n\n\t\t\tx0 = (uint64_t)(x0 >> 32) * (uint32_t)x0;\n\t\t\tx0 += p0[0];\n\t\t\tx0 ^= p1[0];\n\n#if S_SIMD > 1\n\t\t\tx1 = (uint64_t)(x1 >> 32) * (uint32_t)x1;\n\t\t\tx1 += p0[1];\n\t\t\tx1 ^= p1[1];\n#endif\n\n#if S_SIMD > 2\n\t\t\tfor (k = 2; k < S_SIMD; k++) {\n\t\t\t\tx = Xj[k];\n\n\t\t\t\tx = (uint64_t)(x >> 32) * (uint32_t)x;\n\t\t\t\tx += p0[k];\n\t\t\t\tx ^= p1[k];\n\n\t\t\t\tXj[k] = x;\n\t\t\t}\n#endif\n\t\t}\n\n\t\tXj[0] = x0;\n#if S_SIMD > 1\n\t\tXj[1] = x1;\n#endif\n\t}\n}\n\n/**\n * blockmix_pwxform(Bin, Bout, S, r):\n * Compute Bout = BlockMix_pwxform{salsa20/8, S, r}(Bin).  The input Bin must\n * be 128r bytes in length; the output Bout must also be the same size.\n *\n * S lacks const qualifier to match blockmix_salsa8()'s prototype, which we\n * need to refer to both functions via the same function pointers.\n */\nstatic void\nblockmix_pwxform(const uint64_t * Bin, uint64_t * Bout, uint64_t * S, size_t r)\n{\n\tsize_t r1, r2, i;\n\n\t/* Convert 128-byte blocks to (S_P_SIZE * 64-bit) blocks */\n\tr1 = r * 128 / (S_P_SIZE * 8);\n\n\t/* X <-- B_{r1 - 1} */\n\tblkcpy(Bout, &Bin[(r1 - 1) * S_P_SIZE], S_P_SIZE);\n\n\t/* X <-- X \\xor B_i */\n\tblkxor(Bout, Bin, S_P_SIZE);\n\n\t/* X <-- H'(X) */\n\t/* B'_i <-- X */\n\tblock_pwxform(Bout, S);\n\n\t/* for i = 0 to r1 - 1 do */\n\tfor (i = 1; i < r1; i++) {\n\t\t/* X <-- X \\xor B_i */\n\t\tblkcpy(&Bout[i * S_P_SIZE], &Bout[(i - 1) * S_P_SIZE],\n\t\t    S_P_SIZE);\n\t\tblkxor(&Bout[i * S_P_SIZE], &Bin[i * S_P_SIZE], S_P_SIZE);\n\n\t\t/* X <-- H'(X) */\n\t\t/* B'_i <-- X */\n\t\tblock_pwxform(&Bout[i * S_P_SIZE], S);\n\t}\n\n\t/* Handle partial blocks */\n\tif (i * S_P_SIZE < r * 16)\n\t\tblkcpy(&Bout[i * S_P_SIZE], &Bin[i * S_P_SIZE],\n\t\t    r * 16 - i * S_P_SIZE);\n\n\ti = (r1 - 1) * S_P_SIZE / 8;\n\t/* Convert 128-byte blocks to 64-byte blocks */\n\tr2 = r * 2;\n\n\t/* B'_i <-- H(B'_i) */\n\tsalsa20_8(&Bout[i * 8]);\n\ti++;\n\n\tfor (; i < r2; i++) {\n\t\t/* B'_i <-- H(B'_i \\xor B'_{i-1}) */\n\t\tblkxor(&Bout[i * 8], &Bout[(i - 1) * 8], 8);\n\t\tsalsa20_8(&Bout[i * 8]);\n\t}\n}\n\n/**\n * integerify(B, r):\n * Return the result of parsing B_{2r-1} as a little-endian integer.\n */\nstatic inline uint64_t\nintegerify(const uint64_t * B, size_t r)\n{\n/*\n * Our 64-bit words are in host byte order, and word 6 holds the second 32-bit\n * word of B_{2r-1} due to SIMD shuffling.  The 64-bit value we return is also\n * in host byte order, as it should be.\n */\n\tconst uint64_t * X = &B[(2 * r - 1) * 8];\n\tuint32_t lo = X[0];\n\tuint32_t hi = X[6] >> 32;\n\treturn ((uint64_t)hi << 32) + lo;\n}\n\n/**\n * smix1(B, r, N, flags, V, NROM, shared, XY, S):\n * Compute first loop of B = SMix_r(B, N).  The input B must be 128r bytes in\n * length; the temporary storage V must be 128rN bytes in length; the temporary\n * storage XY must be 256r + 64 bytes in length.  The value N must be even and\n * no smaller than 2.\n */\nstatic void\nsmix1(uint64_t * B, size_t r, uint64_t N, yescrypt_flags_t flags,\n    uint64_t * V, uint64_t NROM, const yescrypt_shared_t * shared,\n    uint64_t * XY, uint64_t * S)\n{\n\tvoid (*blockmix)(const uint64_t *, uint64_t *, uint64_t *, size_t) =\n\t    (S ? blockmix_pwxform : blockmix_salsa8);\n\tconst uint64_t * VROM = shared->shared1.aligned;\n\tuint32_t VROM_mask = shared->mask1;\n\tsize_t s = 16 * r;\n\tuint64_t * X = V;\n\tuint64_t * Y = &XY[s];\n\tuint64_t * Z = S ? S : &XY[2 * s];\n\tuint64_t n, i, j;\n\tsize_t k;\n\n\t/* 1: X <-- B */\n\t/* 3: V_i <-- X */\n\tfor (i = 0; i < 2 * r; i++) {\n\t\tconst salsa20_blk_t *src = (const salsa20_blk_t *)&B[i * 8];\n\t\tsalsa20_blk_t *tmp = (salsa20_blk_t *)Y;\n\t\tsalsa20_blk_t *dst = (salsa20_blk_t *)&X[i * 8];\n\t\tfor (k = 0; k < 16; k++)\n\t\t\ttmp->w[k] = le32dec(&src->w[k]);\n\t\tsalsa20_simd_shuffle(tmp, dst);\n\t}\n\n\t/* 4: X <-- H(X) */\n\t/* 3: V_i <-- X */\n\tblockmix(X, Y, Z, r);\n\tblkcpy(&V[s], Y, s);\n\n\tX = XY;\n\n\tif (NROM && (VROM_mask & 1)) {\n\t\tif ((1 & VROM_mask) == 1) {\n\t\t\t/* j <-- Integerify(X) mod NROM */\n\t\t\tj = integerify(Y, r) & (NROM - 1);\n\n\t\t\t/* X <-- H(X \\xor VROM_j) */\n\t\t\tblkxor(Y, &VROM[j * s], s);\n\t\t}\n\n\t\tblockmix(Y, X, Z, r);\n\n\t\t/* 2: for i = 0 to N - 1 do */\n\t\tfor (n = 1, i = 2; i < N; i += 2) {\n\t\t\t/* 3: V_i <-- X */\n\t\t\tblkcpy(&V[i * s], X, s);\n\n\t\t\tif ((i & (i - 1)) == 0)\n\t\t\t\tn <<= 1;\n\n\t\t\t/* j <-- Wrap(Integerify(X), i) */\n\t\t\tj = integerify(X, r) & (n - 1);\n\t\t\tj += i - n;\n\n\t\t\t/* X <-- X \\xor V_j */\n\t\t\tblkxor(X, &V[j * s], s);\n\n\t\t\t/* 4: X <-- H(X) */\n\t\t\tblockmix(X, Y, Z, r);\n\n\t\t\t/* 3: V_i <-- X */\n\t\t\tblkcpy(&V[(i + 1) * s], Y, s);\n\n\t\t\tj = integerify(Y, r);\n\t\t\tif (((i + 1) & VROM_mask) == 1) {\n\t\t\t\t/* j <-- Integerify(X) mod NROM */\n\t\t\t\tj &= NROM - 1;\n\n\t\t\t\t/* X <-- H(X \\xor VROM_j) */\n\t\t\t\tblkxor(Y, &VROM[j * s], s);\n\t\t\t} else {\n\t\t\t\t/* j <-- Wrap(Integerify(X), i) */\n\t\t\t\tj &= n - 1;\n\t\t\t\tj += i + 1 - n;\n\n\t\t\t\t/* X <-- H(X \\xor V_j) */\n\t\t\t\tblkxor(Y, &V[j * s], s);\n\t\t\t}\n\n\t\t\tblockmix(Y, X, Z, r);\n\t\t}\n\t} else {\n\t\tyescrypt_flags_t rw = flags & YESCRYPT_RW;\n\n\t\t/* 4: X <-- H(X) */\n\t\tblockmix(Y, X, Z, r);\n\n\t\t/* 2: for i = 0 to N - 1 do */\n\t\tfor (n = 1, i = 2; i < N; i += 2) {\n\t\t\t/* 3: V_i <-- X */\n\t\t\tblkcpy(&V[i * s], X, s);\n\n\t\t\tif (rw) {\n\t\t\t\tif ((i & (i - 1)) == 0)\n\t\t\t\t\tn <<= 1;\n\n\t\t\t\t/* j <-- Wrap(Integerify(X), i) */\n\t\t\t\tj = integerify(X, r) & (n - 1);\n\t\t\t\tj += i - n;\n\n\t\t\t\t/* X <-- X \\xor V_j */\n\t\t\t\tblkxor(X, &V[j * s], s);\n\t\t\t}\n\n\t\t\t/* 4: X <-- H(X) */\n\t\t\tblockmix(X, Y, Z, r);\n\n\t\t\t/* 3: V_i <-- X */\n\t\t\tblkcpy(&V[(i + 1) * s], Y, s);\n\n\t\t\tif (rw) {\n\t\t\t\t/* j <-- Wrap(Integerify(X), i) */\n\t\t\t\tj = integerify(Y, r) & (n - 1);\n\t\t\t\tj += (i + 1) - n;\n\n\t\t\t\t/* X <-- X \\xor V_j */\n\t\t\t\tblkxor(Y, &V[j * s], s);\n\t\t\t}\n\n\t\t\t/* 4: X <-- H(X) */\n\t\t\tblockmix(Y, X, Z, r);\n\t\t}\n\t}\n\n\t/* B' <-- X */\n\tfor (i = 0; i < 2 * r; i++) {\n\t\tconst salsa20_blk_t *src = (const salsa20_blk_t *)&X[i * 8];\n\t\tsalsa20_blk_t *tmp = (salsa20_blk_t *)Y;\n\t\tsalsa20_blk_t *dst = (salsa20_blk_t *)&B[i * 8];\n\t\tfor (k = 0; k < 16; k++)\n\t\t\tle32enc(&tmp->w[k], src->w[k]);\n\t\tsalsa20_simd_unshuffle(tmp, dst);\n\t}\n}\n\n/**\n * smix2(B, r, N, Nloop, flags, V, NROM, shared, XY, S):\n * Compute second loop of B = SMix_r(B, N).  The input B must be 128r bytes in\n * length; the temporary storage V must be 128rN bytes in length; the temporary\n * storage XY must be 256r + 64 bytes in length.  The value N must be a\n * power of 2 greater than 1.  The value Nloop must be even.\n */\nstatic void\nsmix2(uint64_t * B, size_t r, uint64_t N, uint64_t Nloop,\n    yescrypt_flags_t flags,\n    uint64_t * V, uint64_t NROM, const yescrypt_shared_t * shared,\n    uint64_t * XY, uint64_t * S)\n{\n\tvoid (*blockmix)(const uint64_t *, uint64_t *, uint64_t *, size_t) =\n\t    (S ? blockmix_pwxform : blockmix_salsa8);\n\tconst uint64_t * VROM = shared->shared1.aligned;\n\tuint32_t VROM_mask = shared->mask1 | 1;\n\tsize_t s = 16 * r;\n\tyescrypt_flags_t rw = flags & YESCRYPT_RW;\n\tuint64_t * X = XY;\n\tuint64_t * Y = &XY[s];\n\tuint64_t * Z = S ? S : &XY[2 * s];\n\tuint64_t i, j;\n\tsize_t k;\n\n\tif (Nloop == 0)\n\t\treturn;\n\n\t/* X <-- B' */\n\tfor (i = 0; i < 2 * r; i++) {\n\t\tconst salsa20_blk_t *src = (const salsa20_blk_t *)&B[i * 8];\n\t\tsalsa20_blk_t *tmp = (salsa20_blk_t *)Y;\n\t\tsalsa20_blk_t *dst = (salsa20_blk_t *)&X[i * 8];\n\t\tfor (k = 0; k < 16; k++)\n\t\t\ttmp->w[k] = le32dec(&src->w[k]);\n\t\tsalsa20_simd_shuffle(tmp, dst);\n\t}\n\n\tif (NROM) {\n\t\t/* 6: for i = 0 to N - 1 do */\n\t\tfor (i = 0; i < Nloop; i += 2) {\n\t\t\t/* 7: j <-- Integerify(X) mod N */\n\t\t\tj = integerify(X, r) & (N - 1);\n\n\t\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\t\tblkxor(X, &V[j * s], s);\n\t\t\t/* V_j <-- Xprev \\xor V_j */\n\t\t\tif (rw)\n\t\t\t\tblkcpy(&V[j * s], X, s);\n\t\t\tblockmix(X, Y, Z, r);\n\n\t\t\tj = integerify(Y, r);\n\t\t\tif (((i + 1) & VROM_mask) == 1) {\n\t\t\t\t/* j <-- Integerify(X) mod NROM */\n\t\t\t\tj &= NROM - 1;\n\n\t\t\t\t/* X <-- H(X \\xor VROM_j) */\n\t\t\t\tblkxor(Y, &VROM[j * s], s);\n\t\t\t} else {\n\t\t\t\t/* 7: j <-- Integerify(X) mod N */\n\t\t\t\tj &= N - 1;\n\n\t\t\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\t\t\tblkxor(Y, &V[j * s], s);\n\t\t\t\t/* V_j <-- Xprev \\xor V_j */\n\t\t\t\tif (rw)\n\t\t\t\t\tblkcpy(&V[j * s], Y, s);\n\t\t\t}\n\n\t\t\tblockmix(Y, X, Z, r);\n\t\t}\n\t} else {\n\t\t/* 6: for i = 0 to N - 1 do */\n\t\ti = Nloop / 2;\n\t\tdo {\n\t\t\t/* 7: j <-- Integerify(X) mod N */\n\t\t\tj = integerify(X, r) & (N - 1);\n\n\t\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\t\tblkxor(X, &V[j * s], s);\n\t\t\t/* V_j <-- Xprev \\xor V_j */\n\t\t\tif (rw)\n\t\t\t\tblkcpy(&V[j * s], X, s);\n\t\t\tblockmix(X, Y, Z, r);\n\n\t\t\t/* 7: j <-- Integerify(X) mod N */\n\t\t\tj = integerify(Y, r) & (N - 1);\n\n\t\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\t\tblkxor(Y, &V[j * s], s);\n\t\t\t/* V_j <-- Xprev \\xor V_j */\n\t\t\tif (rw)\n\t\t\t\tblkcpy(&V[j * s], Y, s);\n\t\t\tblockmix(Y, X, Z, r);\n\t\t} while (--i);\n\t}\n\n\t/* 10: B' <-- X */\n\tfor (i = 0; i < 2 * r; i++) {\n\t\tconst salsa20_blk_t *src = (const salsa20_blk_t *)&X[i * 8];\n\t\tsalsa20_blk_t *tmp = (salsa20_blk_t *)Y;\n\t\tsalsa20_blk_t *dst = (salsa20_blk_t *)&B[i * 8];\n\t\tfor (k = 0; k < 16; k++)\n\t\t\tle32enc(&tmp->w[k], src->w[k]);\n\t\tsalsa20_simd_unshuffle(tmp, dst);\n\t}\n}\n\n/**\n * p2floor(x):\n * Largest power of 2 not greater than argument.\n */\nstatic uint64_t\np2floor(uint64_t x)\n{\n\tuint64_t y;\n\twhile ((y = x & (x - 1)))\n\t\tx = y;\n\treturn x;\n}\n\n/**\n * smix(B, r, N, p, t, flags, V, NROM, shared, XY, S):\n * Compute B = SMix_r(B, N).  The input B must be 128rp bytes in length; the\n * temporary storage V must be 128rN bytes in length; the temporary storage\n * XY must be 256r+64 or (256r+64)*p bytes in length (the larger size is\n * required with OpenMP-enabled builds).  The value N must be a power of 2\n * greater than 1.\n */\nstatic void\nsmix(uint64_t * B, size_t r, uint64_t N, uint32_t p, uint32_t t,\n    yescrypt_flags_t flags,\n    uint64_t * V, uint64_t NROM, const yescrypt_shared_t * shared,\n    uint64_t * XY, uint64_t * S)\n{\n\tsize_t s = 16 * r;\n\tuint64_t Nchunk = N / p, Nloop_all, Nloop_rw;\n\tuint32_t i;\n\n\tNloop_all = Nchunk;\n\tif (flags & YESCRYPT_RW) {\n\t\tif (t <= 1) {\n\t\t\tif (t)\n\t\t\t\tNloop_all *= 2; /* 2/3 */\n\t\t\tNloop_all = (Nloop_all + 2) / 3; /* 1/3, round up */\n\t\t} else {\n\t\t\tNloop_all *= t - 1;\n\t\t}\n\t} else if (t) {\n\t\tif (t == 1)\n\t\t\tNloop_all += (Nloop_all + 1) / 2; /* 1.5, round up */\n\t\tNloop_all *= t;\n\t}\n\n\tNloop_rw = 0;\n\tif (flags & __YESCRYPT_INIT_SHARED)\n\t\tNloop_rw = Nloop_all;\n\telse if (flags & YESCRYPT_RW)\n\t\tNloop_rw = Nloop_all / p;\n\n\tNchunk &= ~(uint64_t)1; /* round down to even */\n\tNloop_all++; Nloop_all &= ~(uint64_t)1; /* round up to even */\n\tNloop_rw &= ~(uint64_t)1; /* round down to even */\n\n#ifdef _OPENMP\n#pragma omp parallel if (p > 1) default(none) private(i) shared(B, r, N, p, flags, V, NROM, shared, XY, S, s, Nchunk, Nloop_all, Nloop_rw)\n\t{\n#pragma omp for\n#endif\n\tfor (i = 0; i < p; i++) {\n\t\tuint64_t Vchunk = i * Nchunk;\n\t\tuint64_t * Bp = &B[i * s];\n\t\tuint64_t * Vp = &V[Vchunk * s];\n#ifdef _OPENMP\n\t\tuint64_t * XYp = &XY[i * (2 * s + 8)];\n#else\n\t\tuint64_t * XYp = XY;\n#endif\n\t\tuint64_t Np = (i < p - 1) ? Nchunk : (N - Vchunk);\n\t\tuint64_t * Sp = S ? &S[i * S_SIZE_ALL] : S;\n\t\tif (Sp)\n\t\t\tsmix1(Bp, 1, S_SIZE_ALL / 16,\n\t\t\t    flags & ~YESCRYPT_PWXFORM,\n\t\t\t    Sp, NROM, shared, XYp, NULL);\n\t\tif (!(flags & __YESCRYPT_INIT_SHARED_2))\n\t\t\tsmix1(Bp, r, Np, flags, Vp, NROM, shared, XYp, Sp);\n\t\tsmix2(Bp, r, p2floor(Np), Nloop_rw, flags, Vp,\n\t\t    NROM, shared, XYp, Sp);\n\t}\n\n\tif (Nloop_all > Nloop_rw) {\n#ifdef _OPENMP\n#pragma omp for\n#endif\n\t\tfor (i = 0; i < p; i++) {\n\t\t\tuint64_t * Bp = &B[i * s];\n#ifdef _OPENMP\n\t\t\tuint64_t * XYp = &XY[i * (2 * s + 8)];\n#else\n\t\t\tuint64_t * XYp = XY;\n#endif\n\t\t\tuint64_t * Sp = S ? &S[i * S_SIZE_ALL] : S;\n\t\t\tsmix2(Bp, r, N, Nloop_all - Nloop_rw,\n\t\t\t    flags & ~YESCRYPT_RW, V, NROM, shared, XYp, Sp);\n\t\t}\n\t}\n#ifdef _OPENMP\n\t}\n#endif\n}\n\n/**\n * yescrypt_kdf(shared, local, passwd, passwdlen, salt, saltlen,\n *     N, r, p, t, flags, buf, buflen):\n * Compute scrypt(passwd[0 .. passwdlen - 1], salt[0 .. saltlen - 1], N, r,\n * p, buflen), or a revision of scrypt as requested by flags and shared, and\n * write the result into buf.  The parameters r, p, and buflen must satisfy\n * r * p < 2^30 and buflen <= (2^32 - 1) * 32.  The parameter N must be a power\n * of 2 greater than 1.\n *\n * t controls computation time while not affecting peak memory usage.  shared\n * and flags may request special modes as described in yescrypt.h.  local is\n * the thread-local data structure, allowing to preserve and reuse a memory\n * allocation across calls, thereby reducing its overhead.\n *\n * Return 0 on success; or -1 on error.\n */\nint\nyescrypt_kdf(const yescrypt_shared_t * shared, yescrypt_local_t * local,\n    const uint8_t * passwd, size_t passwdlen,\n    const uint8_t * salt, size_t saltlen,\n    uint64_t N, uint32_t r, uint32_t p, uint32_t t, yescrypt_flags_t flags,\n    uint8_t * buf, size_t buflen)\n{\n\tyescrypt_region_t tmp;\n\tuint64_t NROM;\n\tsize_t B_size, V_size, XY_size, need;\n\tuint64_t * B, * V, * XY, * S;\n\tuint64_t sha256[4];\n\n\t/*\n\t * YESCRYPT_PARALLEL_SMIX is a no-op at p = 1 for its intended purpose,\n\t * so don't let it have side-effects.  Without this adjustment, it'd\n\t * enable the SHA-256 password pre-hashing and output post-hashing,\n\t * because any deviation from classic scrypt implies those.\n\t */\n\tif (p == 1)\n\t\tflags &= ~YESCRYPT_PARALLEL_SMIX;\n\n\t/* Sanity-check parameters */\n\tif (flags & ~YESCRYPT_KNOWN_FLAGS) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n#if SIZE_MAX > UINT32_MAX\n\tif (buflen > (((uint64_t)(1) << 32) - 1) * 32) {\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n#endif\n\tif ((uint64_t)(r) * (uint64_t)(p) >= (1 << 30)) {\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\tif (((N & (N - 1)) != 0) || (N <= 1) || (r < 1) || (p < 1)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif ((flags & YESCRYPT_PARALLEL_SMIX) && (N / p <= 1)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n#if S_MIN_R > 1\n\tif ((flags & YESCRYPT_PWXFORM) && (r < S_MIN_R)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n#endif\n\tif ((p > SIZE_MAX / ((size_t)256 * r + 64)) ||\n#if SIZE_MAX / 256 <= UINT32_MAX\n\t    (r > SIZE_MAX / 256) ||\n#endif\n\t    (N > SIZE_MAX / 128 / r)) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tif (N > UINT64_MAX / ((uint64_t)t + 1)) {\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n#ifdef _OPENMP\n\tif (!(flags & YESCRYPT_PARALLEL_SMIX) &&\n\t    (N > SIZE_MAX / 128 / (r * p))) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n#endif\n\tif ((flags & YESCRYPT_PWXFORM) &&\n#ifndef _OPENMP\n\t    (flags & YESCRYPT_PARALLEL_SMIX) &&\n#endif\n\t    p > SIZE_MAX / (S_SIZE_ALL * sizeof(*S))) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\tNROM = 0;\n\tif (shared->shared1.aligned) {\n\t\tNROM = shared->shared1.aligned_size / ((size_t)128 * r);\n\t\tif (((NROM & (NROM - 1)) != 0) || (NROM <= 1) ||\n\t\t    !(flags & YESCRYPT_RW)) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Allocate memory */\n\tV = NULL;\n\tV_size = (size_t)128 * r * N;\n#ifdef _OPENMP\n\tif (!(flags & YESCRYPT_PARALLEL_SMIX))\n\t\tV_size *= p;\n#endif\n\tneed = V_size;\n\tif (flags & __YESCRYPT_INIT_SHARED) {\n\t\tif (local->aligned_size < need) {\n\t\t\tif (local->base || local->aligned ||\n\t\t\t    local->base_size || local->aligned_size) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!alloc_region(local, need))\n\t\t\t\treturn -1;\n\t\t}\n\t\tV = (uint64_t *)local->aligned;\n\t\tneed = 0;\n\t}\n\tB_size = (size_t)128 * r * p;\n\tneed += B_size;\n\tif (need < B_size) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tXY_size = (size_t)256 * r + 64;\n#ifdef _OPENMP\n\tXY_size *= p;\n#endif\n\tneed += XY_size;\n\tif (need < XY_size) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tif (flags & YESCRYPT_PWXFORM) {\n\t\tsize_t S_size = S_SIZE_ALL * sizeof(*S);\n#ifdef _OPENMP\n\t\tS_size *= p;\n#else\n\t\tif (flags & YESCRYPT_PARALLEL_SMIX)\n\t\t\tS_size *= p;\n#endif\n\t\tneed += S_size;\n\t\tif (need < S_size) {\n\t\t\terrno = ENOMEM;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (flags & __YESCRYPT_INIT_SHARED) {\n\t\tif (!alloc_region(&tmp, need))\n\t\t\treturn -1;\n\t\tB = (uint64_t *)tmp.aligned;\n\t\tXY = (uint64_t *)((uint8_t *)B + B_size);\n\t} else {\n\t\tinit_region(&tmp);\n\t\tif (local->aligned_size < need) {\n\t\t\tif (free_region(local))\n\t\t\t\treturn -1;\n\t\t\tif (!alloc_region(local, need))\n\t\t\t\treturn -1;\n\t\t}\n\t\tB = (uint64_t *)local->aligned;\n\t\tV = (uint64_t *)((uint8_t *)B + B_size);\n\t\tXY = (uint64_t *)((uint8_t *)V + V_size);\n\t}\n\tS = NULL;\n\tif (flags & YESCRYPT_PWXFORM)\n\t\tS = (uint64_t *)((uint8_t *)XY + XY_size);\n\n\tif (t || flags) {\n\t\tSHA256_CTX ctx;\n\t\tSHA256_Init(&ctx);\n\t\tSHA256_Update(&ctx, passwd, passwdlen);\n\t\tSHA256_Final((uint8_t *)sha256, &ctx);\n\t\tpasswd = (uint8_t *)sha256;\n\t\tpasswdlen = sizeof(sha256);\n\t}\n\n\t/* 1: (B_0 ... B_{p-1}) <-- PBKDF2(P, S, 1, p * MFLen) */\n\tPBKDF2_SHA256(passwd, passwdlen, salt, saltlen, 1,\n\t    (uint8_t *)B, B_size);\n\n\tif (t || flags)\n\t\tblkcpy(sha256, B, sizeof(sha256) / sizeof(sha256[0]));\n\n\tif (p == 1 || (flags & YESCRYPT_PARALLEL_SMIX)) {\n\t\tsmix(B, r, N, p, t, flags, V, NROM, shared, XY, S);\n\t} else {\n\t\tuint32_t i;\n\n\t\t/* 2: for i = 0 to p - 1 do */\n#ifdef _OPENMP\n#pragma omp parallel for default(none) private(i) shared(B, r, N, p, t, flags, V, NROM, shared, XY, S)\n#endif\n\t\tfor (i = 0; i < p; i++) {\n\t\t\t/* 3: B_i <-- MF(B_i, N) */\n#ifdef _OPENMP\n\t\t\tsmix(&B[(size_t)16 * r * i], r, N, 1, t, flags,\n\t\t\t    &V[(size_t)16 * r * i * N],\n\t\t\t    NROM, shared,\n\t\t\t    &XY[((size_t)32 * r + 8) * i],\n\t\t\t    S ? &S[S_SIZE_ALL * i] : S);\n#else\n\t\t\tsmix(&B[(size_t)16 * r * i], r, N, 1, t, flags, V,\n\t\t\t    NROM, shared, XY, S);\n#endif\n\t\t}\n\t}\n\n\t/* 5: DK <-- PBKDF2(P, B, 1, dkLen) */\n\tPBKDF2_SHA256(passwd, passwdlen, (uint8_t *)B, B_size, 1, buf, buflen);\n\n\t/*\n\t * Except when computing classic scrypt, allow all computation so far\n\t * to be performed on the client.  The final steps below match those of\n\t * SCRAM (RFC 5802), so that an extension of SCRAM (with the steps so\n\t * far in place of SCRAM's use of PBKDF2 and with SHA-256 in place of\n\t * SCRAM's use of SHA-1) would be usable with yescrypt hashes.\n\t */\n\tif ((t || flags) && buflen == sizeof(sha256)) {\n\t\t/* Compute ClientKey */\n\t\t{\n\t\t\tHMAC_SHA256_CTX ctx;\n\t\t\tHMAC_SHA256_Init(&ctx, buf, buflen);\n\t\t\tHMAC_SHA256_Update(&ctx, \"Client Key\", 10);\n\t\t\tHMAC_SHA256_Final((uint8_t *)sha256, &ctx);\n\t\t}\n\t\t/* Compute StoredKey */\n\t\t{\n\t\t\tSHA256_CTX ctx;\n\t\t\tSHA256_Init(&ctx);\n\t\t\tSHA256_Update(&ctx, (uint8_t *)sha256, sizeof(sha256));\n\t\t\tSHA256_Final(buf, &ctx);\n\t\t}\n\t}\n\n\tif (free_region(&tmp))\n\t\treturn -1;\n\n\t/* Success! */\n\treturn 0;\n}\n"
        },
        {
            "file_name": "yescrypt-ref.c",
            "content": "/*-\n * Copyright 2009 Colin Percival\n * Copyright 2013,2014 Alexander Peslyak\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * This file was originally written by Colin Percival as part of the Tarsnap\n * online backup system.\n *\n * This is the reference implementation.  Its purpose is to provide a simple\n * human- and machine-readable specification that implementations intended\n * for actual use should be tested against.  It is deliberately mostly not\n * optimized, and it is not meant to be used in production.  Instead, use\n * yescrypt-best.c or one of the source files included from there.\n */\n\n#warning \"This reference implementation is deliberately mostly not optimized. Use yescrypt-best.c instead unless you're testing (against) the reference implementation on purpose.\"\n\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#include \"sha256.h\"\n#include \"sysendian.h\"\n\n#include \"yescrypt.h\"\n\nstatic void\nblkcpy(uint32_t * dest, const uint32_t * src, size_t count)\n{\n\tdo {\n\t\t*dest++ = *src++;\n\t} while (--count);\n}\n\nstatic void\nblkxor(uint32_t * dest, const uint32_t * src, size_t count)\n{\n\tdo {\n\t\t*dest++ ^= *src++;\n\t} while (--count);\n}\n\n/**\n * salsa20_8(B):\n * Apply the salsa20/8 core to the provided block.\n */\nstatic void\nsalsa20_8(uint32_t B[16])\n{\n\tuint32_t x[16];\n\tsize_t i;\n\n\t/* Mimic SIMD shuffling */\n\tfor (i = 0; i < 16; i++)\n\t\tx[i * 5 % 16] = B[i];\n\n\tfor (i = 0; i < 8; i += 2) {\n#define R(a,b) (((a) << (b)) | ((a) >> (32 - (b))))\n\t\t/* Operate on columns */\n\t\tx[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);\n\t\tx[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);\n\n\t\tx[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);\n\t\tx[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);\n\n\t\tx[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);\n\t\tx[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);\n\n\t\tx[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);\n\t\tx[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);\n\n\t\t/* Operate on rows */\n\t\tx[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);\n\t\tx[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);\n\n\t\tx[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);\n\t\tx[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);\n\n\t\tx[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);\n\t\tx[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);\n\n\t\tx[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);\n\t\tx[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);\n#undef R\n\t}\n\n\t/* Mimic SIMD shuffling */\n\tfor (i = 0; i < 16; i++)\n\t\tB[i] += x[i * 5 % 16];\n}\n\n/**\n * blockmix_salsa8(B, Y, r):\n * Compute B = BlockMix_{salsa20/8, r}(B).  The input B must be 128r bytes in\n * length; the temporary space Y must also be the same size.\n */\nstatic void\nblockmix_salsa8(uint32_t * B, uint32_t * Y, size_t r)\n{\n\tuint32_t X[16];\n\tsize_t i;\n\n\t/* 1: X <-- B_{2r - 1} */\n\tblkcpy(X, &B[(2 * r - 1) * 16], 16);\n\n\t/* 2: for i = 0 to 2r - 1 do */\n\tfor (i = 0; i < 2 * r; i++) {\n\t\t/* 3: X <-- H(X \\xor B_i) */\n\t\tblkxor(X, &B[i * 16], 16);\n\t\tsalsa20_8(X);\n\n\t\t/* 4: Y_i <-- X */\n\t\tblkcpy(&Y[i * 16], X, 16);\n\t}\n\n\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\tfor (i = 0; i < r; i++)\n\t\tblkcpy(&B[i * 16], &Y[(i * 2) * 16], 16);\n\tfor (i = 0; i < r; i++)\n\t\tblkcpy(&B[(i + r) * 16], &Y[(i * 2 + 1) * 16], 16);\n}\n\n/* These are tunable */\n#define S_BITS 8\n#define S_SIMD 2\n#define S_P 4\n#define S_ROUNDS 6\n\n/* Number of S-boxes.  Not tunable, hard-coded in a few places. */\n#define S_N 2\n\n/* Derived values.  Not tunable on their own. */\n#define S_SIZE1 (1 << S_BITS)\n#define S_MASK ((S_SIZE1 - 1) * S_SIMD * 8)\n#define S_SIZE_ALL (S_N * S_SIZE1 * S_SIMD * 2)\n#define S_P_SIZE (S_P * S_SIMD * 2)\n#define S_MIN_R ((S_P * S_SIMD + 15) / 16)\n\n/**\n * pwxform(B):\n * Transform the provided block using the provided S-boxes.\n */\nstatic void\nblock_pwxform(uint32_t * B, const uint32_t * S)\n{\n\tuint32_t (*X)[S_SIMD][2] = (uint32_t (*)[S_SIMD][2])B;\n\tconst uint32_t (*S0)[2] = (const uint32_t (*)[2])S;\n\tconst uint32_t (*S1)[2] = S0 + S_SIZE1 * S_SIMD;\n\tsize_t i, j, k;\n\n\tfor (i = 0; i < S_ROUNDS; i++) {\n\t\tfor (j = 0; j < S_P; j++) {\n\t\t\tuint32_t xl = X[j][0][0];\n\t\t\tuint32_t xh = X[j][0][1];\n\t\t\tconst uint32_t (*p0)[2], (*p1)[2];\n\n\t\t\tp0 = S0 + (xl & S_MASK) / sizeof(*S0);\n\t\t\tp1 = S1 + (xh & S_MASK) / sizeof(*S1);\n\n\t\t\tfor (k = 0; k < S_SIMD; k++) {\n\t\t\t\tuint64_t x, s0, s1;\n\n\t\t\t\ts0 = ((uint64_t)p0[k][1] << 32) + p0[k][0];\n\t\t\t\ts1 = ((uint64_t)p1[k][1] << 32) + p1[k][0];\n\n\t\t\t\txl = X[j][k][0];\n\t\t\t\txh = X[j][k][1];\n\n\t\t\t\tx = (uint64_t)xh * xl;\n\t\t\t\tx += s0;\n\t\t\t\tx ^= s1;\n\n\t\t\t\tX[j][k][0] = x;\n\t\t\t\tX[j][k][1] = x >> 32;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * blockmix_pwxform(B, Y, S, r):\n * Compute B = BlockMix_pwxform{salsa20/8, S, r}(B).  The input B must be 128r\n * bytes in length; the temporary space Y must be at least S_P_SIZE*4 bytes.\n */\nstatic void\nblockmix_pwxform(uint32_t * B, uint32_t * Y, const uint32_t * S, size_t r)\n{\n\tsize_t r1, r2, i;\n\n\t/* Convert 128-byte blocks to (S_P_SIZE * 32-bit) blocks */\n\tr1 = r * 128 / (S_P_SIZE * 4);\n\n\t/* X <-- B_{r1 - 1} */\n\tblkcpy(Y, &B[(r1 - 1) * S_P_SIZE], S_P_SIZE);\n\n\t/* for i = 0 to r1 - 1 do */\n\tfor (i = 0; i < r1; i++) {\n\t\t/* X <-- X \\xor B_i */\n\t\tblkxor(Y, &B[i * S_P_SIZE], S_P_SIZE);\n\n\t\t/* X <-- H'(X) */\n\t\tblock_pwxform(Y, S);\n\n\t\t/* B'_i <-- X */\n\t\tblkcpy(&B[i * S_P_SIZE], Y, S_P_SIZE);\n\t}\n\n\ti = (r1 - 1) * S_P_SIZE / 16;\n\t/* Convert 128-byte blocks to 64-byte blocks */\n\tr2 = r * 2;\n\n\t/* B_i <-- H(B_i) */\n\tsalsa20_8(&B[i * 16]);\n\ti++;\n\n\tfor (; i < r2; i++) {\n\t\t/* B_i <-- H(B_i \\xor B_{i-1}) */\n\t\tblkxor(&B[i * 16], &B[(i - 1) * 16], 16);\n\t\tsalsa20_8(&B[i * 16]);\n\t}\n}\n\n/**\n * integerify(B, r):\n * Return the result of parsing B_{2r-1} as a little-endian integer.\n */\nstatic uint64_t\nintegerify(const uint32_t * B, size_t r)\n{\n/*\n * Our 32-bit words are in host byte order, and word 13 is the second word of\n * B_{2r-1} due to SIMD shuffling.  The 64-bit value we return is also in host\n * byte order, as it should be.\n */\n\tconst uint32_t * X = &B[(2 * r - 1) * 16];\n\treturn ((uint64_t)X[13] << 32) + X[0];\n}\n\n/**\n * p2floor(x):\n * Largest power of 2 not greater than argument.\n */\nstatic uint64_t\np2floor(uint64_t x)\n{\n\tuint64_t y;\n\twhile ((y = x & (x - 1)))\n\t\tx = y;\n\treturn x;\n}\n\n/**\n * wrap(x, i):\n * Wrap x to the range 0 to i-1.\n */\nstatic uint64_t\nwrap(uint64_t x, uint64_t i)\n{\n\tuint64_t n = p2floor(i);\n\treturn (x & (n - 1)) + (i - n);\n}\n\n/**\n * smix1(B, r, N, flags, V, NROM, shared, XY, S):\n * Compute first loop of B = SMix_r(B, N).  The input B must be 128r bytes in\n * length; the temporary storage V must be 128rN bytes in length; the temporary\n * storage XY must be 256r bytes in length.\n */\nstatic void\nsmix1(uint32_t * B, size_t r, uint64_t N, yescrypt_flags_t flags,\n    uint32_t * V, uint64_t NROM, const yescrypt_shared_t * shared,\n    uint32_t * XY, uint32_t * S)\n{\n\tconst uint32_t * VROM = shared->shared1.aligned;\n\tuint32_t VROM_mask = NROM ? shared->mask1 : 0;\n\tsize_t s = 32 * r;\n\tuint32_t * X = XY;\n\tuint32_t * Y = &XY[s];\n\tuint64_t i, j;\n\tsize_t k;\n\n\t/* 1: X <-- B */\n\tfor (k = 0; k < 2 * r; k++)\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tX[k * 16 + i] = le32dec(&B[k * 16 + (i * 5 % 16)]);\n\n\t/* 2: for i = 0 to N - 1 do */\n\tfor (i = 0; i < N; i++) {\n\t\t/* 3: V_i <-- X */\n\t\tblkcpy(&V[i * s], X, s);\n\n\t\tif ((i & VROM_mask) == 1) {\n\t\t\t/* j <-- Integerify(X) mod NROM */\n\t\t\tj = integerify(X, r) & (NROM - 1);\n\n\t\t\t/* X <-- H(X \\xor VROM_j) */\n\t\t\tblkxor(X, &VROM[j * s], s);\n\t\t} else if ((flags & YESCRYPT_RW) && i > 1) {\n\t\t\t/* j <-- Wrap(Integerify(X), i) */\n\t\t\tj = wrap(integerify(X, r), i);\n\n\t\t\t/* X <-- X \\xor V_j */\n\t\t\tblkxor(X, &V[j * s], s);\n\t\t}\n\n\t\t/* 4: X <-- H(X) */\n\t\tif (S)\n\t\t\tblockmix_pwxform(X, Y, S, r);\n\t\telse\n\t\t\tblockmix_salsa8(X, Y, r);\n\t}\n\n\t/* B' <-- X */\n\tfor (k = 0; k < 2 * r; k++)\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tle32enc(&B[k * 16 + (i * 5 % 16)], X[k * 16 + i]);\n}\n\n/**\n * smix2(B, r, N, Nloop, flags, V, NROM, shared, XY, S):\n * Compute second loop of B = SMix_r(B, N).  The input B must be 128r bytes in\n * length; the temporary storage V must be 128rN bytes in length; the temporary\n * storage XY must be 256r bytes in length.  The value N must be a power of 2\n * greater than 1.\n */\nstatic void\nsmix2(uint32_t * B, size_t r, uint64_t N, uint64_t Nloop,\n    yescrypt_flags_t flags, uint32_t * V, uint64_t NROM,\n    const yescrypt_shared_t * shared, uint32_t * XY, uint32_t * S)\n{\n\tconst uint32_t * VROM = shared->shared1.aligned;\n\tuint32_t VROM_mask = NROM ? (shared->mask1 | 1) : 0;\n\tsize_t s = 32 * r;\n\tuint32_t * X = XY;\n\tuint32_t * Y = &XY[s];\n\tuint64_t i, j;\n\tsize_t k;\n\n\t/* X <-- B */\n\tfor (k = 0; k < 2 * r; k++)\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tX[k * 16 + i] = le32dec(&B[k * 16 + (i * 5 % 16)]);\n\n\t/* 6: for i = 0 to N - 1 do */\n\tfor (i = 0; i < Nloop; i++) {\n\t\tif ((i & VROM_mask) == 1) {\n\t\t\t/* j <-- Integerify(X) mod NROM */\n\t\t\tj = integerify(X, r) & (NROM - 1);\n\n\t\t\t/* X <-- H(X \\xor VROM_j) */\n\t\t\tblkxor(X, &VROM[j * s], s);\n\t\t} else {\n\t\t\t/* 7: j <-- Integerify(X) mod N */\n\t\t\tj = integerify(X, r) & (N - 1);\n\n\t\t\t/* 8.1: X <-- X \\xor V_j */\n\t\t\tblkxor(X, &V[j * s], s);\n\t\t\t/* V_j <-- X */\n\t\t\tif (flags & YESCRYPT_RW)\n\t\t\t\tblkcpy(&V[j * s], X, s);\n\t\t}\n\n\t\t/* 8.2: X <-- H(X) */\n\t\tif (S)\n\t\t\tblockmix_pwxform(X, Y, S, r);\n\t\telse\n\t\t\tblockmix_salsa8(X, Y, r);\n\t}\n\n\t/* 10: B' <-- X */\n\tfor (k = 0; k < 2 * r; k++)\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tle32enc(&B[k * 16 + (i * 5 % 16)], X[k * 16 + i]);\n}\n\n/**\n * smix(B, r, N, p, t, flags, V, NROM, shared, XY, S):\n * Compute B = SMix_r(B, N).  The input B must be 128rp bytes in length; the\n * temporary storage V must be 128rN bytes in length; the temporary storage\n * XY must be 256r bytes in length.  The value N must be a power of 2 greater\n * than 1.\n */\nstatic void\nsmix(uint32_t * B, size_t r, uint64_t N, uint32_t p, uint32_t t,\n    yescrypt_flags_t flags,\n    uint32_t * V, uint64_t NROM, const yescrypt_shared_t * shared,\n    uint32_t * XY, uint32_t * S)\n{\n\tsize_t s = 32 * r;\n\tuint64_t Vchunk = 0, Nchunk = N / p, Nloop_all, Nloop_rw;\n\tuint32_t i;\n\n\tNloop_all = Nchunk;\n\tif (flags & YESCRYPT_RW) {\n\t\tif (t <= 1) {\n\t\t\tif (t)\n\t\t\t\tNloop_all *= 2; /* 2/3 */\n\t\t\tNloop_all = (Nloop_all + 2) / 3; /* 1/3, round up */\n\t\t} else {\n\t\t\tNloop_all *= t - 1;\n\t\t}\n\t} else if (t) {\n\t\tif (t == 1)\n\t\t\tNloop_all += (Nloop_all + 1) / 2; /* 1.5, round up */\n\t\tNloop_all *= t;\n\t}\n\n\tNloop_rw = 0;\n\tif (flags & __YESCRYPT_INIT_SHARED)\n\t\tNloop_rw = Nloop_all;\n\telse if (flags & YESCRYPT_RW)\n\t\tNloop_rw = Nloop_all / p;\n\n\tNchunk &= ~(uint64_t)1; /* round down to even */\n\tNloop_all++; Nloop_all &= ~(uint64_t)1; /* round up to even */\n\tNloop_rw &= ~(uint64_t)1; /* round down to even */\n\n\tfor (i = 0; i < p; i++) {\n\t\tuint32_t * Bp = &B[i * s];\n\t\tuint32_t * Vp = &V[Vchunk * s];\n\t\tuint64_t Np = (i < p - 1) ? Nchunk : (N - Vchunk);\n\t\tuint32_t * Sp = S ? &S[i * S_SIZE_ALL] : S;\n\t\tif (Sp)\n\t\t\tsmix1(Bp, 1, S_SIZE_ALL / 32,\n\t\t\t    flags & ~YESCRYPT_PWXFORM,\n\t\t\t    Sp, NROM, shared, XY, NULL);\n\t\tif (!(flags & __YESCRYPT_INIT_SHARED_2))\n\t\t\tsmix1(Bp, r, Np, flags, Vp, NROM, shared, XY, Sp);\n\t\tsmix2(Bp, r, p2floor(Np), Nloop_rw, flags, Vp,\n\t\t    NROM, shared, XY, Sp);\n\t\tVchunk += Nchunk;\n\t}\n\n\tfor (i = 0; i < p; i++) {\n\t\tuint32_t * Bp = &B[i * s];\n\t\tuint32_t * Sp = S ? &S[i * S_SIZE_ALL] : NULL;\n\t\tsmix2(Bp, r, N, Nloop_all - Nloop_rw, flags & ~YESCRYPT_RW,\n\t\t    V, NROM, shared, XY, Sp);\n\t}\n}\n\n/**\n * yescrypt_kdf(shared, local, passwd, passwdlen, salt, saltlen,\n *     N, r, p, t, flags, buf, buflen):\n * Compute scrypt(passwd[0 .. passwdlen - 1], salt[0 .. saltlen - 1], N, r,\n * p, buflen), or a revision of scrypt as requested by flags and shared, and\n * write the result into buf.  The parameters r, p, and buflen must satisfy\n * r * p < 2^30 and buflen <= (2^32 - 1) * 32.  The parameter N must be a power\n * of 2 greater than 1.\n *\n * t controls computation time while not affecting peak memory usage.  shared\n * and flags may request special modes as described in yescrypt.h.  local is\n * the thread-local data structure, allowing optimized implementations to\n * preserve and reuse a memory allocation across calls, thereby reducing its\n * overhead (this reference implementation does not make that optimization).\n *\n * Return 0 on success; or -1 on error.\n */\nint\nyescrypt_kdf(const yescrypt_shared_t * shared, yescrypt_local_t * local,\n    const uint8_t * passwd, size_t passwdlen,\n    const uint8_t * salt, size_t saltlen,\n    uint64_t N, uint32_t r, uint32_t p, uint32_t t, yescrypt_flags_t flags,\n    uint8_t * buf, size_t buflen)\n{\n\tint retval = -1;\n\tuint64_t NROM;\n\tsize_t B_size, V_size;\n\tuint32_t * B, * V, * XY, * S;\n\tuint32_t sha256[8];\n\n\t/*\n\t * YESCRYPT_PARALLEL_SMIX is a no-op at p = 1 for its intended purpose,\n\t * so don't let it have side-effects.  Without this adjustment, it'd\n\t * enable the SHA-256 password pre-hashing and output post-hashing,\n\t * because any deviation from classic scrypt implies those.\n\t */\n\tif (p == 1)\n\t\tflags &= ~YESCRYPT_PARALLEL_SMIX;\n\n\t/* Sanity-check parameters */\n\tif (flags & ~YESCRYPT_KNOWN_FLAGS) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n#if SIZE_MAX > UINT32_MAX\n\tif (buflen > (((uint64_t)(1) << 32) - 1) * 32) {\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n#endif\n\tif ((uint64_t)(r) * (uint64_t)(p) >= (1 << 30)) {\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\tif (((N & (N - 1)) != 0) || (N <= 1) || (r < 1) || (p < 1)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif ((flags & YESCRYPT_PARALLEL_SMIX) && (N / p <= 1)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n#if S_MIN_R > 1\n\tif ((flags & YESCRYPT_PWXFORM) && (r < S_MIN_R)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n#endif\n\tif ((r > SIZE_MAX / 128 / p) ||\n#if SIZE_MAX / 256 <= UINT32_MAX\n\t    (r > SIZE_MAX / 256) ||\n#endif\n\t    (N > SIZE_MAX / 128 / r)) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tif (N > UINT64_MAX / ((uint64_t)t + 1)) {\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\tif (((flags & (YESCRYPT_PWXFORM | YESCRYPT_PARALLEL_SMIX)) ==\n\t    (YESCRYPT_PWXFORM | YESCRYPT_PARALLEL_SMIX)) &&\n\t    p > SIZE_MAX / (S_SIZE_ALL * sizeof(*S))) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\tNROM = 0;\n\tif (shared->shared1.aligned) {\n\t\tNROM = shared->shared1.aligned_size / ((size_t)128 * r);\n/*\n * This implementation could support NROM without YESCRYPT_RW as well, but we\n * currently don't want to make such support available so that it can be safely\n * excluded from optimized implementations (where it'd require extra code).\n */\n\t\tif (((NROM & (NROM - 1)) != 0) || (NROM <= 1) ||\n\t\t    !(flags & YESCRYPT_RW)) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Allocate memory */\n\tV_size = (size_t)128 * r * N;\n\tif (flags & __YESCRYPT_INIT_SHARED) {\n\t\tV = (uint32_t *)local->aligned;\n\t\tif (local->aligned_size < V_size) {\n\t\t\tif (local->base || local->aligned ||\n\t\t\t    local->base_size || local->aligned_size) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((V = malloc(V_size)) == NULL)\n\t\t\t\treturn -1;\n\t\t\tlocal->base = local->aligned = V;\n\t\t\tlocal->base_size = local->aligned_size = V_size;\n\t\t}\n\t} else {\n\t\tif ((V = malloc(V_size)) == NULL)\n\t\t\treturn -1;\n\t}\n\tB_size = (size_t)128 * r * p;\n\tif ((B = malloc(B_size)) == NULL)\n\t\tgoto free_V;\n\tif ((XY = malloc((size_t)256 * r)) == NULL)\n\t\tgoto free_B;\n\tS = NULL;\n\tif (flags & YESCRYPT_PWXFORM) {\n\t\tsize_t S_size = S_SIZE_ALL * sizeof(*S);\n\t\tif (flags & YESCRYPT_PARALLEL_SMIX)\n\t\t\tS_size *= p;\n\t\tif ((S = malloc(S_size)) == NULL)\n\t\t\tgoto free_XY;\n\t}\n\n\tif (t || flags) {\n\t\tSHA256_CTX ctx;\n\t\tSHA256_Init(&ctx);\n\t\tSHA256_Update(&ctx, passwd, passwdlen);\n\t\tSHA256_Final((uint8_t *)sha256, &ctx);\n\t\tpasswd = (uint8_t *)sha256;\n\t\tpasswdlen = sizeof(sha256);\n\t}\n\n\t/* 1: (B_0 ... B_{p-1}) <-- PBKDF2(P, S, 1, p * MFLen) */\n\tPBKDF2_SHA256(passwd, passwdlen, salt, saltlen, 1,\n\t    (uint8_t *)B, B_size);\n\n\tif (t || flags)\n\t\tblkcpy(sha256, B, sizeof(sha256) / sizeof(sha256[0]));\n\n\tif (flags & YESCRYPT_PARALLEL_SMIX) {\n\t\tsmix(B, r, N, p, t, flags, V, NROM, shared, XY, S);\n\t} else {\n\t\tuint32_t i;\n\n\t\t/* 2: for i = 0 to p - 1 do */\n\t\tfor (i = 0; i < p; i++) {\n\t\t\t/* 3: B_i <-- MF(B_i, N) */\n\t\t\tsmix(&B[(size_t)32 * r * i], r, N, 1, t, flags, V,\n\t\t\t    NROM, shared, XY, S);\n\t\t}\n\t}\n\n\t/* 5: DK <-- PBKDF2(P, B, 1, dkLen) */\n\tPBKDF2_SHA256(passwd, passwdlen, (uint8_t *)B, B_size, 1, buf, buflen);\n\n\t/*\n\t * Except when computing classic scrypt, allow all computation so far\n\t * to be performed on the client.  The final steps below match those of\n\t * SCRAM (RFC 5802), so that an extension of SCRAM (with the steps so\n\t * far in place of SCRAM's use of PBKDF2 and with SHA-256 in place of\n\t * SCRAM's use of SHA-1) would be usable with yescrypt hashes.\n\t */\n\tif ((t || flags) && buflen == sizeof(sha256)) {\n\t\t/* Compute ClientKey */\n\t\t{\n\t\t\tHMAC_SHA256_CTX ctx;\n\t\t\tHMAC_SHA256_Init(&ctx, buf, buflen);\n\t\t\tHMAC_SHA256_Update(&ctx, \"Client Key\", 10);\n\t\t\tHMAC_SHA256_Final((uint8_t *)sha256, &ctx);\n\t\t}\n\t\t/* Compute StoredKey */\n\t\t{\n\t\t\tSHA256_CTX ctx;\n\t\t\tSHA256_Init(&ctx);\n\t\t\tSHA256_Update(&ctx, (uint8_t *)sha256, sizeof(sha256));\n\t\t\tSHA256_Final(buf, &ctx);\n\t\t}\n\t}\n\n\t/* Success! */\n\tretval = 0;\n\n\t/* Free memory */\n\tfree(S);\nfree_XY:\n\tfree(XY);\nfree_B:\n\tfree(B);\nfree_V:\n\tif (!(flags & __YESCRYPT_INIT_SHARED))\n\t\tfree(V);\n\n\treturn retval;\n}\n\nint\nyescrypt_init_shared(yescrypt_shared_t * shared,\n    const uint8_t * param, size_t paramlen,\n    uint64_t N, uint32_t r, uint32_t p,\n    yescrypt_init_shared_flags_t flags, uint32_t mask,\n    uint8_t * buf, size_t buflen)\n{\n\tyescrypt_shared1_t * shared1 = &shared->shared1;\n\tyescrypt_shared_t dummy, half1, half2;\n\tuint8_t salt[32];\n\n\tif (flags & YESCRYPT_SHARED_PREALLOCATED) {\n\t\tif (!shared1->aligned || !shared1->aligned_size)\n\t\t\treturn -1;\n\t} else {\n\t\tshared1->base = shared1->aligned = NULL;\n\t\tshared1->base_size = shared1->aligned_size = 0;\n\t}\n\tshared->mask1 = 1;\n\tif (!param && !paramlen && !N && !r && !p && !buf && !buflen)\n\t\treturn 0;\n\n\tdummy.shared1.base = dummy.shared1.aligned = NULL;\n\tdummy.shared1.base_size = dummy.shared1.aligned_size = 0;\n\tdummy.mask1 = 1;\n\tif (yescrypt_kdf(&dummy, shared1,\n\t    param, paramlen, NULL, 0, N, r, p, 0,\n\t    YESCRYPT_RW | YESCRYPT_PARALLEL_SMIX | __YESCRYPT_INIT_SHARED_1,\n\t    salt, sizeof(salt)))\n\t\tgoto out;\n\n\thalf1 = half2 = *shared;\n\thalf1.shared1.aligned_size /= 2;\n\thalf2.shared1.aligned += half1.shared1.aligned_size;\n\thalf2.shared1.aligned_size = half1.shared1.aligned_size;\n\tN /= 2;\n\n\tif (p > 1 && yescrypt_kdf(&half1, &half2.shared1,\n\t    param, paramlen, salt, sizeof(salt), N, r, p, 0,\n\t    YESCRYPT_RW | YESCRYPT_PARALLEL_SMIX | __YESCRYPT_INIT_SHARED_2,\n\t    salt, sizeof(salt)))\n\t\tgoto out;\n\n\tif (yescrypt_kdf(&half2, &half1.shared1,\n\t    param, paramlen, salt, sizeof(salt), N, r, p, 0,\n\t    YESCRYPT_RW | YESCRYPT_PARALLEL_SMIX | __YESCRYPT_INIT_SHARED_1,\n\t    salt, sizeof(salt)))\n\t\tgoto out;\n\n\tif (yescrypt_kdf(&half1, &half2.shared1,\n\t    param, paramlen, salt, sizeof(salt), N, r, p, 0,\n\t    YESCRYPT_RW | YESCRYPT_PARALLEL_SMIX | __YESCRYPT_INIT_SHARED_1,\n\t    buf, buflen))\n\t\tgoto out;\n\n\tshared->mask1 = mask;\n\n\treturn 0;\n\nout:\n\tif (!(flags & YESCRYPT_SHARED_PREALLOCATED))\n\t\tfree(shared1->base);\n\treturn -1;\n}\n\nint\nyescrypt_free_shared(yescrypt_shared_t * shared)\n{\n\tfree(shared->shared1.base);\n\tshared->shared1.base = shared->shared1.aligned = NULL;\n\tshared->shared1.base_size = shared->shared1.aligned_size = 0;\n\treturn 0;\n}\n\nint\nyescrypt_init_local(yescrypt_local_t * local)\n{\n/* The reference implementation doesn't use the local structure */\n\tlocal->base = local->aligned = NULL;\n\tlocal->base_size = local->aligned_size = 0;\n\treturn 0;\n}\n\nint\nyescrypt_free_local(yescrypt_local_t * local)\n{\n/* The reference implementation frees its memory in yescrypt_kdf() */\n\treturn 0;\n}\n"
        },
        {
            "file_name": "yescrypt-simd.c",
            "content": "/*-\n * Copyright 2009 Colin Percival\n * Copyright 2012-2014 Alexander Peslyak\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * This file was originally written by Colin Percival as part of the Tarsnap\n * online backup system.\n */\n\n/*\n * On 64-bit, enabling SSE4.1 helps our pwxform code indirectly, via avoiding\n * gcc bug 54349 (fixed for gcc 4.9+).  On 32-bit, it's of direct help.  AVX\n * and XOP are of further help either way.\n */\n#ifndef __SSE4_1__\n#warning \"Consider enabling SSE4.1, AVX, or XOP in the C compiler for significantly better performance\"\n#endif\n\n#include <emmintrin.h>\n#ifdef __XOP__\n#include <x86intrin.h>\n#endif\n\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"sha256.h\"\n#include \"sysendian.h\"\n\n#include \"yescrypt.h\"\n\n#include \"yescrypt-platform.c\"\n\n#if __STDC_VERSION__ >= 199901L\n/* have restrict */\n#elif defined(__GNUC__)\n#define restrict __restrict\n#else\n#define restrict\n#endif\n\n#define PREFETCH(x, hint) _mm_prefetch((const char *)(x), (hint));\n#define PREFETCH_OUT(x, hint) /* disabled */\n\n#ifdef __XOP__\n#define ARX(out, in1, in2, s) \\\n\tout = _mm_xor_si128(out, _mm_roti_epi32(_mm_add_epi32(in1, in2), s));\n#else\n#define ARX(out, in1, in2, s) \\\n\t{ \\\n\t\t__m128i T = _mm_add_epi32(in1, in2); \\\n\t\tout = _mm_xor_si128(out, _mm_slli_epi32(T, s)); \\\n\t\tout = _mm_xor_si128(out, _mm_srli_epi32(T, 32-s)); \\\n\t}\n#endif\n\n#define SALSA20_2ROUNDS \\\n\t/* Operate on \"columns\" */ \\\n\tARX(X1, X0, X3, 7) \\\n\tARX(X2, X1, X0, 9) \\\n\tARX(X3, X2, X1, 13) \\\n\tARX(X0, X3, X2, 18) \\\n\\\n\t/* Rearrange data */ \\\n\tX1 = _mm_shuffle_epi32(X1, 0x93); \\\n\tX2 = _mm_shuffle_epi32(X2, 0x4E); \\\n\tX3 = _mm_shuffle_epi32(X3, 0x39); \\\n\\\n\t/* Operate on \"rows\" */ \\\n\tARX(X3, X0, X1, 7) \\\n\tARX(X2, X3, X0, 9) \\\n\tARX(X1, X2, X3, 13) \\\n\tARX(X0, X1, X2, 18) \\\n\\\n\t/* Rearrange data */ \\\n\tX1 = _mm_shuffle_epi32(X1, 0x39); \\\n\tX2 = _mm_shuffle_epi32(X2, 0x4E); \\\n\tX3 = _mm_shuffle_epi32(X3, 0x93);\n\n/**\n * Apply the salsa20/8 core to the block provided in (X0 ... X3).\n */\n#define SALSA20_8_BASE(maybe_decl, out) \\\n\t{ \\\n\t\tmaybe_decl Y0 = X0; \\\n\t\tmaybe_decl Y1 = X1; \\\n\t\tmaybe_decl Y2 = X2; \\\n\t\tmaybe_decl Y3 = X3; \\\n\t\tSALSA20_2ROUNDS \\\n\t\tSALSA20_2ROUNDS \\\n\t\tSALSA20_2ROUNDS \\\n\t\tSALSA20_2ROUNDS \\\n\t\t(out)[0] = X0 = _mm_add_epi32(X0, Y0); \\\n\t\t(out)[1] = X1 = _mm_add_epi32(X1, Y1); \\\n\t\t(out)[2] = X2 = _mm_add_epi32(X2, Y2); \\\n\t\t(out)[3] = X3 = _mm_add_epi32(X3, Y3); \\\n\t}\n#define SALSA20_8(out) \\\n\tSALSA20_8_BASE(__m128i, out)\n\n/**\n * Apply the salsa20/8 core to the block provided in (X0 ... X3) ^ (Z0 ... Z3).\n */\n#define SALSA20_8_XOR_ANY(maybe_decl, Z0, Z1, Z2, Z3, out) \\\n\tX0 = _mm_xor_si128(X0, Z0); \\\n\tX1 = _mm_xor_si128(X1, Z1); \\\n\tX2 = _mm_xor_si128(X2, Z2); \\\n\tX3 = _mm_xor_si128(X3, Z3); \\\n\tSALSA20_8_BASE(maybe_decl, out)\n\n#define SALSA20_8_XOR_MEM(in, out) \\\n\tSALSA20_8_XOR_ANY(__m128i, (in)[0], (in)[1], (in)[2], (in)[3], out)\n\n#define SALSA20_8_XOR_REG(out) \\\n\tSALSA20_8_XOR_ANY(/* empty */, Y0, Y1, Y2, Y3, out)\n\ntypedef union {\n\tuint32_t w[16];\n\t__m128i q[4];\n} salsa20_blk_t;\n\n/**\n * blockmix_salsa8(Bin, Bout, r):\n * Compute Bout = BlockMix_{salsa20/8, r}(Bin).  The input Bin must be 128r\n * bytes in length; the output Bout must also be the same size.\n */\nstatic inline void\nblockmix_salsa8(const salsa20_blk_t *restrict Bin,\n    salsa20_blk_t *restrict Bout, size_t r)\n{\n\t__m128i X0, X1, X2, X3;\n\tsize_t i;\n\n\tr--;\n\tPREFETCH(&Bin[r * 2 + 1], _MM_HINT_T0)\n\tfor (i = 0; i < r; i++) {\n\t\tPREFETCH(&Bin[i * 2], _MM_HINT_T0)\n\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t\tPREFETCH(&Bin[i * 2 + 1], _MM_HINT_T0)\n\t\tPREFETCH_OUT(&Bout[r + 1 + i], _MM_HINT_T0)\n\t}\n\tPREFETCH(&Bin[r * 2], _MM_HINT_T0)\n\tPREFETCH_OUT(&Bout[r], _MM_HINT_T0)\n\tPREFETCH_OUT(&Bout[r * 2 + 1], _MM_HINT_T0)\n\n\t/* 1: X <-- B_{2r - 1} */\n\tX0 = Bin[r * 2 + 1].q[0];\n\tX1 = Bin[r * 2 + 1].q[1];\n\tX2 = Bin[r * 2 + 1].q[2];\n\tX3 = Bin[r * 2 + 1].q[3];\n\n\t/* 3: X <-- H(X \\xor B_i) */\n\t/* 4: Y_i <-- X */\n\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\tSALSA20_8_XOR_MEM(Bin[0].q, Bout[0].q)\n\n\t/* 2: for i = 0 to 2r - 1 do */\n\tfor (i = 0; i < r;) {\n\t\t/* 3: X <-- H(X \\xor B_i) */\n\t\t/* 4: Y_i <-- X */\n\t\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\t\tSALSA20_8_XOR_MEM(Bin[i * 2 + 1].q, Bout[r + 1 + i].q)\n\n\t\ti++;\n\n\t\t/* 3: X <-- H(X \\xor B_i) */\n\t\t/* 4: Y_i <-- X */\n\t\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\t\tSALSA20_8_XOR_MEM(Bin[i * 2].q, Bout[i].q)\n\t}\n\n\t/* 3: X <-- H(X \\xor B_i) */\n\t/* 4: Y_i <-- X */\n\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\tSALSA20_8_XOR_MEM(Bin[r * 2 + 1].q, Bout[r * 2 + 1].q)\n}\n\n/*\n * (V)PSRLDQ and (V)PSHUFD have higher throughput than (V)PSRLQ on some CPUs\n * starting with Sandy Bridge.  Additionally, PSHUFD uses separate source and\n * destination registers, whereas the shifts would require an extra move\n * instruction for our code when building without AVX.  Unfortunately, PSHUFD\n * is much slower on Conroe (4 cycles latency vs. 1 cycle latency for PSRLQ)\n * and somewhat slower on some non-Intel CPUs (luckily not including AMD\n * Bulldozer and Piledriver).  Since for many other CPUs using (V)PSHUFD is a\n * win in terms of throughput or/and not needing a move instruction, we\n * currently use it despite of the higher latency on some older CPUs.  As an\n * alternative, the #if below may be patched to only enable use of (V)PSHUFD\n * when building with SSE4.1 or newer, which is not available on older CPUs\n * where this instruction has higher latency.\n */\n#if 1\n#define HI32(X) \\\n\t_mm_shuffle_epi32((X), _MM_SHUFFLE(2,3,0,1))\n#elif 0\n#define HI32(X) \\\n\t_mm_srli_si128((X), 4)\n#else\n#define HI32(X) \\\n\t_mm_srli_epi64((X), 32)\n#endif\n\n#if defined(__x86_64__) && (defined(__ICC) || defined(__llvm__))\n/* Intel's name, also supported by recent gcc */\n#define EXTRACT64(X) _mm_cvtsi128_si64(X)\n#elif defined(__x86_64__) && !defined(_MSC_VER) && !defined(__OPEN64__)\n/* gcc got the 'x' name earlier than non-'x', MSVC and Open64 had bugs */\n#define EXTRACT64(X) _mm_cvtsi128_si64x(X)\n#elif defined(__x86_64__) && defined(__SSE4_1__)\n/* No known bugs for this intrinsic */\n#include <smmintrin.h>\n#define EXTRACT64(X) _mm_extract_epi64((X), 0)\n#elif defined(__SSE4_1__)\n/* 32-bit */\n#include <smmintrin.h>\n#if 0\n/* This is currently unused by the code below, which instead uses these two\n * intrinsics explicitly when (!defined(__x86_64__) && defined(__SSE4_1__)) */\n#define EXTRACT64(X) \\\n\t((uint64_t)(uint32_t)_mm_cvtsi128_si32(X) | \\\n\t((uint64_t)(uint32_t)_mm_extract_epi32((X), 1) << 32))\n#endif\n#else\n/* 32-bit or compilers with known past bugs in _mm_cvtsi128_si64*() */\n#define EXTRACT64(X) \\\n\t((uint64_t)(uint32_t)_mm_cvtsi128_si32(X) | \\\n\t((uint64_t)(uint32_t)_mm_cvtsi128_si32(HI32(X)) << 32))\n#endif\n\n/* This is tunable */\n#define S_BITS 8\n\n/* Not tunable in this implementation, hard-coded in a few places */\n#define S_SIMD 2\n#define S_P 4\n\n/* Number of S-boxes.  Not tunable by design, hard-coded in a few places. */\n#define S_N 2\n\n/* Derived values.  Not tunable except via S_BITS above. */\n#define S_SIZE1 (1 << S_BITS)\n#define S_MASK ((S_SIZE1 - 1) * S_SIMD * 8)\n#define S_MASK2 (((uint64_t)S_MASK << 32) | S_MASK)\n#define S_SIZE_ALL (S_N * S_SIZE1 * S_SIMD * 8)\n\n#if !defined(__x86_64__) && defined(__SSE4_1__)\n/* 32-bit with SSE4.1 */\n#define PWXFORM_X_T __m128i\n#define PWXFORM_SIMD(X, x, s0, s1) \\\n\tx = _mm_and_si128(X, _mm_set1_epi64x(S_MASK2)); \\\n\ts0 = *(const __m128i *)(S0 + (uint32_t)_mm_cvtsi128_si32(x)); \\\n\ts1 = *(const __m128i *)(S1 + (uint32_t)_mm_extract_epi32(x, 1)); \\\n\tX = _mm_mul_epu32(HI32(X), X); \\\n\tX = _mm_add_epi64(X, s0); \\\n\tX = _mm_xor_si128(X, s1);\n#else\n/* 64-bit, or 32-bit without SSE4.1 */\n#define PWXFORM_X_T uint64_t\n#define PWXFORM_SIMD(X, x, s0, s1) \\\n\tx = EXTRACT64(X) & S_MASK2; \\\n\ts0 = *(const __m128i *)(S0 + (uint32_t)x); \\\n\ts1 = *(const __m128i *)(S1 + (x >> 32)); \\\n\tX = _mm_mul_epu32(HI32(X), X); \\\n\tX = _mm_add_epi64(X, s0); \\\n\tX = _mm_xor_si128(X, s1);\n#endif\n\n#define PWXFORM_ROUND \\\n\tPWXFORM_SIMD(X0, x0, s00, s01) \\\n\tPWXFORM_SIMD(X1, x1, s10, s11) \\\n\tPWXFORM_SIMD(X2, x2, s20, s21) \\\n\tPWXFORM_SIMD(X3, x3, s30, s31)\n\n#define PWXFORM \\\n\t{ \\\n\t\tPWXFORM_X_T x0, x1, x2, x3; \\\n\t\t__m128i s00, s01, s10, s11, s20, s21, s30, s31; \\\n\t\tPWXFORM_ROUND PWXFORM_ROUND \\\n\t\tPWXFORM_ROUND PWXFORM_ROUND \\\n\t\tPWXFORM_ROUND PWXFORM_ROUND \\\n\t}\n\n#define XOR4(in) \\\n\tX0 = _mm_xor_si128(X0, (in)[0]); \\\n\tX1 = _mm_xor_si128(X1, (in)[1]); \\\n\tX2 = _mm_xor_si128(X2, (in)[2]); \\\n\tX3 = _mm_xor_si128(X3, (in)[3]);\n\n#define OUT(out) \\\n\t(out)[0] = X0; \\\n\t(out)[1] = X1; \\\n\t(out)[2] = X2; \\\n\t(out)[3] = X3;\n\n/**\n * blockmix_pwxform(Bin, Bout, r, S):\n * Compute Bout = BlockMix_pwxform{salsa20/8, r, S}(Bin).  The input Bin must\n * be 128r bytes in length; the output Bout must also be the same size.\n */\nstatic void\nblockmix(const salsa20_blk_t *restrict Bin, salsa20_blk_t *restrict Bout,\n    size_t r, const __m128i *restrict S)\n{\n\tconst uint8_t * S0, * S1;\n\t__m128i X0, X1, X2, X3;\n\tsize_t i;\n\n\tif (!S) {\n\t\tblockmix_salsa8(Bin, Bout, r);\n\t\treturn;\n\t}\n\n\tS0 = (const uint8_t *)S;\n\tS1 = (const uint8_t *)S + S_SIZE_ALL / 2;\n\n\t/* Convert 128-byte blocks to 64-byte blocks */\n\tr *= 2;\n\n\tr--;\n\tPREFETCH(&Bin[r], _MM_HINT_T0)\n\tfor (i = 0; i < r; i++) {\n\t\tPREFETCH(&Bin[i], _MM_HINT_T0)\n\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t}\n\tPREFETCH_OUT(&Bout[r], _MM_HINT_T0)\n\n\t/* X <-- B_{r1 - 1} */\n\tX0 = Bin[r].q[0];\n\tX1 = Bin[r].q[1];\n\tX2 = Bin[r].q[2];\n\tX3 = Bin[r].q[3];\n\n\t/* for i = 0 to r1 - 1 do */\n\tfor (i = 0; i < r; i++) {\n\t\t/* X <-- H'(X \\xor B_i) */\n\t\tXOR4(Bin[i].q)\n\t\tPWXFORM\n\t\t/* B'_i <-- X */\n\t\tOUT(Bout[i].q)\n\t}\n\n\t/* Last iteration of the loop above */\n\tXOR4(Bin[i].q)\n\tPWXFORM\n\n\t/* B'_i <-- H(B'_i) */\n\tSALSA20_8(Bout[i].q)\n}\n\n#define XOR4_2(in1, in2) \\\n\tX0 = _mm_xor_si128((in1)[0], (in2)[0]); \\\n\tX1 = _mm_xor_si128((in1)[1], (in2)[1]); \\\n\tX2 = _mm_xor_si128((in1)[2], (in2)[2]); \\\n\tX3 = _mm_xor_si128((in1)[3], (in2)[3]);\n\nstatic inline uint32_t\nblockmix_salsa8_xor(const salsa20_blk_t *restrict Bin1,\n    const salsa20_blk_t *restrict Bin2, salsa20_blk_t *restrict Bout,\n    size_t r, int Bin2_in_ROM)\n{\n\t__m128i X0, X1, X2, X3;\n\tsize_t i;\n\n\tr--;\n\tif (Bin2_in_ROM) {\n\t\tPREFETCH(&Bin2[r * 2 + 1], _MM_HINT_NTA)\n\t\tPREFETCH(&Bin1[r * 2 + 1], _MM_HINT_T0)\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tPREFETCH(&Bin2[i * 2], _MM_HINT_NTA)\n\t\t\tPREFETCH(&Bin1[i * 2], _MM_HINT_T0)\n\t\t\tPREFETCH(&Bin2[i * 2 + 1], _MM_HINT_NTA)\n\t\t\tPREFETCH(&Bin1[i * 2 + 1], _MM_HINT_T0)\n\t\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t\t\tPREFETCH_OUT(&Bout[r + 1 + i], _MM_HINT_T0)\n\t\t}\n\t\tPREFETCH(&Bin2[r * 2], _MM_HINT_T0)\n\t} else {\n\t\tPREFETCH(&Bin2[r * 2 + 1], _MM_HINT_T0)\n\t\tPREFETCH(&Bin1[r * 2 + 1], _MM_HINT_T0)\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tPREFETCH(&Bin2[i * 2], _MM_HINT_T0)\n\t\t\tPREFETCH(&Bin1[i * 2], _MM_HINT_T0)\n\t\t\tPREFETCH(&Bin2[i * 2 + 1], _MM_HINT_T0)\n\t\t\tPREFETCH(&Bin1[i * 2 + 1], _MM_HINT_T0)\n\t\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t\t\tPREFETCH_OUT(&Bout[r + 1 + i], _MM_HINT_T0)\n\t\t}\n\t\tPREFETCH(&Bin2[r * 2], _MM_HINT_T0)\n\t}\n\tPREFETCH(&Bin1[r * 2], _MM_HINT_T0)\n\tPREFETCH_OUT(&Bout[r], _MM_HINT_T0)\n\tPREFETCH_OUT(&Bout[r * 2 + 1], _MM_HINT_T0)\n\n\t/* 1: X <-- B_{2r - 1} */\n\tXOR4_2(Bin1[r * 2 + 1].q, Bin2[r * 2 + 1].q)\n\n\t/* 3: X <-- H(X \\xor B_i) */\n\t/* 4: Y_i <-- X */\n\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\tXOR4(Bin1[0].q)\n\tSALSA20_8_XOR_MEM(Bin2[0].q, Bout[0].q)\n\n\t/* 2: for i = 0 to 2r - 1 do */\n\tfor (i = 0; i < r;) {\n\t\t/* 3: X <-- H(X \\xor B_i) */\n\t\t/* 4: Y_i <-- X */\n\t\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\t\tXOR4(Bin1[i * 2 + 1].q)\n\t\tSALSA20_8_XOR_MEM(Bin2[i * 2 + 1].q, Bout[r + 1 + i].q)\n\n\t\ti++;\n\n\t\t/* 3: X <-- H(X \\xor B_i) */\n\t\t/* 4: Y_i <-- X */\n\t\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\t\tXOR4(Bin1[i * 2].q)\n\t\tSALSA20_8_XOR_MEM(Bin2[i * 2].q, Bout[i].q)\n\t}\n\n\t/* 3: X <-- H(X \\xor B_i) */\n\t/* 4: Y_i <-- X */\n\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\tXOR4(Bin1[r * 2 + 1].q)\n\tSALSA20_8_XOR_MEM(Bin2[r * 2 + 1].q, Bout[r * 2 + 1].q)\n\n\treturn _mm_cvtsi128_si32(X0);\n}\n\nstatic uint32_t\nblockmix_xor(const salsa20_blk_t *restrict Bin1,\n    const salsa20_blk_t *restrict Bin2, salsa20_blk_t *restrict Bout,\n    size_t r, int Bin2_in_ROM, const __m128i *restrict S)\n{\n\tconst uint8_t * S0, * S1;\n\t__m128i X0, X1, X2, X3;\n\tsize_t i;\n\n\tif (!S)\n\t\treturn blockmix_salsa8_xor(Bin1, Bin2, Bout, r, Bin2_in_ROM);\n\n\tS0 = (const uint8_t *)S;\n\tS1 = (const uint8_t *)S + S_SIZE_ALL / 2;\n\n\t/* Convert 128-byte blocks to 64-byte blocks */\n\tr *= 2;\n\n\tr--;\n\tif (Bin2_in_ROM) {\n\t\tPREFETCH(&Bin2[r], _MM_HINT_NTA)\n\t\tPREFETCH(&Bin1[r], _MM_HINT_T0)\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tPREFETCH(&Bin2[i], _MM_HINT_NTA)\n\t\t\tPREFETCH(&Bin1[i], _MM_HINT_T0)\n\t\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t\t}\n\t} else {\n\t\tPREFETCH(&Bin2[r], _MM_HINT_T0)\n\t\tPREFETCH(&Bin1[r], _MM_HINT_T0)\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tPREFETCH(&Bin2[i], _MM_HINT_T0)\n\t\t\tPREFETCH(&Bin1[i], _MM_HINT_T0)\n\t\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t\t}\n\t}\n\tPREFETCH_OUT(&Bout[r], _MM_HINT_T0);\n\n\t/* X <-- B_{r1 - 1} */\n\tXOR4_2(Bin1[r].q, Bin2[r].q)\n\n\t/* for i = 0 to r1 - 1 do */\n\tfor (i = 0; i < r; i++) {\n\t\t/* X <-- H'(X \\xor B_i) */\n\t\tXOR4(Bin1[i].q)\n\t\tXOR4(Bin2[i].q)\n\t\tPWXFORM\n\t\t/* B'_i <-- X */\n\t\tOUT(Bout[i].q)\n\t}\n\n\t/* Last iteration of the loop above */\n\tXOR4(Bin1[i].q)\n\tXOR4(Bin2[i].q)\n\tPWXFORM\n\n\t/* B'_i <-- H(B'_i) */\n\tSALSA20_8(Bout[i].q)\n\n\treturn _mm_cvtsi128_si32(X0);\n}\n\n#undef XOR4\n#define XOR4(in, out) \\\n\t(out)[0] = Y0 = _mm_xor_si128((in)[0], (out)[0]); \\\n\t(out)[1] = Y1 = _mm_xor_si128((in)[1], (out)[1]); \\\n\t(out)[2] = Y2 = _mm_xor_si128((in)[2], (out)[2]); \\\n\t(out)[3] = Y3 = _mm_xor_si128((in)[3], (out)[3]);\n\nstatic inline uint32_t\nblockmix_salsa8_xor_save(const salsa20_blk_t *restrict Bin1,\n    salsa20_blk_t *restrict Bin2, salsa20_blk_t *restrict Bout,\n    size_t r)\n{\n\t__m128i X0, X1, X2, X3, Y0, Y1, Y2, Y3;\n\tsize_t i;\n\n\tr--;\n\tPREFETCH(&Bin2[r * 2 + 1], _MM_HINT_T0)\n\tPREFETCH(&Bin1[r * 2 + 1], _MM_HINT_T0)\n\tfor (i = 0; i < r; i++) {\n\t\tPREFETCH(&Bin2[i * 2], _MM_HINT_T0)\n\t\tPREFETCH(&Bin1[i * 2], _MM_HINT_T0)\n\t\tPREFETCH(&Bin2[i * 2 + 1], _MM_HINT_T0)\n\t\tPREFETCH(&Bin1[i * 2 + 1], _MM_HINT_T0)\n\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t\tPREFETCH_OUT(&Bout[r + 1 + i], _MM_HINT_T0)\n\t}\n\tPREFETCH(&Bin2[r * 2], _MM_HINT_T0)\n\tPREFETCH(&Bin1[r * 2], _MM_HINT_T0)\n\tPREFETCH_OUT(&Bout[r], _MM_HINT_T0)\n\tPREFETCH_OUT(&Bout[r * 2 + 1], _MM_HINT_T0)\n\n\t/* 1: X <-- B_{2r - 1} */\n\tXOR4_2(Bin1[r * 2 + 1].q, Bin2[r * 2 + 1].q)\n\n\t/* 3: X <-- H(X \\xor B_i) */\n\t/* 4: Y_i <-- X */\n\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\tXOR4(Bin1[0].q, Bin2[0].q)\n\tSALSA20_8_XOR_REG(Bout[0].q)\n\n\t/* 2: for i = 0 to 2r - 1 do */\n\tfor (i = 0; i < r;) {\n\t\t/* 3: X <-- H(X \\xor B_i) */\n\t\t/* 4: Y_i <-- X */\n\t\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\t\tXOR4(Bin1[i * 2 + 1].q, Bin2[i * 2 + 1].q)\n\t\tSALSA20_8_XOR_REG(Bout[r + 1 + i].q)\n\n\t\ti++;\n\n\t\t/* 3: X <-- H(X \\xor B_i) */\n\t\t/* 4: Y_i <-- X */\n\t\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\t\tXOR4(Bin1[i * 2].q, Bin2[i * 2].q)\n\t\tSALSA20_8_XOR_REG(Bout[i].q)\n\t}\n\n\t/* 3: X <-- H(X \\xor B_i) */\n\t/* 4: Y_i <-- X */\n\t/* 6: B' <-- (Y_0, Y_2 ... Y_{2r-2}, Y_1, Y_3 ... Y_{2r-1}) */\n\tXOR4(Bin1[r * 2 + 1].q, Bin2[r * 2 + 1].q)\n\tSALSA20_8_XOR_REG(Bout[r * 2 + 1].q)\n\n\treturn _mm_cvtsi128_si32(X0);\n}\n\n#define XOR4_Y \\\n\tX0 = _mm_xor_si128(X0, Y0); \\\n\tX1 = _mm_xor_si128(X1, Y1); \\\n\tX2 = _mm_xor_si128(X2, Y2); \\\n\tX3 = _mm_xor_si128(X3, Y3);\n\nstatic uint32_t\nblockmix_xor_save(const salsa20_blk_t *restrict Bin1,\n    salsa20_blk_t *restrict Bin2, salsa20_blk_t *restrict Bout,\n    size_t r, const __m128i *restrict S)\n{\n\tconst uint8_t * S0, * S1;\n\t__m128i X0, X1, X2, X3, Y0, Y1, Y2, Y3;\n\tsize_t i;\n\n\tif (!S)\n\t\treturn blockmix_salsa8_xor_save(Bin1, Bin2, Bout, r);\n\n\tS0 = (const uint8_t *)S;\n\tS1 = (const uint8_t *)S + S_SIZE_ALL / 2;\n\n\t/* Convert 128-byte blocks to 64-byte blocks */\n\tr *= 2;\n\n\tr--;\n\tPREFETCH(&Bin2[r], _MM_HINT_T0)\n\tPREFETCH(&Bin1[r], _MM_HINT_T0)\n\tfor (i = 0; i < r; i++) {\n\t\tPREFETCH(&Bin2[i], _MM_HINT_T0)\n\t\tPREFETCH(&Bin1[i], _MM_HINT_T0)\n\t\tPREFETCH_OUT(&Bout[i], _MM_HINT_T0)\n\t}\n\tPREFETCH_OUT(&Bout[r], _MM_HINT_T0);\n\n\t/* X <-- B_{r1 - 1} */\n\tXOR4_2(Bin1[r].q, Bin2[r].q)\n\n\t/* for i = 0 to r1 - 1 do */\n\tfor (i = 0; i < r; i++) {\n\t\tXOR4(Bin1[i].q, Bin2[i].q)\n\t\t/* X <-- H'(X \\xor B_i) */\n\t\tXOR4_Y\n\t\tPWXFORM\n\t\t/* B'_i <-- X */\n\t\tOUT(Bout[i].q)\n\t}\n\n\t/* Last iteration of the loop above */\n\tXOR4(Bin1[i].q, Bin2[i].q)\n\tXOR4_Y\n\tPWXFORM\n\n\t/* B'_i <-- H(B'_i) */\n\tSALSA20_8(Bout[i].q)\n\n\treturn _mm_cvtsi128_si32(X0);\n}\n\n#undef ARX\n#undef SALSA20_2ROUNDS\n#undef SALSA20_8\n#undef SALSA20_8_XOR_ANY\n#undef SALSA20_8_XOR_MEM\n#undef SALSA20_8_XOR_REG\n#undef PWXFORM_SIMD_1\n#undef PWXFORM_SIMD_2\n#undef PWXFORM_ROUND\n#undef PWXFORM\n#undef OUT\n#undef XOR4\n#undef XOR4_2\n#undef XOR4_Y\n\n/**\n * integerify(B, r):\n * Return the result of parsing B_{2r-1} as a little-endian integer.\n */\nstatic inline uint32_t\nintegerify(const salsa20_blk_t * B, size_t r)\n{\n\treturn B[2 * r - 1].w[0];\n}\n\n/**\n * smix1(B, r, N, flags, V, NROM, shared, XY, S):\n * Compute first loop of B = SMix_r(B, N).  The input B must be 128r bytes in\n * length; the temporary storage V must be 128rN bytes in length; the temporary\n * storage XY must be 128r bytes in length.  The value N must be even and no\n * smaller than 2.  The array V must be aligned to a multiple of 64 bytes, and\n * arrays B and XY to a multiple of at least 16 bytes (aligning them to 64\n * bytes as well saves cache lines, but might result in cache bank conflicts).\n */\nstatic void\nsmix1(uint8_t * B, size_t r, uint32_t N, yescrypt_flags_t flags,\n    salsa20_blk_t * V, uint32_t NROM, const yescrypt_shared_t * shared,\n    salsa20_blk_t * XY, void * S)\n{\n\tconst salsa20_blk_t * VROM = shared->shared1.aligned;\n\tuint32_t VROM_mask = shared->mask1;\n\tsize_t s = 2 * r;\n\tsalsa20_blk_t * X = V, * Y;\n\tuint32_t i, j;\n\tsize_t k;\n\n\t/* 1: X <-- B */\n\t/* 3: V_i <-- X */\n\tfor (k = 0; k < 2 * r; k++) {\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tX[k].w[i] = le32dec(&B[(k * 16 + (i * 5 % 16)) * 4]);\n\t\t}\n\t}\n\n\tif (NROM && (VROM_mask & 1)) {\n\t\tuint32_t n;\n\t\tsalsa20_blk_t * V_n;\n\t\tconst salsa20_blk_t * V_j;\n\n\t\t/* 4: X <-- H(X) */\n\t\t/* 3: V_i <-- X */\n\t\tY = &V[s];\n\t\tblockmix(X, Y, r, S);\n\n\t\tX = &V[2 * s];\n\t\tif ((1 & VROM_mask) == 1) {\n\t\t\t/* j <-- Integerify(X) mod NROM */\n\t\t\tj = integerify(Y, r) & (NROM - 1);\n\t\t\tV_j = &VROM[j * s];\n\n\t\t\t/* X <-- H(X \\xor VROM_j) */\n\t\t\tj = blockmix_xor(Y, V_j, X, r, 1, S);\n\t\t} else {\n\t\t\t/* X <-- H(X) */\n\t\t\tblockmix(Y, X, r, S);\n\t\t\tj = integerify(X, r);\n\t\t}\n\n\t\tfor (n = 2; n < N; n <<= 1) {\n\t\t\tuint32_t m = (n < N / 2) ? n : (N - 1 - n);\n\n\t\t\tV_n = &V[n * s];\n\n\t\t\t/* 2: for i = 0 to N - 1 do */\n\t\t\tfor (i = 1; i < m; i += 2) {\n\t\t\t\t/* j <-- Wrap(Integerify(X), i) */\n\t\t\t\tj &= n - 1;\n\t\t\t\tj += i - 1;\n\t\t\t\tV_j = &V[j * s];\n\n\t\t\t\t/* X <-- X \\xor V_j */\n\t\t\t\t/* 4: X <-- H(X) */\n\t\t\t\t/* 3: V_i <-- X */\n\t\t\t\tY = &V_n[i * s];\n\t\t\t\tj = blockmix_xor(X, V_j, Y, r, 0, S);\n\n\t\t\t\tif (((n + i) & VROM_mask) == 1) {\n\t\t\t\t\t/* j <-- Integerify(X) mod NROM */\n\t\t\t\t\tj &= NROM - 1;\n\t\t\t\t\tV_j = &VROM[j * s];\n\t\t\t\t} else {\n\t\t\t\t\t/* j <-- Wrap(Integerify(X), i) */\n\t\t\t\t\tj &= n - 1;\n\t\t\t\t\tj += i;\n\t\t\t\t\tV_j = &V[j * s];\n\t\t\t\t}\n\n\t\t\t\t/* X <-- H(X \\xor VROM_j) */\n\t\t\t\tX = &V_n[(i + 1) * s];\n\t\t\t\tj = blockmix_xor(Y, V_j, X, r, 1, S);\n\t\t\t}\n\t\t}\n\n\t\tn >>= 1;\n\n\t\t/* j <-- Wrap(Integerify(X), i) */\n\t\tj &= n - 1;\n\t\tj += N - 2 - n;\n\t\tV_j = &V[j * s];\n\n\t\t/* X <-- X \\xor V_j */\n\t\t/* 4: X <-- H(X) */\n\t\t/* 3: V_i <-- X */\n\t\tY = &V[(N - 1) * s];\n\t\tj = blockmix_xor(X, V_j, Y, r, 0, S);\n\n\t\tif (((N - 1) & VROM_mask) == 1) {\n\t\t\t/* j <-- Integerify(X) mod NROM */\n\t\t\tj &= NROM - 1;\n\t\t\tV_j = &VROM[j * s];\n\t\t} else {\n\t\t\t/* j <-- Wrap(Integerify(X), i) */\n\t\t\tj &= n - 1;\n\t\t\tj += N - 1 - n;\n\t\t\tV_j = &V[j * s];\n\t\t}\n\n\t\t/* X <-- X \\xor V_j */\n\t\t/* 4: X <-- H(X) */\n\t\tX = XY;\n\t\tblockmix_xor(Y, V_j, X, r, 1, S);\n\t} else if (flags & YESCRYPT_RW) {\n\t\tuint32_t n;\n\t\tsalsa20_blk_t * V_n, * V_j;\n\n\t\t/* 4: X <-- H(X) */\n\t\t/* 3: V_i <-- X */\n\t\tY = &V[s];\n\t\tblockmix(X, Y, r, S);\n\n\t\t/* 4: X <-- H(X) */\n\t\t/* 3: V_i <-- X */\n\t\tX = &V[2 * s];\n\t\tblockmix(Y, X, r, S);\n\t\tj = integerify(X, r);\n\n\t\tfor (n = 2; n < N; n <<= 1) {\n\t\t\tuint32_t m = (n < N / 2) ? n : (N - 1 - n);\n\n\t\t\tV_n = &V[n * s];\n\n\t\t\t/* 2: for i = 0 to N - 1 do */\n\t\t\tfor (i = 1; i < m; i += 2) {\n\t\t\t\tY = &V_n[i * s];\n\n\t\t\t\t/* j <-- Wrap(Integerify(X), i) */\n\t\t\t\tj &= n - 1;\n\t\t\t\tj += i - 1;\n\t\t\t\tV_j = &V[j * s];\n\n\t\t\t\t/* X <-- X \\xor V_j */\n\t\t\t\t/* 4: X <-- H(X) */\n\t\t\t\t/* 3: V_i <-- X */\n\t\t\t\tj = blockmix_xor(X, V_j, Y, r, 0, S);\n\n\t\t\t\t/* j <-- Wrap(Integerify(X), i) */\n\t\t\t\tj &= n - 1;\n\t\t\t\tj += i;\n\t\t\t\tV_j = &V[j * s];\n\n\t\t\t\t/* X <-- X \\xor V_j */\n\t\t\t\t/* 4: X <-- H(X) */\n\t\t\t\t/* 3: V_i <-- X */\n\t\t\t\tX = &V_n[(i + 1) * s];\n\t\t\t\tj = blockmix_xor(Y, V_j, X, r, 0, S);\n\t\t\t}\n\t\t}\n\n\t\tn >>= 1;\n\n\t\t/* j <-- Wrap(Integerify(X), i) */\n\t\tj &= n - 1;\n\t\tj += N - 2 - n;\n\t\tV_j = &V[j * s];\n\n\t\t/* X <-- X \\xor V_j */\n\t\t/* 4: X <-- H(X) */\n\t\t/* 3: V_i <-- X */\n\t\tY = &V[(N - 1) * s];\n\t\tj = blockmix_xor(X, V_j, Y, r, 0, S);\n\n\t\t/* j <-- Wrap(Integerify(X), i) */\n\t\tj &= n - 1;\n\t\tj += N - 1 - n;\n\t\tV_j = &V[j * s];\n\n\t\t/* X <-- X \\xor V_j */\n\t\t/* 4: X <-- H(X) */\n\t\tX = XY;\n\t\tblockmix_xor(Y, V_j, X, r, 0, S);\n\t} else {\n\t\t/* 2: for i = 0 to N - 1 do */\n\t\tfor (i = 1; i < N - 1; i += 2) {\n\t\t\t/* 4: X <-- H(X) */\n\t\t\t/* 3: V_i <-- X */\n\t\t\tY = &V[i * s];\n\t\t\tblockmix(X, Y, r, S);\n\n\t\t\t/* 4: X <-- H(X) */\n\t\t\t/* 3: V_i <-- X */\n\t\t\tX = &V[(i + 1) * s];\n\t\t\tblockmix(Y, X, r, S);\n\t\t}\n\n\t\t/* 4: X <-- H(X) */\n\t\t/* 3: V_i <-- X */\n\t\tY = &V[i * s];\n\t\tblockmix(X, Y, r, S);\n\n\t\t/* 4: X <-- H(X) */\n\t\tX = XY;\n\t\tblockmix(Y, X, r, S);\n\t}\n\n\t/* B' <-- X */\n\tfor (k = 0; k < 2 * r; k++) {\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tle32enc(&B[(k * 16 + (i * 5 % 16)) * 4], X[k].w[i]);\n\t\t}\n\t}\n}\n\n/**\n * smix2(B, r, N, Nloop, flags, V, NROM, shared, XY, S):\n * Compute second loop of B = SMix_r(B, N).  The input B must be 128r bytes in\n * length; the temporary storage V must be 128rN bytes in length; the temporary\n * storage XY must be 256r bytes in length.  The value N must be a power of 2\n * greater than 1.  The value Nloop must be even.  The array V must be aligned\n * to a multiple of 64 bytes, and arrays B and XY to a multiple of at least 16\n * bytes (aligning them to 64 bytes as well saves cache lines, but might result\n * in cache bank conflicts).\n */\nstatic void\nsmix2(uint8_t * B, size_t r, uint32_t N, uint64_t Nloop,\n    yescrypt_flags_t flags, salsa20_blk_t * V, uint32_t NROM,\n    const yescrypt_shared_t * shared, salsa20_blk_t * XY, void * S)\n{\n\tconst salsa20_blk_t * VROM = shared->shared1.aligned;\n\tuint32_t VROM_mask = shared->mask1;\n\tsize_t s = 2 * r;\n\tsalsa20_blk_t * X = XY, * Y = &XY[s];\n\tuint64_t i;\n\tuint32_t j;\n\tsize_t k;\n\n\tif (Nloop == 0)\n\t\treturn;\n\n\t/* X <-- B' */\n\t/* 3: V_i <-- X */\n\tfor (k = 0; k < 2 * r; k++) {\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tX[k].w[i] = le32dec(&B[(k * 16 + (i * 5 % 16)) * 4]);\n\t\t}\n\t}\n\n\ti = Nloop / 2;\n\n\t/* 7: j <-- Integerify(X) mod N */\n\tj = integerify(X, r) & (N - 1);\n\n/*\n * Normally, NROM implies YESCRYPT_RW, but we check for these separately\n * because YESCRYPT_PARALLEL_SMIX resets YESCRYPT_RW for the smix2() calls\n * operating on the entire V.\n */\n\tif (NROM && (flags & YESCRYPT_RW)) {\n\t\t/* 6: for i = 0 to N - 1 do */\n\t\tfor (i = 0; i < Nloop; i += 2) {\n\t\t\tsalsa20_blk_t * V_j = &V[j * s];\n\n\t\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\t\t/* V_j <-- Xprev \\xor V_j */\n\t\t\t/* j <-- Integerify(X) mod NROM */\n\t\t\tj = blockmix_xor_save(X, V_j, Y, r, S);\n\n\t\t\tif (((i + 1) & VROM_mask) == 1) {\n\t\t\t\tconst salsa20_blk_t * VROM_j;\n\n\t\t\t\tj &= NROM - 1;\n\t\t\t\tVROM_j = &VROM[j * s];\n\n\t\t\t\t/* X <-- H(X \\xor VROM_j) */\n\t\t\t\t/* 7: j <-- Integerify(X) mod N */\n\t\t\t\tj = blockmix_xor(Y, VROM_j, X, r, 1, S);\n\t\t\t} else {\n\t\t\t\tj &= N - 1;\n\t\t\t\tV_j = &V[j * s];\n\n\t\t\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\t\t\t/* V_j <-- Xprev \\xor V_j */\n\t\t\t\t/* j <-- Integerify(X) mod NROM */\n\t\t\t\tj = blockmix_xor_save(Y, V_j, X, r, S);\n\t\t\t}\n\t\t\tj &= N - 1;\n\t\t\tV_j = &V[j * s];\n\t\t}\n\t} else if (NROM) {\n\t\t/* 6: for i = 0 to N - 1 do */\n\t\tfor (i = 0; i < Nloop; i += 2) {\n\t\t\tconst salsa20_blk_t * V_j = &V[j * s];\n\n\t\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\t\t/* V_j <-- Xprev \\xor V_j */\n\t\t\t/* j <-- Integerify(X) mod NROM */\n\t\t\tj = blockmix_xor(X, V_j, Y, r, 0, S);\n\n\t\t\tif (((i + 1) & VROM_mask) == 1) {\n\t\t\t\tj &= NROM - 1;\n\t\t\t\tV_j = &VROM[j * s];\n\t\t\t} else {\n\t\t\t\tj &= N - 1;\n\t\t\t\tV_j = &V[j * s];\n\t\t\t}\n\n\t\t\t/* X <-- H(X \\xor VROM_j) */\n\t\t\t/* 7: j <-- Integerify(X) mod N */\n\t\t\tj = blockmix_xor(Y, V_j, X, r, 1, S);\n\t\t\tj &= N - 1;\n\t\t\tV_j = &V[j * s];\n\t\t}\n\t} else if (flags & YESCRYPT_RW) {\n\t\t/* 6: for i = 0 to N - 1 do */\n\t\tdo {\n\t\t\tsalsa20_blk_t * V_j = &V[j * s];\n\n\t\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\t\t/* V_j <-- Xprev \\xor V_j */\n\t\t\t/* 7: j <-- Integerify(X) mod N */\n\t\t\tj = blockmix_xor_save(X, V_j, Y, r, S);\n\t\t\tj &= N - 1;\n\t\t\tV_j = &V[j * s];\n\n\t\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\t\t/* V_j <-- Xprev \\xor V_j */\n\t\t\t/* 7: j <-- Integerify(X) mod N */\n\t\t\tj = blockmix_xor_save(Y, V_j, X, r, S);\n\t\t\tj &= N - 1;\n\t\t} while (--i);\n\t} else {\n\t\t/* 6: for i = 0 to N - 1 do */\n\t\tdo {\n\t\t\tconst salsa20_blk_t * V_j = &V[j * s];\n\n\t\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\t\t/* 7: j <-- Integerify(X) mod N */\n\t\t\tj = blockmix_xor(X, V_j, Y, r, 0, S);\n\t\t\tj &= N - 1;\n\t\t\tV_j = &V[j * s];\n\n\t\t\t/* 8: X <-- H(X \\xor V_j) */\n\t\t\t/* 7: j <-- Integerify(X) mod N */\n\t\t\tj = blockmix_xor(Y, V_j, X, r, 0, S);\n\t\t\tj &= N - 1;\n\t\t} while (--i);\n\t}\n\n\t/* 10: B' <-- X */\n\tfor (k = 0; k < 2 * r; k++) {\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tle32enc(&B[(k * 16 + (i * 5 % 16)) * 4], X[k].w[i]);\n\t\t}\n\t}\n}\n\n/**\n * p2floor(x):\n * Largest power of 2 not greater than argument.\n */\nstatic uint64_t\np2floor(uint64_t x)\n{\n\tuint64_t y;\n\twhile ((y = x & (x - 1)))\n\t\tx = y;\n\treturn x;\n}\n\n/**\n * smix(B, r, N, p, t, flags, V, NROM, shared, XY, S):\n * Compute B = SMix_r(B, N).  The input B must be 128rp bytes in length; the\n * temporary storage V must be 128rN bytes in length; the temporary storage XY\n * must be 256r or 256rp bytes in length (the larger size is required with\n * OpenMP-enabled builds).  The value N must be a power of 2 greater than 1.\n * The array V must be aligned to a multiple of 64 bytes, and arrays B and\n * XY to a multiple of at least 16 bytes (aligning them to 64 bytes as well\n * saves cache lines and helps avoid false sharing in OpenMP-enabled builds\n * when p > 1, but it might also result in cache bank conflicts).\n */\nstatic void\nsmix(uint8_t * B, size_t r, uint32_t N, uint32_t p, uint32_t t,\n    yescrypt_flags_t flags,\n    salsa20_blk_t * V, uint32_t NROM, const yescrypt_shared_t * shared,\n    salsa20_blk_t * XY, void * S)\n{\n\tsize_t s = 2 * r;\n\tuint32_t Nchunk = N / p;\n\tuint64_t Nloop_all, Nloop_rw;\n\tuint32_t i;\n\n\tNloop_all = Nchunk;\n\tif (flags & YESCRYPT_RW) {\n\t\tif (t <= 1) {\n\t\t\tif (t)\n\t\t\t\tNloop_all *= 2; /* 2/3 */\n\t\t\tNloop_all = (Nloop_all + 2) / 3; /* 1/3, round up */\n\t\t} else {\n\t\t\tNloop_all *= t - 1;\n\t\t}\n\t} else if (t) {\n\t\tif (t == 1)\n\t\t\tNloop_all += (Nloop_all + 1) / 2; /* 1.5, round up */\n\t\tNloop_all *= t;\n\t}\n\n\tNloop_rw = 0;\n\tif (flags & __YESCRYPT_INIT_SHARED)\n\t\tNloop_rw = Nloop_all;\n\telse if (flags & YESCRYPT_RW)\n\t\tNloop_rw = Nloop_all / p;\n\n\tNchunk &= ~(uint32_t)1; /* round down to even */\n\tNloop_all++; Nloop_all &= ~(uint64_t)1; /* round up to even */\n\tNloop_rw &= ~(uint64_t)1; /* round down to even */\n\n#ifdef _OPENMP\n#pragma omp parallel if (p > 1) default(none) private(i) shared(B, r, N, p, flags, V, NROM, shared, XY, S, s, Nchunk, Nloop_all, Nloop_rw)\n\t{\n#pragma omp for\n#endif\n\tfor (i = 0; i < p; i++) {\n\t\tuint32_t Vchunk = i * Nchunk;\n\t\tuint8_t * Bp = &B[128 * r * i];\n\t\tsalsa20_blk_t * Vp = &V[Vchunk * s];\n#ifdef _OPENMP\n\t\tsalsa20_blk_t * XYp = &XY[i * (2 * s)];\n#else\n\t\tsalsa20_blk_t * XYp = XY;\n#endif\n\t\tuint32_t Np = (i < p - 1) ? Nchunk : (N - Vchunk);\n\t\tvoid * Sp = S ? ((uint8_t *)S + i * S_SIZE_ALL) : S;\n\t\tif (Sp)\n\t\t\tsmix1(Bp, 1, S_SIZE_ALL / 128,\n\t\t\t    flags & ~YESCRYPT_PWXFORM,\n\t\t\t    Sp, NROM, shared, XYp, NULL);\n\t\tif (!(flags & __YESCRYPT_INIT_SHARED_2))\n\t\t\tsmix1(Bp, r, Np, flags, Vp, NROM, shared, XYp, Sp);\n\t\tsmix2(Bp, r, p2floor(Np), Nloop_rw, flags, Vp,\n\t\t    NROM, shared, XYp, Sp);\n\t}\n\n\tif (Nloop_all > Nloop_rw) {\n#ifdef _OPENMP\n#pragma omp for\n#endif\n\t\tfor (i = 0; i < p; i++) {\n\t\t\tuint8_t * Bp = &B[128 * r * i];\n#ifdef _OPENMP\n\t\t\tsalsa20_blk_t * XYp = &XY[i * (2 * s)];\n#else\n\t\t\tsalsa20_blk_t * XYp = XY;\n#endif\n\t\t\tvoid * Sp = S ? ((uint8_t *)S + i * S_SIZE_ALL) : S;\n\t\t\tsmix2(Bp, r, N, Nloop_all - Nloop_rw,\n\t\t\t    flags & ~YESCRYPT_RW, V, NROM, shared, XYp, Sp);\n\t\t}\n\t}\n#ifdef _OPENMP\n\t}\n#endif\n}\n\n/**\n * yescrypt_kdf(shared, local, passwd, passwdlen, salt, saltlen,\n *     N, r, p, t, flags, buf, buflen):\n * Compute scrypt(passwd[0 .. passwdlen - 1], salt[0 .. saltlen - 1], N, r,\n * p, buflen), or a revision of scrypt as requested by flags and shared, and\n * write the result into buf.  The parameters r, p, and buflen must satisfy\n * r * p < 2^30 and buflen <= (2^32 - 1) * 32.  The parameter N must be a power\n * of 2 greater than 1.  (This optimized implementation currently additionally\n * limits N to the range from 8 to 2^31, but other implementation might not.)\n *\n * t controls computation time while not affecting peak memory usage.  shared\n * and flags may request special modes as described in yescrypt.h.  local is\n * the thread-local data structure, allowing to preserve and reuse a memory\n * allocation across calls, thereby reducing its overhead.\n *\n * Return 0 on success; or -1 on error.\n */\nint\nyescrypt_kdf(const yescrypt_shared_t * shared, yescrypt_local_t * local,\n    const uint8_t * passwd, size_t passwdlen,\n    const uint8_t * salt, size_t saltlen,\n    uint64_t N, uint32_t r, uint32_t p, uint32_t t, yescrypt_flags_t flags,\n    uint8_t * buf, size_t buflen)\n{\n\tyescrypt_region_t tmp;\n\tuint64_t NROM;\n\tsize_t B_size, V_size, XY_size, need;\n\tuint8_t * B, * S;\n\tsalsa20_blk_t * V, * XY;\n\tuint8_t sha256[32];\n\n\t/*\n\t * YESCRYPT_PARALLEL_SMIX is a no-op at p = 1 for its intended purpose,\n\t * so don't let it have side-effects.  Without this adjustment, it'd\n\t * enable the SHA-256 password pre-hashing and output post-hashing,\n\t * because any deviation from classic scrypt implies those.\n\t */\n\tif (p == 1)\n\t\tflags &= ~YESCRYPT_PARALLEL_SMIX;\n\n\t/* Sanity-check parameters */\n\tif (flags & ~YESCRYPT_KNOWN_FLAGS) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n#if SIZE_MAX > UINT32_MAX\n\tif (buflen > (((uint64_t)(1) << 32) - 1) * 32) {\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n#endif\n\tif ((uint64_t)(r) * (uint64_t)(p) >= (1 << 30)) {\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\tif (N > UINT32_MAX) {\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\tif (((N & (N - 1)) != 0) || (N <= 7) || (r < 1) || (p < 1)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif ((flags & YESCRYPT_PARALLEL_SMIX) && (N / p <= 7)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif ((r > SIZE_MAX / 256 / p) ||\n\t    (N > SIZE_MAX / 128 / r)) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n#ifdef _OPENMP\n\tif (!(flags & YESCRYPT_PARALLEL_SMIX) &&\n\t    (N > SIZE_MAX / 128 / (r * p))) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n#endif\n\tif ((flags & YESCRYPT_PWXFORM) &&\n#ifndef _OPENMP\n\t    (flags & YESCRYPT_PARALLEL_SMIX) &&\n#endif\n\t    p > SIZE_MAX / S_SIZE_ALL) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\tNROM = 0;\n\tif (shared->shared1.aligned) {\n\t\tNROM = shared->shared1.aligned_size / ((size_t)128 * r);\n\t\tif (NROM > UINT32_MAX) {\n\t\t\terrno = EFBIG;\n\t\t\treturn -1;\n\t\t}\n\t\tif (((NROM & (NROM - 1)) != 0) || (NROM <= 7) ||\n\t\t    !(flags & YESCRYPT_RW)) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Allocate memory */\n\tV = NULL;\n\tV_size = (size_t)128 * r * N;\n#ifdef _OPENMP\n\tif (!(flags & YESCRYPT_PARALLEL_SMIX))\n\t\tV_size *= p;\n#endif\n\tneed = V_size;\n\tif (flags & __YESCRYPT_INIT_SHARED) {\n\t\tif (local->aligned_size < need) {\n\t\t\tif (local->base || local->aligned ||\n\t\t\t    local->base_size || local->aligned_size) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!alloc_region(local, need))\n\t\t\t\treturn -1;\n\t\t}\n\t\tV = (salsa20_blk_t *)local->aligned;\n\t\tneed = 0;\n\t}\n\tB_size = (size_t)128 * r * p;\n\tneed += B_size;\n\tif (need < B_size) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tXY_size = (size_t)256 * r;\n#ifdef _OPENMP\n\tXY_size *= p;\n#endif\n\tneed += XY_size;\n\tif (need < XY_size) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tif (flags & YESCRYPT_PWXFORM) {\n\t\tsize_t S_size = S_SIZE_ALL;\n#ifdef _OPENMP\n\t\tS_size *= p;\n#else\n\t\tif (flags & YESCRYPT_PARALLEL_SMIX)\n\t\t\tS_size *= p;\n#endif\n\t\tneed += S_size;\n\t\tif (need < S_size) {\n\t\t\terrno = ENOMEM;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (flags & __YESCRYPT_INIT_SHARED) {\n\t\tif (!alloc_region(&tmp, need))\n\t\t\treturn -1;\n\t\tB = (uint8_t *)tmp.aligned;\n\t\tXY = (salsa20_blk_t *)((uint8_t *)B + B_size);\n\t} else {\n\t\tinit_region(&tmp);\n\t\tif (local->aligned_size < need) {\n\t\t\tif (free_region(local))\n\t\t\t\treturn -1;\n\t\t\tif (!alloc_region(local, need))\n\t\t\t\treturn -1;\n\t\t}\n\t\tB = (uint8_t *)local->aligned;\n\t\tV = (salsa20_blk_t *)((uint8_t *)B + B_size);\n\t\tXY = (salsa20_blk_t *)((uint8_t *)V + V_size);\n\t}\n\tS = NULL;\n\tif (flags & YESCRYPT_PWXFORM)\n\t\tS = (uint8_t *)XY + XY_size;\n\n\tif (t || flags) {\n\t\tSHA256_CTX ctx;\n\t\tSHA256_Init(&ctx);\n\t\tSHA256_Update(&ctx, passwd, passwdlen);\n\t\tSHA256_Final(sha256, &ctx);\n\t\tpasswd = sha256;\n\t\tpasswdlen = sizeof(sha256);\n\t}\n\n\t/* 1: (B_0 ... B_{p-1}) <-- PBKDF2(P, S, 1, p * MFLen) */\n\tPBKDF2_SHA256(passwd, passwdlen, salt, saltlen, 1, B, B_size);\n\n\tif (t || flags)\n\t\tmemcpy(sha256, B, sizeof(sha256));\n\n\tif (p == 1 || (flags & YESCRYPT_PARALLEL_SMIX)) {\n\t\tsmix(B, r, N, p, t, flags, V, NROM, shared, XY, S);\n\t} else {\n\t\tuint32_t i;\n\n\t\t/* 2: for i = 0 to p - 1 do */\n#ifdef _OPENMP\n#pragma omp parallel for default(none) private(i) shared(B, r, N, p, t, flags, V, NROM, shared, XY, S)\n#endif\n\t\tfor (i = 0; i < p; i++) {\n\t\t\t/* 3: B_i <-- MF(B_i, N) */\n#ifdef _OPENMP\n\t\t\tsmix(&B[(size_t)128 * r * i], r, N, 1, t, flags,\n\t\t\t    &V[(size_t)2 * r * i * N],\n\t\t\t    NROM, shared,\n\t\t\t    &XY[(size_t)4 * r * i],\n\t\t\t    S ? &S[S_SIZE_ALL * i] : S);\n#else\n\t\t\tsmix(&B[(size_t)128 * r * i], r, N, 1, t, flags, V,\n\t\t\t    NROM, shared, XY, S);\n#endif\n\t\t}\n\t}\n\n\t/* 5: DK <-- PBKDF2(P, B, 1, dkLen) */\n\tPBKDF2_SHA256(passwd, passwdlen, B, B_size, 1, buf, buflen);\n\n\t/*\n\t * Except when computing classic scrypt, allow all computation so far\n\t * to be performed on the client.  The final steps below match those of\n\t * SCRAM (RFC 5802), so that an extension of SCRAM (with the steps so\n\t * far in place of SCRAM's use of PBKDF2 and with SHA-256 in place of\n\t * SCRAM's use of SHA-1) would be usable with yescrypt hashes.\n\t */\n\tif ((t || flags) && buflen == sizeof(sha256)) {\n\t\t/* Compute ClientKey */\n\t\t{\n\t\t\tHMAC_SHA256_CTX ctx;\n\t\t\tHMAC_SHA256_Init(&ctx, buf, buflen);\n\t\t\tHMAC_SHA256_Update(&ctx, \"Client Key\", 10);\n\t\t\tHMAC_SHA256_Final(sha256, &ctx);\n\t\t}\n\t\t/* Compute StoredKey */\n\t\t{\n\t\t\tSHA256_CTX ctx;\n\t\t\tSHA256_Init(&ctx);\n\t\t\tSHA256_Update(&ctx, sha256, sizeof(sha256));\n\t\t\tSHA256_Final(buf, &ctx);\n\t\t}\n\t}\n\n\tif (free_region(&tmp))\n\t\treturn -1;\n\n\t/* Success! */\n\treturn 0;\n}\n"
        }
    ]
}